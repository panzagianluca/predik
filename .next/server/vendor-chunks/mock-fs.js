/*
 * ATTENTION: An "eval-source-map" devtool has been used.
 * This devtool is neither made for production nor for readable output files.
 * It uses "eval()" calls to create a separate source file with attached SourceMaps in the browser devtools.
 * If you are trying to read the output file, select a different devtool (https://webpack.js.org/configuration/devtool/)
 * or disable the default devtool with "devtool: false".
 * If you are looking for production-ready output files, see mode: "production" (https://webpack.js.org/configuration/mode/).
 */
exports.id = "vendor-chunks/mock-fs";
exports.ids = ["vendor-chunks/mock-fs"];
exports.modules = {

/***/ "(ssr)/./node_modules/mock-fs/lib/binding.js":
/*!*********************************************!*\
  !*** ./node_modules/mock-fs/lib/binding.js ***!
  \*********************************************/
/***/ ((module, exports, __webpack_require__) => {

"use strict";
eval("\n\nconst path = __webpack_require__(/*! path */ \"path\");\n\nconst File = __webpack_require__(/*! ./file */ \"(ssr)/./node_modules/mock-fs/lib/file.js\");\nconst FileDescriptor = __webpack_require__(/*! ./descriptor */ \"(ssr)/./node_modules/mock-fs/lib/descriptor.js\");\nconst Directory = __webpack_require__(/*! ./directory */ \"(ssr)/./node_modules/mock-fs/lib/directory.js\");\nconst SymbolicLink = __webpack_require__(/*! ./symlink */ \"(ssr)/./node_modules/mock-fs/lib/symlink.js\");\nconst FSError = __webpack_require__(/*! ./error */ \"(ssr)/./node_modules/mock-fs/lib/error.js\");\nconst constants = __webpack_require__(/*! constants */ \"constants\");\nconst getPathParts = (__webpack_require__(/*! ./filesystem */ \"(ssr)/./node_modules/mock-fs/lib/filesystem.js\").getPathParts);\nconst bufferFrom = (__webpack_require__(/*! ./buffer */ \"(ssr)/./node_modules/mock-fs/lib/buffer.js\").from);\nconst bufferAlloc = (__webpack_require__(/*! ./buffer */ \"(ssr)/./node_modules/mock-fs/lib/buffer.js\").alloc);\n\nconst MODE_TO_KTYPE = {\n  [constants.S_IFREG]: constants.UV_DIRENT_FILE,\n  [constants.S_IFDIR]: constants.UV_DIRENT_DIR,\n  [constants.S_IFBLK]: constants.UV_DIRENT_BLOCK,\n  [constants.S_IFCHR]: constants.UV_DIRENT_CHAR,\n  [constants.S_IFLNK]: constants.UV_DIRENT_LINK,\n  [constants.S_IFIFO]: constants.UV_DIRENT_FIFO,\n  [constants.S_IFSOCK]: constants.UV_DIRENT_SOCKET\n};\n\n/** Workaround for optimizations in node 8+ */\nconst fsBinding = process.binding('fs');\nconst kUsePromises = fsBinding.kUsePromises;\nlet statValues;\nif (fsBinding.statValues) {\n  statValues = fsBinding.statValues; // node 10+\n} else if (fsBinding.getStatValues) {\n  statValues = fsBinding.getStatValues(); // node 8\n} else {\n  statValues = [];\n}\n\n// nodejs v6,8,10 and v12 before v12.10.0 has length 28\n// nodejs v12.10.0+ has length 36\nconst statContainsNs = statValues.length > 28;\n\n/** Introduction of BigUint64Array in 10.5 */\nlet BigUint64Array;\nif (global.BigUint64Array) {\n  BigUint64Array = global.BigUint64Array;\n} else {\n  BigUint64Array = function() {};\n}\n\nconst MAX_LINKS = 50;\n\n/**\n * Call the provided function and either return the result or call the callback\n * with it (depending on if a callback is provided).\n * @param {function()} callback Optional callback.\n * @param {Object} ctx Context object (optional), only for nodejs v10+.\n * @param {Object} thisArg This argument for the following function.\n * @param {function()} func Function to call.\n * @return {*} Return (if callback is not provided).\n */\nfunction maybeCallback(callback, ctx, thisArg, func) {\n  let err = null;\n  let val;\n\n  if (kUsePromises && callback === kUsePromises) {\n    // support nodejs v10+ fs.promises\n    try {\n      val = func.call(thisArg);\n    } catch (e) {\n      err = e;\n    }\n    return new Promise(function(resolve, reject) {\n      process.nextTick(function() {\n        if (err) {\n          reject(err);\n        } else {\n          resolve(val);\n        }\n      });\n    });\n  } else if (callback && typeof callback === 'function') {\n    try {\n      val = func.call(thisArg);\n    } catch (e) {\n      err = e;\n    }\n    process.nextTick(function() {\n      if (val === undefined) {\n        callback(err);\n      } else {\n        callback(err, val);\n      }\n    });\n  } else if (ctx && typeof ctx === 'object') {\n    try {\n      return func.call(thisArg);\n    } catch (e) {\n      // default to errno for UNKNOWN\n      ctx.code = e.code || 'UNKNOWN';\n      ctx.errno = e.errno || FSError.codes.UNKNOWN.errno;\n    }\n  } else {\n    return func.call(thisArg);\n  }\n}\n\n/**\n * set syscall property on context object, only for nodejs v10+.\n * @param {Object} ctx Context object (optional), only for nodejs v10+.\n * @param {String} syscall Name of syscall.\n */\nfunction markSyscall(ctx, syscall) {\n  if (ctx && typeof ctx === 'object') {\n    ctx.syscall = syscall;\n  }\n}\n\n/**\n * Handle FSReqWrap oncomplete.\n * @param {Function} callback The callback.\n * @return {Function} The normalized callback.\n */\nfunction normalizeCallback(callback) {\n  if (callback && typeof callback.oncomplete === 'function') {\n    // Unpack callback from FSReqWrap\n    callback = callback.oncomplete.bind(callback);\n  }\n  return callback;\n}\n\n/**\n * Handle stat optimizations introduced in Node 8.\n * See https://github.com/nodejs/node/pull/11665.\n * @param {Function} callback The callback.\n * @return {Function} The wrapped callback.\n */\nfunction wrapStatsCallback(callback) {\n  if (callback && typeof callback.oncomplete === 'function') {\n    // Unpack callback from FSReqWrap\n    callback = callback.oncomplete.bind(callback);\n  }\n  if (typeof callback === 'function') {\n    return function(err, stats) {\n      if (stats) {\n        fillStatsArray(stats, statValues);\n      }\n      callback.apply(this, arguments);\n    };\n  } else {\n    return callback;\n  }\n}\n\nfunction getDirentType(mode) {\n  const ktype = MODE_TO_KTYPE[mode & constants.S_IFMT];\n\n  if (ktype === undefined) {\n    return constants.UV_DIRENT_UNKNOWN;\n  }\n\n  return ktype;\n}\n\nfunction notImplemented() {\n  throw new Error('Method not implemented');\n}\n\nfunction deBuffer(p) {\n  return Buffer.isBuffer(p) ? p.toString() : p;\n}\n\n/**\n * Create a new stats object.\n * @param {Object} config Stats properties.\n * @constructor\n */\nfunction Stats(config) {\n  for (const key in config) {\n    this[key] = config[key];\n  }\n  // node 10 expects an array internally\n  // see https://github.com/nodejs/node/pull/19714\n  fillStatsArray(config, this);\n}\n\n/**\n * Check if mode indicates property.\n * @param {number} property Property to check.\n * @return {boolean} Property matches mode.\n */\nStats.prototype._checkModeProperty = function(property) {\n  return (this.mode & constants.S_IFMT) === property;\n};\n\n/**\n * @return {Boolean} Is a directory.\n */\nStats.prototype.isDirectory = function() {\n  return this._checkModeProperty(constants.S_IFDIR);\n};\n\n/**\n * @return {Boolean} Is a regular file.\n */\nStats.prototype.isFile = function() {\n  return this._checkModeProperty(constants.S_IFREG);\n};\n\n/**\n * @return {Boolean} Is a block device.\n */\nStats.prototype.isBlockDevice = function() {\n  return this._checkModeProperty(constants.S_IFBLK);\n};\n\n/**\n * @return {Boolean} Is a character device.\n */\nStats.prototype.isCharacterDevice = function() {\n  return this._checkModeProperty(constants.S_IFCHR);\n};\n\n/**\n * @return {Boolean} Is a symbolic link.\n */\nStats.prototype.isSymbolicLink = function() {\n  return this._checkModeProperty(constants.S_IFLNK);\n};\n\n/**\n * @return {Boolean} Is a named pipe.\n */\nStats.prototype.isFIFO = function() {\n  return this._checkModeProperty(constants.S_IFIFO);\n};\n\n/**\n * @return {Boolean} Is a socket.\n */\nStats.prototype.isSocket = function() {\n  return this._checkModeProperty(constants.S_IFSOCK);\n};\n\n/**\n * Create a new binding with the given file system.\n * @param {FileSystem} system Mock file system.\n * @constructor\n */\nfunction Binding(system) {\n  /**\n   * Mock file system.\n   * @type {FileSystem}\n   */\n  this._system = system;\n\n  /**\n   * Stats constructor.\n   * @type {function}\n   */\n  this.Stats = Stats;\n\n  /**\n   * Lookup of open files.\n   * @type {Object.<number, FileDescriptor>}\n   */\n  this._openFiles = {};\n\n  /**\n   * Counter for file descriptors.\n   * @type {number}\n   */\n  this._counter = -1;\n\n  const stdin = new FileDescriptor(constants.O_RDWR);\n  stdin.setItem(new File.StandardInput());\n  this.trackDescriptor(stdin);\n\n  const stdout = new FileDescriptor(constants.O_RDWR);\n  stdout.setItem(new File.StandardOutput());\n  this.trackDescriptor(stdout);\n\n  const stderr = new FileDescriptor(constants.O_RDWR);\n  stderr.setItem(new File.StandardError());\n  this.trackDescriptor(stderr);\n}\n\n/**\n * Get the file system underlying this binding.\n * @return {FileSystem} The underlying file system.\n */\nBinding.prototype.getSystem = function() {\n  return this._system;\n};\n\n/**\n * Reset the file system underlying this binding.\n * @param {FileSystem} system The new file system.\n */\nBinding.prototype.setSystem = function(system) {\n  this._system = system;\n};\n\n/**\n * Get a file descriptor.\n * @param {number} fd File descriptor identifier.\n * @return {FileDescriptor} File descriptor.\n */\nBinding.prototype.getDescriptorById = function(fd) {\n  if (!this._openFiles.hasOwnProperty(fd)) {\n    throw new FSError('EBADF');\n  }\n  return this._openFiles[fd];\n};\n\n/**\n * Keep track of a file descriptor as open.\n * @param {FileDescriptor} descriptor The file descriptor.\n * @return {number} Identifier for file descriptor.\n */\nBinding.prototype.trackDescriptor = function(descriptor) {\n  const fd = ++this._counter;\n  this._openFiles[fd] = descriptor;\n  return fd;\n};\n\n/**\n * Stop tracking a file descriptor as open.\n * @param {number} fd Identifier for file descriptor.\n */\nBinding.prototype.untrackDescriptorById = function(fd) {\n  if (!this._openFiles.hasOwnProperty(fd)) {\n    throw new FSError('EBADF');\n  }\n  delete this._openFiles[fd];\n};\n\n/**\n * Resolve the canonicalized absolute pathname.\n * @param {string|Buffer} filepath The file path.\n * @param {string} encoding The encoding for the return.\n * @param {Object} ctx Context object (optional), only for nodejs v10+.\n * @return {string|Buffer} The real path.\n */\nBinding.prototype.realpath = function(filepath, encoding, callback, ctx) {\n  markSyscall(ctx, 'realpath');\n\n  return maybeCallback(normalizeCallback(callback), ctx, this, function() {\n    let realPath;\n    filepath = deBuffer(filepath);\n    const resolved = path.resolve(filepath);\n    const parts = getPathParts(resolved);\n    let item = this._system.getRoot();\n    let itemPath = '/';\n    let name, i, ii;\n    for (i = 0, ii = parts.length; i < ii; ++i) {\n      name = parts[i];\n      while (item instanceof SymbolicLink) {\n        itemPath = path.resolve(path.dirname(itemPath), item.getPath());\n        item = this._system.getItem(itemPath);\n      }\n      if (!item) {\n        throw new FSError('ENOENT', filepath);\n      }\n      if (item instanceof Directory) {\n        itemPath = path.resolve(itemPath, name);\n        item = item.getItem(name);\n      } else {\n        throw new FSError('ENOTDIR', filepath);\n      }\n    }\n    if (item) {\n      while (item instanceof SymbolicLink) {\n        itemPath = path.resolve(path.dirname(itemPath), item.getPath());\n        item = this._system.getItem(itemPath);\n      }\n      realPath = itemPath;\n    } else {\n      throw new FSError('ENOENT', filepath);\n    }\n\n    if (process.platform === 'win32' && realPath.startsWith('\\\\\\\\?\\\\')) {\n      // Remove win32 file namespace prefix \\\\?\\\n      realPath = realPath.slice(4);\n    }\n\n    if (encoding === 'buffer') {\n      realPath = bufferFrom(realPath);\n    }\n\n    return realPath;\n  });\n};\n\n/**\n * Fill a Float64Array with stat information\n * This is based on the internal FillStatsArray function in Node.\n * https://github.com/nodejs/node/blob/4e05952a8a75af6df625415db612d3a9a1322682/src/node_file.cc#L533\n * @param {Object} stats An object with file stats\n * @param {Float64Array} statValues A Float64Array where stat values should be inserted\n * @returns {void}\n */\nfunction fillStatsArray(stats, statValues) {\n  statValues[0] = stats.dev;\n  statValues[1] = stats.mode;\n  statValues[2] = stats.nlink;\n  statValues[3] = stats.uid;\n  statValues[4] = stats.gid;\n  statValues[5] = stats.rdev;\n  statValues[6] = stats.blksize;\n  statValues[7] = stats.ino;\n  statValues[8] = stats.size;\n  statValues[9] = stats.blocks;\n\n  if (statContainsNs) {\n    // nodejs v12.10.0+\n    // This is based on the internal FillStatsArray function in Node.\n    // https://github.com/nodejs/node/blob/3a2e75d9a5c31d20e429d505b82dd182e33f459a/src/node_file.h#L153-L187\n    statValues[10] = Math.floor(stats.atimeMs / 1000);\n    statValues[11] = (stats.atimeMs % 1000) * 1000000;\n    statValues[12] = Math.floor(stats.mtimeMs / 1000);\n    statValues[13] = (stats.mtimeMs % 1000) * 1000000;\n    statValues[14] = Math.floor(stats.ctimeMs / 1000);\n    statValues[15] = (stats.ctimeMs % 1000) * 1000000;\n    statValues[16] = Math.floor(stats.birthtimeMs / 1000);\n    statValues[17] = (stats.birthtimeMs % 1000) * 1000000;\n  } else {\n    // nodejs before v12.10.0\n    // This is based on the internal FillStatsArray function in Node.\n    // https://github.com/nodejs/node/blob/4e05952a8a75af6df625415db612d3a9a1322682/src/node_file.cc#L533\n    statValues[10] = stats.atimeMs;\n    statValues[11] = stats.mtimeMs;\n    statValues[12] = stats.ctimeMs;\n    statValues[13] = stats.birthtimeMs;\n  }\n}\n\n/**\n * Stat an item.\n * @param {string} filepath Path.\n * @param {function(Error, Stats)|Float64Array|BigUint64Array} callback Callback (optional). In Node 7.7.0+ this will be a Float64Array\n * that should be filled with stat values.\n * @param {Object} ctx Context object (optional), only for nodejs v10+.\n * @return {Stats|undefined} Stats or undefined (if sync).\n */\nBinding.prototype.stat = function(filepath, options, callback, ctx) {\n  // this seems wound not happen in nodejs v10+\n  if (arguments.length < 3) {\n    callback = options;\n    options = {};\n  }\n\n  markSyscall(ctx, 'stat');\n\n  return maybeCallback(wrapStatsCallback(callback), ctx, this, function() {\n    filepath = deBuffer(filepath);\n    let item = this._system.getItem(filepath);\n    if (item instanceof SymbolicLink) {\n      item = this._system.getItem(\n        path.resolve(path.dirname(filepath), item.getPath())\n      );\n    }\n    if (!item) {\n      throw new FSError('ENOENT', filepath);\n    }\n    const stats = item.getStats();\n\n    // In Node 7.7.0+, binding.stat accepts a Float64Array as the second argument,\n    // which should be filled with stat values.\n    // In prior versions of Node, binding.stat simply returns a Stats instance.\n    if (\n      callback instanceof Float64Array ||\n      callback instanceof BigUint64Array\n    ) {\n      fillStatsArray(stats, callback);\n    } else {\n      fillStatsArray(stats, statValues);\n      return new Stats(stats);\n    }\n  });\n};\n\n/**\n * Stat an item.\n * @param {number} fd File descriptor.\n * @param {function(Error, Stats)|Float64Array|BigUint64Array} callback Callback (optional). In Node 7.7.0+ this will be a Float64Array\n * that should be filled with stat values.\n * @param {Object} ctx Context object (optional), only for nodejs v10+.\n * @return {Stats|undefined} Stats or undefined (if sync).\n */\nBinding.prototype.fstat = function(fd, options, callback, ctx) {\n  if (arguments.length < 3) {\n    callback = options;\n    options = {};\n  }\n\n  markSyscall(ctx, 'fstat');\n\n  return maybeCallback(wrapStatsCallback(callback), ctx, this, function() {\n    const descriptor = this.getDescriptorById(fd);\n    const item = descriptor.getItem();\n    const stats = item.getStats();\n\n    // In Node 7.7.0+, binding.stat accepts a Float64Array as the second argument,\n    // which should be filled with stat values.\n    // In prior versions of Node, binding.stat simply returns a Stats instance.\n    if (\n      callback instanceof Float64Array ||\n      callback instanceof BigUint64Array\n    ) {\n      fillStatsArray(stats, callback);\n    } else {\n      fillStatsArray(stats, statValues);\n      return new Stats(stats);\n    }\n  });\n};\n\n/**\n * Close a file descriptor.\n * @param {number} fd File descriptor.\n * @param {function(Error)} callback Callback (optional).\n * @param {Object} ctx Context object (optional), only for nodejs v10+.\n */\nBinding.prototype.close = function(fd, callback, ctx) {\n  markSyscall(ctx, 'close');\n\n  return maybeCallback(normalizeCallback(callback), ctx, this, function() {\n    this.untrackDescriptorById(fd);\n  });\n};\n\n/**\n * Open and possibly create a file.\n * @param {string} pathname File path.\n * @param {number} flags Flags.\n * @param {number} mode Mode.\n * @param {function(Error, string)} callback Callback (optional).\n * @param {Object} ctx Context object (optional), only for nodejs v10+.\n * @return {string} File descriptor (if sync).\n */\nBinding.prototype.open = function(pathname, flags, mode, callback, ctx) {\n  markSyscall(ctx, 'open');\n\n  return maybeCallback(normalizeCallback(callback), ctx, this, function() {\n    pathname = deBuffer(pathname);\n    const descriptor = new FileDescriptor(flags);\n    let item = this._system.getItem(pathname);\n    while (item instanceof SymbolicLink) {\n      item = this._system.getItem(\n        path.resolve(path.dirname(pathname), item.getPath())\n      );\n    }\n    if (descriptor.isExclusive() && item) {\n      throw new FSError('EEXIST', pathname);\n    }\n    if (descriptor.isCreate() && !item) {\n      const parent = this._system.getItem(path.dirname(pathname));\n      if (!parent) {\n        throw new FSError('ENOENT', pathname);\n      }\n      if (!(parent instanceof Directory)) {\n        throw new FSError('ENOTDIR', pathname);\n      }\n      item = new File();\n      if (mode) {\n        item.setMode(mode);\n      }\n      parent.addItem(path.basename(pathname), item);\n    }\n    if (descriptor.isRead()) {\n      if (!item) {\n        throw new FSError('ENOENT', pathname);\n      }\n      if (!item.canRead()) {\n        throw new FSError('EACCES', pathname);\n      }\n    }\n    if (descriptor.isWrite() && !item.canWrite()) {\n      throw new FSError('EACCES', pathname);\n    }\n    if (\n      item instanceof Directory &&\n      (descriptor.isTruncate() || descriptor.isAppend())\n    ) {\n      throw new FSError('EISDIR', pathname);\n    }\n    if (descriptor.isTruncate()) {\n      if (!(item instanceof File)) {\n        throw new FSError('EBADF');\n      }\n      item.setContent('');\n    }\n    if (descriptor.isTruncate() || descriptor.isAppend()) {\n      descriptor.setPosition(item.getContent().length);\n    }\n    descriptor.setItem(item);\n    return this.trackDescriptor(descriptor);\n  });\n};\n\n/**\n * Open a file handler. A new api in nodejs v10+ for fs.promises\n * @param {string} pathname File path.\n * @param {number} flags Flags.\n * @param {number} mode Mode.\n * @param {function} callback Callback (optional), expecting kUsePromises in nodejs v10+.\n */\nBinding.prototype.openFileHandle = function(pathname, flags, mode, callback) {\n  const self = this;\n\n  return this.open(pathname, flags, mode, kUsePromises).then(function(fd) {\n    // nodejs v10+ fs.promises FileHandler constructor only ask these three properties.\n    return {\n      getAsyncId: notImplemented,\n      fd: fd,\n      close: function() {\n        return self.close(fd, kUsePromises);\n      }\n    };\n  });\n};\n\n/**\n * Read from a file descriptor.\n * @param {string} fd File descriptor.\n * @param {Buffer} buffer Buffer that the contents will be written to.\n * @param {number} offset Offset in the buffer to start writing to.\n * @param {number} length Number of bytes to read.\n * @param {?number} position Where to begin reading in the file.  If null,\n *     data will be read from the current file position.\n * @param {function(Error, number, Buffer)} callback Callback (optional) called\n *     with any error, number of bytes read, and the buffer.\n * @param {Object} ctx Context object (optional), only for nodejs v10+.\n * @return {number} Number of bytes read (if sync).\n */\nBinding.prototype.read = function(\n  fd,\n  buffer,\n  offset,\n  length,\n  position,\n  callback,\n  ctx\n) {\n  markSyscall(ctx, 'read');\n\n  return maybeCallback(normalizeCallback(callback), ctx, this, function() {\n    const descriptor = this.getDescriptorById(fd);\n    if (!descriptor.isRead()) {\n      throw new FSError('EBADF');\n    }\n    const file = descriptor.getItem();\n    if (file instanceof Directory) {\n      throw new FSError('EISDIR');\n    }\n    if (!(file instanceof File)) {\n      // deleted or not a regular file\n      throw new FSError('EBADF');\n    }\n    if (typeof position !== 'number' || position < 0) {\n      position = descriptor.getPosition();\n    }\n    const content = file.getContent();\n    const start = Math.min(position, content.length);\n    const end = Math.min(position + length, content.length);\n    const read = start < end ? content.copy(buffer, offset, start, end) : 0;\n    descriptor.setPosition(position + read);\n    return read;\n  });\n};\n\n/**\n * Write to a file descriptor given a buffer.\n * @param {string} src Source file.\n * @param {string} dest Destination file.\n * @param {number} flags Modifiers for copy operation.\n * @param {function(Error)} callback Callback (optional) called\n *     with any error.\n * @param {Object} ctx Context object (optional), only for nodejs v10+.\n */\nBinding.prototype.copyFile = function(src, dest, flags, callback, ctx) {\n  markSyscall(ctx, 'copyfile');\n\n  return maybeCallback(normalizeCallback(callback), ctx, this, function() {\n    src = deBuffer(src);\n    dest = deBuffer(dest);\n    const srcFd = this.open(src, constants.O_RDONLY);\n\n    try {\n      const srcDescriptor = this.getDescriptorById(srcFd);\n      if (!srcDescriptor.isRead()) {\n        throw new FSError('EBADF');\n      }\n      const srcFile = srcDescriptor.getItem();\n      if (!(srcFile instanceof File)) {\n        throw new FSError('EBADF');\n      }\n      const srcContent = srcFile.getContent();\n\n      let destFlags =\n        constants.O_WRONLY | constants.O_CREAT | constants.O_TRUNC;\n\n      if ((flags & constants.COPYFILE_EXCL) === constants.COPYFILE_EXCL) {\n        destFlags |= constants.O_EXCL;\n      }\n\n      const destFd = this.open(dest, destFlags);\n\n      try {\n        this.write(destFd, srcContent, 0, srcContent.length, 0);\n      } finally {\n        this.close(destFd);\n      }\n    } finally {\n      this.close(srcFd);\n    }\n  });\n};\n\n/**\n * Write to a file descriptor given a buffer.\n * @param {string} fd File descriptor.\n * @param {Array<Buffer>} buffers Array of buffers with contents to write.\n * @param {?number} position Where to begin writing in the file.  If null,\n *     data will be written to the current file position.\n * @param {function(Error, number, Buffer)} callback Callback (optional) called\n *     with any error, number of bytes written, and the buffer.\n * @param {Object} ctx Context object (optional), only for nodejs v10+.\n * @return {number} Number of bytes written (if sync).\n */\nBinding.prototype.writeBuffers = function(\n  fd,\n  buffers,\n  position,\n  callback,\n  ctx\n) {\n  markSyscall(ctx, 'write');\n\n  return maybeCallback(normalizeCallback(callback), ctx, this, function() {\n    const descriptor = this.getDescriptorById(fd);\n    if (!descriptor.isWrite()) {\n      throw new FSError('EBADF');\n    }\n    const file = descriptor.getItem();\n    if (!(file instanceof File)) {\n      // not a regular file\n      throw new FSError('EBADF');\n    }\n    if (typeof position !== 'number' || position < 0) {\n      position = descriptor.getPosition();\n    }\n    let content = file.getContent();\n    const newContent = Buffer.concat(buffers);\n    const newLength = position + newContent.length;\n    if (content.length < newLength) {\n      const tempContent = bufferAlloc(newLength);\n      content.copy(tempContent);\n      content = tempContent;\n    }\n    const written = newContent.copy(content, position);\n    file.setContent(content);\n    descriptor.setPosition(newLength);\n    return written;\n  });\n};\n\n/**\n * Write to a file descriptor given a buffer.\n * @param {string} fd File descriptor.\n * @param {Buffer} buffer Buffer with contents to write.\n * @param {number} offset Offset in the buffer to start writing from.\n * @param {number} length Number of bytes to write.\n * @param {?number} position Where to begin writing in the file.  If null,\n *     data will be written to the current file position.\n * @param {function(Error, number, Buffer)} callback Callback (optional) called\n *     with any error, number of bytes written, and the buffer.\n * @param {Object} ctx Context object (optional), only for nodejs v10+.\n * @return {number} Number of bytes written (if sync).\n */\nBinding.prototype.writeBuffer = function(\n  fd,\n  buffer,\n  offset,\n  length,\n  position,\n  callback,\n  ctx\n) {\n  markSyscall(ctx, 'write');\n\n  return maybeCallback(normalizeCallback(callback), ctx, this, function() {\n    const descriptor = this.getDescriptorById(fd);\n    if (!descriptor.isWrite()) {\n      throw new FSError('EBADF');\n    }\n    const file = descriptor.getItem();\n    if (!(file instanceof File)) {\n      // not a regular file\n      throw new FSError('EBADF');\n    }\n    if (typeof position !== 'number' || position < 0) {\n      position = descriptor.getPosition();\n    }\n    let content = file.getContent();\n    const newLength = position + length;\n    if (content.length < newLength) {\n      const newContent = bufferAlloc(newLength);\n      content.copy(newContent);\n      content = newContent;\n    }\n    const sourceEnd = Math.min(offset + length, buffer.length);\n    const written = bufferFrom(buffer).copy(\n      content,\n      position,\n      offset,\n      sourceEnd\n    );\n    file.setContent(content);\n    descriptor.setPosition(newLength);\n    return written;\n  });\n};\n\n/**\n * Alias for writeBuffer (used in Node <= 0.10).\n * @param {string} fd File descriptor.\n * @param {Buffer} buffer Buffer with contents to write.\n * @param {number} offset Offset in the buffer to start writing from.\n * @param {number} length Number of bytes to write.\n * @param {?number} position Where to begin writing in the file.  If null,\n *     data will be written to the current file position.\n * @param {function(Error, number, Buffer)} callback Callback (optional) called\n *     with any error, number of bytes written, and the buffer.\n * @param {Object} ctx Context object (optional), only for nodejs v10+.\n * @return {number} Number of bytes written (if sync).\n */\nBinding.prototype.write = Binding.prototype.writeBuffer;\n\n/**\n * Write to a file descriptor given a string.\n * @param {string} fd File descriptor.\n * @param {string} string String with contents to write.\n * @param {number} position Where to begin writing in the file.  If null,\n *     data will be written to the current file position.\n * @param {string} encoding String encoding.\n * @param {function(Error, number, string)} callback Callback (optional) called\n *     with any error, number of bytes written, and the string.\n * @return {number} Number of bytes written (if sync).\n */\nBinding.prototype.writeString = function(\n  fd,\n  string,\n  position,\n  encoding,\n  callback,\n  ctx\n) {\n  markSyscall(ctx, 'write');\n\n  const buffer = bufferFrom(string, encoding);\n  let wrapper;\n  if (callback && callback !== kUsePromises) {\n    if (callback.oncomplete) {\n      callback = callback.oncomplete.bind(callback);\n    }\n    wrapper = function(err, written, returned) {\n      callback(err, written, returned && string);\n    };\n  }\n  return this.writeBuffer(fd, buffer, 0, string.length, position, wrapper, ctx);\n};\n\n/**\n * Rename a file.\n * @param {string} oldPath Old pathname.\n * @param {string} newPath New pathname.\n * @param {function(Error)} callback Callback (optional).\n * @param {Object} ctx Context object (optional), only for nodejs v10+.\n * @return {undefined}\n */\nBinding.prototype.rename = function(oldPath, newPath, callback, ctx) {\n  markSyscall(ctx, 'rename');\n\n  return maybeCallback(normalizeCallback(callback), ctx, this, function() {\n    oldPath = deBuffer(oldPath);\n    newPath = deBuffer(newPath);\n    const oldItem = this._system.getItem(oldPath);\n    if (!oldItem) {\n      throw new FSError('ENOENT', oldPath);\n    }\n    const oldParent = this._system.getItem(path.dirname(oldPath));\n    const oldName = path.basename(oldPath);\n    const newItem = this._system.getItem(newPath);\n    const newParent = this._system.getItem(path.dirname(newPath));\n    const newName = path.basename(newPath);\n    if (newItem) {\n      // make sure they are the same type\n      if (oldItem instanceof File) {\n        if (newItem instanceof Directory) {\n          throw new FSError('EISDIR', newPath);\n        }\n      } else if (oldItem instanceof Directory) {\n        if (!(newItem instanceof Directory)) {\n          throw new FSError('ENOTDIR', newPath);\n        }\n        if (newItem.list().length > 0) {\n          throw new FSError('ENOTEMPTY', newPath);\n        }\n      }\n      newParent.removeItem(newName);\n    } else {\n      if (!newParent) {\n        throw new FSError('ENOENT', newPath);\n      }\n      if (!(newParent instanceof Directory)) {\n        throw new FSError('ENOTDIR', newPath);\n      }\n    }\n    oldParent.removeItem(oldName);\n    newParent.addItem(newName, oldItem);\n  });\n};\n\n/**\n * Read a directory.\n * @param {string} dirpath Path to directory.\n * @param {string} encoding The encoding ('utf-8' or 'buffer').\n * @param {boolean} withFileTypes whether or not to return fs.Dirent objects\n * @param {function(Error, (Array.<string>|Array.<Buffer>)} callback Callback\n *     (optional) called with any error or array of items in the directory.\n * @param {Object} ctx Context object (optional), only for nodejs v10+.\n * @return {Array.<string>|Array.<Buffer>} Array of items in directory (if sync).\n */\nBinding.prototype.readdir = function(\n  dirpath,\n  encoding,\n  withFileTypes,\n  callback,\n  ctx\n) {\n  // again, the shorter arguments would not happen in nodejs v10+\n  if (arguments.length === 2) {\n    callback = encoding;\n    encoding = 'utf-8';\n  } else if (arguments.length === 3) {\n    callback = withFileTypes;\n  }\n\n  markSyscall(ctx, 'scandir');\n\n  return maybeCallback(normalizeCallback(callback), ctx, this, function() {\n    dirpath = deBuffer(dirpath);\n    let dpath = dirpath;\n    let dir = this._system.getItem(dirpath);\n    while (dir instanceof SymbolicLink) {\n      dpath = path.resolve(path.dirname(dpath), dir.getPath());\n      dir = this._system.getItem(dpath);\n    }\n    if (!dir) {\n      throw new FSError('ENOENT', dirpath);\n    }\n    if (!(dir instanceof Directory)) {\n      throw new FSError('ENOTDIR', dirpath);\n    }\n    if (!dir.canRead()) {\n      throw new FSError('EACCES', dirpath);\n    }\n\n    let list = dir.list();\n    if (encoding === 'buffer') {\n      list = list.map(function(item) {\n        return bufferFrom(item);\n      });\n    }\n\n    if (withFileTypes === true) {\n      const types = list.map(function(name) {\n        const stats = dir.getItem(name).getStats();\n\n        return getDirentType(stats.mode);\n      });\n      list = [list, types];\n    }\n\n    return list;\n  });\n};\n\n/**\n * Create a directory.\n * @param {string} pathname Path to new directory.\n * @param {number} mode Permissions.\n * @param {boolean} recursive Recursively create deep directory. (added in nodejs v10+)\n * @param {function(Error)} callback Optional callback.\n * @param {Object} ctx Context object (optional), only for nodejs v10+.\n */\nBinding.prototype.mkdir = function(pathname, mode, recursive, callback, ctx) {\n  if (typeof recursive !== 'boolean') {\n    // when running nodejs < 10\n    ctx = callback;\n    callback = recursive;\n    recursive = false;\n  }\n\n  markSyscall(ctx, 'mkdir');\n\n  return maybeCallback(normalizeCallback(callback), ctx, this, function() {\n    pathname = deBuffer(pathname);\n    const item = this._system.getItem(pathname);\n    if (item) {\n      if (recursive && item instanceof Directory) {\n        // silently pass existing folder in recursive mode\n        return;\n      }\n      throw new FSError('EEXIST', pathname);\n    }\n\n    const _mkdir = function(_pathname) {\n      const parentDir = path.dirname(_pathname);\n      let parent = this._system.getItem(parentDir);\n      if (!parent) {\n        if (!recursive) {\n          throw new FSError('ENOENT', _pathname);\n        }\n        parent = _mkdir(parentDir, true);\n      }\n      this.access(parentDir, parseInt('0002', 8));\n      const dir = new Directory();\n      if (mode) {\n        dir.setMode(mode);\n      }\n      return parent.addItem(path.basename(_pathname), dir);\n    }.bind(this);\n\n    _mkdir(pathname);\n  });\n};\n\n/**\n * Remove a directory.\n * @param {string} pathname Path to directory.\n * @param {function(Error)} callback Optional callback.\n * @param {Object} ctx Context object (optional), only for nodejs v10+.\n */\nBinding.prototype.rmdir = function(pathname, callback, ctx) {\n  markSyscall(ctx, 'rmdir');\n\n  return maybeCallback(normalizeCallback(callback), ctx, this, function() {\n    pathname = deBuffer(pathname);\n    const item = this._system.getItem(pathname);\n    if (!item) {\n      throw new FSError('ENOENT', pathname);\n    }\n    if (!(item instanceof Directory)) {\n      throw new FSError('ENOTDIR', pathname);\n    }\n    if (item.list().length > 0) {\n      throw new FSError('ENOTEMPTY', pathname);\n    }\n    this.access(path.dirname(pathname), parseInt('0002', 8));\n    const parent = this._system.getItem(path.dirname(pathname));\n    parent.removeItem(path.basename(pathname));\n  });\n};\n\nconst PATH_CHARS =\n  'abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789';\n\nconst MAX_ATTEMPTS = 62 * 62 * 62;\n\n/**\n * Create a directory based on a template.\n * See http://web.mit.edu/freebsd/head/lib/libc/stdio/mktemp.c\n * @param {string} template Path template (trailing Xs will be replaced).\n * @param {string} encoding The encoding ('utf-8' or 'buffer').\n * @param {function(Error, string)} callback Optional callback.\n * @param {Object} ctx Context object (optional), only for nodejs v10+.\n */\nBinding.prototype.mkdtemp = function(prefix, encoding, callback, ctx) {\n  if (encoding && typeof encoding !== 'string') {\n    callback = encoding;\n    encoding = 'utf-8';\n  }\n\n  markSyscall(ctx, 'mkdtemp');\n\n  return maybeCallback(normalizeCallback(callback), ctx, this, function() {\n    prefix = prefix.replace(/X{0,6}$/, 'XXXXXX');\n    const parentPath = path.dirname(prefix);\n    const parent = this._system.getItem(parentPath);\n    if (!parent) {\n      throw new FSError('ENOENT', prefix);\n    }\n    if (!(parent instanceof Directory)) {\n      throw new FSError('ENOTDIR', prefix);\n    }\n    this.access(parentPath, parseInt('0002', 8));\n    const template = path.basename(prefix);\n    let unique = false;\n    let count = 0;\n    let name;\n    while (!unique && count < MAX_ATTEMPTS) {\n      let position = template.length - 1;\n      let replacement = '';\n      while (template.charAt(position) === 'X') {\n        replacement += PATH_CHARS.charAt(\n          Math.floor(PATH_CHARS.length * Math.random())\n        );\n        position -= 1;\n      }\n      const candidate = template.slice(0, position + 1) + replacement;\n      if (!parent.getItem(candidate)) {\n        name = candidate;\n        unique = true;\n      }\n      count += 1;\n    }\n    if (!name) {\n      throw new FSError('EEXIST', prefix);\n    }\n    const dir = new Directory();\n    parent.addItem(name, dir);\n    let uniquePath = path.join(parentPath, name);\n    if (encoding === 'buffer') {\n      uniquePath = bufferFrom(uniquePath);\n    }\n    return uniquePath;\n  });\n};\n\n/**\n * Truncate a file.\n * @param {number} fd File descriptor.\n * @param {number} len Number of bytes.\n * @param {function(Error)} callback Optional callback.\n * @param {Object} ctx Context object (optional), only for nodejs v10+.\n */\nBinding.prototype.ftruncate = function(fd, len, callback, ctx) {\n  markSyscall(ctx, 'ftruncate');\n\n  return maybeCallback(normalizeCallback(callback), ctx, this, function() {\n    const descriptor = this.getDescriptorById(fd);\n    if (!descriptor.isWrite()) {\n      throw new FSError('EINVAL');\n    }\n    const file = descriptor.getItem();\n    if (!(file instanceof File)) {\n      throw new FSError('EINVAL');\n    }\n    const content = file.getContent();\n    const newContent = bufferAlloc(len);\n    content.copy(newContent);\n    file.setContent(newContent);\n  });\n};\n\n/**\n * Legacy support.\n * @param {number} fd File descriptor.\n * @param {number} len Number of bytes.\n * @param {function(Error)} callback Optional callback.\n * @param {Object} ctx Context object (optional), only for nodejs v10+.\n */\nBinding.prototype.truncate = Binding.prototype.ftruncate;\n\n/**\n * Change user and group owner.\n * @param {string} pathname Path.\n * @param {number} uid User id.\n * @param {number} gid Group id.\n * @param {function(Error)} callback Optional callback.\n * @param {Object} ctx Context object (optional), only for nodejs v10+.\n */\nBinding.prototype.chown = function(pathname, uid, gid, callback, ctx) {\n  markSyscall(ctx, 'chown');\n\n  return maybeCallback(normalizeCallback(callback), ctx, this, function() {\n    pathname = deBuffer(pathname);\n    const item = this._system.getItem(pathname);\n    if (!item) {\n      throw new FSError('ENOENT', pathname);\n    }\n    item.setUid(uid);\n    item.setGid(gid);\n  });\n};\n\n/**\n * Change user and group owner.\n * @param {number} fd File descriptor.\n * @param {number} uid User id.\n * @param {number} gid Group id.\n * @param {function(Error)} callback Optional callback.\n * @param {Object} ctx Context object (optional), only for nodejs v10+.\n */\nBinding.prototype.fchown = function(fd, uid, gid, callback, ctx) {\n  markSyscall(ctx, 'fchown');\n\n  return maybeCallback(normalizeCallback(callback), ctx, this, function() {\n    const descriptor = this.getDescriptorById(fd);\n    const item = descriptor.getItem();\n    item.setUid(uid);\n    item.setGid(gid);\n  });\n};\n\n/**\n * Change permissions.\n * @param {string} pathname Path.\n * @param {number} mode Mode.\n * @param {function(Error)} callback Optional callback.\n * @param {Object} ctx Context object (optional), only for nodejs v10+.\n */\nBinding.prototype.chmod = function(pathname, mode, callback, ctx) {\n  markSyscall(ctx, 'chmod');\n\n  return maybeCallback(normalizeCallback(callback), ctx, this, function() {\n    pathname = deBuffer(pathname);\n    const item = this._system.getItem(pathname);\n    if (!item) {\n      throw new FSError('ENOENT', pathname);\n    }\n    item.setMode(mode);\n  });\n};\n\n/**\n * Change permissions.\n * @param {number} fd File descriptor.\n * @param {number} mode Mode.\n * @param {function(Error)} callback Optional callback.\n * @param {Object} ctx Context object (optional), only for nodejs v10+.\n */\nBinding.prototype.fchmod = function(fd, mode, callback, ctx) {\n  markSyscall(ctx, 'fchmod');\n\n  return maybeCallback(normalizeCallback(callback), ctx, this, function() {\n    const descriptor = this.getDescriptorById(fd);\n    const item = descriptor.getItem();\n    item.setMode(mode);\n  });\n};\n\n/**\n * Delete a named item.\n * @param {string} pathname Path to item.\n * @param {function(Error)} callback Optional callback.\n * @param {Object} ctx Context object (optional), only for nodejs v10+.\n */\nBinding.prototype.unlink = function(pathname, callback, ctx) {\n  markSyscall(ctx, 'unlink');\n\n  return maybeCallback(normalizeCallback(callback), ctx, this, function() {\n    pathname = deBuffer(pathname);\n    const item = this._system.getItem(pathname);\n    if (!item) {\n      throw new FSError('ENOENT', pathname);\n    }\n    if (item instanceof Directory) {\n      throw new FSError('EPERM', pathname);\n    }\n    const parent = this._system.getItem(path.dirname(pathname));\n    parent.removeItem(path.basename(pathname));\n  });\n};\n\n/**\n * Update timestamps.\n * @param {string} pathname Path to item.\n * @param {number} atime Access time (in seconds).\n * @param {number} mtime Modification time (in seconds).\n * @param {function(Error)} callback Optional callback.\n * @param {Object} ctx Context object (optional), only for nodejs v10+.\n */\nBinding.prototype.utimes = function(pathname, atime, mtime, callback, ctx) {\n  markSyscall(ctx, 'utimes');\n\n  return maybeCallback(normalizeCallback(callback), ctx, this, function() {\n    pathname = deBuffer(pathname);\n    const item = this._system.getItem(pathname);\n    if (!item) {\n      throw new FSError('ENOENT', pathname);\n    }\n    item.setATime(new Date(atime * 1000));\n    item.setMTime(new Date(mtime * 1000));\n  });\n};\n\n/**\n * Update timestamps.\n * @param {number} fd File descriptor.\n * @param {number} atime Access time (in seconds).\n * @param {number} mtime Modification time (in seconds).\n * @param {function(Error)} callback Optional callback.\n * @param {Object} ctx Context object (optional), only for nodejs v10+.\n */\nBinding.prototype.futimes = function(fd, atime, mtime, callback, ctx) {\n  markSyscall(ctx, 'futimes');\n\n  return maybeCallback(normalizeCallback(callback), ctx, this, function() {\n    const descriptor = this.getDescriptorById(fd);\n    const item = descriptor.getItem();\n    item.setATime(new Date(atime * 1000));\n    item.setMTime(new Date(mtime * 1000));\n  });\n};\n\n/**\n * Synchronize in-core state with storage device.\n * @param {number} fd File descriptor.\n * @param {function(Error)} callback Optional callback.\n * @param {Object} ctx Context object (optional), only for nodejs v10+.\n */\nBinding.prototype.fsync = function(fd, callback, ctx) {\n  markSyscall(ctx, 'fsync');\n\n  return maybeCallback(normalizeCallback(callback), ctx, this, function() {\n    this.getDescriptorById(fd);\n  });\n};\n\n/**\n * Synchronize in-core metadata state with storage device.\n * @param {number} fd File descriptor.\n * @param {function(Error)} callback Optional callback.\n * @param {Object} ctx Context object (optional), only for nodejs v10+.\n */\nBinding.prototype.fdatasync = function(fd, callback, ctx) {\n  markSyscall(ctx, 'fdatasync');\n\n  return maybeCallback(normalizeCallback(callback), ctx, this, function() {\n    this.getDescriptorById(fd);\n  });\n};\n\n/**\n * Create a hard link.\n * @param {string} srcPath The existing file.\n * @param {string} destPath The new link to create.\n * @param {function(Error)} callback Optional callback.\n * @param {Object} ctx Context object (optional), only for nodejs v10+.\n */\nBinding.prototype.link = function(srcPath, destPath, callback, ctx) {\n  markSyscall(ctx, 'link');\n\n  return maybeCallback(normalizeCallback(callback), ctx, this, function() {\n    srcPath = deBuffer(srcPath);\n    destPath = deBuffer(destPath);\n    const item = this._system.getItem(srcPath);\n    if (!item) {\n      throw new FSError('ENOENT', srcPath);\n    }\n    if (item instanceof Directory) {\n      throw new FSError('EPERM', srcPath);\n    }\n    if (this._system.getItem(destPath)) {\n      throw new FSError('EEXIST', destPath);\n    }\n    const parent = this._system.getItem(path.dirname(destPath));\n    if (!parent) {\n      throw new FSError('ENOENT', destPath);\n    }\n    if (!(parent instanceof Directory)) {\n      throw new FSError('ENOTDIR', destPath);\n    }\n    parent.addItem(path.basename(destPath), item);\n  });\n};\n\n/**\n * Create a symbolic link.\n * @param {string} srcPath Path from link to the source file.\n * @param {string} destPath Path for the generated link.\n * @param {string} type Ignored (used for Windows only).\n * @param {function(Error)} callback Optional callback.\n * @param {Object} ctx Context object (optional), only for nodejs v10+.\n */\nBinding.prototype.symlink = function(srcPath, destPath, type, callback, ctx) {\n  markSyscall(ctx, 'symlink');\n\n  return maybeCallback(normalizeCallback(callback), ctx, this, function() {\n    srcPath = deBuffer(srcPath);\n    destPath = deBuffer(destPath);\n    if (this._system.getItem(destPath)) {\n      throw new FSError('EEXIST', destPath);\n    }\n    const parent = this._system.getItem(path.dirname(destPath));\n    if (!parent) {\n      throw new FSError('ENOENT', destPath);\n    }\n    if (!(parent instanceof Directory)) {\n      throw new FSError('ENOTDIR', destPath);\n    }\n    const link = new SymbolicLink();\n    link.setPath(srcPath);\n    parent.addItem(path.basename(destPath), link);\n  });\n};\n\n/**\n * Read the contents of a symbolic link.\n * @param {string} pathname Path to symbolic link.\n * @param {string} encoding The encoding ('utf-8' or 'buffer').\n * @param {function(Error, (string|Buffer))} callback Optional callback.\n * @param {Object} ctx Context object (optional), only for nodejs v10+.\n * @return {string|Buffer} Symbolic link contents (path to source).\n */\nBinding.prototype.readlink = function(pathname, encoding, callback, ctx) {\n  if (encoding && typeof encoding !== 'string') {\n    // this would not happend in nodejs v10+\n    callback = encoding;\n    encoding = 'utf-8';\n  }\n\n  markSyscall(ctx, 'readlink');\n\n  return maybeCallback(normalizeCallback(callback), ctx, this, function() {\n    pathname = deBuffer(pathname);\n    const link = this._system.getItem(pathname);\n    if (!link) {\n      throw new FSError('ENOENT', pathname);\n    }\n    if (!(link instanceof SymbolicLink)) {\n      throw new FSError('EINVAL', pathname);\n    }\n    let linkPath = link.getPath();\n    if (encoding === 'buffer') {\n      linkPath = bufferFrom(linkPath);\n    }\n    return linkPath;\n  });\n};\n\n/**\n * Stat an item.\n * @param {string} filepath Path.\n * @param {function(Error, Stats)|Float64Array|BigUint64Array} callback Callback (optional). In Node 7.7.0+ this will be a Float64Array\n * that should be filled with stat values.\n * @param {Object} ctx Context object (optional), only for nodejs v10+.\n * @return {Stats|undefined} Stats or undefined (if sync).\n */\nBinding.prototype.lstat = function(filepath, options, callback, ctx) {\n  if (arguments.length < 3) {\n    // this would not happend in nodejs v10+\n    callback = options;\n    options = {};\n  }\n\n  markSyscall(ctx, 'lstat');\n\n  return maybeCallback(wrapStatsCallback(callback), ctx, this, function() {\n    filepath = deBuffer(filepath);\n    const item = this._system.getItem(filepath);\n    if (!item) {\n      throw new FSError('ENOENT', filepath);\n    }\n    const stats = item.getStats();\n\n    // In Node 7.7.0+, binding.stat accepts a Float64Array as the second argument,\n    // which should be filled with stat values.\n    // In prior versions of Node, binding.stat simply returns a Stats instance.\n    if (\n      callback instanceof Float64Array ||\n      callback instanceof BigUint64Array\n    ) {\n      fillStatsArray(stats, callback);\n    } else {\n      fillStatsArray(stats, statValues);\n      return new Stats(item.getStats());\n    }\n  });\n};\n\n/**\n * Tests user permissions.\n * @param {string} filepath Path.\n * @param {number} mode Mode.\n * @param {function(Error)} callback Callback (optional).\n * @param {Object} ctx Context object (optional), only for nodejs v10+.\n */\nBinding.prototype.access = function(filepath, mode, callback, ctx) {\n  markSyscall(ctx, 'access');\n\n  return maybeCallback(normalizeCallback(callback), ctx, this, function() {\n    filepath = deBuffer(filepath);\n    let item = this._system.getItem(filepath);\n    let links = 0;\n    while (item instanceof SymbolicLink) {\n      if (links > MAX_LINKS) {\n        throw new FSError('ELOOP', filepath);\n      }\n      filepath = path.resolve(path.dirname(filepath), item.getPath());\n      item = this._system.getItem(filepath);\n      ++links;\n    }\n    if (!item) {\n      throw new FSError('ENOENT', filepath);\n    }\n    if (mode && process.getuid && process.getgid) {\n      const itemMode = item.getMode();\n      if (item.getUid() === process.getuid()) {\n        if ((itemMode & (mode * 64)) !== mode * 64) {\n          throw new FSError('EACCES', filepath);\n        }\n      } else if (item.getGid() === process.getgid()) {\n        if ((itemMode & (mode * 8)) !== mode * 8) {\n          throw new FSError('EACCES', filepath);\n        }\n      } else {\n        if ((itemMode & mode) !== mode) {\n          throw new FSError('EACCES', filepath);\n        }\n      }\n    }\n  });\n};\n\n/**\n * Not yet implemented.\n * @type {function()}\n */\nBinding.prototype.StatWatcher = notImplemented;\n\n/**\n * Export the binding constructor.\n * @type {function()}\n */\nexports = module.exports = Binding;\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvbW9jay1mcy9saWIvYmluZGluZy5qcyIsIm1hcHBpbmdzIjoiQUFBYTs7QUFFYixhQUFhLG1CQUFPLENBQUMsa0JBQU07O0FBRTNCLGFBQWEsbUJBQU8sQ0FBQyx3REFBUTtBQUM3Qix1QkFBdUIsbUJBQU8sQ0FBQyxvRUFBYztBQUM3QyxrQkFBa0IsbUJBQU8sQ0FBQyxrRUFBYTtBQUN2QyxxQkFBcUIsbUJBQU8sQ0FBQyw4REFBVztBQUN4QyxnQkFBZ0IsbUJBQU8sQ0FBQywwREFBUztBQUNqQyxrQkFBa0IsbUJBQU8sQ0FBQyw0QkFBVztBQUNyQyxxQkFBcUIsd0dBQW9DO0FBQ3pELG1CQUFtQix3RkFBd0I7QUFDM0Msb0JBQW9CLHlGQUF5Qjs7QUFFN0M7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxxQ0FBcUM7QUFDckMsRUFBRTtBQUNGLDBDQUEwQztBQUMxQyxFQUFFO0FBQ0Y7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxFQUFFO0FBQ0Y7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxXQUFXLFlBQVk7QUFDdkIsV0FBVyxRQUFRO0FBQ25CLFdBQVcsUUFBUTtBQUNuQixXQUFXLFlBQVk7QUFDdkIsWUFBWSxHQUFHO0FBQ2Y7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsVUFBVTtBQUNWO0FBQ0E7QUFDQSxPQUFPO0FBQ1AsS0FBSztBQUNMLElBQUk7QUFDSjtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxRQUFRO0FBQ1I7QUFDQTtBQUNBLEtBQUs7QUFDTCxJQUFJO0FBQ0o7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7QUFDQTtBQUNBLElBQUk7QUFDSjtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLFdBQVcsUUFBUTtBQUNuQixXQUFXLFFBQVE7QUFDbkI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxXQUFXLFVBQVU7QUFDckIsWUFBWSxVQUFVO0FBQ3RCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsV0FBVyxVQUFVO0FBQ3JCLFlBQVksVUFBVTtBQUN0QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLElBQUk7QUFDSjtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxXQUFXLFFBQVE7QUFDbkI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLFdBQVcsUUFBUTtBQUNuQixZQUFZLFNBQVM7QUFDckI7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxZQUFZLFNBQVM7QUFDckI7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxZQUFZLFNBQVM7QUFDckI7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxZQUFZLFNBQVM7QUFDckI7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxZQUFZLFNBQVM7QUFDckI7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxZQUFZLFNBQVM7QUFDckI7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxZQUFZLFNBQVM7QUFDckI7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxZQUFZLFNBQVM7QUFDckI7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLFdBQVcsWUFBWTtBQUN2QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsWUFBWTtBQUNaO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLFlBQVk7QUFDWjtBQUNBOztBQUVBO0FBQ0E7QUFDQSxZQUFZO0FBQ1o7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsWUFBWTtBQUNaO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsWUFBWSxZQUFZO0FBQ3hCO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxXQUFXLFlBQVk7QUFDdkI7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLFdBQVcsUUFBUTtBQUNuQixZQUFZLGdCQUFnQjtBQUM1QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsV0FBVyxnQkFBZ0I7QUFDM0IsWUFBWSxRQUFRO0FBQ3BCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsV0FBVyxRQUFRO0FBQ25CO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxXQUFXLGVBQWU7QUFDMUIsV0FBVyxRQUFRO0FBQ25CLFdBQVcsUUFBUTtBQUNuQixZQUFZLGVBQWU7QUFDM0I7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxtQ0FBbUMsUUFBUTtBQUMzQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsUUFBUTtBQUNSO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLEdBQUc7QUFDSDs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFdBQVcsUUFBUTtBQUNuQixXQUFXLGNBQWM7QUFDekIsYUFBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxJQUFJO0FBQ0o7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxXQUFXLFFBQVE7QUFDbkIsV0FBVyxvREFBb0Q7QUFDL0Q7QUFDQSxXQUFXLFFBQVE7QUFDbkIsWUFBWSxpQkFBaUI7QUFDN0I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIOztBQUVBO0FBQ0E7QUFDQSxXQUFXLFFBQVE7QUFDbkIsV0FBVyxvREFBb0Q7QUFDL0Q7QUFDQSxXQUFXLFFBQVE7QUFDbkIsWUFBWSxpQkFBaUI7QUFDN0I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIOztBQUVBO0FBQ0E7QUFDQSxXQUFXLFFBQVE7QUFDbkIsV0FBVyxpQkFBaUI7QUFDNUIsV0FBVyxRQUFRO0FBQ25CO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsR0FBRztBQUNIOztBQUVBO0FBQ0E7QUFDQSxXQUFXLFFBQVE7QUFDbkIsV0FBVyxRQUFRO0FBQ25CLFdBQVcsUUFBUTtBQUNuQixXQUFXLHlCQUF5QjtBQUNwQyxXQUFXLFFBQVE7QUFDbkIsWUFBWSxRQUFRO0FBQ3BCO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7O0FBRUE7QUFDQTtBQUNBLFdBQVcsUUFBUTtBQUNuQixXQUFXLFFBQVE7QUFDbkIsV0FBVyxRQUFRO0FBQ25CLFdBQVcsVUFBVTtBQUNyQjtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIOztBQUVBO0FBQ0E7QUFDQSxXQUFXLFFBQVE7QUFDbkIsV0FBVyxRQUFRO0FBQ25CLFdBQVcsUUFBUTtBQUNuQixXQUFXLFFBQVE7QUFDbkIsV0FBVyxTQUFTO0FBQ3BCO0FBQ0EsV0FBVyxpQ0FBaUM7QUFDNUM7QUFDQSxXQUFXLFFBQVE7QUFDbkIsWUFBWSxRQUFRO0FBQ3BCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7O0FBRUE7QUFDQTtBQUNBLFdBQVcsUUFBUTtBQUNuQixXQUFXLFFBQVE7QUFDbkIsV0FBVyxRQUFRO0FBQ25CLFdBQVcsaUJBQWlCO0FBQzVCO0FBQ0EsV0FBVyxRQUFRO0FBQ25CO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0EsUUFBUTtBQUNSO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBLEdBQUc7QUFDSDs7QUFFQTtBQUNBO0FBQ0EsV0FBVyxRQUFRO0FBQ25CLFdBQVcsZUFBZTtBQUMxQixXQUFXLFNBQVM7QUFDcEI7QUFDQSxXQUFXLGlDQUFpQztBQUM1QztBQUNBLFdBQVcsUUFBUTtBQUNuQixZQUFZLFFBQVE7QUFDcEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIOztBQUVBO0FBQ0E7QUFDQSxXQUFXLFFBQVE7QUFDbkIsV0FBVyxRQUFRO0FBQ25CLFdBQVcsUUFBUTtBQUNuQixXQUFXLFFBQVE7QUFDbkIsV0FBVyxTQUFTO0FBQ3BCO0FBQ0EsV0FBVyxpQ0FBaUM7QUFDNUM7QUFDQSxXQUFXLFFBQVE7QUFDbkIsWUFBWSxRQUFRO0FBQ3BCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIOztBQUVBO0FBQ0E7QUFDQSxXQUFXLFFBQVE7QUFDbkIsV0FBVyxRQUFRO0FBQ25CLFdBQVcsUUFBUTtBQUNuQixXQUFXLFFBQVE7QUFDbkIsV0FBVyxTQUFTO0FBQ3BCO0FBQ0EsV0FBVyxpQ0FBaUM7QUFDNUM7QUFDQSxXQUFXLFFBQVE7QUFDbkIsWUFBWSxRQUFRO0FBQ3BCO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLFdBQVcsUUFBUTtBQUNuQixXQUFXLFFBQVE7QUFDbkIsV0FBVyxRQUFRO0FBQ25CO0FBQ0EsV0FBVyxRQUFRO0FBQ25CLFdBQVcsaUNBQWlDO0FBQzVDO0FBQ0EsWUFBWSxRQUFRO0FBQ3BCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsV0FBVyxRQUFRO0FBQ25CLFdBQVcsUUFBUTtBQUNuQixXQUFXLGlCQUFpQjtBQUM1QixXQUFXLFFBQVE7QUFDbkIsWUFBWTtBQUNaO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxRQUFRO0FBQ1I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7O0FBRUE7QUFDQTtBQUNBLFdBQVcsUUFBUTtBQUNuQixXQUFXLFFBQVE7QUFDbkIsV0FBVyxTQUFTO0FBQ3BCLFdBQVcsaURBQWlEO0FBQzVEO0FBQ0EsV0FBVyxRQUFRO0FBQ25CLFlBQVksK0JBQStCO0FBQzNDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLElBQUk7QUFDSjtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7O0FBRUE7QUFDQSxHQUFHO0FBQ0g7O0FBRUE7QUFDQTtBQUNBLFdBQVcsUUFBUTtBQUNuQixXQUFXLFFBQVE7QUFDbkIsV0FBVyxTQUFTO0FBQ3BCLFdBQVcsaUJBQWlCO0FBQzVCLFdBQVcsUUFBUTtBQUNuQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7O0FBRUw7QUFDQSxHQUFHO0FBQ0g7O0FBRUE7QUFDQTtBQUNBLFdBQVcsUUFBUTtBQUNuQixXQUFXLGlCQUFpQjtBQUM1QixXQUFXLFFBQVE7QUFDbkI7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDs7QUFFQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLFdBQVcsUUFBUTtBQUNuQixXQUFXLFFBQVE7QUFDbkIsV0FBVyx5QkFBeUI7QUFDcEMsV0FBVyxRQUFRO0FBQ25CO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBLCtCQUErQixJQUFJO0FBQ25DO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDs7QUFFQTtBQUNBO0FBQ0EsV0FBVyxRQUFRO0FBQ25CLFdBQVcsUUFBUTtBQUNuQixXQUFXLGlCQUFpQjtBQUM1QixXQUFXLFFBQVE7QUFDbkI7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIOztBQUVBO0FBQ0E7QUFDQSxXQUFXLFFBQVE7QUFDbkIsV0FBVyxRQUFRO0FBQ25CLFdBQVcsaUJBQWlCO0FBQzVCLFdBQVcsUUFBUTtBQUNuQjtBQUNBOztBQUVBO0FBQ0E7QUFDQSxXQUFXLFFBQVE7QUFDbkIsV0FBVyxRQUFRO0FBQ25CLFdBQVcsUUFBUTtBQUNuQixXQUFXLGlCQUFpQjtBQUM1QixXQUFXLFFBQVE7QUFDbkI7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7O0FBRUE7QUFDQTtBQUNBLFdBQVcsUUFBUTtBQUNuQixXQUFXLFFBQVE7QUFDbkIsV0FBVyxRQUFRO0FBQ25CLFdBQVcsaUJBQWlCO0FBQzVCLFdBQVcsUUFBUTtBQUNuQjtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDs7QUFFQTtBQUNBO0FBQ0EsV0FBVyxRQUFRO0FBQ25CLFdBQVcsUUFBUTtBQUNuQixXQUFXLGlCQUFpQjtBQUM1QixXQUFXLFFBQVE7QUFDbkI7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIOztBQUVBO0FBQ0E7QUFDQSxXQUFXLFFBQVE7QUFDbkIsV0FBVyxRQUFRO0FBQ25CLFdBQVcsaUJBQWlCO0FBQzVCLFdBQVcsUUFBUTtBQUNuQjtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7O0FBRUE7QUFDQTtBQUNBLFdBQVcsUUFBUTtBQUNuQixXQUFXLGlCQUFpQjtBQUM1QixXQUFXLFFBQVE7QUFDbkI7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7O0FBRUE7QUFDQTtBQUNBLFdBQVcsUUFBUTtBQUNuQixXQUFXLFFBQVE7QUFDbkIsV0FBVyxRQUFRO0FBQ25CLFdBQVcsaUJBQWlCO0FBQzVCLFdBQVcsUUFBUTtBQUNuQjtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDs7QUFFQTtBQUNBO0FBQ0EsV0FBVyxRQUFRO0FBQ25CLFdBQVcsUUFBUTtBQUNuQixXQUFXLFFBQVE7QUFDbkIsV0FBVyxpQkFBaUI7QUFDNUIsV0FBVyxRQUFRO0FBQ25CO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIOztBQUVBO0FBQ0E7QUFDQSxXQUFXLFFBQVE7QUFDbkIsV0FBVyxpQkFBaUI7QUFDNUIsV0FBVyxRQUFRO0FBQ25CO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsR0FBRztBQUNIOztBQUVBO0FBQ0E7QUFDQSxXQUFXLFFBQVE7QUFDbkIsV0FBVyxpQkFBaUI7QUFDNUIsV0FBVyxRQUFRO0FBQ25CO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsR0FBRztBQUNIOztBQUVBO0FBQ0E7QUFDQSxXQUFXLFFBQVE7QUFDbkIsV0FBVyxRQUFRO0FBQ25CLFdBQVcsaUJBQWlCO0FBQzVCLFdBQVcsUUFBUTtBQUNuQjtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIOztBQUVBO0FBQ0E7QUFDQSxXQUFXLFFBQVE7QUFDbkIsV0FBVyxRQUFRO0FBQ25CLFdBQVcsUUFBUTtBQUNuQixXQUFXLGlCQUFpQjtBQUM1QixXQUFXLFFBQVE7QUFDbkI7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIOztBQUVBO0FBQ0E7QUFDQSxXQUFXLFFBQVE7QUFDbkIsV0FBVyxRQUFRO0FBQ25CLFdBQVcsa0NBQWtDO0FBQzdDLFdBQVcsUUFBUTtBQUNuQixZQUFZLGVBQWU7QUFDM0I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDs7QUFFQTtBQUNBO0FBQ0EsV0FBVyxRQUFRO0FBQ25CLFdBQVcsb0RBQW9EO0FBQy9EO0FBQ0EsV0FBVyxRQUFRO0FBQ25CLFlBQVksaUJBQWlCO0FBQzdCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIOztBQUVBO0FBQ0E7QUFDQSxXQUFXLFFBQVE7QUFDbkIsV0FBVyxRQUFRO0FBQ25CLFdBQVcsaUJBQWlCO0FBQzVCLFdBQVcsUUFBUTtBQUNuQjtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsUUFBUTtBQUNSO0FBQ0E7QUFDQTtBQUNBLFFBQVE7QUFDUjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIOztBQUVBO0FBQ0E7QUFDQSxVQUFVO0FBQ1Y7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsVUFBVTtBQUNWO0FBQ0EiLCJzb3VyY2VzIjpbIi9Vc2Vycy9wYW56YS9Eb2N1bWVudHMvUGVyc29uYWxQcm9qZWN0cy9wcmVkaWsvbm9kZV9tb2R1bGVzL21vY2stZnMvbGliL2JpbmRpbmcuanMiXSwic291cmNlc0NvbnRlbnQiOlsiJ3VzZSBzdHJpY3QnO1xuXG5jb25zdCBwYXRoID0gcmVxdWlyZSgncGF0aCcpO1xuXG5jb25zdCBGaWxlID0gcmVxdWlyZSgnLi9maWxlJyk7XG5jb25zdCBGaWxlRGVzY3JpcHRvciA9IHJlcXVpcmUoJy4vZGVzY3JpcHRvcicpO1xuY29uc3QgRGlyZWN0b3J5ID0gcmVxdWlyZSgnLi9kaXJlY3RvcnknKTtcbmNvbnN0IFN5bWJvbGljTGluayA9IHJlcXVpcmUoJy4vc3ltbGluaycpO1xuY29uc3QgRlNFcnJvciA9IHJlcXVpcmUoJy4vZXJyb3InKTtcbmNvbnN0IGNvbnN0YW50cyA9IHJlcXVpcmUoJ2NvbnN0YW50cycpO1xuY29uc3QgZ2V0UGF0aFBhcnRzID0gcmVxdWlyZSgnLi9maWxlc3lzdGVtJykuZ2V0UGF0aFBhcnRzO1xuY29uc3QgYnVmZmVyRnJvbSA9IHJlcXVpcmUoJy4vYnVmZmVyJykuZnJvbTtcbmNvbnN0IGJ1ZmZlckFsbG9jID0gcmVxdWlyZSgnLi9idWZmZXInKS5hbGxvYztcblxuY29uc3QgTU9ERV9UT19LVFlQRSA9IHtcbiAgW2NvbnN0YW50cy5TX0lGUkVHXTogY29uc3RhbnRzLlVWX0RJUkVOVF9GSUxFLFxuICBbY29uc3RhbnRzLlNfSUZESVJdOiBjb25zdGFudHMuVVZfRElSRU5UX0RJUixcbiAgW2NvbnN0YW50cy5TX0lGQkxLXTogY29uc3RhbnRzLlVWX0RJUkVOVF9CTE9DSyxcbiAgW2NvbnN0YW50cy5TX0lGQ0hSXTogY29uc3RhbnRzLlVWX0RJUkVOVF9DSEFSLFxuICBbY29uc3RhbnRzLlNfSUZMTktdOiBjb25zdGFudHMuVVZfRElSRU5UX0xJTkssXG4gIFtjb25zdGFudHMuU19JRklGT106IGNvbnN0YW50cy5VVl9ESVJFTlRfRklGTyxcbiAgW2NvbnN0YW50cy5TX0lGU09DS106IGNvbnN0YW50cy5VVl9ESVJFTlRfU09DS0VUXG59O1xuXG4vKiogV29ya2Fyb3VuZCBmb3Igb3B0aW1pemF0aW9ucyBpbiBub2RlIDgrICovXG5jb25zdCBmc0JpbmRpbmcgPSBwcm9jZXNzLmJpbmRpbmcoJ2ZzJyk7XG5jb25zdCBrVXNlUHJvbWlzZXMgPSBmc0JpbmRpbmcua1VzZVByb21pc2VzO1xubGV0IHN0YXRWYWx1ZXM7XG5pZiAoZnNCaW5kaW5nLnN0YXRWYWx1ZXMpIHtcbiAgc3RhdFZhbHVlcyA9IGZzQmluZGluZy5zdGF0VmFsdWVzOyAvLyBub2RlIDEwK1xufSBlbHNlIGlmIChmc0JpbmRpbmcuZ2V0U3RhdFZhbHVlcykge1xuICBzdGF0VmFsdWVzID0gZnNCaW5kaW5nLmdldFN0YXRWYWx1ZXMoKTsgLy8gbm9kZSA4XG59IGVsc2Uge1xuICBzdGF0VmFsdWVzID0gW107XG59XG5cbi8vIG5vZGVqcyB2Niw4LDEwIGFuZCB2MTIgYmVmb3JlIHYxMi4xMC4wIGhhcyBsZW5ndGggMjhcbi8vIG5vZGVqcyB2MTIuMTAuMCsgaGFzIGxlbmd0aCAzNlxuY29uc3Qgc3RhdENvbnRhaW5zTnMgPSBzdGF0VmFsdWVzLmxlbmd0aCA+IDI4O1xuXG4vKiogSW50cm9kdWN0aW9uIG9mIEJpZ1VpbnQ2NEFycmF5IGluIDEwLjUgKi9cbmxldCBCaWdVaW50NjRBcnJheTtcbmlmIChnbG9iYWwuQmlnVWludDY0QXJyYXkpIHtcbiAgQmlnVWludDY0QXJyYXkgPSBnbG9iYWwuQmlnVWludDY0QXJyYXk7XG59IGVsc2Uge1xuICBCaWdVaW50NjRBcnJheSA9IGZ1bmN0aW9uKCkge307XG59XG5cbmNvbnN0IE1BWF9MSU5LUyA9IDUwO1xuXG4vKipcbiAqIENhbGwgdGhlIHByb3ZpZGVkIGZ1bmN0aW9uIGFuZCBlaXRoZXIgcmV0dXJuIHRoZSByZXN1bHQgb3IgY2FsbCB0aGUgY2FsbGJhY2tcbiAqIHdpdGggaXQgKGRlcGVuZGluZyBvbiBpZiBhIGNhbGxiYWNrIGlzIHByb3ZpZGVkKS5cbiAqIEBwYXJhbSB7ZnVuY3Rpb24oKX0gY2FsbGJhY2sgT3B0aW9uYWwgY2FsbGJhY2suXG4gKiBAcGFyYW0ge09iamVjdH0gY3R4IENvbnRleHQgb2JqZWN0IChvcHRpb25hbCksIG9ubHkgZm9yIG5vZGVqcyB2MTArLlxuICogQHBhcmFtIHtPYmplY3R9IHRoaXNBcmcgVGhpcyBhcmd1bWVudCBmb3IgdGhlIGZvbGxvd2luZyBmdW5jdGlvbi5cbiAqIEBwYXJhbSB7ZnVuY3Rpb24oKX0gZnVuYyBGdW5jdGlvbiB0byBjYWxsLlxuICogQHJldHVybiB7Kn0gUmV0dXJuIChpZiBjYWxsYmFjayBpcyBub3QgcHJvdmlkZWQpLlxuICovXG5mdW5jdGlvbiBtYXliZUNhbGxiYWNrKGNhbGxiYWNrLCBjdHgsIHRoaXNBcmcsIGZ1bmMpIHtcbiAgbGV0IGVyciA9IG51bGw7XG4gIGxldCB2YWw7XG5cbiAgaWYgKGtVc2VQcm9taXNlcyAmJiBjYWxsYmFjayA9PT0ga1VzZVByb21pc2VzKSB7XG4gICAgLy8gc3VwcG9ydCBub2RlanMgdjEwKyBmcy5wcm9taXNlc1xuICAgIHRyeSB7XG4gICAgICB2YWwgPSBmdW5jLmNhbGwodGhpc0FyZyk7XG4gICAgfSBjYXRjaCAoZSkge1xuICAgICAgZXJyID0gZTtcbiAgICB9XG4gICAgcmV0dXJuIG5ldyBQcm9taXNlKGZ1bmN0aW9uKHJlc29sdmUsIHJlamVjdCkge1xuICAgICAgcHJvY2Vzcy5uZXh0VGljayhmdW5jdGlvbigpIHtcbiAgICAgICAgaWYgKGVycikge1xuICAgICAgICAgIHJlamVjdChlcnIpO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIHJlc29sdmUodmFsKTtcbiAgICAgICAgfVxuICAgICAgfSk7XG4gICAgfSk7XG4gIH0gZWxzZSBpZiAoY2FsbGJhY2sgJiYgdHlwZW9mIGNhbGxiYWNrID09PSAnZnVuY3Rpb24nKSB7XG4gICAgdHJ5IHtcbiAgICAgIHZhbCA9IGZ1bmMuY2FsbCh0aGlzQXJnKTtcbiAgICB9IGNhdGNoIChlKSB7XG4gICAgICBlcnIgPSBlO1xuICAgIH1cbiAgICBwcm9jZXNzLm5leHRUaWNrKGZ1bmN0aW9uKCkge1xuICAgICAgaWYgKHZhbCA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICAgIGNhbGxiYWNrKGVycik7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBjYWxsYmFjayhlcnIsIHZhbCk7XG4gICAgICB9XG4gICAgfSk7XG4gIH0gZWxzZSBpZiAoY3R4ICYmIHR5cGVvZiBjdHggPT09ICdvYmplY3QnKSB7XG4gICAgdHJ5IHtcbiAgICAgIHJldHVybiBmdW5jLmNhbGwodGhpc0FyZyk7XG4gICAgfSBjYXRjaCAoZSkge1xuICAgICAgLy8gZGVmYXVsdCB0byBlcnJubyBmb3IgVU5LTk9XTlxuICAgICAgY3R4LmNvZGUgPSBlLmNvZGUgfHwgJ1VOS05PV04nO1xuICAgICAgY3R4LmVycm5vID0gZS5lcnJubyB8fCBGU0Vycm9yLmNvZGVzLlVOS05PV04uZXJybm87XG4gICAgfVxuICB9IGVsc2Uge1xuICAgIHJldHVybiBmdW5jLmNhbGwodGhpc0FyZyk7XG4gIH1cbn1cblxuLyoqXG4gKiBzZXQgc3lzY2FsbCBwcm9wZXJ0eSBvbiBjb250ZXh0IG9iamVjdCwgb25seSBmb3Igbm9kZWpzIHYxMCsuXG4gKiBAcGFyYW0ge09iamVjdH0gY3R4IENvbnRleHQgb2JqZWN0IChvcHRpb25hbCksIG9ubHkgZm9yIG5vZGVqcyB2MTArLlxuICogQHBhcmFtIHtTdHJpbmd9IHN5c2NhbGwgTmFtZSBvZiBzeXNjYWxsLlxuICovXG5mdW5jdGlvbiBtYXJrU3lzY2FsbChjdHgsIHN5c2NhbGwpIHtcbiAgaWYgKGN0eCAmJiB0eXBlb2YgY3R4ID09PSAnb2JqZWN0Jykge1xuICAgIGN0eC5zeXNjYWxsID0gc3lzY2FsbDtcbiAgfVxufVxuXG4vKipcbiAqIEhhbmRsZSBGU1JlcVdyYXAgb25jb21wbGV0ZS5cbiAqIEBwYXJhbSB7RnVuY3Rpb259IGNhbGxiYWNrIFRoZSBjYWxsYmFjay5cbiAqIEByZXR1cm4ge0Z1bmN0aW9ufSBUaGUgbm9ybWFsaXplZCBjYWxsYmFjay5cbiAqL1xuZnVuY3Rpb24gbm9ybWFsaXplQ2FsbGJhY2soY2FsbGJhY2spIHtcbiAgaWYgKGNhbGxiYWNrICYmIHR5cGVvZiBjYWxsYmFjay5vbmNvbXBsZXRlID09PSAnZnVuY3Rpb24nKSB7XG4gICAgLy8gVW5wYWNrIGNhbGxiYWNrIGZyb20gRlNSZXFXcmFwXG4gICAgY2FsbGJhY2sgPSBjYWxsYmFjay5vbmNvbXBsZXRlLmJpbmQoY2FsbGJhY2spO1xuICB9XG4gIHJldHVybiBjYWxsYmFjaztcbn1cblxuLyoqXG4gKiBIYW5kbGUgc3RhdCBvcHRpbWl6YXRpb25zIGludHJvZHVjZWQgaW4gTm9kZSA4LlxuICogU2VlIGh0dHBzOi8vZ2l0aHViLmNvbS9ub2RlanMvbm9kZS9wdWxsLzExNjY1LlxuICogQHBhcmFtIHtGdW5jdGlvbn0gY2FsbGJhY2sgVGhlIGNhbGxiYWNrLlxuICogQHJldHVybiB7RnVuY3Rpb259IFRoZSB3cmFwcGVkIGNhbGxiYWNrLlxuICovXG5mdW5jdGlvbiB3cmFwU3RhdHNDYWxsYmFjayhjYWxsYmFjaykge1xuICBpZiAoY2FsbGJhY2sgJiYgdHlwZW9mIGNhbGxiYWNrLm9uY29tcGxldGUgPT09ICdmdW5jdGlvbicpIHtcbiAgICAvLyBVbnBhY2sgY2FsbGJhY2sgZnJvbSBGU1JlcVdyYXBcbiAgICBjYWxsYmFjayA9IGNhbGxiYWNrLm9uY29tcGxldGUuYmluZChjYWxsYmFjayk7XG4gIH1cbiAgaWYgKHR5cGVvZiBjYWxsYmFjayA9PT0gJ2Z1bmN0aW9uJykge1xuICAgIHJldHVybiBmdW5jdGlvbihlcnIsIHN0YXRzKSB7XG4gICAgICBpZiAoc3RhdHMpIHtcbiAgICAgICAgZmlsbFN0YXRzQXJyYXkoc3RhdHMsIHN0YXRWYWx1ZXMpO1xuICAgICAgfVxuICAgICAgY2FsbGJhY2suYXBwbHkodGhpcywgYXJndW1lbnRzKTtcbiAgICB9O1xuICB9IGVsc2Uge1xuICAgIHJldHVybiBjYWxsYmFjaztcbiAgfVxufVxuXG5mdW5jdGlvbiBnZXREaXJlbnRUeXBlKG1vZGUpIHtcbiAgY29uc3Qga3R5cGUgPSBNT0RFX1RPX0tUWVBFW21vZGUgJiBjb25zdGFudHMuU19JRk1UXTtcblxuICBpZiAoa3R5cGUgPT09IHVuZGVmaW5lZCkge1xuICAgIHJldHVybiBjb25zdGFudHMuVVZfRElSRU5UX1VOS05PV047XG4gIH1cblxuICByZXR1cm4ga3R5cGU7XG59XG5cbmZ1bmN0aW9uIG5vdEltcGxlbWVudGVkKCkge1xuICB0aHJvdyBuZXcgRXJyb3IoJ01ldGhvZCBub3QgaW1wbGVtZW50ZWQnKTtcbn1cblxuZnVuY3Rpb24gZGVCdWZmZXIocCkge1xuICByZXR1cm4gQnVmZmVyLmlzQnVmZmVyKHApID8gcC50b1N0cmluZygpIDogcDtcbn1cblxuLyoqXG4gKiBDcmVhdGUgYSBuZXcgc3RhdHMgb2JqZWN0LlxuICogQHBhcmFtIHtPYmplY3R9IGNvbmZpZyBTdGF0cyBwcm9wZXJ0aWVzLlxuICogQGNvbnN0cnVjdG9yXG4gKi9cbmZ1bmN0aW9uIFN0YXRzKGNvbmZpZykge1xuICBmb3IgKGNvbnN0IGtleSBpbiBjb25maWcpIHtcbiAgICB0aGlzW2tleV0gPSBjb25maWdba2V5XTtcbiAgfVxuICAvLyBub2RlIDEwIGV4cGVjdHMgYW4gYXJyYXkgaW50ZXJuYWxseVxuICAvLyBzZWUgaHR0cHM6Ly9naXRodWIuY29tL25vZGVqcy9ub2RlL3B1bGwvMTk3MTRcbiAgZmlsbFN0YXRzQXJyYXkoY29uZmlnLCB0aGlzKTtcbn1cblxuLyoqXG4gKiBDaGVjayBpZiBtb2RlIGluZGljYXRlcyBwcm9wZXJ0eS5cbiAqIEBwYXJhbSB7bnVtYmVyfSBwcm9wZXJ0eSBQcm9wZXJ0eSB0byBjaGVjay5cbiAqIEByZXR1cm4ge2Jvb2xlYW59IFByb3BlcnR5IG1hdGNoZXMgbW9kZS5cbiAqL1xuU3RhdHMucHJvdG90eXBlLl9jaGVja01vZGVQcm9wZXJ0eSA9IGZ1bmN0aW9uKHByb3BlcnR5KSB7XG4gIHJldHVybiAodGhpcy5tb2RlICYgY29uc3RhbnRzLlNfSUZNVCkgPT09IHByb3BlcnR5O1xufTtcblxuLyoqXG4gKiBAcmV0dXJuIHtCb29sZWFufSBJcyBhIGRpcmVjdG9yeS5cbiAqL1xuU3RhdHMucHJvdG90eXBlLmlzRGlyZWN0b3J5ID0gZnVuY3Rpb24oKSB7XG4gIHJldHVybiB0aGlzLl9jaGVja01vZGVQcm9wZXJ0eShjb25zdGFudHMuU19JRkRJUik7XG59O1xuXG4vKipcbiAqIEByZXR1cm4ge0Jvb2xlYW59IElzIGEgcmVndWxhciBmaWxlLlxuICovXG5TdGF0cy5wcm90b3R5cGUuaXNGaWxlID0gZnVuY3Rpb24oKSB7XG4gIHJldHVybiB0aGlzLl9jaGVja01vZGVQcm9wZXJ0eShjb25zdGFudHMuU19JRlJFRyk7XG59O1xuXG4vKipcbiAqIEByZXR1cm4ge0Jvb2xlYW59IElzIGEgYmxvY2sgZGV2aWNlLlxuICovXG5TdGF0cy5wcm90b3R5cGUuaXNCbG9ja0RldmljZSA9IGZ1bmN0aW9uKCkge1xuICByZXR1cm4gdGhpcy5fY2hlY2tNb2RlUHJvcGVydHkoY29uc3RhbnRzLlNfSUZCTEspO1xufTtcblxuLyoqXG4gKiBAcmV0dXJuIHtCb29sZWFufSBJcyBhIGNoYXJhY3RlciBkZXZpY2UuXG4gKi9cblN0YXRzLnByb3RvdHlwZS5pc0NoYXJhY3RlckRldmljZSA9IGZ1bmN0aW9uKCkge1xuICByZXR1cm4gdGhpcy5fY2hlY2tNb2RlUHJvcGVydHkoY29uc3RhbnRzLlNfSUZDSFIpO1xufTtcblxuLyoqXG4gKiBAcmV0dXJuIHtCb29sZWFufSBJcyBhIHN5bWJvbGljIGxpbmsuXG4gKi9cblN0YXRzLnByb3RvdHlwZS5pc1N5bWJvbGljTGluayA9IGZ1bmN0aW9uKCkge1xuICByZXR1cm4gdGhpcy5fY2hlY2tNb2RlUHJvcGVydHkoY29uc3RhbnRzLlNfSUZMTkspO1xufTtcblxuLyoqXG4gKiBAcmV0dXJuIHtCb29sZWFufSBJcyBhIG5hbWVkIHBpcGUuXG4gKi9cblN0YXRzLnByb3RvdHlwZS5pc0ZJRk8gPSBmdW5jdGlvbigpIHtcbiAgcmV0dXJuIHRoaXMuX2NoZWNrTW9kZVByb3BlcnR5KGNvbnN0YW50cy5TX0lGSUZPKTtcbn07XG5cbi8qKlxuICogQHJldHVybiB7Qm9vbGVhbn0gSXMgYSBzb2NrZXQuXG4gKi9cblN0YXRzLnByb3RvdHlwZS5pc1NvY2tldCA9IGZ1bmN0aW9uKCkge1xuICByZXR1cm4gdGhpcy5fY2hlY2tNb2RlUHJvcGVydHkoY29uc3RhbnRzLlNfSUZTT0NLKTtcbn07XG5cbi8qKlxuICogQ3JlYXRlIGEgbmV3IGJpbmRpbmcgd2l0aCB0aGUgZ2l2ZW4gZmlsZSBzeXN0ZW0uXG4gKiBAcGFyYW0ge0ZpbGVTeXN0ZW19IHN5c3RlbSBNb2NrIGZpbGUgc3lzdGVtLlxuICogQGNvbnN0cnVjdG9yXG4gKi9cbmZ1bmN0aW9uIEJpbmRpbmcoc3lzdGVtKSB7XG4gIC8qKlxuICAgKiBNb2NrIGZpbGUgc3lzdGVtLlxuICAgKiBAdHlwZSB7RmlsZVN5c3RlbX1cbiAgICovXG4gIHRoaXMuX3N5c3RlbSA9IHN5c3RlbTtcblxuICAvKipcbiAgICogU3RhdHMgY29uc3RydWN0b3IuXG4gICAqIEB0eXBlIHtmdW5jdGlvbn1cbiAgICovXG4gIHRoaXMuU3RhdHMgPSBTdGF0cztcblxuICAvKipcbiAgICogTG9va3VwIG9mIG9wZW4gZmlsZXMuXG4gICAqIEB0eXBlIHtPYmplY3QuPG51bWJlciwgRmlsZURlc2NyaXB0b3I+fVxuICAgKi9cbiAgdGhpcy5fb3BlbkZpbGVzID0ge307XG5cbiAgLyoqXG4gICAqIENvdW50ZXIgZm9yIGZpbGUgZGVzY3JpcHRvcnMuXG4gICAqIEB0eXBlIHtudW1iZXJ9XG4gICAqL1xuICB0aGlzLl9jb3VudGVyID0gLTE7XG5cbiAgY29uc3Qgc3RkaW4gPSBuZXcgRmlsZURlc2NyaXB0b3IoY29uc3RhbnRzLk9fUkRXUik7XG4gIHN0ZGluLnNldEl0ZW0obmV3IEZpbGUuU3RhbmRhcmRJbnB1dCgpKTtcbiAgdGhpcy50cmFja0Rlc2NyaXB0b3Ioc3RkaW4pO1xuXG4gIGNvbnN0IHN0ZG91dCA9IG5ldyBGaWxlRGVzY3JpcHRvcihjb25zdGFudHMuT19SRFdSKTtcbiAgc3Rkb3V0LnNldEl0ZW0obmV3IEZpbGUuU3RhbmRhcmRPdXRwdXQoKSk7XG4gIHRoaXMudHJhY2tEZXNjcmlwdG9yKHN0ZG91dCk7XG5cbiAgY29uc3Qgc3RkZXJyID0gbmV3IEZpbGVEZXNjcmlwdG9yKGNvbnN0YW50cy5PX1JEV1IpO1xuICBzdGRlcnIuc2V0SXRlbShuZXcgRmlsZS5TdGFuZGFyZEVycm9yKCkpO1xuICB0aGlzLnRyYWNrRGVzY3JpcHRvcihzdGRlcnIpO1xufVxuXG4vKipcbiAqIEdldCB0aGUgZmlsZSBzeXN0ZW0gdW5kZXJseWluZyB0aGlzIGJpbmRpbmcuXG4gKiBAcmV0dXJuIHtGaWxlU3lzdGVtfSBUaGUgdW5kZXJseWluZyBmaWxlIHN5c3RlbS5cbiAqL1xuQmluZGluZy5wcm90b3R5cGUuZ2V0U3lzdGVtID0gZnVuY3Rpb24oKSB7XG4gIHJldHVybiB0aGlzLl9zeXN0ZW07XG59O1xuXG4vKipcbiAqIFJlc2V0IHRoZSBmaWxlIHN5c3RlbSB1bmRlcmx5aW5nIHRoaXMgYmluZGluZy5cbiAqIEBwYXJhbSB7RmlsZVN5c3RlbX0gc3lzdGVtIFRoZSBuZXcgZmlsZSBzeXN0ZW0uXG4gKi9cbkJpbmRpbmcucHJvdG90eXBlLnNldFN5c3RlbSA9IGZ1bmN0aW9uKHN5c3RlbSkge1xuICB0aGlzLl9zeXN0ZW0gPSBzeXN0ZW07XG59O1xuXG4vKipcbiAqIEdldCBhIGZpbGUgZGVzY3JpcHRvci5cbiAqIEBwYXJhbSB7bnVtYmVyfSBmZCBGaWxlIGRlc2NyaXB0b3IgaWRlbnRpZmllci5cbiAqIEByZXR1cm4ge0ZpbGVEZXNjcmlwdG9yfSBGaWxlIGRlc2NyaXB0b3IuXG4gKi9cbkJpbmRpbmcucHJvdG90eXBlLmdldERlc2NyaXB0b3JCeUlkID0gZnVuY3Rpb24oZmQpIHtcbiAgaWYgKCF0aGlzLl9vcGVuRmlsZXMuaGFzT3duUHJvcGVydHkoZmQpKSB7XG4gICAgdGhyb3cgbmV3IEZTRXJyb3IoJ0VCQURGJyk7XG4gIH1cbiAgcmV0dXJuIHRoaXMuX29wZW5GaWxlc1tmZF07XG59O1xuXG4vKipcbiAqIEtlZXAgdHJhY2sgb2YgYSBmaWxlIGRlc2NyaXB0b3IgYXMgb3Blbi5cbiAqIEBwYXJhbSB7RmlsZURlc2NyaXB0b3J9IGRlc2NyaXB0b3IgVGhlIGZpbGUgZGVzY3JpcHRvci5cbiAqIEByZXR1cm4ge251bWJlcn0gSWRlbnRpZmllciBmb3IgZmlsZSBkZXNjcmlwdG9yLlxuICovXG5CaW5kaW5nLnByb3RvdHlwZS50cmFja0Rlc2NyaXB0b3IgPSBmdW5jdGlvbihkZXNjcmlwdG9yKSB7XG4gIGNvbnN0IGZkID0gKyt0aGlzLl9jb3VudGVyO1xuICB0aGlzLl9vcGVuRmlsZXNbZmRdID0gZGVzY3JpcHRvcjtcbiAgcmV0dXJuIGZkO1xufTtcblxuLyoqXG4gKiBTdG9wIHRyYWNraW5nIGEgZmlsZSBkZXNjcmlwdG9yIGFzIG9wZW4uXG4gKiBAcGFyYW0ge251bWJlcn0gZmQgSWRlbnRpZmllciBmb3IgZmlsZSBkZXNjcmlwdG9yLlxuICovXG5CaW5kaW5nLnByb3RvdHlwZS51bnRyYWNrRGVzY3JpcHRvckJ5SWQgPSBmdW5jdGlvbihmZCkge1xuICBpZiAoIXRoaXMuX29wZW5GaWxlcy5oYXNPd25Qcm9wZXJ0eShmZCkpIHtcbiAgICB0aHJvdyBuZXcgRlNFcnJvcignRUJBREYnKTtcbiAgfVxuICBkZWxldGUgdGhpcy5fb3BlbkZpbGVzW2ZkXTtcbn07XG5cbi8qKlxuICogUmVzb2x2ZSB0aGUgY2Fub25pY2FsaXplZCBhYnNvbHV0ZSBwYXRobmFtZS5cbiAqIEBwYXJhbSB7c3RyaW5nfEJ1ZmZlcn0gZmlsZXBhdGggVGhlIGZpbGUgcGF0aC5cbiAqIEBwYXJhbSB7c3RyaW5nfSBlbmNvZGluZyBUaGUgZW5jb2RpbmcgZm9yIHRoZSByZXR1cm4uXG4gKiBAcGFyYW0ge09iamVjdH0gY3R4IENvbnRleHQgb2JqZWN0IChvcHRpb25hbCksIG9ubHkgZm9yIG5vZGVqcyB2MTArLlxuICogQHJldHVybiB7c3RyaW5nfEJ1ZmZlcn0gVGhlIHJlYWwgcGF0aC5cbiAqL1xuQmluZGluZy5wcm90b3R5cGUucmVhbHBhdGggPSBmdW5jdGlvbihmaWxlcGF0aCwgZW5jb2RpbmcsIGNhbGxiYWNrLCBjdHgpIHtcbiAgbWFya1N5c2NhbGwoY3R4LCAncmVhbHBhdGgnKTtcblxuICByZXR1cm4gbWF5YmVDYWxsYmFjayhub3JtYWxpemVDYWxsYmFjayhjYWxsYmFjayksIGN0eCwgdGhpcywgZnVuY3Rpb24oKSB7XG4gICAgbGV0IHJlYWxQYXRoO1xuICAgIGZpbGVwYXRoID0gZGVCdWZmZXIoZmlsZXBhdGgpO1xuICAgIGNvbnN0IHJlc29sdmVkID0gcGF0aC5yZXNvbHZlKGZpbGVwYXRoKTtcbiAgICBjb25zdCBwYXJ0cyA9IGdldFBhdGhQYXJ0cyhyZXNvbHZlZCk7XG4gICAgbGV0IGl0ZW0gPSB0aGlzLl9zeXN0ZW0uZ2V0Um9vdCgpO1xuICAgIGxldCBpdGVtUGF0aCA9ICcvJztcbiAgICBsZXQgbmFtZSwgaSwgaWk7XG4gICAgZm9yIChpID0gMCwgaWkgPSBwYXJ0cy5sZW5ndGg7IGkgPCBpaTsgKytpKSB7XG4gICAgICBuYW1lID0gcGFydHNbaV07XG4gICAgICB3aGlsZSAoaXRlbSBpbnN0YW5jZW9mIFN5bWJvbGljTGluaykge1xuICAgICAgICBpdGVtUGF0aCA9IHBhdGgucmVzb2x2ZShwYXRoLmRpcm5hbWUoaXRlbVBhdGgpLCBpdGVtLmdldFBhdGgoKSk7XG4gICAgICAgIGl0ZW0gPSB0aGlzLl9zeXN0ZW0uZ2V0SXRlbShpdGVtUGF0aCk7XG4gICAgICB9XG4gICAgICBpZiAoIWl0ZW0pIHtcbiAgICAgICAgdGhyb3cgbmV3IEZTRXJyb3IoJ0VOT0VOVCcsIGZpbGVwYXRoKTtcbiAgICAgIH1cbiAgICAgIGlmIChpdGVtIGluc3RhbmNlb2YgRGlyZWN0b3J5KSB7XG4gICAgICAgIGl0ZW1QYXRoID0gcGF0aC5yZXNvbHZlKGl0ZW1QYXRoLCBuYW1lKTtcbiAgICAgICAgaXRlbSA9IGl0ZW0uZ2V0SXRlbShuYW1lKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHRocm93IG5ldyBGU0Vycm9yKCdFTk9URElSJywgZmlsZXBhdGgpO1xuICAgICAgfVxuICAgIH1cbiAgICBpZiAoaXRlbSkge1xuICAgICAgd2hpbGUgKGl0ZW0gaW5zdGFuY2VvZiBTeW1ib2xpY0xpbmspIHtcbiAgICAgICAgaXRlbVBhdGggPSBwYXRoLnJlc29sdmUocGF0aC5kaXJuYW1lKGl0ZW1QYXRoKSwgaXRlbS5nZXRQYXRoKCkpO1xuICAgICAgICBpdGVtID0gdGhpcy5fc3lzdGVtLmdldEl0ZW0oaXRlbVBhdGgpO1xuICAgICAgfVxuICAgICAgcmVhbFBhdGggPSBpdGVtUGF0aDtcbiAgICB9IGVsc2Uge1xuICAgICAgdGhyb3cgbmV3IEZTRXJyb3IoJ0VOT0VOVCcsIGZpbGVwYXRoKTtcbiAgICB9XG5cbiAgICBpZiAocHJvY2Vzcy5wbGF0Zm9ybSA9PT0gJ3dpbjMyJyAmJiByZWFsUGF0aC5zdGFydHNXaXRoKCdcXFxcXFxcXD9cXFxcJykpIHtcbiAgICAgIC8vIFJlbW92ZSB3aW4zMiBmaWxlIG5hbWVzcGFjZSBwcmVmaXggXFxcXD9cXFxuICAgICAgcmVhbFBhdGggPSByZWFsUGF0aC5zbGljZSg0KTtcbiAgICB9XG5cbiAgICBpZiAoZW5jb2RpbmcgPT09ICdidWZmZXInKSB7XG4gICAgICByZWFsUGF0aCA9IGJ1ZmZlckZyb20ocmVhbFBhdGgpO1xuICAgIH1cblxuICAgIHJldHVybiByZWFsUGF0aDtcbiAgfSk7XG59O1xuXG4vKipcbiAqIEZpbGwgYSBGbG9hdDY0QXJyYXkgd2l0aCBzdGF0IGluZm9ybWF0aW9uXG4gKiBUaGlzIGlzIGJhc2VkIG9uIHRoZSBpbnRlcm5hbCBGaWxsU3RhdHNBcnJheSBmdW5jdGlvbiBpbiBOb2RlLlxuICogaHR0cHM6Ly9naXRodWIuY29tL25vZGVqcy9ub2RlL2Jsb2IvNGUwNTk1MmE4YTc1YWY2ZGY2MjU0MTVkYjYxMmQzYTlhMTMyMjY4Mi9zcmMvbm9kZV9maWxlLmNjI0w1MzNcbiAqIEBwYXJhbSB7T2JqZWN0fSBzdGF0cyBBbiBvYmplY3Qgd2l0aCBmaWxlIHN0YXRzXG4gKiBAcGFyYW0ge0Zsb2F0NjRBcnJheX0gc3RhdFZhbHVlcyBBIEZsb2F0NjRBcnJheSB3aGVyZSBzdGF0IHZhbHVlcyBzaG91bGQgYmUgaW5zZXJ0ZWRcbiAqIEByZXR1cm5zIHt2b2lkfVxuICovXG5mdW5jdGlvbiBmaWxsU3RhdHNBcnJheShzdGF0cywgc3RhdFZhbHVlcykge1xuICBzdGF0VmFsdWVzWzBdID0gc3RhdHMuZGV2O1xuICBzdGF0VmFsdWVzWzFdID0gc3RhdHMubW9kZTtcbiAgc3RhdFZhbHVlc1syXSA9IHN0YXRzLm5saW5rO1xuICBzdGF0VmFsdWVzWzNdID0gc3RhdHMudWlkO1xuICBzdGF0VmFsdWVzWzRdID0gc3RhdHMuZ2lkO1xuICBzdGF0VmFsdWVzWzVdID0gc3RhdHMucmRldjtcbiAgc3RhdFZhbHVlc1s2XSA9IHN0YXRzLmJsa3NpemU7XG4gIHN0YXRWYWx1ZXNbN10gPSBzdGF0cy5pbm87XG4gIHN0YXRWYWx1ZXNbOF0gPSBzdGF0cy5zaXplO1xuICBzdGF0VmFsdWVzWzldID0gc3RhdHMuYmxvY2tzO1xuXG4gIGlmIChzdGF0Q29udGFpbnNOcykge1xuICAgIC8vIG5vZGVqcyB2MTIuMTAuMCtcbiAgICAvLyBUaGlzIGlzIGJhc2VkIG9uIHRoZSBpbnRlcm5hbCBGaWxsU3RhdHNBcnJheSBmdW5jdGlvbiBpbiBOb2RlLlxuICAgIC8vIGh0dHBzOi8vZ2l0aHViLmNvbS9ub2RlanMvbm9kZS9ibG9iLzNhMmU3NWQ5YTVjMzFkMjBlNDI5ZDUwNWI4MmRkMTgyZTMzZjQ1OWEvc3JjL25vZGVfZmlsZS5oI0wxNTMtTDE4N1xuICAgIHN0YXRWYWx1ZXNbMTBdID0gTWF0aC5mbG9vcihzdGF0cy5hdGltZU1zIC8gMTAwMCk7XG4gICAgc3RhdFZhbHVlc1sxMV0gPSAoc3RhdHMuYXRpbWVNcyAlIDEwMDApICogMTAwMDAwMDtcbiAgICBzdGF0VmFsdWVzWzEyXSA9IE1hdGguZmxvb3Ioc3RhdHMubXRpbWVNcyAvIDEwMDApO1xuICAgIHN0YXRWYWx1ZXNbMTNdID0gKHN0YXRzLm10aW1lTXMgJSAxMDAwKSAqIDEwMDAwMDA7XG4gICAgc3RhdFZhbHVlc1sxNF0gPSBNYXRoLmZsb29yKHN0YXRzLmN0aW1lTXMgLyAxMDAwKTtcbiAgICBzdGF0VmFsdWVzWzE1XSA9IChzdGF0cy5jdGltZU1zICUgMTAwMCkgKiAxMDAwMDAwO1xuICAgIHN0YXRWYWx1ZXNbMTZdID0gTWF0aC5mbG9vcihzdGF0cy5iaXJ0aHRpbWVNcyAvIDEwMDApO1xuICAgIHN0YXRWYWx1ZXNbMTddID0gKHN0YXRzLmJpcnRodGltZU1zICUgMTAwMCkgKiAxMDAwMDAwO1xuICB9IGVsc2Uge1xuICAgIC8vIG5vZGVqcyBiZWZvcmUgdjEyLjEwLjBcbiAgICAvLyBUaGlzIGlzIGJhc2VkIG9uIHRoZSBpbnRlcm5hbCBGaWxsU3RhdHNBcnJheSBmdW5jdGlvbiBpbiBOb2RlLlxuICAgIC8vIGh0dHBzOi8vZ2l0aHViLmNvbS9ub2RlanMvbm9kZS9ibG9iLzRlMDU5NTJhOGE3NWFmNmRmNjI1NDE1ZGI2MTJkM2E5YTEzMjI2ODIvc3JjL25vZGVfZmlsZS5jYyNMNTMzXG4gICAgc3RhdFZhbHVlc1sxMF0gPSBzdGF0cy5hdGltZU1zO1xuICAgIHN0YXRWYWx1ZXNbMTFdID0gc3RhdHMubXRpbWVNcztcbiAgICBzdGF0VmFsdWVzWzEyXSA9IHN0YXRzLmN0aW1lTXM7XG4gICAgc3RhdFZhbHVlc1sxM10gPSBzdGF0cy5iaXJ0aHRpbWVNcztcbiAgfVxufVxuXG4vKipcbiAqIFN0YXQgYW4gaXRlbS5cbiAqIEBwYXJhbSB7c3RyaW5nfSBmaWxlcGF0aCBQYXRoLlxuICogQHBhcmFtIHtmdW5jdGlvbihFcnJvciwgU3RhdHMpfEZsb2F0NjRBcnJheXxCaWdVaW50NjRBcnJheX0gY2FsbGJhY2sgQ2FsbGJhY2sgKG9wdGlvbmFsKS4gSW4gTm9kZSA3LjcuMCsgdGhpcyB3aWxsIGJlIGEgRmxvYXQ2NEFycmF5XG4gKiB0aGF0IHNob3VsZCBiZSBmaWxsZWQgd2l0aCBzdGF0IHZhbHVlcy5cbiAqIEBwYXJhbSB7T2JqZWN0fSBjdHggQ29udGV4dCBvYmplY3QgKG9wdGlvbmFsKSwgb25seSBmb3Igbm9kZWpzIHYxMCsuXG4gKiBAcmV0dXJuIHtTdGF0c3x1bmRlZmluZWR9IFN0YXRzIG9yIHVuZGVmaW5lZCAoaWYgc3luYykuXG4gKi9cbkJpbmRpbmcucHJvdG90eXBlLnN0YXQgPSBmdW5jdGlvbihmaWxlcGF0aCwgb3B0aW9ucywgY2FsbGJhY2ssIGN0eCkge1xuICAvLyB0aGlzIHNlZW1zIHdvdW5kIG5vdCBoYXBwZW4gaW4gbm9kZWpzIHYxMCtcbiAgaWYgKGFyZ3VtZW50cy5sZW5ndGggPCAzKSB7XG4gICAgY2FsbGJhY2sgPSBvcHRpb25zO1xuICAgIG9wdGlvbnMgPSB7fTtcbiAgfVxuXG4gIG1hcmtTeXNjYWxsKGN0eCwgJ3N0YXQnKTtcblxuICByZXR1cm4gbWF5YmVDYWxsYmFjayh3cmFwU3RhdHNDYWxsYmFjayhjYWxsYmFjayksIGN0eCwgdGhpcywgZnVuY3Rpb24oKSB7XG4gICAgZmlsZXBhdGggPSBkZUJ1ZmZlcihmaWxlcGF0aCk7XG4gICAgbGV0IGl0ZW0gPSB0aGlzLl9zeXN0ZW0uZ2V0SXRlbShmaWxlcGF0aCk7XG4gICAgaWYgKGl0ZW0gaW5zdGFuY2VvZiBTeW1ib2xpY0xpbmspIHtcbiAgICAgIGl0ZW0gPSB0aGlzLl9zeXN0ZW0uZ2V0SXRlbShcbiAgICAgICAgcGF0aC5yZXNvbHZlKHBhdGguZGlybmFtZShmaWxlcGF0aCksIGl0ZW0uZ2V0UGF0aCgpKVxuICAgICAgKTtcbiAgICB9XG4gICAgaWYgKCFpdGVtKSB7XG4gICAgICB0aHJvdyBuZXcgRlNFcnJvcignRU5PRU5UJywgZmlsZXBhdGgpO1xuICAgIH1cbiAgICBjb25zdCBzdGF0cyA9IGl0ZW0uZ2V0U3RhdHMoKTtcblxuICAgIC8vIEluIE5vZGUgNy43LjArLCBiaW5kaW5nLnN0YXQgYWNjZXB0cyBhIEZsb2F0NjRBcnJheSBhcyB0aGUgc2Vjb25kIGFyZ3VtZW50LFxuICAgIC8vIHdoaWNoIHNob3VsZCBiZSBmaWxsZWQgd2l0aCBzdGF0IHZhbHVlcy5cbiAgICAvLyBJbiBwcmlvciB2ZXJzaW9ucyBvZiBOb2RlLCBiaW5kaW5nLnN0YXQgc2ltcGx5IHJldHVybnMgYSBTdGF0cyBpbnN0YW5jZS5cbiAgICBpZiAoXG4gICAgICBjYWxsYmFjayBpbnN0YW5jZW9mIEZsb2F0NjRBcnJheSB8fFxuICAgICAgY2FsbGJhY2sgaW5zdGFuY2VvZiBCaWdVaW50NjRBcnJheVxuICAgICkge1xuICAgICAgZmlsbFN0YXRzQXJyYXkoc3RhdHMsIGNhbGxiYWNrKTtcbiAgICB9IGVsc2Uge1xuICAgICAgZmlsbFN0YXRzQXJyYXkoc3RhdHMsIHN0YXRWYWx1ZXMpO1xuICAgICAgcmV0dXJuIG5ldyBTdGF0cyhzdGF0cyk7XG4gICAgfVxuICB9KTtcbn07XG5cbi8qKlxuICogU3RhdCBhbiBpdGVtLlxuICogQHBhcmFtIHtudW1iZXJ9IGZkIEZpbGUgZGVzY3JpcHRvci5cbiAqIEBwYXJhbSB7ZnVuY3Rpb24oRXJyb3IsIFN0YXRzKXxGbG9hdDY0QXJyYXl8QmlnVWludDY0QXJyYXl9IGNhbGxiYWNrIENhbGxiYWNrIChvcHRpb25hbCkuIEluIE5vZGUgNy43LjArIHRoaXMgd2lsbCBiZSBhIEZsb2F0NjRBcnJheVxuICogdGhhdCBzaG91bGQgYmUgZmlsbGVkIHdpdGggc3RhdCB2YWx1ZXMuXG4gKiBAcGFyYW0ge09iamVjdH0gY3R4IENvbnRleHQgb2JqZWN0IChvcHRpb25hbCksIG9ubHkgZm9yIG5vZGVqcyB2MTArLlxuICogQHJldHVybiB7U3RhdHN8dW5kZWZpbmVkfSBTdGF0cyBvciB1bmRlZmluZWQgKGlmIHN5bmMpLlxuICovXG5CaW5kaW5nLnByb3RvdHlwZS5mc3RhdCA9IGZ1bmN0aW9uKGZkLCBvcHRpb25zLCBjYWxsYmFjaywgY3R4KSB7XG4gIGlmIChhcmd1bWVudHMubGVuZ3RoIDwgMykge1xuICAgIGNhbGxiYWNrID0gb3B0aW9ucztcbiAgICBvcHRpb25zID0ge307XG4gIH1cblxuICBtYXJrU3lzY2FsbChjdHgsICdmc3RhdCcpO1xuXG4gIHJldHVybiBtYXliZUNhbGxiYWNrKHdyYXBTdGF0c0NhbGxiYWNrKGNhbGxiYWNrKSwgY3R4LCB0aGlzLCBmdW5jdGlvbigpIHtcbiAgICBjb25zdCBkZXNjcmlwdG9yID0gdGhpcy5nZXREZXNjcmlwdG9yQnlJZChmZCk7XG4gICAgY29uc3QgaXRlbSA9IGRlc2NyaXB0b3IuZ2V0SXRlbSgpO1xuICAgIGNvbnN0IHN0YXRzID0gaXRlbS5nZXRTdGF0cygpO1xuXG4gICAgLy8gSW4gTm9kZSA3LjcuMCssIGJpbmRpbmcuc3RhdCBhY2NlcHRzIGEgRmxvYXQ2NEFycmF5IGFzIHRoZSBzZWNvbmQgYXJndW1lbnQsXG4gICAgLy8gd2hpY2ggc2hvdWxkIGJlIGZpbGxlZCB3aXRoIHN0YXQgdmFsdWVzLlxuICAgIC8vIEluIHByaW9yIHZlcnNpb25zIG9mIE5vZGUsIGJpbmRpbmcuc3RhdCBzaW1wbHkgcmV0dXJucyBhIFN0YXRzIGluc3RhbmNlLlxuICAgIGlmIChcbiAgICAgIGNhbGxiYWNrIGluc3RhbmNlb2YgRmxvYXQ2NEFycmF5IHx8XG4gICAgICBjYWxsYmFjayBpbnN0YW5jZW9mIEJpZ1VpbnQ2NEFycmF5XG4gICAgKSB7XG4gICAgICBmaWxsU3RhdHNBcnJheShzdGF0cywgY2FsbGJhY2spO1xuICAgIH0gZWxzZSB7XG4gICAgICBmaWxsU3RhdHNBcnJheShzdGF0cywgc3RhdFZhbHVlcyk7XG4gICAgICByZXR1cm4gbmV3IFN0YXRzKHN0YXRzKTtcbiAgICB9XG4gIH0pO1xufTtcblxuLyoqXG4gKiBDbG9zZSBhIGZpbGUgZGVzY3JpcHRvci5cbiAqIEBwYXJhbSB7bnVtYmVyfSBmZCBGaWxlIGRlc2NyaXB0b3IuXG4gKiBAcGFyYW0ge2Z1bmN0aW9uKEVycm9yKX0gY2FsbGJhY2sgQ2FsbGJhY2sgKG9wdGlvbmFsKS5cbiAqIEBwYXJhbSB7T2JqZWN0fSBjdHggQ29udGV4dCBvYmplY3QgKG9wdGlvbmFsKSwgb25seSBmb3Igbm9kZWpzIHYxMCsuXG4gKi9cbkJpbmRpbmcucHJvdG90eXBlLmNsb3NlID0gZnVuY3Rpb24oZmQsIGNhbGxiYWNrLCBjdHgpIHtcbiAgbWFya1N5c2NhbGwoY3R4LCAnY2xvc2UnKTtcblxuICByZXR1cm4gbWF5YmVDYWxsYmFjayhub3JtYWxpemVDYWxsYmFjayhjYWxsYmFjayksIGN0eCwgdGhpcywgZnVuY3Rpb24oKSB7XG4gICAgdGhpcy51bnRyYWNrRGVzY3JpcHRvckJ5SWQoZmQpO1xuICB9KTtcbn07XG5cbi8qKlxuICogT3BlbiBhbmQgcG9zc2libHkgY3JlYXRlIGEgZmlsZS5cbiAqIEBwYXJhbSB7c3RyaW5nfSBwYXRobmFtZSBGaWxlIHBhdGguXG4gKiBAcGFyYW0ge251bWJlcn0gZmxhZ3MgRmxhZ3MuXG4gKiBAcGFyYW0ge251bWJlcn0gbW9kZSBNb2RlLlxuICogQHBhcmFtIHtmdW5jdGlvbihFcnJvciwgc3RyaW5nKX0gY2FsbGJhY2sgQ2FsbGJhY2sgKG9wdGlvbmFsKS5cbiAqIEBwYXJhbSB7T2JqZWN0fSBjdHggQ29udGV4dCBvYmplY3QgKG9wdGlvbmFsKSwgb25seSBmb3Igbm9kZWpzIHYxMCsuXG4gKiBAcmV0dXJuIHtzdHJpbmd9IEZpbGUgZGVzY3JpcHRvciAoaWYgc3luYykuXG4gKi9cbkJpbmRpbmcucHJvdG90eXBlLm9wZW4gPSBmdW5jdGlvbihwYXRobmFtZSwgZmxhZ3MsIG1vZGUsIGNhbGxiYWNrLCBjdHgpIHtcbiAgbWFya1N5c2NhbGwoY3R4LCAnb3BlbicpO1xuXG4gIHJldHVybiBtYXliZUNhbGxiYWNrKG5vcm1hbGl6ZUNhbGxiYWNrKGNhbGxiYWNrKSwgY3R4LCB0aGlzLCBmdW5jdGlvbigpIHtcbiAgICBwYXRobmFtZSA9IGRlQnVmZmVyKHBhdGhuYW1lKTtcbiAgICBjb25zdCBkZXNjcmlwdG9yID0gbmV3IEZpbGVEZXNjcmlwdG9yKGZsYWdzKTtcbiAgICBsZXQgaXRlbSA9IHRoaXMuX3N5c3RlbS5nZXRJdGVtKHBhdGhuYW1lKTtcbiAgICB3aGlsZSAoaXRlbSBpbnN0YW5jZW9mIFN5bWJvbGljTGluaykge1xuICAgICAgaXRlbSA9IHRoaXMuX3N5c3RlbS5nZXRJdGVtKFxuICAgICAgICBwYXRoLnJlc29sdmUocGF0aC5kaXJuYW1lKHBhdGhuYW1lKSwgaXRlbS5nZXRQYXRoKCkpXG4gICAgICApO1xuICAgIH1cbiAgICBpZiAoZGVzY3JpcHRvci5pc0V4Y2x1c2l2ZSgpICYmIGl0ZW0pIHtcbiAgICAgIHRocm93IG5ldyBGU0Vycm9yKCdFRVhJU1QnLCBwYXRobmFtZSk7XG4gICAgfVxuICAgIGlmIChkZXNjcmlwdG9yLmlzQ3JlYXRlKCkgJiYgIWl0ZW0pIHtcbiAgICAgIGNvbnN0IHBhcmVudCA9IHRoaXMuX3N5c3RlbS5nZXRJdGVtKHBhdGguZGlybmFtZShwYXRobmFtZSkpO1xuICAgICAgaWYgKCFwYXJlbnQpIHtcbiAgICAgICAgdGhyb3cgbmV3IEZTRXJyb3IoJ0VOT0VOVCcsIHBhdGhuYW1lKTtcbiAgICAgIH1cbiAgICAgIGlmICghKHBhcmVudCBpbnN0YW5jZW9mIERpcmVjdG9yeSkpIHtcbiAgICAgICAgdGhyb3cgbmV3IEZTRXJyb3IoJ0VOT1RESVInLCBwYXRobmFtZSk7XG4gICAgICB9XG4gICAgICBpdGVtID0gbmV3IEZpbGUoKTtcbiAgICAgIGlmIChtb2RlKSB7XG4gICAgICAgIGl0ZW0uc2V0TW9kZShtb2RlKTtcbiAgICAgIH1cbiAgICAgIHBhcmVudC5hZGRJdGVtKHBhdGguYmFzZW5hbWUocGF0aG5hbWUpLCBpdGVtKTtcbiAgICB9XG4gICAgaWYgKGRlc2NyaXB0b3IuaXNSZWFkKCkpIHtcbiAgICAgIGlmICghaXRlbSkge1xuICAgICAgICB0aHJvdyBuZXcgRlNFcnJvcignRU5PRU5UJywgcGF0aG5hbWUpO1xuICAgICAgfVxuICAgICAgaWYgKCFpdGVtLmNhblJlYWQoKSkge1xuICAgICAgICB0aHJvdyBuZXcgRlNFcnJvcignRUFDQ0VTJywgcGF0aG5hbWUpO1xuICAgICAgfVxuICAgIH1cbiAgICBpZiAoZGVzY3JpcHRvci5pc1dyaXRlKCkgJiYgIWl0ZW0uY2FuV3JpdGUoKSkge1xuICAgICAgdGhyb3cgbmV3IEZTRXJyb3IoJ0VBQ0NFUycsIHBhdGhuYW1lKTtcbiAgICB9XG4gICAgaWYgKFxuICAgICAgaXRlbSBpbnN0YW5jZW9mIERpcmVjdG9yeSAmJlxuICAgICAgKGRlc2NyaXB0b3IuaXNUcnVuY2F0ZSgpIHx8IGRlc2NyaXB0b3IuaXNBcHBlbmQoKSlcbiAgICApIHtcbiAgICAgIHRocm93IG5ldyBGU0Vycm9yKCdFSVNESVInLCBwYXRobmFtZSk7XG4gICAgfVxuICAgIGlmIChkZXNjcmlwdG9yLmlzVHJ1bmNhdGUoKSkge1xuICAgICAgaWYgKCEoaXRlbSBpbnN0YW5jZW9mIEZpbGUpKSB7XG4gICAgICAgIHRocm93IG5ldyBGU0Vycm9yKCdFQkFERicpO1xuICAgICAgfVxuICAgICAgaXRlbS5zZXRDb250ZW50KCcnKTtcbiAgICB9XG4gICAgaWYgKGRlc2NyaXB0b3IuaXNUcnVuY2F0ZSgpIHx8IGRlc2NyaXB0b3IuaXNBcHBlbmQoKSkge1xuICAgICAgZGVzY3JpcHRvci5zZXRQb3NpdGlvbihpdGVtLmdldENvbnRlbnQoKS5sZW5ndGgpO1xuICAgIH1cbiAgICBkZXNjcmlwdG9yLnNldEl0ZW0oaXRlbSk7XG4gICAgcmV0dXJuIHRoaXMudHJhY2tEZXNjcmlwdG9yKGRlc2NyaXB0b3IpO1xuICB9KTtcbn07XG5cbi8qKlxuICogT3BlbiBhIGZpbGUgaGFuZGxlci4gQSBuZXcgYXBpIGluIG5vZGVqcyB2MTArIGZvciBmcy5wcm9taXNlc1xuICogQHBhcmFtIHtzdHJpbmd9IHBhdGhuYW1lIEZpbGUgcGF0aC5cbiAqIEBwYXJhbSB7bnVtYmVyfSBmbGFncyBGbGFncy5cbiAqIEBwYXJhbSB7bnVtYmVyfSBtb2RlIE1vZGUuXG4gKiBAcGFyYW0ge2Z1bmN0aW9ufSBjYWxsYmFjayBDYWxsYmFjayAob3B0aW9uYWwpLCBleHBlY3Rpbmcga1VzZVByb21pc2VzIGluIG5vZGVqcyB2MTArLlxuICovXG5CaW5kaW5nLnByb3RvdHlwZS5vcGVuRmlsZUhhbmRsZSA9IGZ1bmN0aW9uKHBhdGhuYW1lLCBmbGFncywgbW9kZSwgY2FsbGJhY2spIHtcbiAgY29uc3Qgc2VsZiA9IHRoaXM7XG5cbiAgcmV0dXJuIHRoaXMub3BlbihwYXRobmFtZSwgZmxhZ3MsIG1vZGUsIGtVc2VQcm9taXNlcykudGhlbihmdW5jdGlvbihmZCkge1xuICAgIC8vIG5vZGVqcyB2MTArIGZzLnByb21pc2VzIEZpbGVIYW5kbGVyIGNvbnN0cnVjdG9yIG9ubHkgYXNrIHRoZXNlIHRocmVlIHByb3BlcnRpZXMuXG4gICAgcmV0dXJuIHtcbiAgICAgIGdldEFzeW5jSWQ6IG5vdEltcGxlbWVudGVkLFxuICAgICAgZmQ6IGZkLFxuICAgICAgY2xvc2U6IGZ1bmN0aW9uKCkge1xuICAgICAgICByZXR1cm4gc2VsZi5jbG9zZShmZCwga1VzZVByb21pc2VzKTtcbiAgICAgIH1cbiAgICB9O1xuICB9KTtcbn07XG5cbi8qKlxuICogUmVhZCBmcm9tIGEgZmlsZSBkZXNjcmlwdG9yLlxuICogQHBhcmFtIHtzdHJpbmd9IGZkIEZpbGUgZGVzY3JpcHRvci5cbiAqIEBwYXJhbSB7QnVmZmVyfSBidWZmZXIgQnVmZmVyIHRoYXQgdGhlIGNvbnRlbnRzIHdpbGwgYmUgd3JpdHRlbiB0by5cbiAqIEBwYXJhbSB7bnVtYmVyfSBvZmZzZXQgT2Zmc2V0IGluIHRoZSBidWZmZXIgdG8gc3RhcnQgd3JpdGluZyB0by5cbiAqIEBwYXJhbSB7bnVtYmVyfSBsZW5ndGggTnVtYmVyIG9mIGJ5dGVzIHRvIHJlYWQuXG4gKiBAcGFyYW0gez9udW1iZXJ9IHBvc2l0aW9uIFdoZXJlIHRvIGJlZ2luIHJlYWRpbmcgaW4gdGhlIGZpbGUuICBJZiBudWxsLFxuICogICAgIGRhdGEgd2lsbCBiZSByZWFkIGZyb20gdGhlIGN1cnJlbnQgZmlsZSBwb3NpdGlvbi5cbiAqIEBwYXJhbSB7ZnVuY3Rpb24oRXJyb3IsIG51bWJlciwgQnVmZmVyKX0gY2FsbGJhY2sgQ2FsbGJhY2sgKG9wdGlvbmFsKSBjYWxsZWRcbiAqICAgICB3aXRoIGFueSBlcnJvciwgbnVtYmVyIG9mIGJ5dGVzIHJlYWQsIGFuZCB0aGUgYnVmZmVyLlxuICogQHBhcmFtIHtPYmplY3R9IGN0eCBDb250ZXh0IG9iamVjdCAob3B0aW9uYWwpLCBvbmx5IGZvciBub2RlanMgdjEwKy5cbiAqIEByZXR1cm4ge251bWJlcn0gTnVtYmVyIG9mIGJ5dGVzIHJlYWQgKGlmIHN5bmMpLlxuICovXG5CaW5kaW5nLnByb3RvdHlwZS5yZWFkID0gZnVuY3Rpb24oXG4gIGZkLFxuICBidWZmZXIsXG4gIG9mZnNldCxcbiAgbGVuZ3RoLFxuICBwb3NpdGlvbixcbiAgY2FsbGJhY2ssXG4gIGN0eFxuKSB7XG4gIG1hcmtTeXNjYWxsKGN0eCwgJ3JlYWQnKTtcblxuICByZXR1cm4gbWF5YmVDYWxsYmFjayhub3JtYWxpemVDYWxsYmFjayhjYWxsYmFjayksIGN0eCwgdGhpcywgZnVuY3Rpb24oKSB7XG4gICAgY29uc3QgZGVzY3JpcHRvciA9IHRoaXMuZ2V0RGVzY3JpcHRvckJ5SWQoZmQpO1xuICAgIGlmICghZGVzY3JpcHRvci5pc1JlYWQoKSkge1xuICAgICAgdGhyb3cgbmV3IEZTRXJyb3IoJ0VCQURGJyk7XG4gICAgfVxuICAgIGNvbnN0IGZpbGUgPSBkZXNjcmlwdG9yLmdldEl0ZW0oKTtcbiAgICBpZiAoZmlsZSBpbnN0YW5jZW9mIERpcmVjdG9yeSkge1xuICAgICAgdGhyb3cgbmV3IEZTRXJyb3IoJ0VJU0RJUicpO1xuICAgIH1cbiAgICBpZiAoIShmaWxlIGluc3RhbmNlb2YgRmlsZSkpIHtcbiAgICAgIC8vIGRlbGV0ZWQgb3Igbm90IGEgcmVndWxhciBmaWxlXG4gICAgICB0aHJvdyBuZXcgRlNFcnJvcignRUJBREYnKTtcbiAgICB9XG4gICAgaWYgKHR5cGVvZiBwb3NpdGlvbiAhPT0gJ251bWJlcicgfHwgcG9zaXRpb24gPCAwKSB7XG4gICAgICBwb3NpdGlvbiA9IGRlc2NyaXB0b3IuZ2V0UG9zaXRpb24oKTtcbiAgICB9XG4gICAgY29uc3QgY29udGVudCA9IGZpbGUuZ2V0Q29udGVudCgpO1xuICAgIGNvbnN0IHN0YXJ0ID0gTWF0aC5taW4ocG9zaXRpb24sIGNvbnRlbnQubGVuZ3RoKTtcbiAgICBjb25zdCBlbmQgPSBNYXRoLm1pbihwb3NpdGlvbiArIGxlbmd0aCwgY29udGVudC5sZW5ndGgpO1xuICAgIGNvbnN0IHJlYWQgPSBzdGFydCA8IGVuZCA/IGNvbnRlbnQuY29weShidWZmZXIsIG9mZnNldCwgc3RhcnQsIGVuZCkgOiAwO1xuICAgIGRlc2NyaXB0b3Iuc2V0UG9zaXRpb24ocG9zaXRpb24gKyByZWFkKTtcbiAgICByZXR1cm4gcmVhZDtcbiAgfSk7XG59O1xuXG4vKipcbiAqIFdyaXRlIHRvIGEgZmlsZSBkZXNjcmlwdG9yIGdpdmVuIGEgYnVmZmVyLlxuICogQHBhcmFtIHtzdHJpbmd9IHNyYyBTb3VyY2UgZmlsZS5cbiAqIEBwYXJhbSB7c3RyaW5nfSBkZXN0IERlc3RpbmF0aW9uIGZpbGUuXG4gKiBAcGFyYW0ge251bWJlcn0gZmxhZ3MgTW9kaWZpZXJzIGZvciBjb3B5IG9wZXJhdGlvbi5cbiAqIEBwYXJhbSB7ZnVuY3Rpb24oRXJyb3IpfSBjYWxsYmFjayBDYWxsYmFjayAob3B0aW9uYWwpIGNhbGxlZFxuICogICAgIHdpdGggYW55IGVycm9yLlxuICogQHBhcmFtIHtPYmplY3R9IGN0eCBDb250ZXh0IG9iamVjdCAob3B0aW9uYWwpLCBvbmx5IGZvciBub2RlanMgdjEwKy5cbiAqL1xuQmluZGluZy5wcm90b3R5cGUuY29weUZpbGUgPSBmdW5jdGlvbihzcmMsIGRlc3QsIGZsYWdzLCBjYWxsYmFjaywgY3R4KSB7XG4gIG1hcmtTeXNjYWxsKGN0eCwgJ2NvcHlmaWxlJyk7XG5cbiAgcmV0dXJuIG1heWJlQ2FsbGJhY2sobm9ybWFsaXplQ2FsbGJhY2soY2FsbGJhY2spLCBjdHgsIHRoaXMsIGZ1bmN0aW9uKCkge1xuICAgIHNyYyA9IGRlQnVmZmVyKHNyYyk7XG4gICAgZGVzdCA9IGRlQnVmZmVyKGRlc3QpO1xuICAgIGNvbnN0IHNyY0ZkID0gdGhpcy5vcGVuKHNyYywgY29uc3RhbnRzLk9fUkRPTkxZKTtcblxuICAgIHRyeSB7XG4gICAgICBjb25zdCBzcmNEZXNjcmlwdG9yID0gdGhpcy5nZXREZXNjcmlwdG9yQnlJZChzcmNGZCk7XG4gICAgICBpZiAoIXNyY0Rlc2NyaXB0b3IuaXNSZWFkKCkpIHtcbiAgICAgICAgdGhyb3cgbmV3IEZTRXJyb3IoJ0VCQURGJyk7XG4gICAgICB9XG4gICAgICBjb25zdCBzcmNGaWxlID0gc3JjRGVzY3JpcHRvci5nZXRJdGVtKCk7XG4gICAgICBpZiAoIShzcmNGaWxlIGluc3RhbmNlb2YgRmlsZSkpIHtcbiAgICAgICAgdGhyb3cgbmV3IEZTRXJyb3IoJ0VCQURGJyk7XG4gICAgICB9XG4gICAgICBjb25zdCBzcmNDb250ZW50ID0gc3JjRmlsZS5nZXRDb250ZW50KCk7XG5cbiAgICAgIGxldCBkZXN0RmxhZ3MgPVxuICAgICAgICBjb25zdGFudHMuT19XUk9OTFkgfCBjb25zdGFudHMuT19DUkVBVCB8IGNvbnN0YW50cy5PX1RSVU5DO1xuXG4gICAgICBpZiAoKGZsYWdzICYgY29uc3RhbnRzLkNPUFlGSUxFX0VYQ0wpID09PSBjb25zdGFudHMuQ09QWUZJTEVfRVhDTCkge1xuICAgICAgICBkZXN0RmxhZ3MgfD0gY29uc3RhbnRzLk9fRVhDTDtcbiAgICAgIH1cblxuICAgICAgY29uc3QgZGVzdEZkID0gdGhpcy5vcGVuKGRlc3QsIGRlc3RGbGFncyk7XG5cbiAgICAgIHRyeSB7XG4gICAgICAgIHRoaXMud3JpdGUoZGVzdEZkLCBzcmNDb250ZW50LCAwLCBzcmNDb250ZW50Lmxlbmd0aCwgMCk7XG4gICAgICB9IGZpbmFsbHkge1xuICAgICAgICB0aGlzLmNsb3NlKGRlc3RGZCk7XG4gICAgICB9XG4gICAgfSBmaW5hbGx5IHtcbiAgICAgIHRoaXMuY2xvc2Uoc3JjRmQpO1xuICAgIH1cbiAgfSk7XG59O1xuXG4vKipcbiAqIFdyaXRlIHRvIGEgZmlsZSBkZXNjcmlwdG9yIGdpdmVuIGEgYnVmZmVyLlxuICogQHBhcmFtIHtzdHJpbmd9IGZkIEZpbGUgZGVzY3JpcHRvci5cbiAqIEBwYXJhbSB7QXJyYXk8QnVmZmVyPn0gYnVmZmVycyBBcnJheSBvZiBidWZmZXJzIHdpdGggY29udGVudHMgdG8gd3JpdGUuXG4gKiBAcGFyYW0gez9udW1iZXJ9IHBvc2l0aW9uIFdoZXJlIHRvIGJlZ2luIHdyaXRpbmcgaW4gdGhlIGZpbGUuICBJZiBudWxsLFxuICogICAgIGRhdGEgd2lsbCBiZSB3cml0dGVuIHRvIHRoZSBjdXJyZW50IGZpbGUgcG9zaXRpb24uXG4gKiBAcGFyYW0ge2Z1bmN0aW9uKEVycm9yLCBudW1iZXIsIEJ1ZmZlcil9IGNhbGxiYWNrIENhbGxiYWNrIChvcHRpb25hbCkgY2FsbGVkXG4gKiAgICAgd2l0aCBhbnkgZXJyb3IsIG51bWJlciBvZiBieXRlcyB3cml0dGVuLCBhbmQgdGhlIGJ1ZmZlci5cbiAqIEBwYXJhbSB7T2JqZWN0fSBjdHggQ29udGV4dCBvYmplY3QgKG9wdGlvbmFsKSwgb25seSBmb3Igbm9kZWpzIHYxMCsuXG4gKiBAcmV0dXJuIHtudW1iZXJ9IE51bWJlciBvZiBieXRlcyB3cml0dGVuIChpZiBzeW5jKS5cbiAqL1xuQmluZGluZy5wcm90b3R5cGUud3JpdGVCdWZmZXJzID0gZnVuY3Rpb24oXG4gIGZkLFxuICBidWZmZXJzLFxuICBwb3NpdGlvbixcbiAgY2FsbGJhY2ssXG4gIGN0eFxuKSB7XG4gIG1hcmtTeXNjYWxsKGN0eCwgJ3dyaXRlJyk7XG5cbiAgcmV0dXJuIG1heWJlQ2FsbGJhY2sobm9ybWFsaXplQ2FsbGJhY2soY2FsbGJhY2spLCBjdHgsIHRoaXMsIGZ1bmN0aW9uKCkge1xuICAgIGNvbnN0IGRlc2NyaXB0b3IgPSB0aGlzLmdldERlc2NyaXB0b3JCeUlkKGZkKTtcbiAgICBpZiAoIWRlc2NyaXB0b3IuaXNXcml0ZSgpKSB7XG4gICAgICB0aHJvdyBuZXcgRlNFcnJvcignRUJBREYnKTtcbiAgICB9XG4gICAgY29uc3QgZmlsZSA9IGRlc2NyaXB0b3IuZ2V0SXRlbSgpO1xuICAgIGlmICghKGZpbGUgaW5zdGFuY2VvZiBGaWxlKSkge1xuICAgICAgLy8gbm90IGEgcmVndWxhciBmaWxlXG4gICAgICB0aHJvdyBuZXcgRlNFcnJvcignRUJBREYnKTtcbiAgICB9XG4gICAgaWYgKHR5cGVvZiBwb3NpdGlvbiAhPT0gJ251bWJlcicgfHwgcG9zaXRpb24gPCAwKSB7XG4gICAgICBwb3NpdGlvbiA9IGRlc2NyaXB0b3IuZ2V0UG9zaXRpb24oKTtcbiAgICB9XG4gICAgbGV0IGNvbnRlbnQgPSBmaWxlLmdldENvbnRlbnQoKTtcbiAgICBjb25zdCBuZXdDb250ZW50ID0gQnVmZmVyLmNvbmNhdChidWZmZXJzKTtcbiAgICBjb25zdCBuZXdMZW5ndGggPSBwb3NpdGlvbiArIG5ld0NvbnRlbnQubGVuZ3RoO1xuICAgIGlmIChjb250ZW50Lmxlbmd0aCA8IG5ld0xlbmd0aCkge1xuICAgICAgY29uc3QgdGVtcENvbnRlbnQgPSBidWZmZXJBbGxvYyhuZXdMZW5ndGgpO1xuICAgICAgY29udGVudC5jb3B5KHRlbXBDb250ZW50KTtcbiAgICAgIGNvbnRlbnQgPSB0ZW1wQ29udGVudDtcbiAgICB9XG4gICAgY29uc3Qgd3JpdHRlbiA9IG5ld0NvbnRlbnQuY29weShjb250ZW50LCBwb3NpdGlvbik7XG4gICAgZmlsZS5zZXRDb250ZW50KGNvbnRlbnQpO1xuICAgIGRlc2NyaXB0b3Iuc2V0UG9zaXRpb24obmV3TGVuZ3RoKTtcbiAgICByZXR1cm4gd3JpdHRlbjtcbiAgfSk7XG59O1xuXG4vKipcbiAqIFdyaXRlIHRvIGEgZmlsZSBkZXNjcmlwdG9yIGdpdmVuIGEgYnVmZmVyLlxuICogQHBhcmFtIHtzdHJpbmd9IGZkIEZpbGUgZGVzY3JpcHRvci5cbiAqIEBwYXJhbSB7QnVmZmVyfSBidWZmZXIgQnVmZmVyIHdpdGggY29udGVudHMgdG8gd3JpdGUuXG4gKiBAcGFyYW0ge251bWJlcn0gb2Zmc2V0IE9mZnNldCBpbiB0aGUgYnVmZmVyIHRvIHN0YXJ0IHdyaXRpbmcgZnJvbS5cbiAqIEBwYXJhbSB7bnVtYmVyfSBsZW5ndGggTnVtYmVyIG9mIGJ5dGVzIHRvIHdyaXRlLlxuICogQHBhcmFtIHs/bnVtYmVyfSBwb3NpdGlvbiBXaGVyZSB0byBiZWdpbiB3cml0aW5nIGluIHRoZSBmaWxlLiAgSWYgbnVsbCxcbiAqICAgICBkYXRhIHdpbGwgYmUgd3JpdHRlbiB0byB0aGUgY3VycmVudCBmaWxlIHBvc2l0aW9uLlxuICogQHBhcmFtIHtmdW5jdGlvbihFcnJvciwgbnVtYmVyLCBCdWZmZXIpfSBjYWxsYmFjayBDYWxsYmFjayAob3B0aW9uYWwpIGNhbGxlZFxuICogICAgIHdpdGggYW55IGVycm9yLCBudW1iZXIgb2YgYnl0ZXMgd3JpdHRlbiwgYW5kIHRoZSBidWZmZXIuXG4gKiBAcGFyYW0ge09iamVjdH0gY3R4IENvbnRleHQgb2JqZWN0IChvcHRpb25hbCksIG9ubHkgZm9yIG5vZGVqcyB2MTArLlxuICogQHJldHVybiB7bnVtYmVyfSBOdW1iZXIgb2YgYnl0ZXMgd3JpdHRlbiAoaWYgc3luYykuXG4gKi9cbkJpbmRpbmcucHJvdG90eXBlLndyaXRlQnVmZmVyID0gZnVuY3Rpb24oXG4gIGZkLFxuICBidWZmZXIsXG4gIG9mZnNldCxcbiAgbGVuZ3RoLFxuICBwb3NpdGlvbixcbiAgY2FsbGJhY2ssXG4gIGN0eFxuKSB7XG4gIG1hcmtTeXNjYWxsKGN0eCwgJ3dyaXRlJyk7XG5cbiAgcmV0dXJuIG1heWJlQ2FsbGJhY2sobm9ybWFsaXplQ2FsbGJhY2soY2FsbGJhY2spLCBjdHgsIHRoaXMsIGZ1bmN0aW9uKCkge1xuICAgIGNvbnN0IGRlc2NyaXB0b3IgPSB0aGlzLmdldERlc2NyaXB0b3JCeUlkKGZkKTtcbiAgICBpZiAoIWRlc2NyaXB0b3IuaXNXcml0ZSgpKSB7XG4gICAgICB0aHJvdyBuZXcgRlNFcnJvcignRUJBREYnKTtcbiAgICB9XG4gICAgY29uc3QgZmlsZSA9IGRlc2NyaXB0b3IuZ2V0SXRlbSgpO1xuICAgIGlmICghKGZpbGUgaW5zdGFuY2VvZiBGaWxlKSkge1xuICAgICAgLy8gbm90IGEgcmVndWxhciBmaWxlXG4gICAgICB0aHJvdyBuZXcgRlNFcnJvcignRUJBREYnKTtcbiAgICB9XG4gICAgaWYgKHR5cGVvZiBwb3NpdGlvbiAhPT0gJ251bWJlcicgfHwgcG9zaXRpb24gPCAwKSB7XG4gICAgICBwb3NpdGlvbiA9IGRlc2NyaXB0b3IuZ2V0UG9zaXRpb24oKTtcbiAgICB9XG4gICAgbGV0IGNvbnRlbnQgPSBmaWxlLmdldENvbnRlbnQoKTtcbiAgICBjb25zdCBuZXdMZW5ndGggPSBwb3NpdGlvbiArIGxlbmd0aDtcbiAgICBpZiAoY29udGVudC5sZW5ndGggPCBuZXdMZW5ndGgpIHtcbiAgICAgIGNvbnN0IG5ld0NvbnRlbnQgPSBidWZmZXJBbGxvYyhuZXdMZW5ndGgpO1xuICAgICAgY29udGVudC5jb3B5KG5ld0NvbnRlbnQpO1xuICAgICAgY29udGVudCA9IG5ld0NvbnRlbnQ7XG4gICAgfVxuICAgIGNvbnN0IHNvdXJjZUVuZCA9IE1hdGgubWluKG9mZnNldCArIGxlbmd0aCwgYnVmZmVyLmxlbmd0aCk7XG4gICAgY29uc3Qgd3JpdHRlbiA9IGJ1ZmZlckZyb20oYnVmZmVyKS5jb3B5KFxuICAgICAgY29udGVudCxcbiAgICAgIHBvc2l0aW9uLFxuICAgICAgb2Zmc2V0LFxuICAgICAgc291cmNlRW5kXG4gICAgKTtcbiAgICBmaWxlLnNldENvbnRlbnQoY29udGVudCk7XG4gICAgZGVzY3JpcHRvci5zZXRQb3NpdGlvbihuZXdMZW5ndGgpO1xuICAgIHJldHVybiB3cml0dGVuO1xuICB9KTtcbn07XG5cbi8qKlxuICogQWxpYXMgZm9yIHdyaXRlQnVmZmVyICh1c2VkIGluIE5vZGUgPD0gMC4xMCkuXG4gKiBAcGFyYW0ge3N0cmluZ30gZmQgRmlsZSBkZXNjcmlwdG9yLlxuICogQHBhcmFtIHtCdWZmZXJ9IGJ1ZmZlciBCdWZmZXIgd2l0aCBjb250ZW50cyB0byB3cml0ZS5cbiAqIEBwYXJhbSB7bnVtYmVyfSBvZmZzZXQgT2Zmc2V0IGluIHRoZSBidWZmZXIgdG8gc3RhcnQgd3JpdGluZyBmcm9tLlxuICogQHBhcmFtIHtudW1iZXJ9IGxlbmd0aCBOdW1iZXIgb2YgYnl0ZXMgdG8gd3JpdGUuXG4gKiBAcGFyYW0gez9udW1iZXJ9IHBvc2l0aW9uIFdoZXJlIHRvIGJlZ2luIHdyaXRpbmcgaW4gdGhlIGZpbGUuICBJZiBudWxsLFxuICogICAgIGRhdGEgd2lsbCBiZSB3cml0dGVuIHRvIHRoZSBjdXJyZW50IGZpbGUgcG9zaXRpb24uXG4gKiBAcGFyYW0ge2Z1bmN0aW9uKEVycm9yLCBudW1iZXIsIEJ1ZmZlcil9IGNhbGxiYWNrIENhbGxiYWNrIChvcHRpb25hbCkgY2FsbGVkXG4gKiAgICAgd2l0aCBhbnkgZXJyb3IsIG51bWJlciBvZiBieXRlcyB3cml0dGVuLCBhbmQgdGhlIGJ1ZmZlci5cbiAqIEBwYXJhbSB7T2JqZWN0fSBjdHggQ29udGV4dCBvYmplY3QgKG9wdGlvbmFsKSwgb25seSBmb3Igbm9kZWpzIHYxMCsuXG4gKiBAcmV0dXJuIHtudW1iZXJ9IE51bWJlciBvZiBieXRlcyB3cml0dGVuIChpZiBzeW5jKS5cbiAqL1xuQmluZGluZy5wcm90b3R5cGUud3JpdGUgPSBCaW5kaW5nLnByb3RvdHlwZS53cml0ZUJ1ZmZlcjtcblxuLyoqXG4gKiBXcml0ZSB0byBhIGZpbGUgZGVzY3JpcHRvciBnaXZlbiBhIHN0cmluZy5cbiAqIEBwYXJhbSB7c3RyaW5nfSBmZCBGaWxlIGRlc2NyaXB0b3IuXG4gKiBAcGFyYW0ge3N0cmluZ30gc3RyaW5nIFN0cmluZyB3aXRoIGNvbnRlbnRzIHRvIHdyaXRlLlxuICogQHBhcmFtIHtudW1iZXJ9IHBvc2l0aW9uIFdoZXJlIHRvIGJlZ2luIHdyaXRpbmcgaW4gdGhlIGZpbGUuICBJZiBudWxsLFxuICogICAgIGRhdGEgd2lsbCBiZSB3cml0dGVuIHRvIHRoZSBjdXJyZW50IGZpbGUgcG9zaXRpb24uXG4gKiBAcGFyYW0ge3N0cmluZ30gZW5jb2RpbmcgU3RyaW5nIGVuY29kaW5nLlxuICogQHBhcmFtIHtmdW5jdGlvbihFcnJvciwgbnVtYmVyLCBzdHJpbmcpfSBjYWxsYmFjayBDYWxsYmFjayAob3B0aW9uYWwpIGNhbGxlZFxuICogICAgIHdpdGggYW55IGVycm9yLCBudW1iZXIgb2YgYnl0ZXMgd3JpdHRlbiwgYW5kIHRoZSBzdHJpbmcuXG4gKiBAcmV0dXJuIHtudW1iZXJ9IE51bWJlciBvZiBieXRlcyB3cml0dGVuIChpZiBzeW5jKS5cbiAqL1xuQmluZGluZy5wcm90b3R5cGUud3JpdGVTdHJpbmcgPSBmdW5jdGlvbihcbiAgZmQsXG4gIHN0cmluZyxcbiAgcG9zaXRpb24sXG4gIGVuY29kaW5nLFxuICBjYWxsYmFjayxcbiAgY3R4XG4pIHtcbiAgbWFya1N5c2NhbGwoY3R4LCAnd3JpdGUnKTtcblxuICBjb25zdCBidWZmZXIgPSBidWZmZXJGcm9tKHN0cmluZywgZW5jb2RpbmcpO1xuICBsZXQgd3JhcHBlcjtcbiAgaWYgKGNhbGxiYWNrICYmIGNhbGxiYWNrICE9PSBrVXNlUHJvbWlzZXMpIHtcbiAgICBpZiAoY2FsbGJhY2sub25jb21wbGV0ZSkge1xuICAgICAgY2FsbGJhY2sgPSBjYWxsYmFjay5vbmNvbXBsZXRlLmJpbmQoY2FsbGJhY2spO1xuICAgIH1cbiAgICB3cmFwcGVyID0gZnVuY3Rpb24oZXJyLCB3cml0dGVuLCByZXR1cm5lZCkge1xuICAgICAgY2FsbGJhY2soZXJyLCB3cml0dGVuLCByZXR1cm5lZCAmJiBzdHJpbmcpO1xuICAgIH07XG4gIH1cbiAgcmV0dXJuIHRoaXMud3JpdGVCdWZmZXIoZmQsIGJ1ZmZlciwgMCwgc3RyaW5nLmxlbmd0aCwgcG9zaXRpb24sIHdyYXBwZXIsIGN0eCk7XG59O1xuXG4vKipcbiAqIFJlbmFtZSBhIGZpbGUuXG4gKiBAcGFyYW0ge3N0cmluZ30gb2xkUGF0aCBPbGQgcGF0aG5hbWUuXG4gKiBAcGFyYW0ge3N0cmluZ30gbmV3UGF0aCBOZXcgcGF0aG5hbWUuXG4gKiBAcGFyYW0ge2Z1bmN0aW9uKEVycm9yKX0gY2FsbGJhY2sgQ2FsbGJhY2sgKG9wdGlvbmFsKS5cbiAqIEBwYXJhbSB7T2JqZWN0fSBjdHggQ29udGV4dCBvYmplY3QgKG9wdGlvbmFsKSwgb25seSBmb3Igbm9kZWpzIHYxMCsuXG4gKiBAcmV0dXJuIHt1bmRlZmluZWR9XG4gKi9cbkJpbmRpbmcucHJvdG90eXBlLnJlbmFtZSA9IGZ1bmN0aW9uKG9sZFBhdGgsIG5ld1BhdGgsIGNhbGxiYWNrLCBjdHgpIHtcbiAgbWFya1N5c2NhbGwoY3R4LCAncmVuYW1lJyk7XG5cbiAgcmV0dXJuIG1heWJlQ2FsbGJhY2sobm9ybWFsaXplQ2FsbGJhY2soY2FsbGJhY2spLCBjdHgsIHRoaXMsIGZ1bmN0aW9uKCkge1xuICAgIG9sZFBhdGggPSBkZUJ1ZmZlcihvbGRQYXRoKTtcbiAgICBuZXdQYXRoID0gZGVCdWZmZXIobmV3UGF0aCk7XG4gICAgY29uc3Qgb2xkSXRlbSA9IHRoaXMuX3N5c3RlbS5nZXRJdGVtKG9sZFBhdGgpO1xuICAgIGlmICghb2xkSXRlbSkge1xuICAgICAgdGhyb3cgbmV3IEZTRXJyb3IoJ0VOT0VOVCcsIG9sZFBhdGgpO1xuICAgIH1cbiAgICBjb25zdCBvbGRQYXJlbnQgPSB0aGlzLl9zeXN0ZW0uZ2V0SXRlbShwYXRoLmRpcm5hbWUob2xkUGF0aCkpO1xuICAgIGNvbnN0IG9sZE5hbWUgPSBwYXRoLmJhc2VuYW1lKG9sZFBhdGgpO1xuICAgIGNvbnN0IG5ld0l0ZW0gPSB0aGlzLl9zeXN0ZW0uZ2V0SXRlbShuZXdQYXRoKTtcbiAgICBjb25zdCBuZXdQYXJlbnQgPSB0aGlzLl9zeXN0ZW0uZ2V0SXRlbShwYXRoLmRpcm5hbWUobmV3UGF0aCkpO1xuICAgIGNvbnN0IG5ld05hbWUgPSBwYXRoLmJhc2VuYW1lKG5ld1BhdGgpO1xuICAgIGlmIChuZXdJdGVtKSB7XG4gICAgICAvLyBtYWtlIHN1cmUgdGhleSBhcmUgdGhlIHNhbWUgdHlwZVxuICAgICAgaWYgKG9sZEl0ZW0gaW5zdGFuY2VvZiBGaWxlKSB7XG4gICAgICAgIGlmIChuZXdJdGVtIGluc3RhbmNlb2YgRGlyZWN0b3J5KSB7XG4gICAgICAgICAgdGhyb3cgbmV3IEZTRXJyb3IoJ0VJU0RJUicsIG5ld1BhdGgpO1xuICAgICAgICB9XG4gICAgICB9IGVsc2UgaWYgKG9sZEl0ZW0gaW5zdGFuY2VvZiBEaXJlY3RvcnkpIHtcbiAgICAgICAgaWYgKCEobmV3SXRlbSBpbnN0YW5jZW9mIERpcmVjdG9yeSkpIHtcbiAgICAgICAgICB0aHJvdyBuZXcgRlNFcnJvcignRU5PVERJUicsIG5ld1BhdGgpO1xuICAgICAgICB9XG4gICAgICAgIGlmIChuZXdJdGVtLmxpc3QoKS5sZW5ndGggPiAwKSB7XG4gICAgICAgICAgdGhyb3cgbmV3IEZTRXJyb3IoJ0VOT1RFTVBUWScsIG5ld1BhdGgpO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgICBuZXdQYXJlbnQucmVtb3ZlSXRlbShuZXdOYW1lKTtcbiAgICB9IGVsc2Uge1xuICAgICAgaWYgKCFuZXdQYXJlbnQpIHtcbiAgICAgICAgdGhyb3cgbmV3IEZTRXJyb3IoJ0VOT0VOVCcsIG5ld1BhdGgpO1xuICAgICAgfVxuICAgICAgaWYgKCEobmV3UGFyZW50IGluc3RhbmNlb2YgRGlyZWN0b3J5KSkge1xuICAgICAgICB0aHJvdyBuZXcgRlNFcnJvcignRU5PVERJUicsIG5ld1BhdGgpO1xuICAgICAgfVxuICAgIH1cbiAgICBvbGRQYXJlbnQucmVtb3ZlSXRlbShvbGROYW1lKTtcbiAgICBuZXdQYXJlbnQuYWRkSXRlbShuZXdOYW1lLCBvbGRJdGVtKTtcbiAgfSk7XG59O1xuXG4vKipcbiAqIFJlYWQgYSBkaXJlY3RvcnkuXG4gKiBAcGFyYW0ge3N0cmluZ30gZGlycGF0aCBQYXRoIHRvIGRpcmVjdG9yeS5cbiAqIEBwYXJhbSB7c3RyaW5nfSBlbmNvZGluZyBUaGUgZW5jb2RpbmcgKCd1dGYtOCcgb3IgJ2J1ZmZlcicpLlxuICogQHBhcmFtIHtib29sZWFufSB3aXRoRmlsZVR5cGVzIHdoZXRoZXIgb3Igbm90IHRvIHJldHVybiBmcy5EaXJlbnQgb2JqZWN0c1xuICogQHBhcmFtIHtmdW5jdGlvbihFcnJvciwgKEFycmF5LjxzdHJpbmc+fEFycmF5LjxCdWZmZXI+KX0gY2FsbGJhY2sgQ2FsbGJhY2tcbiAqICAgICAob3B0aW9uYWwpIGNhbGxlZCB3aXRoIGFueSBlcnJvciBvciBhcnJheSBvZiBpdGVtcyBpbiB0aGUgZGlyZWN0b3J5LlxuICogQHBhcmFtIHtPYmplY3R9IGN0eCBDb250ZXh0IG9iamVjdCAob3B0aW9uYWwpLCBvbmx5IGZvciBub2RlanMgdjEwKy5cbiAqIEByZXR1cm4ge0FycmF5LjxzdHJpbmc+fEFycmF5LjxCdWZmZXI+fSBBcnJheSBvZiBpdGVtcyBpbiBkaXJlY3RvcnkgKGlmIHN5bmMpLlxuICovXG5CaW5kaW5nLnByb3RvdHlwZS5yZWFkZGlyID0gZnVuY3Rpb24oXG4gIGRpcnBhdGgsXG4gIGVuY29kaW5nLFxuICB3aXRoRmlsZVR5cGVzLFxuICBjYWxsYmFjayxcbiAgY3R4XG4pIHtcbiAgLy8gYWdhaW4sIHRoZSBzaG9ydGVyIGFyZ3VtZW50cyB3b3VsZCBub3QgaGFwcGVuIGluIG5vZGVqcyB2MTArXG4gIGlmIChhcmd1bWVudHMubGVuZ3RoID09PSAyKSB7XG4gICAgY2FsbGJhY2sgPSBlbmNvZGluZztcbiAgICBlbmNvZGluZyA9ICd1dGYtOCc7XG4gIH0gZWxzZSBpZiAoYXJndW1lbnRzLmxlbmd0aCA9PT0gMykge1xuICAgIGNhbGxiYWNrID0gd2l0aEZpbGVUeXBlcztcbiAgfVxuXG4gIG1hcmtTeXNjYWxsKGN0eCwgJ3NjYW5kaXInKTtcblxuICByZXR1cm4gbWF5YmVDYWxsYmFjayhub3JtYWxpemVDYWxsYmFjayhjYWxsYmFjayksIGN0eCwgdGhpcywgZnVuY3Rpb24oKSB7XG4gICAgZGlycGF0aCA9IGRlQnVmZmVyKGRpcnBhdGgpO1xuICAgIGxldCBkcGF0aCA9IGRpcnBhdGg7XG4gICAgbGV0IGRpciA9IHRoaXMuX3N5c3RlbS5nZXRJdGVtKGRpcnBhdGgpO1xuICAgIHdoaWxlIChkaXIgaW5zdGFuY2VvZiBTeW1ib2xpY0xpbmspIHtcbiAgICAgIGRwYXRoID0gcGF0aC5yZXNvbHZlKHBhdGguZGlybmFtZShkcGF0aCksIGRpci5nZXRQYXRoKCkpO1xuICAgICAgZGlyID0gdGhpcy5fc3lzdGVtLmdldEl0ZW0oZHBhdGgpO1xuICAgIH1cbiAgICBpZiAoIWRpcikge1xuICAgICAgdGhyb3cgbmV3IEZTRXJyb3IoJ0VOT0VOVCcsIGRpcnBhdGgpO1xuICAgIH1cbiAgICBpZiAoIShkaXIgaW5zdGFuY2VvZiBEaXJlY3RvcnkpKSB7XG4gICAgICB0aHJvdyBuZXcgRlNFcnJvcignRU5PVERJUicsIGRpcnBhdGgpO1xuICAgIH1cbiAgICBpZiAoIWRpci5jYW5SZWFkKCkpIHtcbiAgICAgIHRocm93IG5ldyBGU0Vycm9yKCdFQUNDRVMnLCBkaXJwYXRoKTtcbiAgICB9XG5cbiAgICBsZXQgbGlzdCA9IGRpci5saXN0KCk7XG4gICAgaWYgKGVuY29kaW5nID09PSAnYnVmZmVyJykge1xuICAgICAgbGlzdCA9IGxpc3QubWFwKGZ1bmN0aW9uKGl0ZW0pIHtcbiAgICAgICAgcmV0dXJuIGJ1ZmZlckZyb20oaXRlbSk7XG4gICAgICB9KTtcbiAgICB9XG5cbiAgICBpZiAod2l0aEZpbGVUeXBlcyA9PT0gdHJ1ZSkge1xuICAgICAgY29uc3QgdHlwZXMgPSBsaXN0Lm1hcChmdW5jdGlvbihuYW1lKSB7XG4gICAgICAgIGNvbnN0IHN0YXRzID0gZGlyLmdldEl0ZW0obmFtZSkuZ2V0U3RhdHMoKTtcblxuICAgICAgICByZXR1cm4gZ2V0RGlyZW50VHlwZShzdGF0cy5tb2RlKTtcbiAgICAgIH0pO1xuICAgICAgbGlzdCA9IFtsaXN0LCB0eXBlc107XG4gICAgfVxuXG4gICAgcmV0dXJuIGxpc3Q7XG4gIH0pO1xufTtcblxuLyoqXG4gKiBDcmVhdGUgYSBkaXJlY3RvcnkuXG4gKiBAcGFyYW0ge3N0cmluZ30gcGF0aG5hbWUgUGF0aCB0byBuZXcgZGlyZWN0b3J5LlxuICogQHBhcmFtIHtudW1iZXJ9IG1vZGUgUGVybWlzc2lvbnMuXG4gKiBAcGFyYW0ge2Jvb2xlYW59IHJlY3Vyc2l2ZSBSZWN1cnNpdmVseSBjcmVhdGUgZGVlcCBkaXJlY3RvcnkuIChhZGRlZCBpbiBub2RlanMgdjEwKylcbiAqIEBwYXJhbSB7ZnVuY3Rpb24oRXJyb3IpfSBjYWxsYmFjayBPcHRpb25hbCBjYWxsYmFjay5cbiAqIEBwYXJhbSB7T2JqZWN0fSBjdHggQ29udGV4dCBvYmplY3QgKG9wdGlvbmFsKSwgb25seSBmb3Igbm9kZWpzIHYxMCsuXG4gKi9cbkJpbmRpbmcucHJvdG90eXBlLm1rZGlyID0gZnVuY3Rpb24ocGF0aG5hbWUsIG1vZGUsIHJlY3Vyc2l2ZSwgY2FsbGJhY2ssIGN0eCkge1xuICBpZiAodHlwZW9mIHJlY3Vyc2l2ZSAhPT0gJ2Jvb2xlYW4nKSB7XG4gICAgLy8gd2hlbiBydW5uaW5nIG5vZGVqcyA8IDEwXG4gICAgY3R4ID0gY2FsbGJhY2s7XG4gICAgY2FsbGJhY2sgPSByZWN1cnNpdmU7XG4gICAgcmVjdXJzaXZlID0gZmFsc2U7XG4gIH1cblxuICBtYXJrU3lzY2FsbChjdHgsICdta2RpcicpO1xuXG4gIHJldHVybiBtYXliZUNhbGxiYWNrKG5vcm1hbGl6ZUNhbGxiYWNrKGNhbGxiYWNrKSwgY3R4LCB0aGlzLCBmdW5jdGlvbigpIHtcbiAgICBwYXRobmFtZSA9IGRlQnVmZmVyKHBhdGhuYW1lKTtcbiAgICBjb25zdCBpdGVtID0gdGhpcy5fc3lzdGVtLmdldEl0ZW0ocGF0aG5hbWUpO1xuICAgIGlmIChpdGVtKSB7XG4gICAgICBpZiAocmVjdXJzaXZlICYmIGl0ZW0gaW5zdGFuY2VvZiBEaXJlY3RvcnkpIHtcbiAgICAgICAgLy8gc2lsZW50bHkgcGFzcyBleGlzdGluZyBmb2xkZXIgaW4gcmVjdXJzaXZlIG1vZGVcbiAgICAgICAgcmV0dXJuO1xuICAgICAgfVxuICAgICAgdGhyb3cgbmV3IEZTRXJyb3IoJ0VFWElTVCcsIHBhdGhuYW1lKTtcbiAgICB9XG5cbiAgICBjb25zdCBfbWtkaXIgPSBmdW5jdGlvbihfcGF0aG5hbWUpIHtcbiAgICAgIGNvbnN0IHBhcmVudERpciA9IHBhdGguZGlybmFtZShfcGF0aG5hbWUpO1xuICAgICAgbGV0IHBhcmVudCA9IHRoaXMuX3N5c3RlbS5nZXRJdGVtKHBhcmVudERpcik7XG4gICAgICBpZiAoIXBhcmVudCkge1xuICAgICAgICBpZiAoIXJlY3Vyc2l2ZSkge1xuICAgICAgICAgIHRocm93IG5ldyBGU0Vycm9yKCdFTk9FTlQnLCBfcGF0aG5hbWUpO1xuICAgICAgICB9XG4gICAgICAgIHBhcmVudCA9IF9ta2RpcihwYXJlbnREaXIsIHRydWUpO1xuICAgICAgfVxuICAgICAgdGhpcy5hY2Nlc3MocGFyZW50RGlyLCBwYXJzZUludCgnMDAwMicsIDgpKTtcbiAgICAgIGNvbnN0IGRpciA9IG5ldyBEaXJlY3RvcnkoKTtcbiAgICAgIGlmIChtb2RlKSB7XG4gICAgICAgIGRpci5zZXRNb2RlKG1vZGUpO1xuICAgICAgfVxuICAgICAgcmV0dXJuIHBhcmVudC5hZGRJdGVtKHBhdGguYmFzZW5hbWUoX3BhdGhuYW1lKSwgZGlyKTtcbiAgICB9LmJpbmQodGhpcyk7XG5cbiAgICBfbWtkaXIocGF0aG5hbWUpO1xuICB9KTtcbn07XG5cbi8qKlxuICogUmVtb3ZlIGEgZGlyZWN0b3J5LlxuICogQHBhcmFtIHtzdHJpbmd9IHBhdGhuYW1lIFBhdGggdG8gZGlyZWN0b3J5LlxuICogQHBhcmFtIHtmdW5jdGlvbihFcnJvcil9IGNhbGxiYWNrIE9wdGlvbmFsIGNhbGxiYWNrLlxuICogQHBhcmFtIHtPYmplY3R9IGN0eCBDb250ZXh0IG9iamVjdCAob3B0aW9uYWwpLCBvbmx5IGZvciBub2RlanMgdjEwKy5cbiAqL1xuQmluZGluZy5wcm90b3R5cGUucm1kaXIgPSBmdW5jdGlvbihwYXRobmFtZSwgY2FsbGJhY2ssIGN0eCkge1xuICBtYXJrU3lzY2FsbChjdHgsICdybWRpcicpO1xuXG4gIHJldHVybiBtYXliZUNhbGxiYWNrKG5vcm1hbGl6ZUNhbGxiYWNrKGNhbGxiYWNrKSwgY3R4LCB0aGlzLCBmdW5jdGlvbigpIHtcbiAgICBwYXRobmFtZSA9IGRlQnVmZmVyKHBhdGhuYW1lKTtcbiAgICBjb25zdCBpdGVtID0gdGhpcy5fc3lzdGVtLmdldEl0ZW0ocGF0aG5hbWUpO1xuICAgIGlmICghaXRlbSkge1xuICAgICAgdGhyb3cgbmV3IEZTRXJyb3IoJ0VOT0VOVCcsIHBhdGhuYW1lKTtcbiAgICB9XG4gICAgaWYgKCEoaXRlbSBpbnN0YW5jZW9mIERpcmVjdG9yeSkpIHtcbiAgICAgIHRocm93IG5ldyBGU0Vycm9yKCdFTk9URElSJywgcGF0aG5hbWUpO1xuICAgIH1cbiAgICBpZiAoaXRlbS5saXN0KCkubGVuZ3RoID4gMCkge1xuICAgICAgdGhyb3cgbmV3IEZTRXJyb3IoJ0VOT1RFTVBUWScsIHBhdGhuYW1lKTtcbiAgICB9XG4gICAgdGhpcy5hY2Nlc3MocGF0aC5kaXJuYW1lKHBhdGhuYW1lKSwgcGFyc2VJbnQoJzAwMDInLCA4KSk7XG4gICAgY29uc3QgcGFyZW50ID0gdGhpcy5fc3lzdGVtLmdldEl0ZW0ocGF0aC5kaXJuYW1lKHBhdGhuYW1lKSk7XG4gICAgcGFyZW50LnJlbW92ZUl0ZW0ocGF0aC5iYXNlbmFtZShwYXRobmFtZSkpO1xuICB9KTtcbn07XG5cbmNvbnN0IFBBVEhfQ0hBUlMgPVxuICAnYWJjZGVmZ2hpamtsbW5vcHFyc3R1dnd4eXpBQkNERUZHSElKS0xNTk9QUVJTVFVWV1hZWjAxMjM0NTY3ODknO1xuXG5jb25zdCBNQVhfQVRURU1QVFMgPSA2MiAqIDYyICogNjI7XG5cbi8qKlxuICogQ3JlYXRlIGEgZGlyZWN0b3J5IGJhc2VkIG9uIGEgdGVtcGxhdGUuXG4gKiBTZWUgaHR0cDovL3dlYi5taXQuZWR1L2ZyZWVic2QvaGVhZC9saWIvbGliYy9zdGRpby9ta3RlbXAuY1xuICogQHBhcmFtIHtzdHJpbmd9IHRlbXBsYXRlIFBhdGggdGVtcGxhdGUgKHRyYWlsaW5nIFhzIHdpbGwgYmUgcmVwbGFjZWQpLlxuICogQHBhcmFtIHtzdHJpbmd9IGVuY29kaW5nIFRoZSBlbmNvZGluZyAoJ3V0Zi04JyBvciAnYnVmZmVyJykuXG4gKiBAcGFyYW0ge2Z1bmN0aW9uKEVycm9yLCBzdHJpbmcpfSBjYWxsYmFjayBPcHRpb25hbCBjYWxsYmFjay5cbiAqIEBwYXJhbSB7T2JqZWN0fSBjdHggQ29udGV4dCBvYmplY3QgKG9wdGlvbmFsKSwgb25seSBmb3Igbm9kZWpzIHYxMCsuXG4gKi9cbkJpbmRpbmcucHJvdG90eXBlLm1rZHRlbXAgPSBmdW5jdGlvbihwcmVmaXgsIGVuY29kaW5nLCBjYWxsYmFjaywgY3R4KSB7XG4gIGlmIChlbmNvZGluZyAmJiB0eXBlb2YgZW5jb2RpbmcgIT09ICdzdHJpbmcnKSB7XG4gICAgY2FsbGJhY2sgPSBlbmNvZGluZztcbiAgICBlbmNvZGluZyA9ICd1dGYtOCc7XG4gIH1cblxuICBtYXJrU3lzY2FsbChjdHgsICdta2R0ZW1wJyk7XG5cbiAgcmV0dXJuIG1heWJlQ2FsbGJhY2sobm9ybWFsaXplQ2FsbGJhY2soY2FsbGJhY2spLCBjdHgsIHRoaXMsIGZ1bmN0aW9uKCkge1xuICAgIHByZWZpeCA9IHByZWZpeC5yZXBsYWNlKC9YezAsNn0kLywgJ1hYWFhYWCcpO1xuICAgIGNvbnN0IHBhcmVudFBhdGggPSBwYXRoLmRpcm5hbWUocHJlZml4KTtcbiAgICBjb25zdCBwYXJlbnQgPSB0aGlzLl9zeXN0ZW0uZ2V0SXRlbShwYXJlbnRQYXRoKTtcbiAgICBpZiAoIXBhcmVudCkge1xuICAgICAgdGhyb3cgbmV3IEZTRXJyb3IoJ0VOT0VOVCcsIHByZWZpeCk7XG4gICAgfVxuICAgIGlmICghKHBhcmVudCBpbnN0YW5jZW9mIERpcmVjdG9yeSkpIHtcbiAgICAgIHRocm93IG5ldyBGU0Vycm9yKCdFTk9URElSJywgcHJlZml4KTtcbiAgICB9XG4gICAgdGhpcy5hY2Nlc3MocGFyZW50UGF0aCwgcGFyc2VJbnQoJzAwMDInLCA4KSk7XG4gICAgY29uc3QgdGVtcGxhdGUgPSBwYXRoLmJhc2VuYW1lKHByZWZpeCk7XG4gICAgbGV0IHVuaXF1ZSA9IGZhbHNlO1xuICAgIGxldCBjb3VudCA9IDA7XG4gICAgbGV0IG5hbWU7XG4gICAgd2hpbGUgKCF1bmlxdWUgJiYgY291bnQgPCBNQVhfQVRURU1QVFMpIHtcbiAgICAgIGxldCBwb3NpdGlvbiA9IHRlbXBsYXRlLmxlbmd0aCAtIDE7XG4gICAgICBsZXQgcmVwbGFjZW1lbnQgPSAnJztcbiAgICAgIHdoaWxlICh0ZW1wbGF0ZS5jaGFyQXQocG9zaXRpb24pID09PSAnWCcpIHtcbiAgICAgICAgcmVwbGFjZW1lbnQgKz0gUEFUSF9DSEFSUy5jaGFyQXQoXG4gICAgICAgICAgTWF0aC5mbG9vcihQQVRIX0NIQVJTLmxlbmd0aCAqIE1hdGgucmFuZG9tKCkpXG4gICAgICAgICk7XG4gICAgICAgIHBvc2l0aW9uIC09IDE7XG4gICAgICB9XG4gICAgICBjb25zdCBjYW5kaWRhdGUgPSB0ZW1wbGF0ZS5zbGljZSgwLCBwb3NpdGlvbiArIDEpICsgcmVwbGFjZW1lbnQ7XG4gICAgICBpZiAoIXBhcmVudC5nZXRJdGVtKGNhbmRpZGF0ZSkpIHtcbiAgICAgICAgbmFtZSA9IGNhbmRpZGF0ZTtcbiAgICAgICAgdW5pcXVlID0gdHJ1ZTtcbiAgICAgIH1cbiAgICAgIGNvdW50ICs9IDE7XG4gICAgfVxuICAgIGlmICghbmFtZSkge1xuICAgICAgdGhyb3cgbmV3IEZTRXJyb3IoJ0VFWElTVCcsIHByZWZpeCk7XG4gICAgfVxuICAgIGNvbnN0IGRpciA9IG5ldyBEaXJlY3RvcnkoKTtcbiAgICBwYXJlbnQuYWRkSXRlbShuYW1lLCBkaXIpO1xuICAgIGxldCB1bmlxdWVQYXRoID0gcGF0aC5qb2luKHBhcmVudFBhdGgsIG5hbWUpO1xuICAgIGlmIChlbmNvZGluZyA9PT0gJ2J1ZmZlcicpIHtcbiAgICAgIHVuaXF1ZVBhdGggPSBidWZmZXJGcm9tKHVuaXF1ZVBhdGgpO1xuICAgIH1cbiAgICByZXR1cm4gdW5pcXVlUGF0aDtcbiAgfSk7XG59O1xuXG4vKipcbiAqIFRydW5jYXRlIGEgZmlsZS5cbiAqIEBwYXJhbSB7bnVtYmVyfSBmZCBGaWxlIGRlc2NyaXB0b3IuXG4gKiBAcGFyYW0ge251bWJlcn0gbGVuIE51bWJlciBvZiBieXRlcy5cbiAqIEBwYXJhbSB7ZnVuY3Rpb24oRXJyb3IpfSBjYWxsYmFjayBPcHRpb25hbCBjYWxsYmFjay5cbiAqIEBwYXJhbSB7T2JqZWN0fSBjdHggQ29udGV4dCBvYmplY3QgKG9wdGlvbmFsKSwgb25seSBmb3Igbm9kZWpzIHYxMCsuXG4gKi9cbkJpbmRpbmcucHJvdG90eXBlLmZ0cnVuY2F0ZSA9IGZ1bmN0aW9uKGZkLCBsZW4sIGNhbGxiYWNrLCBjdHgpIHtcbiAgbWFya1N5c2NhbGwoY3R4LCAnZnRydW5jYXRlJyk7XG5cbiAgcmV0dXJuIG1heWJlQ2FsbGJhY2sobm9ybWFsaXplQ2FsbGJhY2soY2FsbGJhY2spLCBjdHgsIHRoaXMsIGZ1bmN0aW9uKCkge1xuICAgIGNvbnN0IGRlc2NyaXB0b3IgPSB0aGlzLmdldERlc2NyaXB0b3JCeUlkKGZkKTtcbiAgICBpZiAoIWRlc2NyaXB0b3IuaXNXcml0ZSgpKSB7XG4gICAgICB0aHJvdyBuZXcgRlNFcnJvcignRUlOVkFMJyk7XG4gICAgfVxuICAgIGNvbnN0IGZpbGUgPSBkZXNjcmlwdG9yLmdldEl0ZW0oKTtcbiAgICBpZiAoIShmaWxlIGluc3RhbmNlb2YgRmlsZSkpIHtcbiAgICAgIHRocm93IG5ldyBGU0Vycm9yKCdFSU5WQUwnKTtcbiAgICB9XG4gICAgY29uc3QgY29udGVudCA9IGZpbGUuZ2V0Q29udGVudCgpO1xuICAgIGNvbnN0IG5ld0NvbnRlbnQgPSBidWZmZXJBbGxvYyhsZW4pO1xuICAgIGNvbnRlbnQuY29weShuZXdDb250ZW50KTtcbiAgICBmaWxlLnNldENvbnRlbnQobmV3Q29udGVudCk7XG4gIH0pO1xufTtcblxuLyoqXG4gKiBMZWdhY3kgc3VwcG9ydC5cbiAqIEBwYXJhbSB7bnVtYmVyfSBmZCBGaWxlIGRlc2NyaXB0b3IuXG4gKiBAcGFyYW0ge251bWJlcn0gbGVuIE51bWJlciBvZiBieXRlcy5cbiAqIEBwYXJhbSB7ZnVuY3Rpb24oRXJyb3IpfSBjYWxsYmFjayBPcHRpb25hbCBjYWxsYmFjay5cbiAqIEBwYXJhbSB7T2JqZWN0fSBjdHggQ29udGV4dCBvYmplY3QgKG9wdGlvbmFsKSwgb25seSBmb3Igbm9kZWpzIHYxMCsuXG4gKi9cbkJpbmRpbmcucHJvdG90eXBlLnRydW5jYXRlID0gQmluZGluZy5wcm90b3R5cGUuZnRydW5jYXRlO1xuXG4vKipcbiAqIENoYW5nZSB1c2VyIGFuZCBncm91cCBvd25lci5cbiAqIEBwYXJhbSB7c3RyaW5nfSBwYXRobmFtZSBQYXRoLlxuICogQHBhcmFtIHtudW1iZXJ9IHVpZCBVc2VyIGlkLlxuICogQHBhcmFtIHtudW1iZXJ9IGdpZCBHcm91cCBpZC5cbiAqIEBwYXJhbSB7ZnVuY3Rpb24oRXJyb3IpfSBjYWxsYmFjayBPcHRpb25hbCBjYWxsYmFjay5cbiAqIEBwYXJhbSB7T2JqZWN0fSBjdHggQ29udGV4dCBvYmplY3QgKG9wdGlvbmFsKSwgb25seSBmb3Igbm9kZWpzIHYxMCsuXG4gKi9cbkJpbmRpbmcucHJvdG90eXBlLmNob3duID0gZnVuY3Rpb24ocGF0aG5hbWUsIHVpZCwgZ2lkLCBjYWxsYmFjaywgY3R4KSB7XG4gIG1hcmtTeXNjYWxsKGN0eCwgJ2Nob3duJyk7XG5cbiAgcmV0dXJuIG1heWJlQ2FsbGJhY2sobm9ybWFsaXplQ2FsbGJhY2soY2FsbGJhY2spLCBjdHgsIHRoaXMsIGZ1bmN0aW9uKCkge1xuICAgIHBhdGhuYW1lID0gZGVCdWZmZXIocGF0aG5hbWUpO1xuICAgIGNvbnN0IGl0ZW0gPSB0aGlzLl9zeXN0ZW0uZ2V0SXRlbShwYXRobmFtZSk7XG4gICAgaWYgKCFpdGVtKSB7XG4gICAgICB0aHJvdyBuZXcgRlNFcnJvcignRU5PRU5UJywgcGF0aG5hbWUpO1xuICAgIH1cbiAgICBpdGVtLnNldFVpZCh1aWQpO1xuICAgIGl0ZW0uc2V0R2lkKGdpZCk7XG4gIH0pO1xufTtcblxuLyoqXG4gKiBDaGFuZ2UgdXNlciBhbmQgZ3JvdXAgb3duZXIuXG4gKiBAcGFyYW0ge251bWJlcn0gZmQgRmlsZSBkZXNjcmlwdG9yLlxuICogQHBhcmFtIHtudW1iZXJ9IHVpZCBVc2VyIGlkLlxuICogQHBhcmFtIHtudW1iZXJ9IGdpZCBHcm91cCBpZC5cbiAqIEBwYXJhbSB7ZnVuY3Rpb24oRXJyb3IpfSBjYWxsYmFjayBPcHRpb25hbCBjYWxsYmFjay5cbiAqIEBwYXJhbSB7T2JqZWN0fSBjdHggQ29udGV4dCBvYmplY3QgKG9wdGlvbmFsKSwgb25seSBmb3Igbm9kZWpzIHYxMCsuXG4gKi9cbkJpbmRpbmcucHJvdG90eXBlLmZjaG93biA9IGZ1bmN0aW9uKGZkLCB1aWQsIGdpZCwgY2FsbGJhY2ssIGN0eCkge1xuICBtYXJrU3lzY2FsbChjdHgsICdmY2hvd24nKTtcblxuICByZXR1cm4gbWF5YmVDYWxsYmFjayhub3JtYWxpemVDYWxsYmFjayhjYWxsYmFjayksIGN0eCwgdGhpcywgZnVuY3Rpb24oKSB7XG4gICAgY29uc3QgZGVzY3JpcHRvciA9IHRoaXMuZ2V0RGVzY3JpcHRvckJ5SWQoZmQpO1xuICAgIGNvbnN0IGl0ZW0gPSBkZXNjcmlwdG9yLmdldEl0ZW0oKTtcbiAgICBpdGVtLnNldFVpZCh1aWQpO1xuICAgIGl0ZW0uc2V0R2lkKGdpZCk7XG4gIH0pO1xufTtcblxuLyoqXG4gKiBDaGFuZ2UgcGVybWlzc2lvbnMuXG4gKiBAcGFyYW0ge3N0cmluZ30gcGF0aG5hbWUgUGF0aC5cbiAqIEBwYXJhbSB7bnVtYmVyfSBtb2RlIE1vZGUuXG4gKiBAcGFyYW0ge2Z1bmN0aW9uKEVycm9yKX0gY2FsbGJhY2sgT3B0aW9uYWwgY2FsbGJhY2suXG4gKiBAcGFyYW0ge09iamVjdH0gY3R4IENvbnRleHQgb2JqZWN0IChvcHRpb25hbCksIG9ubHkgZm9yIG5vZGVqcyB2MTArLlxuICovXG5CaW5kaW5nLnByb3RvdHlwZS5jaG1vZCA9IGZ1bmN0aW9uKHBhdGhuYW1lLCBtb2RlLCBjYWxsYmFjaywgY3R4KSB7XG4gIG1hcmtTeXNjYWxsKGN0eCwgJ2NobW9kJyk7XG5cbiAgcmV0dXJuIG1heWJlQ2FsbGJhY2sobm9ybWFsaXplQ2FsbGJhY2soY2FsbGJhY2spLCBjdHgsIHRoaXMsIGZ1bmN0aW9uKCkge1xuICAgIHBhdGhuYW1lID0gZGVCdWZmZXIocGF0aG5hbWUpO1xuICAgIGNvbnN0IGl0ZW0gPSB0aGlzLl9zeXN0ZW0uZ2V0SXRlbShwYXRobmFtZSk7XG4gICAgaWYgKCFpdGVtKSB7XG4gICAgICB0aHJvdyBuZXcgRlNFcnJvcignRU5PRU5UJywgcGF0aG5hbWUpO1xuICAgIH1cbiAgICBpdGVtLnNldE1vZGUobW9kZSk7XG4gIH0pO1xufTtcblxuLyoqXG4gKiBDaGFuZ2UgcGVybWlzc2lvbnMuXG4gKiBAcGFyYW0ge251bWJlcn0gZmQgRmlsZSBkZXNjcmlwdG9yLlxuICogQHBhcmFtIHtudW1iZXJ9IG1vZGUgTW9kZS5cbiAqIEBwYXJhbSB7ZnVuY3Rpb24oRXJyb3IpfSBjYWxsYmFjayBPcHRpb25hbCBjYWxsYmFjay5cbiAqIEBwYXJhbSB7T2JqZWN0fSBjdHggQ29udGV4dCBvYmplY3QgKG9wdGlvbmFsKSwgb25seSBmb3Igbm9kZWpzIHYxMCsuXG4gKi9cbkJpbmRpbmcucHJvdG90eXBlLmZjaG1vZCA9IGZ1bmN0aW9uKGZkLCBtb2RlLCBjYWxsYmFjaywgY3R4KSB7XG4gIG1hcmtTeXNjYWxsKGN0eCwgJ2ZjaG1vZCcpO1xuXG4gIHJldHVybiBtYXliZUNhbGxiYWNrKG5vcm1hbGl6ZUNhbGxiYWNrKGNhbGxiYWNrKSwgY3R4LCB0aGlzLCBmdW5jdGlvbigpIHtcbiAgICBjb25zdCBkZXNjcmlwdG9yID0gdGhpcy5nZXREZXNjcmlwdG9yQnlJZChmZCk7XG4gICAgY29uc3QgaXRlbSA9IGRlc2NyaXB0b3IuZ2V0SXRlbSgpO1xuICAgIGl0ZW0uc2V0TW9kZShtb2RlKTtcbiAgfSk7XG59O1xuXG4vKipcbiAqIERlbGV0ZSBhIG5hbWVkIGl0ZW0uXG4gKiBAcGFyYW0ge3N0cmluZ30gcGF0aG5hbWUgUGF0aCB0byBpdGVtLlxuICogQHBhcmFtIHtmdW5jdGlvbihFcnJvcil9IGNhbGxiYWNrIE9wdGlvbmFsIGNhbGxiYWNrLlxuICogQHBhcmFtIHtPYmplY3R9IGN0eCBDb250ZXh0IG9iamVjdCAob3B0aW9uYWwpLCBvbmx5IGZvciBub2RlanMgdjEwKy5cbiAqL1xuQmluZGluZy5wcm90b3R5cGUudW5saW5rID0gZnVuY3Rpb24ocGF0aG5hbWUsIGNhbGxiYWNrLCBjdHgpIHtcbiAgbWFya1N5c2NhbGwoY3R4LCAndW5saW5rJyk7XG5cbiAgcmV0dXJuIG1heWJlQ2FsbGJhY2sobm9ybWFsaXplQ2FsbGJhY2soY2FsbGJhY2spLCBjdHgsIHRoaXMsIGZ1bmN0aW9uKCkge1xuICAgIHBhdGhuYW1lID0gZGVCdWZmZXIocGF0aG5hbWUpO1xuICAgIGNvbnN0IGl0ZW0gPSB0aGlzLl9zeXN0ZW0uZ2V0SXRlbShwYXRobmFtZSk7XG4gICAgaWYgKCFpdGVtKSB7XG4gICAgICB0aHJvdyBuZXcgRlNFcnJvcignRU5PRU5UJywgcGF0aG5hbWUpO1xuICAgIH1cbiAgICBpZiAoaXRlbSBpbnN0YW5jZW9mIERpcmVjdG9yeSkge1xuICAgICAgdGhyb3cgbmV3IEZTRXJyb3IoJ0VQRVJNJywgcGF0aG5hbWUpO1xuICAgIH1cbiAgICBjb25zdCBwYXJlbnQgPSB0aGlzLl9zeXN0ZW0uZ2V0SXRlbShwYXRoLmRpcm5hbWUocGF0aG5hbWUpKTtcbiAgICBwYXJlbnQucmVtb3ZlSXRlbShwYXRoLmJhc2VuYW1lKHBhdGhuYW1lKSk7XG4gIH0pO1xufTtcblxuLyoqXG4gKiBVcGRhdGUgdGltZXN0YW1wcy5cbiAqIEBwYXJhbSB7c3RyaW5nfSBwYXRobmFtZSBQYXRoIHRvIGl0ZW0uXG4gKiBAcGFyYW0ge251bWJlcn0gYXRpbWUgQWNjZXNzIHRpbWUgKGluIHNlY29uZHMpLlxuICogQHBhcmFtIHtudW1iZXJ9IG10aW1lIE1vZGlmaWNhdGlvbiB0aW1lIChpbiBzZWNvbmRzKS5cbiAqIEBwYXJhbSB7ZnVuY3Rpb24oRXJyb3IpfSBjYWxsYmFjayBPcHRpb25hbCBjYWxsYmFjay5cbiAqIEBwYXJhbSB7T2JqZWN0fSBjdHggQ29udGV4dCBvYmplY3QgKG9wdGlvbmFsKSwgb25seSBmb3Igbm9kZWpzIHYxMCsuXG4gKi9cbkJpbmRpbmcucHJvdG90eXBlLnV0aW1lcyA9IGZ1bmN0aW9uKHBhdGhuYW1lLCBhdGltZSwgbXRpbWUsIGNhbGxiYWNrLCBjdHgpIHtcbiAgbWFya1N5c2NhbGwoY3R4LCAndXRpbWVzJyk7XG5cbiAgcmV0dXJuIG1heWJlQ2FsbGJhY2sobm9ybWFsaXplQ2FsbGJhY2soY2FsbGJhY2spLCBjdHgsIHRoaXMsIGZ1bmN0aW9uKCkge1xuICAgIHBhdGhuYW1lID0gZGVCdWZmZXIocGF0aG5hbWUpO1xuICAgIGNvbnN0IGl0ZW0gPSB0aGlzLl9zeXN0ZW0uZ2V0SXRlbShwYXRobmFtZSk7XG4gICAgaWYgKCFpdGVtKSB7XG4gICAgICB0aHJvdyBuZXcgRlNFcnJvcignRU5PRU5UJywgcGF0aG5hbWUpO1xuICAgIH1cbiAgICBpdGVtLnNldEFUaW1lKG5ldyBEYXRlKGF0aW1lICogMTAwMCkpO1xuICAgIGl0ZW0uc2V0TVRpbWUobmV3IERhdGUobXRpbWUgKiAxMDAwKSk7XG4gIH0pO1xufTtcblxuLyoqXG4gKiBVcGRhdGUgdGltZXN0YW1wcy5cbiAqIEBwYXJhbSB7bnVtYmVyfSBmZCBGaWxlIGRlc2NyaXB0b3IuXG4gKiBAcGFyYW0ge251bWJlcn0gYXRpbWUgQWNjZXNzIHRpbWUgKGluIHNlY29uZHMpLlxuICogQHBhcmFtIHtudW1iZXJ9IG10aW1lIE1vZGlmaWNhdGlvbiB0aW1lIChpbiBzZWNvbmRzKS5cbiAqIEBwYXJhbSB7ZnVuY3Rpb24oRXJyb3IpfSBjYWxsYmFjayBPcHRpb25hbCBjYWxsYmFjay5cbiAqIEBwYXJhbSB7T2JqZWN0fSBjdHggQ29udGV4dCBvYmplY3QgKG9wdGlvbmFsKSwgb25seSBmb3Igbm9kZWpzIHYxMCsuXG4gKi9cbkJpbmRpbmcucHJvdG90eXBlLmZ1dGltZXMgPSBmdW5jdGlvbihmZCwgYXRpbWUsIG10aW1lLCBjYWxsYmFjaywgY3R4KSB7XG4gIG1hcmtTeXNjYWxsKGN0eCwgJ2Z1dGltZXMnKTtcblxuICByZXR1cm4gbWF5YmVDYWxsYmFjayhub3JtYWxpemVDYWxsYmFjayhjYWxsYmFjayksIGN0eCwgdGhpcywgZnVuY3Rpb24oKSB7XG4gICAgY29uc3QgZGVzY3JpcHRvciA9IHRoaXMuZ2V0RGVzY3JpcHRvckJ5SWQoZmQpO1xuICAgIGNvbnN0IGl0ZW0gPSBkZXNjcmlwdG9yLmdldEl0ZW0oKTtcbiAgICBpdGVtLnNldEFUaW1lKG5ldyBEYXRlKGF0aW1lICogMTAwMCkpO1xuICAgIGl0ZW0uc2V0TVRpbWUobmV3IERhdGUobXRpbWUgKiAxMDAwKSk7XG4gIH0pO1xufTtcblxuLyoqXG4gKiBTeW5jaHJvbml6ZSBpbi1jb3JlIHN0YXRlIHdpdGggc3RvcmFnZSBkZXZpY2UuXG4gKiBAcGFyYW0ge251bWJlcn0gZmQgRmlsZSBkZXNjcmlwdG9yLlxuICogQHBhcmFtIHtmdW5jdGlvbihFcnJvcil9IGNhbGxiYWNrIE9wdGlvbmFsIGNhbGxiYWNrLlxuICogQHBhcmFtIHtPYmplY3R9IGN0eCBDb250ZXh0IG9iamVjdCAob3B0aW9uYWwpLCBvbmx5IGZvciBub2RlanMgdjEwKy5cbiAqL1xuQmluZGluZy5wcm90b3R5cGUuZnN5bmMgPSBmdW5jdGlvbihmZCwgY2FsbGJhY2ssIGN0eCkge1xuICBtYXJrU3lzY2FsbChjdHgsICdmc3luYycpO1xuXG4gIHJldHVybiBtYXliZUNhbGxiYWNrKG5vcm1hbGl6ZUNhbGxiYWNrKGNhbGxiYWNrKSwgY3R4LCB0aGlzLCBmdW5jdGlvbigpIHtcbiAgICB0aGlzLmdldERlc2NyaXB0b3JCeUlkKGZkKTtcbiAgfSk7XG59O1xuXG4vKipcbiAqIFN5bmNocm9uaXplIGluLWNvcmUgbWV0YWRhdGEgc3RhdGUgd2l0aCBzdG9yYWdlIGRldmljZS5cbiAqIEBwYXJhbSB7bnVtYmVyfSBmZCBGaWxlIGRlc2NyaXB0b3IuXG4gKiBAcGFyYW0ge2Z1bmN0aW9uKEVycm9yKX0gY2FsbGJhY2sgT3B0aW9uYWwgY2FsbGJhY2suXG4gKiBAcGFyYW0ge09iamVjdH0gY3R4IENvbnRleHQgb2JqZWN0IChvcHRpb25hbCksIG9ubHkgZm9yIG5vZGVqcyB2MTArLlxuICovXG5CaW5kaW5nLnByb3RvdHlwZS5mZGF0YXN5bmMgPSBmdW5jdGlvbihmZCwgY2FsbGJhY2ssIGN0eCkge1xuICBtYXJrU3lzY2FsbChjdHgsICdmZGF0YXN5bmMnKTtcblxuICByZXR1cm4gbWF5YmVDYWxsYmFjayhub3JtYWxpemVDYWxsYmFjayhjYWxsYmFjayksIGN0eCwgdGhpcywgZnVuY3Rpb24oKSB7XG4gICAgdGhpcy5nZXREZXNjcmlwdG9yQnlJZChmZCk7XG4gIH0pO1xufTtcblxuLyoqXG4gKiBDcmVhdGUgYSBoYXJkIGxpbmsuXG4gKiBAcGFyYW0ge3N0cmluZ30gc3JjUGF0aCBUaGUgZXhpc3RpbmcgZmlsZS5cbiAqIEBwYXJhbSB7c3RyaW5nfSBkZXN0UGF0aCBUaGUgbmV3IGxpbmsgdG8gY3JlYXRlLlxuICogQHBhcmFtIHtmdW5jdGlvbihFcnJvcil9IGNhbGxiYWNrIE9wdGlvbmFsIGNhbGxiYWNrLlxuICogQHBhcmFtIHtPYmplY3R9IGN0eCBDb250ZXh0IG9iamVjdCAob3B0aW9uYWwpLCBvbmx5IGZvciBub2RlanMgdjEwKy5cbiAqL1xuQmluZGluZy5wcm90b3R5cGUubGluayA9IGZ1bmN0aW9uKHNyY1BhdGgsIGRlc3RQYXRoLCBjYWxsYmFjaywgY3R4KSB7XG4gIG1hcmtTeXNjYWxsKGN0eCwgJ2xpbmsnKTtcblxuICByZXR1cm4gbWF5YmVDYWxsYmFjayhub3JtYWxpemVDYWxsYmFjayhjYWxsYmFjayksIGN0eCwgdGhpcywgZnVuY3Rpb24oKSB7XG4gICAgc3JjUGF0aCA9IGRlQnVmZmVyKHNyY1BhdGgpO1xuICAgIGRlc3RQYXRoID0gZGVCdWZmZXIoZGVzdFBhdGgpO1xuICAgIGNvbnN0IGl0ZW0gPSB0aGlzLl9zeXN0ZW0uZ2V0SXRlbShzcmNQYXRoKTtcbiAgICBpZiAoIWl0ZW0pIHtcbiAgICAgIHRocm93IG5ldyBGU0Vycm9yKCdFTk9FTlQnLCBzcmNQYXRoKTtcbiAgICB9XG4gICAgaWYgKGl0ZW0gaW5zdGFuY2VvZiBEaXJlY3RvcnkpIHtcbiAgICAgIHRocm93IG5ldyBGU0Vycm9yKCdFUEVSTScsIHNyY1BhdGgpO1xuICAgIH1cbiAgICBpZiAodGhpcy5fc3lzdGVtLmdldEl0ZW0oZGVzdFBhdGgpKSB7XG4gICAgICB0aHJvdyBuZXcgRlNFcnJvcignRUVYSVNUJywgZGVzdFBhdGgpO1xuICAgIH1cbiAgICBjb25zdCBwYXJlbnQgPSB0aGlzLl9zeXN0ZW0uZ2V0SXRlbShwYXRoLmRpcm5hbWUoZGVzdFBhdGgpKTtcbiAgICBpZiAoIXBhcmVudCkge1xuICAgICAgdGhyb3cgbmV3IEZTRXJyb3IoJ0VOT0VOVCcsIGRlc3RQYXRoKTtcbiAgICB9XG4gICAgaWYgKCEocGFyZW50IGluc3RhbmNlb2YgRGlyZWN0b3J5KSkge1xuICAgICAgdGhyb3cgbmV3IEZTRXJyb3IoJ0VOT1RESVInLCBkZXN0UGF0aCk7XG4gICAgfVxuICAgIHBhcmVudC5hZGRJdGVtKHBhdGguYmFzZW5hbWUoZGVzdFBhdGgpLCBpdGVtKTtcbiAgfSk7XG59O1xuXG4vKipcbiAqIENyZWF0ZSBhIHN5bWJvbGljIGxpbmsuXG4gKiBAcGFyYW0ge3N0cmluZ30gc3JjUGF0aCBQYXRoIGZyb20gbGluayB0byB0aGUgc291cmNlIGZpbGUuXG4gKiBAcGFyYW0ge3N0cmluZ30gZGVzdFBhdGggUGF0aCBmb3IgdGhlIGdlbmVyYXRlZCBsaW5rLlxuICogQHBhcmFtIHtzdHJpbmd9IHR5cGUgSWdub3JlZCAodXNlZCBmb3IgV2luZG93cyBvbmx5KS5cbiAqIEBwYXJhbSB7ZnVuY3Rpb24oRXJyb3IpfSBjYWxsYmFjayBPcHRpb25hbCBjYWxsYmFjay5cbiAqIEBwYXJhbSB7T2JqZWN0fSBjdHggQ29udGV4dCBvYmplY3QgKG9wdGlvbmFsKSwgb25seSBmb3Igbm9kZWpzIHYxMCsuXG4gKi9cbkJpbmRpbmcucHJvdG90eXBlLnN5bWxpbmsgPSBmdW5jdGlvbihzcmNQYXRoLCBkZXN0UGF0aCwgdHlwZSwgY2FsbGJhY2ssIGN0eCkge1xuICBtYXJrU3lzY2FsbChjdHgsICdzeW1saW5rJyk7XG5cbiAgcmV0dXJuIG1heWJlQ2FsbGJhY2sobm9ybWFsaXplQ2FsbGJhY2soY2FsbGJhY2spLCBjdHgsIHRoaXMsIGZ1bmN0aW9uKCkge1xuICAgIHNyY1BhdGggPSBkZUJ1ZmZlcihzcmNQYXRoKTtcbiAgICBkZXN0UGF0aCA9IGRlQnVmZmVyKGRlc3RQYXRoKTtcbiAgICBpZiAodGhpcy5fc3lzdGVtLmdldEl0ZW0oZGVzdFBhdGgpKSB7XG4gICAgICB0aHJvdyBuZXcgRlNFcnJvcignRUVYSVNUJywgZGVzdFBhdGgpO1xuICAgIH1cbiAgICBjb25zdCBwYXJlbnQgPSB0aGlzLl9zeXN0ZW0uZ2V0SXRlbShwYXRoLmRpcm5hbWUoZGVzdFBhdGgpKTtcbiAgICBpZiAoIXBhcmVudCkge1xuICAgICAgdGhyb3cgbmV3IEZTRXJyb3IoJ0VOT0VOVCcsIGRlc3RQYXRoKTtcbiAgICB9XG4gICAgaWYgKCEocGFyZW50IGluc3RhbmNlb2YgRGlyZWN0b3J5KSkge1xuICAgICAgdGhyb3cgbmV3IEZTRXJyb3IoJ0VOT1RESVInLCBkZXN0UGF0aCk7XG4gICAgfVxuICAgIGNvbnN0IGxpbmsgPSBuZXcgU3ltYm9saWNMaW5rKCk7XG4gICAgbGluay5zZXRQYXRoKHNyY1BhdGgpO1xuICAgIHBhcmVudC5hZGRJdGVtKHBhdGguYmFzZW5hbWUoZGVzdFBhdGgpLCBsaW5rKTtcbiAgfSk7XG59O1xuXG4vKipcbiAqIFJlYWQgdGhlIGNvbnRlbnRzIG9mIGEgc3ltYm9saWMgbGluay5cbiAqIEBwYXJhbSB7c3RyaW5nfSBwYXRobmFtZSBQYXRoIHRvIHN5bWJvbGljIGxpbmsuXG4gKiBAcGFyYW0ge3N0cmluZ30gZW5jb2RpbmcgVGhlIGVuY29kaW5nICgndXRmLTgnIG9yICdidWZmZXInKS5cbiAqIEBwYXJhbSB7ZnVuY3Rpb24oRXJyb3IsIChzdHJpbmd8QnVmZmVyKSl9IGNhbGxiYWNrIE9wdGlvbmFsIGNhbGxiYWNrLlxuICogQHBhcmFtIHtPYmplY3R9IGN0eCBDb250ZXh0IG9iamVjdCAob3B0aW9uYWwpLCBvbmx5IGZvciBub2RlanMgdjEwKy5cbiAqIEByZXR1cm4ge3N0cmluZ3xCdWZmZXJ9IFN5bWJvbGljIGxpbmsgY29udGVudHMgKHBhdGggdG8gc291cmNlKS5cbiAqL1xuQmluZGluZy5wcm90b3R5cGUucmVhZGxpbmsgPSBmdW5jdGlvbihwYXRobmFtZSwgZW5jb2RpbmcsIGNhbGxiYWNrLCBjdHgpIHtcbiAgaWYgKGVuY29kaW5nICYmIHR5cGVvZiBlbmNvZGluZyAhPT0gJ3N0cmluZycpIHtcbiAgICAvLyB0aGlzIHdvdWxkIG5vdCBoYXBwZW5kIGluIG5vZGVqcyB2MTArXG4gICAgY2FsbGJhY2sgPSBlbmNvZGluZztcbiAgICBlbmNvZGluZyA9ICd1dGYtOCc7XG4gIH1cblxuICBtYXJrU3lzY2FsbChjdHgsICdyZWFkbGluaycpO1xuXG4gIHJldHVybiBtYXliZUNhbGxiYWNrKG5vcm1hbGl6ZUNhbGxiYWNrKGNhbGxiYWNrKSwgY3R4LCB0aGlzLCBmdW5jdGlvbigpIHtcbiAgICBwYXRobmFtZSA9IGRlQnVmZmVyKHBhdGhuYW1lKTtcbiAgICBjb25zdCBsaW5rID0gdGhpcy5fc3lzdGVtLmdldEl0ZW0ocGF0aG5hbWUpO1xuICAgIGlmICghbGluaykge1xuICAgICAgdGhyb3cgbmV3IEZTRXJyb3IoJ0VOT0VOVCcsIHBhdGhuYW1lKTtcbiAgICB9XG4gICAgaWYgKCEobGluayBpbnN0YW5jZW9mIFN5bWJvbGljTGluaykpIHtcbiAgICAgIHRocm93IG5ldyBGU0Vycm9yKCdFSU5WQUwnLCBwYXRobmFtZSk7XG4gICAgfVxuICAgIGxldCBsaW5rUGF0aCA9IGxpbmsuZ2V0UGF0aCgpO1xuICAgIGlmIChlbmNvZGluZyA9PT0gJ2J1ZmZlcicpIHtcbiAgICAgIGxpbmtQYXRoID0gYnVmZmVyRnJvbShsaW5rUGF0aCk7XG4gICAgfVxuICAgIHJldHVybiBsaW5rUGF0aDtcbiAgfSk7XG59O1xuXG4vKipcbiAqIFN0YXQgYW4gaXRlbS5cbiAqIEBwYXJhbSB7c3RyaW5nfSBmaWxlcGF0aCBQYXRoLlxuICogQHBhcmFtIHtmdW5jdGlvbihFcnJvciwgU3RhdHMpfEZsb2F0NjRBcnJheXxCaWdVaW50NjRBcnJheX0gY2FsbGJhY2sgQ2FsbGJhY2sgKG9wdGlvbmFsKS4gSW4gTm9kZSA3LjcuMCsgdGhpcyB3aWxsIGJlIGEgRmxvYXQ2NEFycmF5XG4gKiB0aGF0IHNob3VsZCBiZSBmaWxsZWQgd2l0aCBzdGF0IHZhbHVlcy5cbiAqIEBwYXJhbSB7T2JqZWN0fSBjdHggQ29udGV4dCBvYmplY3QgKG9wdGlvbmFsKSwgb25seSBmb3Igbm9kZWpzIHYxMCsuXG4gKiBAcmV0dXJuIHtTdGF0c3x1bmRlZmluZWR9IFN0YXRzIG9yIHVuZGVmaW5lZCAoaWYgc3luYykuXG4gKi9cbkJpbmRpbmcucHJvdG90eXBlLmxzdGF0ID0gZnVuY3Rpb24oZmlsZXBhdGgsIG9wdGlvbnMsIGNhbGxiYWNrLCBjdHgpIHtcbiAgaWYgKGFyZ3VtZW50cy5sZW5ndGggPCAzKSB7XG4gICAgLy8gdGhpcyB3b3VsZCBub3QgaGFwcGVuZCBpbiBub2RlanMgdjEwK1xuICAgIGNhbGxiYWNrID0gb3B0aW9ucztcbiAgICBvcHRpb25zID0ge307XG4gIH1cblxuICBtYXJrU3lzY2FsbChjdHgsICdsc3RhdCcpO1xuXG4gIHJldHVybiBtYXliZUNhbGxiYWNrKHdyYXBTdGF0c0NhbGxiYWNrKGNhbGxiYWNrKSwgY3R4LCB0aGlzLCBmdW5jdGlvbigpIHtcbiAgICBmaWxlcGF0aCA9IGRlQnVmZmVyKGZpbGVwYXRoKTtcbiAgICBjb25zdCBpdGVtID0gdGhpcy5fc3lzdGVtLmdldEl0ZW0oZmlsZXBhdGgpO1xuICAgIGlmICghaXRlbSkge1xuICAgICAgdGhyb3cgbmV3IEZTRXJyb3IoJ0VOT0VOVCcsIGZpbGVwYXRoKTtcbiAgICB9XG4gICAgY29uc3Qgc3RhdHMgPSBpdGVtLmdldFN0YXRzKCk7XG5cbiAgICAvLyBJbiBOb2RlIDcuNy4wKywgYmluZGluZy5zdGF0IGFjY2VwdHMgYSBGbG9hdDY0QXJyYXkgYXMgdGhlIHNlY29uZCBhcmd1bWVudCxcbiAgICAvLyB3aGljaCBzaG91bGQgYmUgZmlsbGVkIHdpdGggc3RhdCB2YWx1ZXMuXG4gICAgLy8gSW4gcHJpb3IgdmVyc2lvbnMgb2YgTm9kZSwgYmluZGluZy5zdGF0IHNpbXBseSByZXR1cm5zIGEgU3RhdHMgaW5zdGFuY2UuXG4gICAgaWYgKFxuICAgICAgY2FsbGJhY2sgaW5zdGFuY2VvZiBGbG9hdDY0QXJyYXkgfHxcbiAgICAgIGNhbGxiYWNrIGluc3RhbmNlb2YgQmlnVWludDY0QXJyYXlcbiAgICApIHtcbiAgICAgIGZpbGxTdGF0c0FycmF5KHN0YXRzLCBjYWxsYmFjayk7XG4gICAgfSBlbHNlIHtcbiAgICAgIGZpbGxTdGF0c0FycmF5KHN0YXRzLCBzdGF0VmFsdWVzKTtcbiAgICAgIHJldHVybiBuZXcgU3RhdHMoaXRlbS5nZXRTdGF0cygpKTtcbiAgICB9XG4gIH0pO1xufTtcblxuLyoqXG4gKiBUZXN0cyB1c2VyIHBlcm1pc3Npb25zLlxuICogQHBhcmFtIHtzdHJpbmd9IGZpbGVwYXRoIFBhdGguXG4gKiBAcGFyYW0ge251bWJlcn0gbW9kZSBNb2RlLlxuICogQHBhcmFtIHtmdW5jdGlvbihFcnJvcil9IGNhbGxiYWNrIENhbGxiYWNrIChvcHRpb25hbCkuXG4gKiBAcGFyYW0ge09iamVjdH0gY3R4IENvbnRleHQgb2JqZWN0IChvcHRpb25hbCksIG9ubHkgZm9yIG5vZGVqcyB2MTArLlxuICovXG5CaW5kaW5nLnByb3RvdHlwZS5hY2Nlc3MgPSBmdW5jdGlvbihmaWxlcGF0aCwgbW9kZSwgY2FsbGJhY2ssIGN0eCkge1xuICBtYXJrU3lzY2FsbChjdHgsICdhY2Nlc3MnKTtcblxuICByZXR1cm4gbWF5YmVDYWxsYmFjayhub3JtYWxpemVDYWxsYmFjayhjYWxsYmFjayksIGN0eCwgdGhpcywgZnVuY3Rpb24oKSB7XG4gICAgZmlsZXBhdGggPSBkZUJ1ZmZlcihmaWxlcGF0aCk7XG4gICAgbGV0IGl0ZW0gPSB0aGlzLl9zeXN0ZW0uZ2V0SXRlbShmaWxlcGF0aCk7XG4gICAgbGV0IGxpbmtzID0gMDtcbiAgICB3aGlsZSAoaXRlbSBpbnN0YW5jZW9mIFN5bWJvbGljTGluaykge1xuICAgICAgaWYgKGxpbmtzID4gTUFYX0xJTktTKSB7XG4gICAgICAgIHRocm93IG5ldyBGU0Vycm9yKCdFTE9PUCcsIGZpbGVwYXRoKTtcbiAgICAgIH1cbiAgICAgIGZpbGVwYXRoID0gcGF0aC5yZXNvbHZlKHBhdGguZGlybmFtZShmaWxlcGF0aCksIGl0ZW0uZ2V0UGF0aCgpKTtcbiAgICAgIGl0ZW0gPSB0aGlzLl9zeXN0ZW0uZ2V0SXRlbShmaWxlcGF0aCk7XG4gICAgICArK2xpbmtzO1xuICAgIH1cbiAgICBpZiAoIWl0ZW0pIHtcbiAgICAgIHRocm93IG5ldyBGU0Vycm9yKCdFTk9FTlQnLCBmaWxlcGF0aCk7XG4gICAgfVxuICAgIGlmIChtb2RlICYmIHByb2Nlc3MuZ2V0dWlkICYmIHByb2Nlc3MuZ2V0Z2lkKSB7XG4gICAgICBjb25zdCBpdGVtTW9kZSA9IGl0ZW0uZ2V0TW9kZSgpO1xuICAgICAgaWYgKGl0ZW0uZ2V0VWlkKCkgPT09IHByb2Nlc3MuZ2V0dWlkKCkpIHtcbiAgICAgICAgaWYgKChpdGVtTW9kZSAmIChtb2RlICogNjQpKSAhPT0gbW9kZSAqIDY0KSB7XG4gICAgICAgICAgdGhyb3cgbmV3IEZTRXJyb3IoJ0VBQ0NFUycsIGZpbGVwYXRoKTtcbiAgICAgICAgfVxuICAgICAgfSBlbHNlIGlmIChpdGVtLmdldEdpZCgpID09PSBwcm9jZXNzLmdldGdpZCgpKSB7XG4gICAgICAgIGlmICgoaXRlbU1vZGUgJiAobW9kZSAqIDgpKSAhPT0gbW9kZSAqIDgpIHtcbiAgICAgICAgICB0aHJvdyBuZXcgRlNFcnJvcignRUFDQ0VTJywgZmlsZXBhdGgpO1xuICAgICAgICB9XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBpZiAoKGl0ZW1Nb2RlICYgbW9kZSkgIT09IG1vZGUpIHtcbiAgICAgICAgICB0aHJvdyBuZXcgRlNFcnJvcignRUFDQ0VTJywgZmlsZXBhdGgpO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuICB9KTtcbn07XG5cbi8qKlxuICogTm90IHlldCBpbXBsZW1lbnRlZC5cbiAqIEB0eXBlIHtmdW5jdGlvbigpfVxuICovXG5CaW5kaW5nLnByb3RvdHlwZS5TdGF0V2F0Y2hlciA9IG5vdEltcGxlbWVudGVkO1xuXG4vKipcbiAqIEV4cG9ydCB0aGUgYmluZGluZyBjb25zdHJ1Y3Rvci5cbiAqIEB0eXBlIHtmdW5jdGlvbigpfVxuICovXG5leHBvcnRzID0gbW9kdWxlLmV4cG9ydHMgPSBCaW5kaW5nO1xuIl0sIm5hbWVzIjpbXSwiaWdub3JlTGlzdCI6WzBdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/mock-fs/lib/binding.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/mock-fs/lib/buffer.js":
/*!********************************************!*\
  !*** ./node_modules/mock-fs/lib/buffer.js ***!
  \********************************************/
/***/ ((__unused_webpack_module, exports) => {

eval("exports.from =\n  Buffer.from ||\n  function(value, encoding) {\n    if (encoding) {\n      return new Buffer(value, encoding);\n    }\n    return new Buffer(value);\n  };\n\nexports.alloc =\n  Buffer.alloc ||\n  function(size) {\n    return new Buffer(size);\n  };\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvbW9jay1mcy9saWIvYnVmZmVyLmpzIiwibWFwcGluZ3MiOiJBQUFBLFlBQVk7QUFDWjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQSxhQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0EiLCJzb3VyY2VzIjpbIi9Vc2Vycy9wYW56YS9Eb2N1bWVudHMvUGVyc29uYWxQcm9qZWN0cy9wcmVkaWsvbm9kZV9tb2R1bGVzL21vY2stZnMvbGliL2J1ZmZlci5qcyJdLCJzb3VyY2VzQ29udGVudCI6WyJleHBvcnRzLmZyb20gPVxuICBCdWZmZXIuZnJvbSB8fFxuICBmdW5jdGlvbih2YWx1ZSwgZW5jb2RpbmcpIHtcbiAgICBpZiAoZW5jb2RpbmcpIHtcbiAgICAgIHJldHVybiBuZXcgQnVmZmVyKHZhbHVlLCBlbmNvZGluZyk7XG4gICAgfVxuICAgIHJldHVybiBuZXcgQnVmZmVyKHZhbHVlKTtcbiAgfTtcblxuZXhwb3J0cy5hbGxvYyA9XG4gIEJ1ZmZlci5hbGxvYyB8fFxuICBmdW5jdGlvbihzaXplKSB7XG4gICAgcmV0dXJuIG5ldyBCdWZmZXIoc2l6ZSk7XG4gIH07XG4iXSwibmFtZXMiOltdLCJpZ25vcmVMaXN0IjpbMF0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/mock-fs/lib/buffer.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/mock-fs/lib/bypass.js":
/*!********************************************!*\
  !*** ./node_modules/mock-fs/lib/bypass.js ***!
  \********************************************/
/***/ ((module, exports) => {

eval("const realBinding = process.binding('fs');\nlet storedBinding;\n\n/**\n * Perform action, bypassing mock FS\n * @example\n * // This file exists on the real FS, not on the mocked FS\n * const filePath = '/path/file.json';\n * const data = mock.bypass(() => fs.readFileSync(filePath, 'utf-8'));\n */\nexports = module.exports = function bypass(fn) {\n  if (typeof fn !== 'function') {\n    throw new Error(`Must provide a function to perform for mock.bypass()`);\n  }\n\n  disable();\n\n  let result;\n  try {\n    result = fn();\n  } finally {\n    if (result && typeof result.then === 'function') {\n      result.then(\n        r => {\n          enable();\n          return r;\n        },\n        err => {\n          enable();\n          throw err;\n        }\n      );\n    } else {\n      enable();\n    }\n  }\n\n  return result;\n};\n\n/**\n * Temporarily disable Mocked FS\n */\nfunction disable() {\n  if (realBinding._mockedBinding) {\n    storedBinding = realBinding._mockedBinding;\n    delete realBinding._mockedBinding;\n  }\n}\n\n/**\n * Enables Mocked FS after being disabled by disable()\n */\nfunction enable() {\n  if (storedBinding) {\n    realBinding._mockedBinding = storedBinding;\n    storedBinding = undefined;\n  }\n}\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvbW9jay1mcy9saWIvYnlwYXNzLmpzIiwibWFwcGluZ3MiOiJBQUFBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxJQUFJO0FBQ0o7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EiLCJzb3VyY2VzIjpbIi9Vc2Vycy9wYW56YS9Eb2N1bWVudHMvUGVyc29uYWxQcm9qZWN0cy9wcmVkaWsvbm9kZV9tb2R1bGVzL21vY2stZnMvbGliL2J5cGFzcy5qcyJdLCJzb3VyY2VzQ29udGVudCI6WyJjb25zdCByZWFsQmluZGluZyA9IHByb2Nlc3MuYmluZGluZygnZnMnKTtcbmxldCBzdG9yZWRCaW5kaW5nO1xuXG4vKipcbiAqIFBlcmZvcm0gYWN0aW9uLCBieXBhc3NpbmcgbW9jayBGU1xuICogQGV4YW1wbGVcbiAqIC8vIFRoaXMgZmlsZSBleGlzdHMgb24gdGhlIHJlYWwgRlMsIG5vdCBvbiB0aGUgbW9ja2VkIEZTXG4gKiBjb25zdCBmaWxlUGF0aCA9ICcvcGF0aC9maWxlLmpzb24nO1xuICogY29uc3QgZGF0YSA9IG1vY2suYnlwYXNzKCgpID0+IGZzLnJlYWRGaWxlU3luYyhmaWxlUGF0aCwgJ3V0Zi04JykpO1xuICovXG5leHBvcnRzID0gbW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbiBieXBhc3MoZm4pIHtcbiAgaWYgKHR5cGVvZiBmbiAhPT0gJ2Z1bmN0aW9uJykge1xuICAgIHRocm93IG5ldyBFcnJvcihgTXVzdCBwcm92aWRlIGEgZnVuY3Rpb24gdG8gcGVyZm9ybSBmb3IgbW9jay5ieXBhc3MoKWApO1xuICB9XG5cbiAgZGlzYWJsZSgpO1xuXG4gIGxldCByZXN1bHQ7XG4gIHRyeSB7XG4gICAgcmVzdWx0ID0gZm4oKTtcbiAgfSBmaW5hbGx5IHtcbiAgICBpZiAocmVzdWx0ICYmIHR5cGVvZiByZXN1bHQudGhlbiA9PT0gJ2Z1bmN0aW9uJykge1xuICAgICAgcmVzdWx0LnRoZW4oXG4gICAgICAgIHIgPT4ge1xuICAgICAgICAgIGVuYWJsZSgpO1xuICAgICAgICAgIHJldHVybiByO1xuICAgICAgICB9LFxuICAgICAgICBlcnIgPT4ge1xuICAgICAgICAgIGVuYWJsZSgpO1xuICAgICAgICAgIHRocm93IGVycjtcbiAgICAgICAgfVxuICAgICAgKTtcbiAgICB9IGVsc2Uge1xuICAgICAgZW5hYmxlKCk7XG4gICAgfVxuICB9XG5cbiAgcmV0dXJuIHJlc3VsdDtcbn07XG5cbi8qKlxuICogVGVtcG9yYXJpbHkgZGlzYWJsZSBNb2NrZWQgRlNcbiAqL1xuZnVuY3Rpb24gZGlzYWJsZSgpIHtcbiAgaWYgKHJlYWxCaW5kaW5nLl9tb2NrZWRCaW5kaW5nKSB7XG4gICAgc3RvcmVkQmluZGluZyA9IHJlYWxCaW5kaW5nLl9tb2NrZWRCaW5kaW5nO1xuICAgIGRlbGV0ZSByZWFsQmluZGluZy5fbW9ja2VkQmluZGluZztcbiAgfVxufVxuXG4vKipcbiAqIEVuYWJsZXMgTW9ja2VkIEZTIGFmdGVyIGJlaW5nIGRpc2FibGVkIGJ5IGRpc2FibGUoKVxuICovXG5mdW5jdGlvbiBlbmFibGUoKSB7XG4gIGlmIChzdG9yZWRCaW5kaW5nKSB7XG4gICAgcmVhbEJpbmRpbmcuX21vY2tlZEJpbmRpbmcgPSBzdG9yZWRCaW5kaW5nO1xuICAgIHN0b3JlZEJpbmRpbmcgPSB1bmRlZmluZWQ7XG4gIH1cbn1cbiJdLCJuYW1lcyI6W10sImlnbm9yZUxpc3QiOlswXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/mock-fs/lib/bypass.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/mock-fs/lib/descriptor.js":
/*!************************************************!*\
  !*** ./node_modules/mock-fs/lib/descriptor.js ***!
  \************************************************/
/***/ ((module, exports, __webpack_require__) => {

"use strict";
eval("\n\nconst constants = __webpack_require__(/*! constants */ \"constants\");\n\n/**\n * Create a new file descriptor.\n * @param {number} flags Flags.\n * @constructor\n */\nfunction FileDescriptor(flags) {\n  /**\n   * Flags.\n   * @type {number}\n   */\n  this._flags = flags;\n\n  /**\n   * File system item.\n   * @type {Item}\n   */\n  this._item = null;\n\n  /**\n   * Current file position.\n   * @type {number}\n   */\n  this._position = 0;\n}\n\n/**\n * Set the item.\n * @param {Item} item File system item.\n */\nFileDescriptor.prototype.setItem = function(item) {\n  this._item = item;\n};\n\n/**\n * Get the item.\n * @return {Item} File system item.\n */\nFileDescriptor.prototype.getItem = function() {\n  return this._item;\n};\n\n/**\n * Get the current file position.\n * @return {number} File position.\n */\nFileDescriptor.prototype.getPosition = function() {\n  return this._position;\n};\n\n/**\n * Set the current file position.\n * @param {number} position File position.\n */\nFileDescriptor.prototype.setPosition = function(position) {\n  this._position = position;\n};\n\n/**\n * Check if file opened for appending.\n * @return {boolean} Opened for appending.\n */\nFileDescriptor.prototype.isAppend = function() {\n  return (this._flags & constants.O_APPEND) === constants.O_APPEND;\n};\n\n/**\n * Check if file opened for creation.\n * @return {boolean} Opened for creation.\n */\nFileDescriptor.prototype.isCreate = function() {\n  return (this._flags & constants.O_CREAT) === constants.O_CREAT;\n};\n\n/**\n * Check if file opened for reading.\n * @return {boolean} Opened for reading.\n */\nFileDescriptor.prototype.isRead = function() {\n  return (this._flags & constants.O_WRONLY) !== constants.O_WRONLY;\n};\n\n/**\n * Check if file opened for writing.\n * @return {boolean} Opened for writing.\n */\nFileDescriptor.prototype.isWrite = function() {\n  return (\n    (this._flags & constants.O_WRONLY) === constants.O_WRONLY ||\n    (this._flags & constants.O_RDWR) === constants.O_RDWR\n  );\n};\n\n/**\n * Check if file opened for truncating.\n * @return {boolean} Opened for truncating.\n */\nFileDescriptor.prototype.isTruncate = function() {\n  return (this._flags & constants.O_TRUNC) === constants.O_TRUNC;\n};\n\n/**\n * Check if file opened with exclusive flag.\n * @return {boolean} Opened with exclusive.\n */\nFileDescriptor.prototype.isExclusive = function() {\n  return (this._flags & constants.O_EXCL) === constants.O_EXCL;\n};\n\n/**\n * Export the constructor.\n * @type {function()}\n */\nexports = module.exports = FileDescriptor;\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvbW9jay1mcy9saWIvZGVzY3JpcHRvci5qcyIsIm1hcHBpbmdzIjoiQUFBYTs7QUFFYixrQkFBa0IsbUJBQU8sQ0FBQyw0QkFBVzs7QUFFckM7QUFDQTtBQUNBLFdBQVcsUUFBUTtBQUNuQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsWUFBWTtBQUNaO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLFlBQVk7QUFDWjtBQUNBOztBQUVBO0FBQ0E7QUFDQSxZQUFZO0FBQ1o7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxXQUFXLE1BQU07QUFDakI7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLFlBQVksTUFBTTtBQUNsQjtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsWUFBWSxRQUFRO0FBQ3BCO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxXQUFXLFFBQVE7QUFDbkI7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLFlBQVksU0FBUztBQUNyQjtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsWUFBWSxTQUFTO0FBQ3JCO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxZQUFZLFNBQVM7QUFDckI7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLFlBQVksU0FBUztBQUNyQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsWUFBWSxTQUFTO0FBQ3JCO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxZQUFZLFNBQVM7QUFDckI7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLFVBQVU7QUFDVjtBQUNBIiwic291cmNlcyI6WyIvVXNlcnMvcGFuemEvRG9jdW1lbnRzL1BlcnNvbmFsUHJvamVjdHMvcHJlZGlrL25vZGVfbW9kdWxlcy9tb2NrLWZzL2xpYi9kZXNjcmlwdG9yLmpzIl0sInNvdXJjZXNDb250ZW50IjpbIid1c2Ugc3RyaWN0JztcblxuY29uc3QgY29uc3RhbnRzID0gcmVxdWlyZSgnY29uc3RhbnRzJyk7XG5cbi8qKlxuICogQ3JlYXRlIGEgbmV3IGZpbGUgZGVzY3JpcHRvci5cbiAqIEBwYXJhbSB7bnVtYmVyfSBmbGFncyBGbGFncy5cbiAqIEBjb25zdHJ1Y3RvclxuICovXG5mdW5jdGlvbiBGaWxlRGVzY3JpcHRvcihmbGFncykge1xuICAvKipcbiAgICogRmxhZ3MuXG4gICAqIEB0eXBlIHtudW1iZXJ9XG4gICAqL1xuICB0aGlzLl9mbGFncyA9IGZsYWdzO1xuXG4gIC8qKlxuICAgKiBGaWxlIHN5c3RlbSBpdGVtLlxuICAgKiBAdHlwZSB7SXRlbX1cbiAgICovXG4gIHRoaXMuX2l0ZW0gPSBudWxsO1xuXG4gIC8qKlxuICAgKiBDdXJyZW50IGZpbGUgcG9zaXRpb24uXG4gICAqIEB0eXBlIHtudW1iZXJ9XG4gICAqL1xuICB0aGlzLl9wb3NpdGlvbiA9IDA7XG59XG5cbi8qKlxuICogU2V0IHRoZSBpdGVtLlxuICogQHBhcmFtIHtJdGVtfSBpdGVtIEZpbGUgc3lzdGVtIGl0ZW0uXG4gKi9cbkZpbGVEZXNjcmlwdG9yLnByb3RvdHlwZS5zZXRJdGVtID0gZnVuY3Rpb24oaXRlbSkge1xuICB0aGlzLl9pdGVtID0gaXRlbTtcbn07XG5cbi8qKlxuICogR2V0IHRoZSBpdGVtLlxuICogQHJldHVybiB7SXRlbX0gRmlsZSBzeXN0ZW0gaXRlbS5cbiAqL1xuRmlsZURlc2NyaXB0b3IucHJvdG90eXBlLmdldEl0ZW0gPSBmdW5jdGlvbigpIHtcbiAgcmV0dXJuIHRoaXMuX2l0ZW07XG59O1xuXG4vKipcbiAqIEdldCB0aGUgY3VycmVudCBmaWxlIHBvc2l0aW9uLlxuICogQHJldHVybiB7bnVtYmVyfSBGaWxlIHBvc2l0aW9uLlxuICovXG5GaWxlRGVzY3JpcHRvci5wcm90b3R5cGUuZ2V0UG9zaXRpb24gPSBmdW5jdGlvbigpIHtcbiAgcmV0dXJuIHRoaXMuX3Bvc2l0aW9uO1xufTtcblxuLyoqXG4gKiBTZXQgdGhlIGN1cnJlbnQgZmlsZSBwb3NpdGlvbi5cbiAqIEBwYXJhbSB7bnVtYmVyfSBwb3NpdGlvbiBGaWxlIHBvc2l0aW9uLlxuICovXG5GaWxlRGVzY3JpcHRvci5wcm90b3R5cGUuc2V0UG9zaXRpb24gPSBmdW5jdGlvbihwb3NpdGlvbikge1xuICB0aGlzLl9wb3NpdGlvbiA9IHBvc2l0aW9uO1xufTtcblxuLyoqXG4gKiBDaGVjayBpZiBmaWxlIG9wZW5lZCBmb3IgYXBwZW5kaW5nLlxuICogQHJldHVybiB7Ym9vbGVhbn0gT3BlbmVkIGZvciBhcHBlbmRpbmcuXG4gKi9cbkZpbGVEZXNjcmlwdG9yLnByb3RvdHlwZS5pc0FwcGVuZCA9IGZ1bmN0aW9uKCkge1xuICByZXR1cm4gKHRoaXMuX2ZsYWdzICYgY29uc3RhbnRzLk9fQVBQRU5EKSA9PT0gY29uc3RhbnRzLk9fQVBQRU5EO1xufTtcblxuLyoqXG4gKiBDaGVjayBpZiBmaWxlIG9wZW5lZCBmb3IgY3JlYXRpb24uXG4gKiBAcmV0dXJuIHtib29sZWFufSBPcGVuZWQgZm9yIGNyZWF0aW9uLlxuICovXG5GaWxlRGVzY3JpcHRvci5wcm90b3R5cGUuaXNDcmVhdGUgPSBmdW5jdGlvbigpIHtcbiAgcmV0dXJuICh0aGlzLl9mbGFncyAmIGNvbnN0YW50cy5PX0NSRUFUKSA9PT0gY29uc3RhbnRzLk9fQ1JFQVQ7XG59O1xuXG4vKipcbiAqIENoZWNrIGlmIGZpbGUgb3BlbmVkIGZvciByZWFkaW5nLlxuICogQHJldHVybiB7Ym9vbGVhbn0gT3BlbmVkIGZvciByZWFkaW5nLlxuICovXG5GaWxlRGVzY3JpcHRvci5wcm90b3R5cGUuaXNSZWFkID0gZnVuY3Rpb24oKSB7XG4gIHJldHVybiAodGhpcy5fZmxhZ3MgJiBjb25zdGFudHMuT19XUk9OTFkpICE9PSBjb25zdGFudHMuT19XUk9OTFk7XG59O1xuXG4vKipcbiAqIENoZWNrIGlmIGZpbGUgb3BlbmVkIGZvciB3cml0aW5nLlxuICogQHJldHVybiB7Ym9vbGVhbn0gT3BlbmVkIGZvciB3cml0aW5nLlxuICovXG5GaWxlRGVzY3JpcHRvci5wcm90b3R5cGUuaXNXcml0ZSA9IGZ1bmN0aW9uKCkge1xuICByZXR1cm4gKFxuICAgICh0aGlzLl9mbGFncyAmIGNvbnN0YW50cy5PX1dST05MWSkgPT09IGNvbnN0YW50cy5PX1dST05MWSB8fFxuICAgICh0aGlzLl9mbGFncyAmIGNvbnN0YW50cy5PX1JEV1IpID09PSBjb25zdGFudHMuT19SRFdSXG4gICk7XG59O1xuXG4vKipcbiAqIENoZWNrIGlmIGZpbGUgb3BlbmVkIGZvciB0cnVuY2F0aW5nLlxuICogQHJldHVybiB7Ym9vbGVhbn0gT3BlbmVkIGZvciB0cnVuY2F0aW5nLlxuICovXG5GaWxlRGVzY3JpcHRvci5wcm90b3R5cGUuaXNUcnVuY2F0ZSA9IGZ1bmN0aW9uKCkge1xuICByZXR1cm4gKHRoaXMuX2ZsYWdzICYgY29uc3RhbnRzLk9fVFJVTkMpID09PSBjb25zdGFudHMuT19UUlVOQztcbn07XG5cbi8qKlxuICogQ2hlY2sgaWYgZmlsZSBvcGVuZWQgd2l0aCBleGNsdXNpdmUgZmxhZy5cbiAqIEByZXR1cm4ge2Jvb2xlYW59IE9wZW5lZCB3aXRoIGV4Y2x1c2l2ZS5cbiAqL1xuRmlsZURlc2NyaXB0b3IucHJvdG90eXBlLmlzRXhjbHVzaXZlID0gZnVuY3Rpb24oKSB7XG4gIHJldHVybiAodGhpcy5fZmxhZ3MgJiBjb25zdGFudHMuT19FWENMKSA9PT0gY29uc3RhbnRzLk9fRVhDTDtcbn07XG5cbi8qKlxuICogRXhwb3J0IHRoZSBjb25zdHJ1Y3Rvci5cbiAqIEB0eXBlIHtmdW5jdGlvbigpfVxuICovXG5leHBvcnRzID0gbW9kdWxlLmV4cG9ydHMgPSBGaWxlRGVzY3JpcHRvcjtcbiJdLCJuYW1lcyI6W10sImlnbm9yZUxpc3QiOlswXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/mock-fs/lib/descriptor.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/mock-fs/lib/directory.js":
/*!***********************************************!*\
  !*** ./node_modules/mock-fs/lib/directory.js ***!
  \***********************************************/
/***/ ((module, exports, __webpack_require__) => {

"use strict";
eval("\n\nconst util = __webpack_require__(/*! util */ \"util\");\n\nconst Item = __webpack_require__(/*! ./item */ \"(ssr)/./node_modules/mock-fs/lib/item.js\");\n\nconst constants = __webpack_require__(/*! constants */ \"constants\");\n\n/**\n * A directory.\n * @constructor\n */\nfunction Directory() {\n  Item.call(this);\n\n  /**\n   * Items in this directory.\n   * @type {Object.<string, Item>}\n   */\n  this._items = {};\n\n  /**\n   * Permissions.\n   */\n  this._mode = 511; // 0777\n}\nutil.inherits(Directory, Item);\n\n/**\n * Add an item to the directory.\n * @param {string} name The name to give the item.\n * @param {Item} item The item to add.\n * @return {Item} The added item.\n */\nDirectory.prototype.addItem = function(name, item) {\n  if (this._items.hasOwnProperty(name)) {\n    throw new Error('Item with the same name already exists: ' + name);\n  }\n  this._items[name] = item;\n  ++item.links;\n  if (item instanceof Directory) {\n    // for '.' entry\n    ++item.links;\n    // for subdirectory\n    ++this.links;\n  }\n  this.setMTime(new Date());\n  return item;\n};\n\n/**\n * Get a named item.\n * @param {string} name Item name.\n * @return {Item} The named item (or null if none).\n */\nDirectory.prototype.getItem = function(name) {\n  let item = null;\n  if (this._items.hasOwnProperty(name)) {\n    item = this._items[name];\n  }\n  return item;\n};\n\n/**\n * Remove an item.\n * @param {string} name Name of item to remove.\n * @return {Item} The orphan item.\n */\nDirectory.prototype.removeItem = function(name) {\n  if (!this._items.hasOwnProperty(name)) {\n    throw new Error('Item does not exist in directory: ' + name);\n  }\n  const item = this._items[name];\n  delete this._items[name];\n  --item.links;\n  if (item instanceof Directory) {\n    // for '.' entry\n    --item.links;\n    // for subdirectory\n    --this.links;\n  }\n  this.setMTime(new Date());\n  return item;\n};\n\n/**\n * Get list of item names in this directory.\n * @return {Array.<string>} Item names.\n */\nDirectory.prototype.list = function() {\n  return Object.keys(this._items).sort();\n};\n\n/**\n * Get directory stats.\n * @return {Object} Stats properties.\n */\nDirectory.prototype.getStats = function() {\n  const stats = Item.prototype.getStats.call(this);\n  stats.mode = this.getMode() | constants.S_IFDIR;\n  stats.size = 1;\n  stats.blocks = 1;\n  return stats;\n};\n\n/**\n * Export the constructor.\n * @type {function()}\n */\nexports = module.exports = Directory;\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvbW9jay1mcy9saWIvZGlyZWN0b3J5LmpzIiwibWFwcGluZ3MiOiJBQUFhOztBQUViLGFBQWEsbUJBQU8sQ0FBQyxrQkFBTTs7QUFFM0IsYUFBYSxtQkFBTyxDQUFDLHdEQUFROztBQUU3QixrQkFBa0IsbUJBQU8sQ0FBQyw0QkFBVzs7QUFFckM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxZQUFZO0FBQ1o7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxvQkFBb0I7QUFDcEI7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsV0FBVyxRQUFRO0FBQ25CLFdBQVcsTUFBTTtBQUNqQixZQUFZLE1BQU07QUFDbEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLFdBQVcsUUFBUTtBQUNuQixZQUFZLE1BQU07QUFDbEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsV0FBVyxRQUFRO0FBQ25CLFlBQVksTUFBTTtBQUNsQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxZQUFZLGdCQUFnQjtBQUM1QjtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsWUFBWSxRQUFRO0FBQ3BCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLFVBQVU7QUFDVjtBQUNBIiwic291cmNlcyI6WyIvVXNlcnMvcGFuemEvRG9jdW1lbnRzL1BlcnNvbmFsUHJvamVjdHMvcHJlZGlrL25vZGVfbW9kdWxlcy9tb2NrLWZzL2xpYi9kaXJlY3RvcnkuanMiXSwic291cmNlc0NvbnRlbnQiOlsiJ3VzZSBzdHJpY3QnO1xuXG5jb25zdCB1dGlsID0gcmVxdWlyZSgndXRpbCcpO1xuXG5jb25zdCBJdGVtID0gcmVxdWlyZSgnLi9pdGVtJyk7XG5cbmNvbnN0IGNvbnN0YW50cyA9IHJlcXVpcmUoJ2NvbnN0YW50cycpO1xuXG4vKipcbiAqIEEgZGlyZWN0b3J5LlxuICogQGNvbnN0cnVjdG9yXG4gKi9cbmZ1bmN0aW9uIERpcmVjdG9yeSgpIHtcbiAgSXRlbS5jYWxsKHRoaXMpO1xuXG4gIC8qKlxuICAgKiBJdGVtcyBpbiB0aGlzIGRpcmVjdG9yeS5cbiAgICogQHR5cGUge09iamVjdC48c3RyaW5nLCBJdGVtPn1cbiAgICovXG4gIHRoaXMuX2l0ZW1zID0ge307XG5cbiAgLyoqXG4gICAqIFBlcm1pc3Npb25zLlxuICAgKi9cbiAgdGhpcy5fbW9kZSA9IDUxMTsgLy8gMDc3N1xufVxudXRpbC5pbmhlcml0cyhEaXJlY3RvcnksIEl0ZW0pO1xuXG4vKipcbiAqIEFkZCBhbiBpdGVtIHRvIHRoZSBkaXJlY3RvcnkuXG4gKiBAcGFyYW0ge3N0cmluZ30gbmFtZSBUaGUgbmFtZSB0byBnaXZlIHRoZSBpdGVtLlxuICogQHBhcmFtIHtJdGVtfSBpdGVtIFRoZSBpdGVtIHRvIGFkZC5cbiAqIEByZXR1cm4ge0l0ZW19IFRoZSBhZGRlZCBpdGVtLlxuICovXG5EaXJlY3RvcnkucHJvdG90eXBlLmFkZEl0ZW0gPSBmdW5jdGlvbihuYW1lLCBpdGVtKSB7XG4gIGlmICh0aGlzLl9pdGVtcy5oYXNPd25Qcm9wZXJ0eShuYW1lKSkge1xuICAgIHRocm93IG5ldyBFcnJvcignSXRlbSB3aXRoIHRoZSBzYW1lIG5hbWUgYWxyZWFkeSBleGlzdHM6ICcgKyBuYW1lKTtcbiAgfVxuICB0aGlzLl9pdGVtc1tuYW1lXSA9IGl0ZW07XG4gICsraXRlbS5saW5rcztcbiAgaWYgKGl0ZW0gaW5zdGFuY2VvZiBEaXJlY3RvcnkpIHtcbiAgICAvLyBmb3IgJy4nIGVudHJ5XG4gICAgKytpdGVtLmxpbmtzO1xuICAgIC8vIGZvciBzdWJkaXJlY3RvcnlcbiAgICArK3RoaXMubGlua3M7XG4gIH1cbiAgdGhpcy5zZXRNVGltZShuZXcgRGF0ZSgpKTtcbiAgcmV0dXJuIGl0ZW07XG59O1xuXG4vKipcbiAqIEdldCBhIG5hbWVkIGl0ZW0uXG4gKiBAcGFyYW0ge3N0cmluZ30gbmFtZSBJdGVtIG5hbWUuXG4gKiBAcmV0dXJuIHtJdGVtfSBUaGUgbmFtZWQgaXRlbSAob3IgbnVsbCBpZiBub25lKS5cbiAqL1xuRGlyZWN0b3J5LnByb3RvdHlwZS5nZXRJdGVtID0gZnVuY3Rpb24obmFtZSkge1xuICBsZXQgaXRlbSA9IG51bGw7XG4gIGlmICh0aGlzLl9pdGVtcy5oYXNPd25Qcm9wZXJ0eShuYW1lKSkge1xuICAgIGl0ZW0gPSB0aGlzLl9pdGVtc1tuYW1lXTtcbiAgfVxuICByZXR1cm4gaXRlbTtcbn07XG5cbi8qKlxuICogUmVtb3ZlIGFuIGl0ZW0uXG4gKiBAcGFyYW0ge3N0cmluZ30gbmFtZSBOYW1lIG9mIGl0ZW0gdG8gcmVtb3ZlLlxuICogQHJldHVybiB7SXRlbX0gVGhlIG9ycGhhbiBpdGVtLlxuICovXG5EaXJlY3RvcnkucHJvdG90eXBlLnJlbW92ZUl0ZW0gPSBmdW5jdGlvbihuYW1lKSB7XG4gIGlmICghdGhpcy5faXRlbXMuaGFzT3duUHJvcGVydHkobmFtZSkpIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoJ0l0ZW0gZG9lcyBub3QgZXhpc3QgaW4gZGlyZWN0b3J5OiAnICsgbmFtZSk7XG4gIH1cbiAgY29uc3QgaXRlbSA9IHRoaXMuX2l0ZW1zW25hbWVdO1xuICBkZWxldGUgdGhpcy5faXRlbXNbbmFtZV07XG4gIC0taXRlbS5saW5rcztcbiAgaWYgKGl0ZW0gaW5zdGFuY2VvZiBEaXJlY3RvcnkpIHtcbiAgICAvLyBmb3IgJy4nIGVudHJ5XG4gICAgLS1pdGVtLmxpbmtzO1xuICAgIC8vIGZvciBzdWJkaXJlY3RvcnlcbiAgICAtLXRoaXMubGlua3M7XG4gIH1cbiAgdGhpcy5zZXRNVGltZShuZXcgRGF0ZSgpKTtcbiAgcmV0dXJuIGl0ZW07XG59O1xuXG4vKipcbiAqIEdldCBsaXN0IG9mIGl0ZW0gbmFtZXMgaW4gdGhpcyBkaXJlY3RvcnkuXG4gKiBAcmV0dXJuIHtBcnJheS48c3RyaW5nPn0gSXRlbSBuYW1lcy5cbiAqL1xuRGlyZWN0b3J5LnByb3RvdHlwZS5saXN0ID0gZnVuY3Rpb24oKSB7XG4gIHJldHVybiBPYmplY3Qua2V5cyh0aGlzLl9pdGVtcykuc29ydCgpO1xufTtcblxuLyoqXG4gKiBHZXQgZGlyZWN0b3J5IHN0YXRzLlxuICogQHJldHVybiB7T2JqZWN0fSBTdGF0cyBwcm9wZXJ0aWVzLlxuICovXG5EaXJlY3RvcnkucHJvdG90eXBlLmdldFN0YXRzID0gZnVuY3Rpb24oKSB7XG4gIGNvbnN0IHN0YXRzID0gSXRlbS5wcm90b3R5cGUuZ2V0U3RhdHMuY2FsbCh0aGlzKTtcbiAgc3RhdHMubW9kZSA9IHRoaXMuZ2V0TW9kZSgpIHwgY29uc3RhbnRzLlNfSUZESVI7XG4gIHN0YXRzLnNpemUgPSAxO1xuICBzdGF0cy5ibG9ja3MgPSAxO1xuICByZXR1cm4gc3RhdHM7XG59O1xuXG4vKipcbiAqIEV4cG9ydCB0aGUgY29uc3RydWN0b3IuXG4gKiBAdHlwZSB7ZnVuY3Rpb24oKX1cbiAqL1xuZXhwb3J0cyA9IG1vZHVsZS5leHBvcnRzID0gRGlyZWN0b3J5O1xuIl0sIm5hbWVzIjpbXSwiaWdub3JlTGlzdCI6WzBdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/mock-fs/lib/directory.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/mock-fs/lib/error.js":
/*!*******************************************!*\
  !*** ./node_modules/mock-fs/lib/error.js ***!
  \*******************************************/
/***/ ((module, exports) => {

"use strict";
eval("\n\nconst uvBinding = process.binding('uv');\n/**\n * Error codes from libuv.\n * @enum {number}\n */\nconst codes = {};\n\nif (uvBinding.errmap) {\n  // nodejs v8+\n  uvBinding.errmap.forEach(function(value, errno) {\n    const code = value[0];\n    const message = value[1];\n    codes[code] = {errno: errno, message: message};\n  });\n} else {\n  // nodejs v4 and v6\n  Object.keys(uvBinding).forEach(function(key) {\n    if (key.startsWith('UV_')) {\n      const code = key.slice(3);\n      const errno = uvBinding[key];\n      codes[code] = {errno: errno, message: key};\n    }\n  });\n}\n\n/**\n * Create an error.\n * @param {string} code Error code.\n * @param {string} path Path (optional).\n * @constructor\n */\nfunction FSError(code, path) {\n  if (!codes.hasOwnProperty(code)) {\n    throw new Error('Programmer error, invalid error code: ' + code);\n  }\n  Error.call(this);\n  const details = codes[code];\n  let message = code + ', ' + details.message;\n  if (path) {\n    message += \" '\" + path + \"'\";\n  }\n  this.message = message;\n  this.code = code;\n  this.errno = details.errno;\n  if (path !== undefined) {\n    this.path = path;\n  }\n  Error.captureStackTrace(this, FSError);\n}\nFSError.prototype = new Error();\nFSError.codes = codes;\n\n/**\n * Error constructor.\n */\nexports = module.exports = FSError;\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvbW9jay1mcy9saWIvZXJyb3IuanMiLCJtYXBwaW5ncyI6IkFBQWE7O0FBRWI7QUFDQTtBQUNBO0FBQ0EsVUFBVTtBQUNWO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG1CQUFtQjtBQUNuQixHQUFHO0FBQ0gsRUFBRTtBQUNGO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxxQkFBcUI7QUFDckI7QUFDQSxHQUFHO0FBQ0g7O0FBRUE7QUFDQTtBQUNBLFdBQVcsUUFBUTtBQUNuQixXQUFXLFFBQVE7QUFDbkI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EiLCJzb3VyY2VzIjpbIi9Vc2Vycy9wYW56YS9Eb2N1bWVudHMvUGVyc29uYWxQcm9qZWN0cy9wcmVkaWsvbm9kZV9tb2R1bGVzL21vY2stZnMvbGliL2Vycm9yLmpzIl0sInNvdXJjZXNDb250ZW50IjpbIid1c2Ugc3RyaWN0JztcblxuY29uc3QgdXZCaW5kaW5nID0gcHJvY2Vzcy5iaW5kaW5nKCd1dicpO1xuLyoqXG4gKiBFcnJvciBjb2RlcyBmcm9tIGxpYnV2LlxuICogQGVudW0ge251bWJlcn1cbiAqL1xuY29uc3QgY29kZXMgPSB7fTtcblxuaWYgKHV2QmluZGluZy5lcnJtYXApIHtcbiAgLy8gbm9kZWpzIHY4K1xuICB1dkJpbmRpbmcuZXJybWFwLmZvckVhY2goZnVuY3Rpb24odmFsdWUsIGVycm5vKSB7XG4gICAgY29uc3QgY29kZSA9IHZhbHVlWzBdO1xuICAgIGNvbnN0IG1lc3NhZ2UgPSB2YWx1ZVsxXTtcbiAgICBjb2Rlc1tjb2RlXSA9IHtlcnJubzogZXJybm8sIG1lc3NhZ2U6IG1lc3NhZ2V9O1xuICB9KTtcbn0gZWxzZSB7XG4gIC8vIG5vZGVqcyB2NCBhbmQgdjZcbiAgT2JqZWN0LmtleXModXZCaW5kaW5nKS5mb3JFYWNoKGZ1bmN0aW9uKGtleSkge1xuICAgIGlmIChrZXkuc3RhcnRzV2l0aCgnVVZfJykpIHtcbiAgICAgIGNvbnN0IGNvZGUgPSBrZXkuc2xpY2UoMyk7XG4gICAgICBjb25zdCBlcnJubyA9IHV2QmluZGluZ1trZXldO1xuICAgICAgY29kZXNbY29kZV0gPSB7ZXJybm86IGVycm5vLCBtZXNzYWdlOiBrZXl9O1xuICAgIH1cbiAgfSk7XG59XG5cbi8qKlxuICogQ3JlYXRlIGFuIGVycm9yLlxuICogQHBhcmFtIHtzdHJpbmd9IGNvZGUgRXJyb3IgY29kZS5cbiAqIEBwYXJhbSB7c3RyaW5nfSBwYXRoIFBhdGggKG9wdGlvbmFsKS5cbiAqIEBjb25zdHJ1Y3RvclxuICovXG5mdW5jdGlvbiBGU0Vycm9yKGNvZGUsIHBhdGgpIHtcbiAgaWYgKCFjb2Rlcy5oYXNPd25Qcm9wZXJ0eShjb2RlKSkge1xuICAgIHRocm93IG5ldyBFcnJvcignUHJvZ3JhbW1lciBlcnJvciwgaW52YWxpZCBlcnJvciBjb2RlOiAnICsgY29kZSk7XG4gIH1cbiAgRXJyb3IuY2FsbCh0aGlzKTtcbiAgY29uc3QgZGV0YWlscyA9IGNvZGVzW2NvZGVdO1xuICBsZXQgbWVzc2FnZSA9IGNvZGUgKyAnLCAnICsgZGV0YWlscy5tZXNzYWdlO1xuICBpZiAocGF0aCkge1xuICAgIG1lc3NhZ2UgKz0gXCIgJ1wiICsgcGF0aCArIFwiJ1wiO1xuICB9XG4gIHRoaXMubWVzc2FnZSA9IG1lc3NhZ2U7XG4gIHRoaXMuY29kZSA9IGNvZGU7XG4gIHRoaXMuZXJybm8gPSBkZXRhaWxzLmVycm5vO1xuICBpZiAocGF0aCAhPT0gdW5kZWZpbmVkKSB7XG4gICAgdGhpcy5wYXRoID0gcGF0aDtcbiAgfVxuICBFcnJvci5jYXB0dXJlU3RhY2tUcmFjZSh0aGlzLCBGU0Vycm9yKTtcbn1cbkZTRXJyb3IucHJvdG90eXBlID0gbmV3IEVycm9yKCk7XG5GU0Vycm9yLmNvZGVzID0gY29kZXM7XG5cbi8qKlxuICogRXJyb3IgY29uc3RydWN0b3IuXG4gKi9cbmV4cG9ydHMgPSBtb2R1bGUuZXhwb3J0cyA9IEZTRXJyb3I7XG4iXSwibmFtZXMiOltdLCJpZ25vcmVMaXN0IjpbMF0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/mock-fs/lib/error.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/mock-fs/lib/file.js":
/*!******************************************!*\
  !*** ./node_modules/mock-fs/lib/file.js ***!
  \******************************************/
/***/ ((module, exports, __webpack_require__) => {

"use strict";
eval("\n\nconst util = __webpack_require__(/*! util */ \"util\");\n\nconst Item = __webpack_require__(/*! ./item */ \"(ssr)/./node_modules/mock-fs/lib/item.js\");\nconst bufferFrom = (__webpack_require__(/*! ./buffer */ \"(ssr)/./node_modules/mock-fs/lib/buffer.js\").from);\nconst bufferAlloc = (__webpack_require__(/*! ./buffer */ \"(ssr)/./node_modules/mock-fs/lib/buffer.js\").alloc);\n\nconst EMPTY = bufferAlloc(0);\nconst constants = __webpack_require__(/*! constants */ \"constants\");\n\n/**\n * A file.\n * @constructor\n */\nfunction File() {\n  Item.call(this);\n\n  /**\n   * File content.\n   * @type {Buffer}\n   */\n  this._content = EMPTY;\n}\nutil.inherits(File, Item);\n\n/**\n * Get the file contents.\n * @return {Buffer} File contents.\n */\nFile.prototype.getContent = function() {\n  this.setATime(new Date());\n  return this._content;\n};\n\n/**\n * Set the file contents.\n * @param {string|Buffer} content File contents.\n */\nFile.prototype.setContent = function(content) {\n  if (typeof content === 'string') {\n    content = bufferFrom(content);\n  } else if (!Buffer.isBuffer(content)) {\n    throw new Error('File content must be a string or buffer');\n  }\n  this._content = content;\n  const now = Date.now();\n  this.setCTime(new Date(now));\n  this.setMTime(new Date(now));\n};\n\n/**\n * Get file stats.\n * @return {Object} Stats properties.\n */\nFile.prototype.getStats = function() {\n  const size = this._content.length;\n  const stats = Item.prototype.getStats.call(this);\n  stats.mode = this.getMode() | constants.S_IFREG;\n  stats.size = size;\n  stats.blocks = Math.ceil(size / 512);\n  return stats;\n};\n\n/**\n * Export the constructor.\n * @type {function()}\n */\nexports = module.exports = File;\n\n/**\n * Standard input.\n * @constructor\n */\nfunction StandardInput() {\n  File.call(this);\n  this.setMode(438); // 0666\n}\nutil.inherits(StandardInput, File);\n\nexports.StandardInput = StandardInput;\n\n/**\n * Standard output.\n * @constructor\n */\nfunction StandardOutput() {\n  File.call(this);\n  this.setMode(438); // 0666\n}\nutil.inherits(StandardOutput, File);\n\n/**\n * Write the contents to stdout.\n * @param {string|Buffer} content File contents.\n */\nStandardOutput.prototype.setContent = function(content) {\n  if (process.stdout.isTTY) {\n    process.stdout.write(content);\n  }\n};\n\nexports.StandardOutput = StandardOutput;\n\n/**\n * Standard error.\n * @constructor\n */\nfunction StandardError() {\n  File.call(this);\n  this.setMode(438); // 0666\n}\nutil.inherits(StandardError, File);\n\n/**\n * Write the contents to stderr.\n * @param {string|Buffer} content File contents.\n */\nStandardError.prototype.setContent = function(content) {\n  if (process.stderr.isTTY) {\n    process.stderr.write(content);\n  }\n};\n\nexports.StandardError = StandardError;\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvbW9jay1mcy9saWIvZmlsZS5qcyIsIm1hcHBpbmdzIjoiQUFBYTs7QUFFYixhQUFhLG1CQUFPLENBQUMsa0JBQU07O0FBRTNCLGFBQWEsbUJBQU8sQ0FBQyx3REFBUTtBQUM3QixtQkFBbUIsd0ZBQXdCO0FBQzNDLG9CQUFvQix5RkFBeUI7O0FBRTdDO0FBQ0Esa0JBQWtCLG1CQUFPLENBQUMsNEJBQVc7O0FBRXJDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsWUFBWTtBQUNaO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxZQUFZLFFBQVE7QUFDcEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsV0FBVyxlQUFlO0FBQzFCO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsSUFBSTtBQUNKO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxZQUFZLFFBQVE7QUFDcEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxVQUFVO0FBQ1Y7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxxQkFBcUI7QUFDckI7QUFDQTs7QUFFQSxxQkFBcUI7O0FBRXJCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHFCQUFxQjtBQUNyQjtBQUNBOztBQUVBO0FBQ0E7QUFDQSxXQUFXLGVBQWU7QUFDMUI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBLHNCQUFzQjs7QUFFdEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EscUJBQXFCO0FBQ3JCO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLFdBQVcsZUFBZTtBQUMxQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUEscUJBQXFCIiwic291cmNlcyI6WyIvVXNlcnMvcGFuemEvRG9jdW1lbnRzL1BlcnNvbmFsUHJvamVjdHMvcHJlZGlrL25vZGVfbW9kdWxlcy9tb2NrLWZzL2xpYi9maWxlLmpzIl0sInNvdXJjZXNDb250ZW50IjpbIid1c2Ugc3RyaWN0JztcblxuY29uc3QgdXRpbCA9IHJlcXVpcmUoJ3V0aWwnKTtcblxuY29uc3QgSXRlbSA9IHJlcXVpcmUoJy4vaXRlbScpO1xuY29uc3QgYnVmZmVyRnJvbSA9IHJlcXVpcmUoJy4vYnVmZmVyJykuZnJvbTtcbmNvbnN0IGJ1ZmZlckFsbG9jID0gcmVxdWlyZSgnLi9idWZmZXInKS5hbGxvYztcblxuY29uc3QgRU1QVFkgPSBidWZmZXJBbGxvYygwKTtcbmNvbnN0IGNvbnN0YW50cyA9IHJlcXVpcmUoJ2NvbnN0YW50cycpO1xuXG4vKipcbiAqIEEgZmlsZS5cbiAqIEBjb25zdHJ1Y3RvclxuICovXG5mdW5jdGlvbiBGaWxlKCkge1xuICBJdGVtLmNhbGwodGhpcyk7XG5cbiAgLyoqXG4gICAqIEZpbGUgY29udGVudC5cbiAgICogQHR5cGUge0J1ZmZlcn1cbiAgICovXG4gIHRoaXMuX2NvbnRlbnQgPSBFTVBUWTtcbn1cbnV0aWwuaW5oZXJpdHMoRmlsZSwgSXRlbSk7XG5cbi8qKlxuICogR2V0IHRoZSBmaWxlIGNvbnRlbnRzLlxuICogQHJldHVybiB7QnVmZmVyfSBGaWxlIGNvbnRlbnRzLlxuICovXG5GaWxlLnByb3RvdHlwZS5nZXRDb250ZW50ID0gZnVuY3Rpb24oKSB7XG4gIHRoaXMuc2V0QVRpbWUobmV3IERhdGUoKSk7XG4gIHJldHVybiB0aGlzLl9jb250ZW50O1xufTtcblxuLyoqXG4gKiBTZXQgdGhlIGZpbGUgY29udGVudHMuXG4gKiBAcGFyYW0ge3N0cmluZ3xCdWZmZXJ9IGNvbnRlbnQgRmlsZSBjb250ZW50cy5cbiAqL1xuRmlsZS5wcm90b3R5cGUuc2V0Q29udGVudCA9IGZ1bmN0aW9uKGNvbnRlbnQpIHtcbiAgaWYgKHR5cGVvZiBjb250ZW50ID09PSAnc3RyaW5nJykge1xuICAgIGNvbnRlbnQgPSBidWZmZXJGcm9tKGNvbnRlbnQpO1xuICB9IGVsc2UgaWYgKCFCdWZmZXIuaXNCdWZmZXIoY29udGVudCkpIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoJ0ZpbGUgY29udGVudCBtdXN0IGJlIGEgc3RyaW5nIG9yIGJ1ZmZlcicpO1xuICB9XG4gIHRoaXMuX2NvbnRlbnQgPSBjb250ZW50O1xuICBjb25zdCBub3cgPSBEYXRlLm5vdygpO1xuICB0aGlzLnNldENUaW1lKG5ldyBEYXRlKG5vdykpO1xuICB0aGlzLnNldE1UaW1lKG5ldyBEYXRlKG5vdykpO1xufTtcblxuLyoqXG4gKiBHZXQgZmlsZSBzdGF0cy5cbiAqIEByZXR1cm4ge09iamVjdH0gU3RhdHMgcHJvcGVydGllcy5cbiAqL1xuRmlsZS5wcm90b3R5cGUuZ2V0U3RhdHMgPSBmdW5jdGlvbigpIHtcbiAgY29uc3Qgc2l6ZSA9IHRoaXMuX2NvbnRlbnQubGVuZ3RoO1xuICBjb25zdCBzdGF0cyA9IEl0ZW0ucHJvdG90eXBlLmdldFN0YXRzLmNhbGwodGhpcyk7XG4gIHN0YXRzLm1vZGUgPSB0aGlzLmdldE1vZGUoKSB8IGNvbnN0YW50cy5TX0lGUkVHO1xuICBzdGF0cy5zaXplID0gc2l6ZTtcbiAgc3RhdHMuYmxvY2tzID0gTWF0aC5jZWlsKHNpemUgLyA1MTIpO1xuICByZXR1cm4gc3RhdHM7XG59O1xuXG4vKipcbiAqIEV4cG9ydCB0aGUgY29uc3RydWN0b3IuXG4gKiBAdHlwZSB7ZnVuY3Rpb24oKX1cbiAqL1xuZXhwb3J0cyA9IG1vZHVsZS5leHBvcnRzID0gRmlsZTtcblxuLyoqXG4gKiBTdGFuZGFyZCBpbnB1dC5cbiAqIEBjb25zdHJ1Y3RvclxuICovXG5mdW5jdGlvbiBTdGFuZGFyZElucHV0KCkge1xuICBGaWxlLmNhbGwodGhpcyk7XG4gIHRoaXMuc2V0TW9kZSg0MzgpOyAvLyAwNjY2XG59XG51dGlsLmluaGVyaXRzKFN0YW5kYXJkSW5wdXQsIEZpbGUpO1xuXG5leHBvcnRzLlN0YW5kYXJkSW5wdXQgPSBTdGFuZGFyZElucHV0O1xuXG4vKipcbiAqIFN0YW5kYXJkIG91dHB1dC5cbiAqIEBjb25zdHJ1Y3RvclxuICovXG5mdW5jdGlvbiBTdGFuZGFyZE91dHB1dCgpIHtcbiAgRmlsZS5jYWxsKHRoaXMpO1xuICB0aGlzLnNldE1vZGUoNDM4KTsgLy8gMDY2NlxufVxudXRpbC5pbmhlcml0cyhTdGFuZGFyZE91dHB1dCwgRmlsZSk7XG5cbi8qKlxuICogV3JpdGUgdGhlIGNvbnRlbnRzIHRvIHN0ZG91dC5cbiAqIEBwYXJhbSB7c3RyaW5nfEJ1ZmZlcn0gY29udGVudCBGaWxlIGNvbnRlbnRzLlxuICovXG5TdGFuZGFyZE91dHB1dC5wcm90b3R5cGUuc2V0Q29udGVudCA9IGZ1bmN0aW9uKGNvbnRlbnQpIHtcbiAgaWYgKHByb2Nlc3Muc3Rkb3V0LmlzVFRZKSB7XG4gICAgcHJvY2Vzcy5zdGRvdXQud3JpdGUoY29udGVudCk7XG4gIH1cbn07XG5cbmV4cG9ydHMuU3RhbmRhcmRPdXRwdXQgPSBTdGFuZGFyZE91dHB1dDtcblxuLyoqXG4gKiBTdGFuZGFyZCBlcnJvci5cbiAqIEBjb25zdHJ1Y3RvclxuICovXG5mdW5jdGlvbiBTdGFuZGFyZEVycm9yKCkge1xuICBGaWxlLmNhbGwodGhpcyk7XG4gIHRoaXMuc2V0TW9kZSg0MzgpOyAvLyAwNjY2XG59XG51dGlsLmluaGVyaXRzKFN0YW5kYXJkRXJyb3IsIEZpbGUpO1xuXG4vKipcbiAqIFdyaXRlIHRoZSBjb250ZW50cyB0byBzdGRlcnIuXG4gKiBAcGFyYW0ge3N0cmluZ3xCdWZmZXJ9IGNvbnRlbnQgRmlsZSBjb250ZW50cy5cbiAqL1xuU3RhbmRhcmRFcnJvci5wcm90b3R5cGUuc2V0Q29udGVudCA9IGZ1bmN0aW9uKGNvbnRlbnQpIHtcbiAgaWYgKHByb2Nlc3Muc3RkZXJyLmlzVFRZKSB7XG4gICAgcHJvY2Vzcy5zdGRlcnIud3JpdGUoY29udGVudCk7XG4gIH1cbn07XG5cbmV4cG9ydHMuU3RhbmRhcmRFcnJvciA9IFN0YW5kYXJkRXJyb3I7XG4iXSwibmFtZXMiOltdLCJpZ25vcmVMaXN0IjpbMF0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/mock-fs/lib/file.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/mock-fs/lib/filesystem.js":
/*!************************************************!*\
  !*** ./node_modules/mock-fs/lib/filesystem.js ***!
  \************************************************/
/***/ ((module, exports, __webpack_require__) => {

"use strict";
eval("\n\nconst os = __webpack_require__(/*! os */ \"os\");\nconst path = __webpack_require__(/*! path */ \"path\");\n\nconst Directory = __webpack_require__(/*! ./directory */ \"(ssr)/./node_modules/mock-fs/lib/directory.js\");\nconst File = __webpack_require__(/*! ./file */ \"(ssr)/./node_modules/mock-fs/lib/file.js\");\nconst FSError = __webpack_require__(/*! ./error */ \"(ssr)/./node_modules/mock-fs/lib/error.js\");\nconst SymbolicLink = __webpack_require__(/*! ./symlink */ \"(ssr)/./node_modules/mock-fs/lib/symlink.js\");\n\nconst isWindows = process.platform === 'win32';\n\nfunction toNamespacedPath(filePath) {\n  return path.toNamespacedPath\n    ? path.toNamespacedPath(filePath)\n    : path._makeLong(filePath);\n}\n\nfunction getPathParts(filepath) {\n  const parts = toNamespacedPath(path.resolve(filepath)).split(path.sep);\n  parts.shift();\n  if (isWindows) {\n    // parts currently looks like ['', '?', 'c:', ...]\n    parts.shift();\n    const q = parts.shift(); // should be '?'\n    const base = '\\\\\\\\' + q + '\\\\' + parts.shift().toLowerCase();\n    parts.unshift(base);\n  }\n  if (parts[parts.length - 1] === '') {\n    parts.pop();\n  }\n  return parts;\n}\n\n/**\n * Create a new file system.\n * @param {Object} options Any filesystem options.\n * @param {boolean} options.createCwd Create a directory for `process.cwd()`\n *     (defaults to `true`).\n * @param {boolean} options.createTmp Create a directory for `os.tmpdir()`\n *     (defaults to `true`).\n * @constructor\n */\nfunction FileSystem(options) {\n  options = options || {};\n\n  const createCwd = 'createCwd' in options ? options.createCwd : true;\n  const createTmp = 'createTmp' in options ? options.createTmp : true;\n\n  const root = new Directory();\n\n  // populate with default directories\n  const defaults = [];\n  if (createCwd) {\n    defaults.push(process.cwd());\n  }\n\n  if (createTmp) {\n    defaults.push((os.tmpdir && os.tmpdir()) || os.tmpDir());\n  }\n\n  defaults.forEach(function(dir) {\n    const parts = getPathParts(dir);\n    let directory = root;\n    for (let i = 0, ii = parts.length; i < ii; ++i) {\n      const name = parts[i];\n      const candidate = directory.getItem(name);\n      if (!candidate) {\n        directory = directory.addItem(name, new Directory());\n      } else if (candidate instanceof Directory) {\n        directory = candidate;\n      } else {\n        throw new Error('Failed to create directory: ' + dir);\n      }\n    }\n  });\n\n  /**\n   * Root directory.\n   * @type {Directory}\n   */\n  this._root = root;\n}\n\n/**\n * Get the root directory.\n * @return {Directory} The root directory.\n */\nFileSystem.prototype.getRoot = function() {\n  return this._root;\n};\n\n/**\n * Get a file system item.\n * @param {string} filepath Path to item.\n * @return {Item} The item (or null if not found).\n */\nFileSystem.prototype.getItem = function(filepath) {\n  const parts = getPathParts(filepath);\n  const currentParts = getPathParts(process.cwd());\n  let item = this._root;\n  let itemPath = '/';\n  for (let i = 0, ii = parts.length; i < ii; ++i) {\n    const name = parts[i];\n    while (item instanceof SymbolicLink) {\n      // Symbolic link being traversed as a directory --- If link targets\n      // another symbolic link, resolve target's path relative to the original\n      // link's target, otherwise relative to the current item.\n      itemPath = path.resolve(path.dirname(itemPath), item.getPath());\n      item = this.getItem(itemPath);\n    }\n    if (item) {\n      if (item instanceof Directory && name !== currentParts[i]) {\n        // make sure traversal is allowed\n        // This fails for Windows directories which do not have execute permission, by default. It may be a good idea\n        // to change this logic to windows-friendly. See notes in mock.createDirectoryInfoFromPaths()\n        if (!item.canExecute()) {\n          throw new FSError('EACCES', filepath);\n        }\n      }\n      if (item instanceof File) {\n        throw new FSError('ENOTDIR', filepath);\n      }\n      item = item.getItem(name);\n    }\n    if (!item) {\n      break;\n    }\n    itemPath = path.resolve(itemPath, name);\n  }\n  return item;\n};\n\n/**\n * Populate a directory with an item.\n * @param {Directory} directory The directory to populate.\n * @param {string} name The name of the item.\n * @param {string|Buffer|function|Object} obj Instructions for creating the\n *     item.\n */\nfunction populate(directory, name, obj) {\n  let item;\n  if (typeof obj === 'string' || Buffer.isBuffer(obj)) {\n    // contents for a file\n    item = new File();\n    item.setContent(obj);\n  } else if (typeof obj === 'function') {\n    // item factory\n    item = obj();\n  } else if (typeof obj === 'object') {\n    // directory with more to populate\n    item = new Directory();\n    for (const key in obj) {\n      populate(item, key, obj[key]);\n    }\n  } else {\n    throw new Error('Unsupported type: ' + typeof obj + ' of item ' + name);\n  }\n\n  /**\n   * Special exception for redundant adding of empty directories.\n   */\n  if (\n    item instanceof Directory &&\n    item.list().length === 0 &&\n    directory.getItem(name) instanceof Directory\n  ) {\n    // pass\n  } else {\n    directory.addItem(name, item);\n  }\n}\n\n/**\n * Configure a mock file system.\n * @param {Object} paths Config object.\n * @param {Object} options Any filesystem options.\n * @param {boolean} options.createCwd Create a directory for `process.cwd()`\n *     (defaults to `true`).\n * @param {boolean} options.createTmp Create a directory for `os.tmpdir()`\n *     (defaults to `true`).\n * @return {FileSystem} Mock file system.\n */\nFileSystem.create = function(paths, options) {\n  const system = new FileSystem(options);\n\n  for (const filepath in paths) {\n    const parts = getPathParts(filepath);\n    let directory = system._root;\n    for (let i = 0, ii = parts.length - 1; i < ii; ++i) {\n      const name = parts[i];\n      const candidate = directory.getItem(name);\n      if (!candidate) {\n        directory = directory.addItem(name, new Directory());\n      } else if (candidate instanceof Directory) {\n        directory = candidate;\n      } else {\n        throw new Error('Failed to create directory: ' + filepath);\n      }\n    }\n    populate(directory, parts[parts.length - 1], paths[filepath]);\n  }\n\n  return system;\n};\n\n/**\n * Generate a factory for new files.\n * @param {Object} config File config.\n * @return {function():File} Factory that creates a new file.\n */\nFileSystem.file = function(config) {\n  config = config || {};\n  return function() {\n    const file = new File();\n    if (config.hasOwnProperty('content')) {\n      file.setContent(config.content);\n    }\n    if (config.hasOwnProperty('mode')) {\n      file.setMode(config.mode);\n    } else {\n      file.setMode(438); // 0666\n    }\n    if (config.hasOwnProperty('uid')) {\n      file.setUid(config.uid);\n    }\n    if (config.hasOwnProperty('gid')) {\n      file.setGid(config.gid);\n    }\n    if (config.hasOwnProperty('atime')) {\n      file.setATime(config.atime);\n    }\n    if (config.hasOwnProperty('ctime')) {\n      file.setCTime(config.ctime);\n    }\n    if (config.hasOwnProperty('mtime')) {\n      file.setMTime(config.mtime);\n    }\n    if (config.hasOwnProperty('birthtime')) {\n      file.setBirthtime(config.birthtime);\n    }\n    return file;\n  };\n};\n\n/**\n * Generate a factory for new symbolic links.\n * @param {Object} config File config.\n * @return {function():File} Factory that creates a new symbolic link.\n */\nFileSystem.symlink = function(config) {\n  config = config || {};\n  return function() {\n    const link = new SymbolicLink();\n    if (config.hasOwnProperty('mode')) {\n      link.setMode(config.mode);\n    } else {\n      link.setMode(438); // 0666\n    }\n    if (config.hasOwnProperty('uid')) {\n      link.setUid(config.uid);\n    }\n    if (config.hasOwnProperty('gid')) {\n      link.setGid(config.gid);\n    }\n    if (config.hasOwnProperty('path')) {\n      link.setPath(config.path);\n    } else {\n      throw new Error('Missing \"path\" property');\n    }\n    if (config.hasOwnProperty('atime')) {\n      link.setATime(config.atime);\n    }\n    if (config.hasOwnProperty('ctime')) {\n      link.setCTime(config.ctime);\n    }\n    if (config.hasOwnProperty('mtime')) {\n      link.setMTime(config.mtime);\n    }\n    if (config.hasOwnProperty('birthtime')) {\n      link.setBirthtime(config.birthtime);\n    }\n    return link;\n  };\n};\n\n/**\n * Generate a factory for new directories.\n * @param {Object} config File config.\n * @return {function():Directory} Factory that creates a new directory.\n */\nFileSystem.directory = function(config) {\n  config = config || {};\n  return function() {\n    const dir = new Directory();\n    if (config.hasOwnProperty('mode')) {\n      dir.setMode(config.mode);\n    }\n    if (config.hasOwnProperty('uid')) {\n      dir.setUid(config.uid);\n    }\n    if (config.hasOwnProperty('gid')) {\n      dir.setGid(config.gid);\n    }\n    if (config.hasOwnProperty('items')) {\n      for (const name in config.items) {\n        populate(dir, name, config.items[name]);\n      }\n    }\n    if (config.hasOwnProperty('atime')) {\n      dir.setATime(config.atime);\n    }\n    if (config.hasOwnProperty('ctime')) {\n      dir.setCTime(config.ctime);\n    }\n    if (config.hasOwnProperty('mtime')) {\n      dir.setMTime(config.mtime);\n    }\n    if (config.hasOwnProperty('birthtime')) {\n      dir.setBirthtime(config.birthtime);\n    }\n    return dir;\n  };\n};\n\n/**\n * Module exports.\n * @type {function}\n */\nexports = module.exports = FileSystem;\nexports.getPathParts = getPathParts;\nexports.toNamespacedPath = toNamespacedPath;\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvbW9jay1mcy9saWIvZmlsZXN5c3RlbS5qcyIsIm1hcHBpbmdzIjoiQUFBYTs7QUFFYixXQUFXLG1CQUFPLENBQUMsY0FBSTtBQUN2QixhQUFhLG1CQUFPLENBQUMsa0JBQU07O0FBRTNCLGtCQUFrQixtQkFBTyxDQUFDLGtFQUFhO0FBQ3ZDLGFBQWEsbUJBQU8sQ0FBQyx3REFBUTtBQUM3QixnQkFBZ0IsbUJBQU8sQ0FBQywwREFBUztBQUNqQyxxQkFBcUIsbUJBQU8sQ0FBQyw4REFBVzs7QUFFeEM7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw2QkFBNkI7QUFDN0I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsV0FBVyxRQUFRO0FBQ25CLFdBQVcsU0FBUztBQUNwQjtBQUNBLFdBQVcsU0FBUztBQUNwQjtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsdUNBQXVDLFFBQVE7QUFDL0M7QUFDQTtBQUNBO0FBQ0E7QUFDQSxRQUFRO0FBQ1I7QUFDQSxRQUFRO0FBQ1I7QUFDQTtBQUNBO0FBQ0EsR0FBRzs7QUFFSDtBQUNBO0FBQ0EsWUFBWTtBQUNaO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsWUFBWSxXQUFXO0FBQ3ZCO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxXQUFXLFFBQVE7QUFDbkIsWUFBWSxNQUFNO0FBQ2xCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHFDQUFxQyxRQUFRO0FBQzdDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLFdBQVcsV0FBVztBQUN0QixXQUFXLFFBQVE7QUFDbkIsV0FBVywrQkFBK0I7QUFDMUM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLElBQUk7QUFDSjtBQUNBO0FBQ0EsSUFBSTtBQUNKO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxJQUFJO0FBQ0o7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxJQUFJO0FBQ0o7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxXQUFXLFFBQVE7QUFDbkIsV0FBVyxRQUFRO0FBQ25CLFdBQVcsU0FBUztBQUNwQjtBQUNBLFdBQVcsU0FBUztBQUNwQjtBQUNBLFlBQVksWUFBWTtBQUN4QjtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsMkNBQTJDLFFBQVE7QUFDbkQ7QUFDQTtBQUNBO0FBQ0E7QUFDQSxRQUFRO0FBQ1I7QUFDQSxRQUFRO0FBQ1I7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxXQUFXLFFBQVE7QUFDbkIsWUFBWSxpQkFBaUI7QUFDN0I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ04seUJBQXlCO0FBQ3pCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxXQUFXLFFBQVE7QUFDbkIsWUFBWSxpQkFBaUI7QUFDN0I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ04seUJBQXlCO0FBQ3pCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxXQUFXLFFBQVE7QUFDbkIsWUFBWSxzQkFBc0I7QUFDbEM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLFVBQVU7QUFDVjtBQUNBO0FBQ0Esb0JBQW9CO0FBQ3BCLHdCQUF3QiIsInNvdXJjZXMiOlsiL1VzZXJzL3BhbnphL0RvY3VtZW50cy9QZXJzb25hbFByb2plY3RzL3ByZWRpay9ub2RlX21vZHVsZXMvbW9jay1mcy9saWIvZmlsZXN5c3RlbS5qcyJdLCJzb3VyY2VzQ29udGVudCI6WyIndXNlIHN0cmljdCc7XG5cbmNvbnN0IG9zID0gcmVxdWlyZSgnb3MnKTtcbmNvbnN0IHBhdGggPSByZXF1aXJlKCdwYXRoJyk7XG5cbmNvbnN0IERpcmVjdG9yeSA9IHJlcXVpcmUoJy4vZGlyZWN0b3J5Jyk7XG5jb25zdCBGaWxlID0gcmVxdWlyZSgnLi9maWxlJyk7XG5jb25zdCBGU0Vycm9yID0gcmVxdWlyZSgnLi9lcnJvcicpO1xuY29uc3QgU3ltYm9saWNMaW5rID0gcmVxdWlyZSgnLi9zeW1saW5rJyk7XG5cbmNvbnN0IGlzV2luZG93cyA9IHByb2Nlc3MucGxhdGZvcm0gPT09ICd3aW4zMic7XG5cbmZ1bmN0aW9uIHRvTmFtZXNwYWNlZFBhdGgoZmlsZVBhdGgpIHtcbiAgcmV0dXJuIHBhdGgudG9OYW1lc3BhY2VkUGF0aFxuICAgID8gcGF0aC50b05hbWVzcGFjZWRQYXRoKGZpbGVQYXRoKVxuICAgIDogcGF0aC5fbWFrZUxvbmcoZmlsZVBhdGgpO1xufVxuXG5mdW5jdGlvbiBnZXRQYXRoUGFydHMoZmlsZXBhdGgpIHtcbiAgY29uc3QgcGFydHMgPSB0b05hbWVzcGFjZWRQYXRoKHBhdGgucmVzb2x2ZShmaWxlcGF0aCkpLnNwbGl0KHBhdGguc2VwKTtcbiAgcGFydHMuc2hpZnQoKTtcbiAgaWYgKGlzV2luZG93cykge1xuICAgIC8vIHBhcnRzIGN1cnJlbnRseSBsb29rcyBsaWtlIFsnJywgJz8nLCAnYzonLCAuLi5dXG4gICAgcGFydHMuc2hpZnQoKTtcbiAgICBjb25zdCBxID0gcGFydHMuc2hpZnQoKTsgLy8gc2hvdWxkIGJlICc/J1xuICAgIGNvbnN0IGJhc2UgPSAnXFxcXFxcXFwnICsgcSArICdcXFxcJyArIHBhcnRzLnNoaWZ0KCkudG9Mb3dlckNhc2UoKTtcbiAgICBwYXJ0cy51bnNoaWZ0KGJhc2UpO1xuICB9XG4gIGlmIChwYXJ0c1twYXJ0cy5sZW5ndGggLSAxXSA9PT0gJycpIHtcbiAgICBwYXJ0cy5wb3AoKTtcbiAgfVxuICByZXR1cm4gcGFydHM7XG59XG5cbi8qKlxuICogQ3JlYXRlIGEgbmV3IGZpbGUgc3lzdGVtLlxuICogQHBhcmFtIHtPYmplY3R9IG9wdGlvbnMgQW55IGZpbGVzeXN0ZW0gb3B0aW9ucy5cbiAqIEBwYXJhbSB7Ym9vbGVhbn0gb3B0aW9ucy5jcmVhdGVDd2QgQ3JlYXRlIGEgZGlyZWN0b3J5IGZvciBgcHJvY2Vzcy5jd2QoKWBcbiAqICAgICAoZGVmYXVsdHMgdG8gYHRydWVgKS5cbiAqIEBwYXJhbSB7Ym9vbGVhbn0gb3B0aW9ucy5jcmVhdGVUbXAgQ3JlYXRlIGEgZGlyZWN0b3J5IGZvciBgb3MudG1wZGlyKClgXG4gKiAgICAgKGRlZmF1bHRzIHRvIGB0cnVlYCkuXG4gKiBAY29uc3RydWN0b3JcbiAqL1xuZnVuY3Rpb24gRmlsZVN5c3RlbShvcHRpb25zKSB7XG4gIG9wdGlvbnMgPSBvcHRpb25zIHx8IHt9O1xuXG4gIGNvbnN0IGNyZWF0ZUN3ZCA9ICdjcmVhdGVDd2QnIGluIG9wdGlvbnMgPyBvcHRpb25zLmNyZWF0ZUN3ZCA6IHRydWU7XG4gIGNvbnN0IGNyZWF0ZVRtcCA9ICdjcmVhdGVUbXAnIGluIG9wdGlvbnMgPyBvcHRpb25zLmNyZWF0ZVRtcCA6IHRydWU7XG5cbiAgY29uc3Qgcm9vdCA9IG5ldyBEaXJlY3RvcnkoKTtcblxuICAvLyBwb3B1bGF0ZSB3aXRoIGRlZmF1bHQgZGlyZWN0b3JpZXNcbiAgY29uc3QgZGVmYXVsdHMgPSBbXTtcbiAgaWYgKGNyZWF0ZUN3ZCkge1xuICAgIGRlZmF1bHRzLnB1c2gocHJvY2Vzcy5jd2QoKSk7XG4gIH1cblxuICBpZiAoY3JlYXRlVG1wKSB7XG4gICAgZGVmYXVsdHMucHVzaCgob3MudG1wZGlyICYmIG9zLnRtcGRpcigpKSB8fCBvcy50bXBEaXIoKSk7XG4gIH1cblxuICBkZWZhdWx0cy5mb3JFYWNoKGZ1bmN0aW9uKGRpcikge1xuICAgIGNvbnN0IHBhcnRzID0gZ2V0UGF0aFBhcnRzKGRpcik7XG4gICAgbGV0IGRpcmVjdG9yeSA9IHJvb3Q7XG4gICAgZm9yIChsZXQgaSA9IDAsIGlpID0gcGFydHMubGVuZ3RoOyBpIDwgaWk7ICsraSkge1xuICAgICAgY29uc3QgbmFtZSA9IHBhcnRzW2ldO1xuICAgICAgY29uc3QgY2FuZGlkYXRlID0gZGlyZWN0b3J5LmdldEl0ZW0obmFtZSk7XG4gICAgICBpZiAoIWNhbmRpZGF0ZSkge1xuICAgICAgICBkaXJlY3RvcnkgPSBkaXJlY3RvcnkuYWRkSXRlbShuYW1lLCBuZXcgRGlyZWN0b3J5KCkpO1xuICAgICAgfSBlbHNlIGlmIChjYW5kaWRhdGUgaW5zdGFuY2VvZiBEaXJlY3RvcnkpIHtcbiAgICAgICAgZGlyZWN0b3J5ID0gY2FuZGlkYXRlO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdGYWlsZWQgdG8gY3JlYXRlIGRpcmVjdG9yeTogJyArIGRpcik7XG4gICAgICB9XG4gICAgfVxuICB9KTtcblxuICAvKipcbiAgICogUm9vdCBkaXJlY3RvcnkuXG4gICAqIEB0eXBlIHtEaXJlY3Rvcnl9XG4gICAqL1xuICB0aGlzLl9yb290ID0gcm9vdDtcbn1cblxuLyoqXG4gKiBHZXQgdGhlIHJvb3QgZGlyZWN0b3J5LlxuICogQHJldHVybiB7RGlyZWN0b3J5fSBUaGUgcm9vdCBkaXJlY3RvcnkuXG4gKi9cbkZpbGVTeXN0ZW0ucHJvdG90eXBlLmdldFJvb3QgPSBmdW5jdGlvbigpIHtcbiAgcmV0dXJuIHRoaXMuX3Jvb3Q7XG59O1xuXG4vKipcbiAqIEdldCBhIGZpbGUgc3lzdGVtIGl0ZW0uXG4gKiBAcGFyYW0ge3N0cmluZ30gZmlsZXBhdGggUGF0aCB0byBpdGVtLlxuICogQHJldHVybiB7SXRlbX0gVGhlIGl0ZW0gKG9yIG51bGwgaWYgbm90IGZvdW5kKS5cbiAqL1xuRmlsZVN5c3RlbS5wcm90b3R5cGUuZ2V0SXRlbSA9IGZ1bmN0aW9uKGZpbGVwYXRoKSB7XG4gIGNvbnN0IHBhcnRzID0gZ2V0UGF0aFBhcnRzKGZpbGVwYXRoKTtcbiAgY29uc3QgY3VycmVudFBhcnRzID0gZ2V0UGF0aFBhcnRzKHByb2Nlc3MuY3dkKCkpO1xuICBsZXQgaXRlbSA9IHRoaXMuX3Jvb3Q7XG4gIGxldCBpdGVtUGF0aCA9ICcvJztcbiAgZm9yIChsZXQgaSA9IDAsIGlpID0gcGFydHMubGVuZ3RoOyBpIDwgaWk7ICsraSkge1xuICAgIGNvbnN0IG5hbWUgPSBwYXJ0c1tpXTtcbiAgICB3aGlsZSAoaXRlbSBpbnN0YW5jZW9mIFN5bWJvbGljTGluaykge1xuICAgICAgLy8gU3ltYm9saWMgbGluayBiZWluZyB0cmF2ZXJzZWQgYXMgYSBkaXJlY3RvcnkgLS0tIElmIGxpbmsgdGFyZ2V0c1xuICAgICAgLy8gYW5vdGhlciBzeW1ib2xpYyBsaW5rLCByZXNvbHZlIHRhcmdldCdzIHBhdGggcmVsYXRpdmUgdG8gdGhlIG9yaWdpbmFsXG4gICAgICAvLyBsaW5rJ3MgdGFyZ2V0LCBvdGhlcndpc2UgcmVsYXRpdmUgdG8gdGhlIGN1cnJlbnQgaXRlbS5cbiAgICAgIGl0ZW1QYXRoID0gcGF0aC5yZXNvbHZlKHBhdGguZGlybmFtZShpdGVtUGF0aCksIGl0ZW0uZ2V0UGF0aCgpKTtcbiAgICAgIGl0ZW0gPSB0aGlzLmdldEl0ZW0oaXRlbVBhdGgpO1xuICAgIH1cbiAgICBpZiAoaXRlbSkge1xuICAgICAgaWYgKGl0ZW0gaW5zdGFuY2VvZiBEaXJlY3RvcnkgJiYgbmFtZSAhPT0gY3VycmVudFBhcnRzW2ldKSB7XG4gICAgICAgIC8vIG1ha2Ugc3VyZSB0cmF2ZXJzYWwgaXMgYWxsb3dlZFxuICAgICAgICAvLyBUaGlzIGZhaWxzIGZvciBXaW5kb3dzIGRpcmVjdG9yaWVzIHdoaWNoIGRvIG5vdCBoYXZlIGV4ZWN1dGUgcGVybWlzc2lvbiwgYnkgZGVmYXVsdC4gSXQgbWF5IGJlIGEgZ29vZCBpZGVhXG4gICAgICAgIC8vIHRvIGNoYW5nZSB0aGlzIGxvZ2ljIHRvIHdpbmRvd3MtZnJpZW5kbHkuIFNlZSBub3RlcyBpbiBtb2NrLmNyZWF0ZURpcmVjdG9yeUluZm9Gcm9tUGF0aHMoKVxuICAgICAgICBpZiAoIWl0ZW0uY2FuRXhlY3V0ZSgpKSB7XG4gICAgICAgICAgdGhyb3cgbmV3IEZTRXJyb3IoJ0VBQ0NFUycsIGZpbGVwYXRoKTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgaWYgKGl0ZW0gaW5zdGFuY2VvZiBGaWxlKSB7XG4gICAgICAgIHRocm93IG5ldyBGU0Vycm9yKCdFTk9URElSJywgZmlsZXBhdGgpO1xuICAgICAgfVxuICAgICAgaXRlbSA9IGl0ZW0uZ2V0SXRlbShuYW1lKTtcbiAgICB9XG4gICAgaWYgKCFpdGVtKSB7XG4gICAgICBicmVhaztcbiAgICB9XG4gICAgaXRlbVBhdGggPSBwYXRoLnJlc29sdmUoaXRlbVBhdGgsIG5hbWUpO1xuICB9XG4gIHJldHVybiBpdGVtO1xufTtcblxuLyoqXG4gKiBQb3B1bGF0ZSBhIGRpcmVjdG9yeSB3aXRoIGFuIGl0ZW0uXG4gKiBAcGFyYW0ge0RpcmVjdG9yeX0gZGlyZWN0b3J5IFRoZSBkaXJlY3RvcnkgdG8gcG9wdWxhdGUuXG4gKiBAcGFyYW0ge3N0cmluZ30gbmFtZSBUaGUgbmFtZSBvZiB0aGUgaXRlbS5cbiAqIEBwYXJhbSB7c3RyaW5nfEJ1ZmZlcnxmdW5jdGlvbnxPYmplY3R9IG9iaiBJbnN0cnVjdGlvbnMgZm9yIGNyZWF0aW5nIHRoZVxuICogICAgIGl0ZW0uXG4gKi9cbmZ1bmN0aW9uIHBvcHVsYXRlKGRpcmVjdG9yeSwgbmFtZSwgb2JqKSB7XG4gIGxldCBpdGVtO1xuICBpZiAodHlwZW9mIG9iaiA9PT0gJ3N0cmluZycgfHwgQnVmZmVyLmlzQnVmZmVyKG9iaikpIHtcbiAgICAvLyBjb250ZW50cyBmb3IgYSBmaWxlXG4gICAgaXRlbSA9IG5ldyBGaWxlKCk7XG4gICAgaXRlbS5zZXRDb250ZW50KG9iaik7XG4gIH0gZWxzZSBpZiAodHlwZW9mIG9iaiA9PT0gJ2Z1bmN0aW9uJykge1xuICAgIC8vIGl0ZW0gZmFjdG9yeVxuICAgIGl0ZW0gPSBvYmooKTtcbiAgfSBlbHNlIGlmICh0eXBlb2Ygb2JqID09PSAnb2JqZWN0Jykge1xuICAgIC8vIGRpcmVjdG9yeSB3aXRoIG1vcmUgdG8gcG9wdWxhdGVcbiAgICBpdGVtID0gbmV3IERpcmVjdG9yeSgpO1xuICAgIGZvciAoY29uc3Qga2V5IGluIG9iaikge1xuICAgICAgcG9wdWxhdGUoaXRlbSwga2V5LCBvYmpba2V5XSk7XG4gICAgfVxuICB9IGVsc2Uge1xuICAgIHRocm93IG5ldyBFcnJvcignVW5zdXBwb3J0ZWQgdHlwZTogJyArIHR5cGVvZiBvYmogKyAnIG9mIGl0ZW0gJyArIG5hbWUpO1xuICB9XG5cbiAgLyoqXG4gICAqIFNwZWNpYWwgZXhjZXB0aW9uIGZvciByZWR1bmRhbnQgYWRkaW5nIG9mIGVtcHR5IGRpcmVjdG9yaWVzLlxuICAgKi9cbiAgaWYgKFxuICAgIGl0ZW0gaW5zdGFuY2VvZiBEaXJlY3RvcnkgJiZcbiAgICBpdGVtLmxpc3QoKS5sZW5ndGggPT09IDAgJiZcbiAgICBkaXJlY3RvcnkuZ2V0SXRlbShuYW1lKSBpbnN0YW5jZW9mIERpcmVjdG9yeVxuICApIHtcbiAgICAvLyBwYXNzXG4gIH0gZWxzZSB7XG4gICAgZGlyZWN0b3J5LmFkZEl0ZW0obmFtZSwgaXRlbSk7XG4gIH1cbn1cblxuLyoqXG4gKiBDb25maWd1cmUgYSBtb2NrIGZpbGUgc3lzdGVtLlxuICogQHBhcmFtIHtPYmplY3R9IHBhdGhzIENvbmZpZyBvYmplY3QuXG4gKiBAcGFyYW0ge09iamVjdH0gb3B0aW9ucyBBbnkgZmlsZXN5c3RlbSBvcHRpb25zLlxuICogQHBhcmFtIHtib29sZWFufSBvcHRpb25zLmNyZWF0ZUN3ZCBDcmVhdGUgYSBkaXJlY3RvcnkgZm9yIGBwcm9jZXNzLmN3ZCgpYFxuICogICAgIChkZWZhdWx0cyB0byBgdHJ1ZWApLlxuICogQHBhcmFtIHtib29sZWFufSBvcHRpb25zLmNyZWF0ZVRtcCBDcmVhdGUgYSBkaXJlY3RvcnkgZm9yIGBvcy50bXBkaXIoKWBcbiAqICAgICAoZGVmYXVsdHMgdG8gYHRydWVgKS5cbiAqIEByZXR1cm4ge0ZpbGVTeXN0ZW19IE1vY2sgZmlsZSBzeXN0ZW0uXG4gKi9cbkZpbGVTeXN0ZW0uY3JlYXRlID0gZnVuY3Rpb24ocGF0aHMsIG9wdGlvbnMpIHtcbiAgY29uc3Qgc3lzdGVtID0gbmV3IEZpbGVTeXN0ZW0ob3B0aW9ucyk7XG5cbiAgZm9yIChjb25zdCBmaWxlcGF0aCBpbiBwYXRocykge1xuICAgIGNvbnN0IHBhcnRzID0gZ2V0UGF0aFBhcnRzKGZpbGVwYXRoKTtcbiAgICBsZXQgZGlyZWN0b3J5ID0gc3lzdGVtLl9yb290O1xuICAgIGZvciAobGV0IGkgPSAwLCBpaSA9IHBhcnRzLmxlbmd0aCAtIDE7IGkgPCBpaTsgKytpKSB7XG4gICAgICBjb25zdCBuYW1lID0gcGFydHNbaV07XG4gICAgICBjb25zdCBjYW5kaWRhdGUgPSBkaXJlY3RvcnkuZ2V0SXRlbShuYW1lKTtcbiAgICAgIGlmICghY2FuZGlkYXRlKSB7XG4gICAgICAgIGRpcmVjdG9yeSA9IGRpcmVjdG9yeS5hZGRJdGVtKG5hbWUsIG5ldyBEaXJlY3RvcnkoKSk7XG4gICAgICB9IGVsc2UgaWYgKGNhbmRpZGF0ZSBpbnN0YW5jZW9mIERpcmVjdG9yeSkge1xuICAgICAgICBkaXJlY3RvcnkgPSBjYW5kaWRhdGU7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ0ZhaWxlZCB0byBjcmVhdGUgZGlyZWN0b3J5OiAnICsgZmlsZXBhdGgpO1xuICAgICAgfVxuICAgIH1cbiAgICBwb3B1bGF0ZShkaXJlY3RvcnksIHBhcnRzW3BhcnRzLmxlbmd0aCAtIDFdLCBwYXRoc1tmaWxlcGF0aF0pO1xuICB9XG5cbiAgcmV0dXJuIHN5c3RlbTtcbn07XG5cbi8qKlxuICogR2VuZXJhdGUgYSBmYWN0b3J5IGZvciBuZXcgZmlsZXMuXG4gKiBAcGFyYW0ge09iamVjdH0gY29uZmlnIEZpbGUgY29uZmlnLlxuICogQHJldHVybiB7ZnVuY3Rpb24oKTpGaWxlfSBGYWN0b3J5IHRoYXQgY3JlYXRlcyBhIG5ldyBmaWxlLlxuICovXG5GaWxlU3lzdGVtLmZpbGUgPSBmdW5jdGlvbihjb25maWcpIHtcbiAgY29uZmlnID0gY29uZmlnIHx8IHt9O1xuICByZXR1cm4gZnVuY3Rpb24oKSB7XG4gICAgY29uc3QgZmlsZSA9IG5ldyBGaWxlKCk7XG4gICAgaWYgKGNvbmZpZy5oYXNPd25Qcm9wZXJ0eSgnY29udGVudCcpKSB7XG4gICAgICBmaWxlLnNldENvbnRlbnQoY29uZmlnLmNvbnRlbnQpO1xuICAgIH1cbiAgICBpZiAoY29uZmlnLmhhc093blByb3BlcnR5KCdtb2RlJykpIHtcbiAgICAgIGZpbGUuc2V0TW9kZShjb25maWcubW9kZSk7XG4gICAgfSBlbHNlIHtcbiAgICAgIGZpbGUuc2V0TW9kZSg0MzgpOyAvLyAwNjY2XG4gICAgfVxuICAgIGlmIChjb25maWcuaGFzT3duUHJvcGVydHkoJ3VpZCcpKSB7XG4gICAgICBmaWxlLnNldFVpZChjb25maWcudWlkKTtcbiAgICB9XG4gICAgaWYgKGNvbmZpZy5oYXNPd25Qcm9wZXJ0eSgnZ2lkJykpIHtcbiAgICAgIGZpbGUuc2V0R2lkKGNvbmZpZy5naWQpO1xuICAgIH1cbiAgICBpZiAoY29uZmlnLmhhc093blByb3BlcnR5KCdhdGltZScpKSB7XG4gICAgICBmaWxlLnNldEFUaW1lKGNvbmZpZy5hdGltZSk7XG4gICAgfVxuICAgIGlmIChjb25maWcuaGFzT3duUHJvcGVydHkoJ2N0aW1lJykpIHtcbiAgICAgIGZpbGUuc2V0Q1RpbWUoY29uZmlnLmN0aW1lKTtcbiAgICB9XG4gICAgaWYgKGNvbmZpZy5oYXNPd25Qcm9wZXJ0eSgnbXRpbWUnKSkge1xuICAgICAgZmlsZS5zZXRNVGltZShjb25maWcubXRpbWUpO1xuICAgIH1cbiAgICBpZiAoY29uZmlnLmhhc093blByb3BlcnR5KCdiaXJ0aHRpbWUnKSkge1xuICAgICAgZmlsZS5zZXRCaXJ0aHRpbWUoY29uZmlnLmJpcnRodGltZSk7XG4gICAgfVxuICAgIHJldHVybiBmaWxlO1xuICB9O1xufTtcblxuLyoqXG4gKiBHZW5lcmF0ZSBhIGZhY3RvcnkgZm9yIG5ldyBzeW1ib2xpYyBsaW5rcy5cbiAqIEBwYXJhbSB7T2JqZWN0fSBjb25maWcgRmlsZSBjb25maWcuXG4gKiBAcmV0dXJuIHtmdW5jdGlvbigpOkZpbGV9IEZhY3RvcnkgdGhhdCBjcmVhdGVzIGEgbmV3IHN5bWJvbGljIGxpbmsuXG4gKi9cbkZpbGVTeXN0ZW0uc3ltbGluayA9IGZ1bmN0aW9uKGNvbmZpZykge1xuICBjb25maWcgPSBjb25maWcgfHwge307XG4gIHJldHVybiBmdW5jdGlvbigpIHtcbiAgICBjb25zdCBsaW5rID0gbmV3IFN5bWJvbGljTGluaygpO1xuICAgIGlmIChjb25maWcuaGFzT3duUHJvcGVydHkoJ21vZGUnKSkge1xuICAgICAgbGluay5zZXRNb2RlKGNvbmZpZy5tb2RlKTtcbiAgICB9IGVsc2Uge1xuICAgICAgbGluay5zZXRNb2RlKDQzOCk7IC8vIDA2NjZcbiAgICB9XG4gICAgaWYgKGNvbmZpZy5oYXNPd25Qcm9wZXJ0eSgndWlkJykpIHtcbiAgICAgIGxpbmsuc2V0VWlkKGNvbmZpZy51aWQpO1xuICAgIH1cbiAgICBpZiAoY29uZmlnLmhhc093blByb3BlcnR5KCdnaWQnKSkge1xuICAgICAgbGluay5zZXRHaWQoY29uZmlnLmdpZCk7XG4gICAgfVxuICAgIGlmIChjb25maWcuaGFzT3duUHJvcGVydHkoJ3BhdGgnKSkge1xuICAgICAgbGluay5zZXRQYXRoKGNvbmZpZy5wYXRoKTtcbiAgICB9IGVsc2Uge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKCdNaXNzaW5nIFwicGF0aFwiIHByb3BlcnR5Jyk7XG4gICAgfVxuICAgIGlmIChjb25maWcuaGFzT3duUHJvcGVydHkoJ2F0aW1lJykpIHtcbiAgICAgIGxpbmsuc2V0QVRpbWUoY29uZmlnLmF0aW1lKTtcbiAgICB9XG4gICAgaWYgKGNvbmZpZy5oYXNPd25Qcm9wZXJ0eSgnY3RpbWUnKSkge1xuICAgICAgbGluay5zZXRDVGltZShjb25maWcuY3RpbWUpO1xuICAgIH1cbiAgICBpZiAoY29uZmlnLmhhc093blByb3BlcnR5KCdtdGltZScpKSB7XG4gICAgICBsaW5rLnNldE1UaW1lKGNvbmZpZy5tdGltZSk7XG4gICAgfVxuICAgIGlmIChjb25maWcuaGFzT3duUHJvcGVydHkoJ2JpcnRodGltZScpKSB7XG4gICAgICBsaW5rLnNldEJpcnRodGltZShjb25maWcuYmlydGh0aW1lKTtcbiAgICB9XG4gICAgcmV0dXJuIGxpbms7XG4gIH07XG59O1xuXG4vKipcbiAqIEdlbmVyYXRlIGEgZmFjdG9yeSBmb3IgbmV3IGRpcmVjdG9yaWVzLlxuICogQHBhcmFtIHtPYmplY3R9IGNvbmZpZyBGaWxlIGNvbmZpZy5cbiAqIEByZXR1cm4ge2Z1bmN0aW9uKCk6RGlyZWN0b3J5fSBGYWN0b3J5IHRoYXQgY3JlYXRlcyBhIG5ldyBkaXJlY3RvcnkuXG4gKi9cbkZpbGVTeXN0ZW0uZGlyZWN0b3J5ID0gZnVuY3Rpb24oY29uZmlnKSB7XG4gIGNvbmZpZyA9IGNvbmZpZyB8fCB7fTtcbiAgcmV0dXJuIGZ1bmN0aW9uKCkge1xuICAgIGNvbnN0IGRpciA9IG5ldyBEaXJlY3RvcnkoKTtcbiAgICBpZiAoY29uZmlnLmhhc093blByb3BlcnR5KCdtb2RlJykpIHtcbiAgICAgIGRpci5zZXRNb2RlKGNvbmZpZy5tb2RlKTtcbiAgICB9XG4gICAgaWYgKGNvbmZpZy5oYXNPd25Qcm9wZXJ0eSgndWlkJykpIHtcbiAgICAgIGRpci5zZXRVaWQoY29uZmlnLnVpZCk7XG4gICAgfVxuICAgIGlmIChjb25maWcuaGFzT3duUHJvcGVydHkoJ2dpZCcpKSB7XG4gICAgICBkaXIuc2V0R2lkKGNvbmZpZy5naWQpO1xuICAgIH1cbiAgICBpZiAoY29uZmlnLmhhc093blByb3BlcnR5KCdpdGVtcycpKSB7XG4gICAgICBmb3IgKGNvbnN0IG5hbWUgaW4gY29uZmlnLml0ZW1zKSB7XG4gICAgICAgIHBvcHVsYXRlKGRpciwgbmFtZSwgY29uZmlnLml0ZW1zW25hbWVdKTtcbiAgICAgIH1cbiAgICB9XG4gICAgaWYgKGNvbmZpZy5oYXNPd25Qcm9wZXJ0eSgnYXRpbWUnKSkge1xuICAgICAgZGlyLnNldEFUaW1lKGNvbmZpZy5hdGltZSk7XG4gICAgfVxuICAgIGlmIChjb25maWcuaGFzT3duUHJvcGVydHkoJ2N0aW1lJykpIHtcbiAgICAgIGRpci5zZXRDVGltZShjb25maWcuY3RpbWUpO1xuICAgIH1cbiAgICBpZiAoY29uZmlnLmhhc093blByb3BlcnR5KCdtdGltZScpKSB7XG4gICAgICBkaXIuc2V0TVRpbWUoY29uZmlnLm10aW1lKTtcbiAgICB9XG4gICAgaWYgKGNvbmZpZy5oYXNPd25Qcm9wZXJ0eSgnYmlydGh0aW1lJykpIHtcbiAgICAgIGRpci5zZXRCaXJ0aHRpbWUoY29uZmlnLmJpcnRodGltZSk7XG4gICAgfVxuICAgIHJldHVybiBkaXI7XG4gIH07XG59O1xuXG4vKipcbiAqIE1vZHVsZSBleHBvcnRzLlxuICogQHR5cGUge2Z1bmN0aW9ufVxuICovXG5leHBvcnRzID0gbW9kdWxlLmV4cG9ydHMgPSBGaWxlU3lzdGVtO1xuZXhwb3J0cy5nZXRQYXRoUGFydHMgPSBnZXRQYXRoUGFydHM7XG5leHBvcnRzLnRvTmFtZXNwYWNlZFBhdGggPSB0b05hbWVzcGFjZWRQYXRoO1xuIl0sIm5hbWVzIjpbXSwiaWdub3JlTGlzdCI6WzBdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/mock-fs/lib/filesystem.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/mock-fs/lib/index.js":
/*!*******************************************!*\
  !*** ./node_modules/mock-fs/lib/index.js ***!
  \*******************************************/
/***/ ((module, exports, __webpack_require__) => {

"use strict";
eval("\n\nconst Binding = __webpack_require__(/*! ./binding */ \"(ssr)/./node_modules/mock-fs/lib/binding.js\");\nconst FSError = __webpack_require__(/*! ./error */ \"(ssr)/./node_modules/mock-fs/lib/error.js\");\nconst FileSystem = __webpack_require__(/*! ./filesystem */ \"(ssr)/./node_modules/mock-fs/lib/filesystem.js\");\nconst realBinding = process.binding('fs');\nconst path = __webpack_require__(/*! path */ \"path\");\nconst loader = __webpack_require__(/*! ./loader */ \"(ssr)/./node_modules/mock-fs/lib/loader.js\");\nconst bypass = __webpack_require__(/*! ./bypass */ \"(ssr)/./node_modules/mock-fs/lib/bypass.js\");\nconst fs = __webpack_require__(/*! fs */ \"fs\");\n\nconst toNamespacedPath = FileSystem.toNamespacedPath;\n\nconst realProcessProps = {\n  cwd: process.cwd,\n  chdir: process.chdir\n};\nconst realCreateWriteStream = fs.createWriteStream;\nconst realStats = realBinding.Stats;\nconst realStatWatcher = realBinding.StatWatcher;\n\n/**\n * Pre-patch fs binding.\n * This allows mock-fs to work properly under nodejs v10+ readFile\n * As ReadFileContext nodejs v10+ implementation traps original binding methods:\n * const { FSReqWrap, close, read } = process.binding('fs');\n * Note this patch only solves issue for readFile, as the require of\n * ReadFileContext is delayed by readFile implementation.\n * if (!ReadFileContext) ReadFileContext = require('internal/fs/read_file_context')\n *\n * @param {string} key Property name.\n */\nfunction patch(key) {\n  const existingMethod = realBinding[key];\n  realBinding[key] = function() {\n    if (this._mockedBinding) {\n      return this._mockedBinding[key].apply(this._mockedBinding, arguments);\n    } else {\n      return existingMethod.apply(this, arguments);\n    }\n  }.bind(realBinding);\n}\n\nfor (const key in Binding.prototype) {\n  if (typeof realBinding[key] === 'function') {\n    // Stats and StatWatcher are constructors\n    if (key !== 'Stats' && key !== 'StatWatcher') {\n      patch(key);\n    }\n  }\n}\n\nfunction overrideBinding(binding) {\n  realBinding._mockedBinding = binding;\n}\n\nfunction overrideProcess(cwd, chdir) {\n  process.cwd = cwd;\n  process.chdir = chdir;\n}\n\n/**\n * Have to disable write stream _writev on nodejs v10+.\n *\n * nodejs v8 lib/fs.js\n * note binding.writeBuffers will use mock-fs patched writeBuffers.\n *\n *   const binding = process.binding('fs');\n *   function writev(fd, chunks, position, callback) {\n *     // ...\n *     binding.writeBuffers(fd, chunks, position, req);\n *   }\n *\n * nodejs v10+ lib/internal/fs/streams.js\n * note it uses original writeBuffers, bypassed mock-fs patched writeBuffers.\n *\n *  const {writeBuffers} = internalBinding('fs');\n *  function writev(fd, chunks, position, callback) {\n *    // ...\n *    writeBuffers(fd, chunks, position, req);\n *  }\n *\n * Luckily _writev is an optional method on Writeable stream implementation.\n * When _writev is missing, it will fall back to make multiple _write calls.\n */\nfunction overrideCreateWriteStream() {\n  fs.createWriteStream = function(path, options) {\n    const output = realCreateWriteStream(path, options);\n    // disable _writev, this will over shadow WriteStream.prototype._writev\n    if (realBinding._mockedBinding) {\n      output._writev = undefined;\n    }\n    return output;\n  };\n}\n\nfunction restoreBinding() {\n  delete realBinding._mockedBinding;\n  realBinding.Stats = realStats;\n  realBinding.StatWatcher = realStatWatcher;\n}\n\nfunction restoreProcess() {\n  for (const key in realProcessProps) {\n    process[key] = realProcessProps[key];\n  }\n}\n\nfunction restoreCreateWriteStream() {\n  fs.createWriteStream = realCreateWriteStream;\n}\n\n/**\n * Swap out the fs bindings for a mock file system.\n * @param {Object} config Mock file system configuration.\n * @param {Object} options Any filesystem options.\n * @param {boolean} options.createCwd Create a directory for `process.cwd()`\n *     (defaults to `true`).\n * @param {boolean} options.createTmp Create a directory for `os.tmpdir()`\n *     (defaults to `true`).\n */\nexports = module.exports = function mock(config, options) {\n  const system = FileSystem.create(config, options);\n  const binding = new Binding(system);\n\n  overrideBinding(binding);\n\n  let currentPath = process.cwd();\n  overrideProcess(\n    function cwd() {\n      if (realBinding._mockedBinding) {\n        return currentPath;\n      }\n      return realProcessProps.cwd();\n    },\n    function chdir(directory) {\n      if (realBinding._mockedBinding) {\n        if (!binding.stat(toNamespacedPath(directory)).isDirectory()) {\n          throw new FSError('ENOTDIR');\n        }\n        currentPath = path.resolve(currentPath, directory);\n      } else {\n        return realProcessProps.chdir(directory);\n      }\n    }\n  );\n\n  overrideCreateWriteStream();\n};\n\n/**\n * Get hold of the mocked filesystem's 'root'\n * If fs hasn't currently been replaced, this will return an empty object\n */\nexports.getMockRoot = function() {\n  if (realBinding._mockedBinding) {\n    return realBinding._mockedBinding.getSystem().getRoot();\n  } else {\n    return {};\n  }\n};\n\n/**\n * Restore the fs bindings for the real file system.\n */\nexports.restore = function() {\n  restoreBinding();\n  restoreProcess();\n  restoreCreateWriteStream();\n};\n\n/**\n * Create a file factory.\n */\nexports.file = FileSystem.file;\n\n/**\n * Create a directory factory.\n */\nexports.directory = FileSystem.directory;\n\n/**\n * Create a symbolic link factory.\n */\nexports.symlink = FileSystem.symlink;\n\n/**\n * Automatically maps specified paths (for use with `mock()`)\n */\nexports.load = loader.load;\n\n/**\n * Perform action, bypassing mock FS\n * @example\n * // This file exists on the real FS, not on the mocked FS\n * const filePath = '/path/file.json';\n * const data = mock.bypass(() => fs.readFileSync(filePath, 'utf-8'));\n */\nexports.bypass = bypass;\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvbW9jay1mcy9saWIvaW5kZXguanMiLCJtYXBwaW5ncyI6IkFBQWE7O0FBRWIsZ0JBQWdCLG1CQUFPLENBQUMsOERBQVc7QUFDbkMsZ0JBQWdCLG1CQUFPLENBQUMsMERBQVM7QUFDakMsbUJBQW1CLG1CQUFPLENBQUMsb0VBQWM7QUFDekM7QUFDQSxhQUFhLG1CQUFPLENBQUMsa0JBQU07QUFDM0IsZUFBZSxtQkFBTyxDQUFDLDREQUFVO0FBQ2pDLGVBQWUsbUJBQU8sQ0FBQyw0REFBVTtBQUNqQyxXQUFXLG1CQUFPLENBQUMsY0FBSTs7QUFFdkI7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxXQUFXLHlCQUF5QjtBQUNwQztBQUNBO0FBQ0E7QUFDQTtBQUNBLFdBQVcsUUFBUTtBQUNuQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBLEdBQUc7QUFDSDs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxXQUFXLGNBQWM7QUFDekI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLFdBQVcsUUFBUTtBQUNuQixXQUFXLFFBQVE7QUFDbkIsV0FBVyxTQUFTO0FBQ3BCO0FBQ0EsV0FBVyxTQUFTO0FBQ3BCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsUUFBUTtBQUNSO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxtQkFBbUI7QUFDbkI7QUFDQTtBQUNBLElBQUk7QUFDSjtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsZUFBZTtBQUNmO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLFlBQVk7O0FBRVo7QUFDQTtBQUNBO0FBQ0EsaUJBQWlCOztBQUVqQjtBQUNBO0FBQ0E7QUFDQSxlQUFlOztBQUVmO0FBQ0E7QUFDQTtBQUNBLFlBQVk7O0FBRVo7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxjQUFjIiwic291cmNlcyI6WyIvVXNlcnMvcGFuemEvRG9jdW1lbnRzL1BlcnNvbmFsUHJvamVjdHMvcHJlZGlrL25vZGVfbW9kdWxlcy9tb2NrLWZzL2xpYi9pbmRleC5qcyJdLCJzb3VyY2VzQ29udGVudCI6WyIndXNlIHN0cmljdCc7XG5cbmNvbnN0IEJpbmRpbmcgPSByZXF1aXJlKCcuL2JpbmRpbmcnKTtcbmNvbnN0IEZTRXJyb3IgPSByZXF1aXJlKCcuL2Vycm9yJyk7XG5jb25zdCBGaWxlU3lzdGVtID0gcmVxdWlyZSgnLi9maWxlc3lzdGVtJyk7XG5jb25zdCByZWFsQmluZGluZyA9IHByb2Nlc3MuYmluZGluZygnZnMnKTtcbmNvbnN0IHBhdGggPSByZXF1aXJlKCdwYXRoJyk7XG5jb25zdCBsb2FkZXIgPSByZXF1aXJlKCcuL2xvYWRlcicpO1xuY29uc3QgYnlwYXNzID0gcmVxdWlyZSgnLi9ieXBhc3MnKTtcbmNvbnN0IGZzID0gcmVxdWlyZSgnZnMnKTtcblxuY29uc3QgdG9OYW1lc3BhY2VkUGF0aCA9IEZpbGVTeXN0ZW0udG9OYW1lc3BhY2VkUGF0aDtcblxuY29uc3QgcmVhbFByb2Nlc3NQcm9wcyA9IHtcbiAgY3dkOiBwcm9jZXNzLmN3ZCxcbiAgY2hkaXI6IHByb2Nlc3MuY2hkaXJcbn07XG5jb25zdCByZWFsQ3JlYXRlV3JpdGVTdHJlYW0gPSBmcy5jcmVhdGVXcml0ZVN0cmVhbTtcbmNvbnN0IHJlYWxTdGF0cyA9IHJlYWxCaW5kaW5nLlN0YXRzO1xuY29uc3QgcmVhbFN0YXRXYXRjaGVyID0gcmVhbEJpbmRpbmcuU3RhdFdhdGNoZXI7XG5cbi8qKlxuICogUHJlLXBhdGNoIGZzIGJpbmRpbmcuXG4gKiBUaGlzIGFsbG93cyBtb2NrLWZzIHRvIHdvcmsgcHJvcGVybHkgdW5kZXIgbm9kZWpzIHYxMCsgcmVhZEZpbGVcbiAqIEFzIFJlYWRGaWxlQ29udGV4dCBub2RlanMgdjEwKyBpbXBsZW1lbnRhdGlvbiB0cmFwcyBvcmlnaW5hbCBiaW5kaW5nIG1ldGhvZHM6XG4gKiBjb25zdCB7IEZTUmVxV3JhcCwgY2xvc2UsIHJlYWQgfSA9IHByb2Nlc3MuYmluZGluZygnZnMnKTtcbiAqIE5vdGUgdGhpcyBwYXRjaCBvbmx5IHNvbHZlcyBpc3N1ZSBmb3IgcmVhZEZpbGUsIGFzIHRoZSByZXF1aXJlIG9mXG4gKiBSZWFkRmlsZUNvbnRleHQgaXMgZGVsYXllZCBieSByZWFkRmlsZSBpbXBsZW1lbnRhdGlvbi5cbiAqIGlmICghUmVhZEZpbGVDb250ZXh0KSBSZWFkRmlsZUNvbnRleHQgPSByZXF1aXJlKCdpbnRlcm5hbC9mcy9yZWFkX2ZpbGVfY29udGV4dCcpXG4gKlxuICogQHBhcmFtIHtzdHJpbmd9IGtleSBQcm9wZXJ0eSBuYW1lLlxuICovXG5mdW5jdGlvbiBwYXRjaChrZXkpIHtcbiAgY29uc3QgZXhpc3RpbmdNZXRob2QgPSByZWFsQmluZGluZ1trZXldO1xuICByZWFsQmluZGluZ1trZXldID0gZnVuY3Rpb24oKSB7XG4gICAgaWYgKHRoaXMuX21vY2tlZEJpbmRpbmcpIHtcbiAgICAgIHJldHVybiB0aGlzLl9tb2NrZWRCaW5kaW5nW2tleV0uYXBwbHkodGhpcy5fbW9ja2VkQmluZGluZywgYXJndW1lbnRzKTtcbiAgICB9IGVsc2Uge1xuICAgICAgcmV0dXJuIGV4aXN0aW5nTWV0aG9kLmFwcGx5KHRoaXMsIGFyZ3VtZW50cyk7XG4gICAgfVxuICB9LmJpbmQocmVhbEJpbmRpbmcpO1xufVxuXG5mb3IgKGNvbnN0IGtleSBpbiBCaW5kaW5nLnByb3RvdHlwZSkge1xuICBpZiAodHlwZW9mIHJlYWxCaW5kaW5nW2tleV0gPT09ICdmdW5jdGlvbicpIHtcbiAgICAvLyBTdGF0cyBhbmQgU3RhdFdhdGNoZXIgYXJlIGNvbnN0cnVjdG9yc1xuICAgIGlmIChrZXkgIT09ICdTdGF0cycgJiYga2V5ICE9PSAnU3RhdFdhdGNoZXInKSB7XG4gICAgICBwYXRjaChrZXkpO1xuICAgIH1cbiAgfVxufVxuXG5mdW5jdGlvbiBvdmVycmlkZUJpbmRpbmcoYmluZGluZykge1xuICByZWFsQmluZGluZy5fbW9ja2VkQmluZGluZyA9IGJpbmRpbmc7XG59XG5cbmZ1bmN0aW9uIG92ZXJyaWRlUHJvY2Vzcyhjd2QsIGNoZGlyKSB7XG4gIHByb2Nlc3MuY3dkID0gY3dkO1xuICBwcm9jZXNzLmNoZGlyID0gY2hkaXI7XG59XG5cbi8qKlxuICogSGF2ZSB0byBkaXNhYmxlIHdyaXRlIHN0cmVhbSBfd3JpdGV2IG9uIG5vZGVqcyB2MTArLlxuICpcbiAqIG5vZGVqcyB2OCBsaWIvZnMuanNcbiAqIG5vdGUgYmluZGluZy53cml0ZUJ1ZmZlcnMgd2lsbCB1c2UgbW9jay1mcyBwYXRjaGVkIHdyaXRlQnVmZmVycy5cbiAqXG4gKiAgIGNvbnN0IGJpbmRpbmcgPSBwcm9jZXNzLmJpbmRpbmcoJ2ZzJyk7XG4gKiAgIGZ1bmN0aW9uIHdyaXRldihmZCwgY2h1bmtzLCBwb3NpdGlvbiwgY2FsbGJhY2spIHtcbiAqICAgICAvLyAuLi5cbiAqICAgICBiaW5kaW5nLndyaXRlQnVmZmVycyhmZCwgY2h1bmtzLCBwb3NpdGlvbiwgcmVxKTtcbiAqICAgfVxuICpcbiAqIG5vZGVqcyB2MTArIGxpYi9pbnRlcm5hbC9mcy9zdHJlYW1zLmpzXG4gKiBub3RlIGl0IHVzZXMgb3JpZ2luYWwgd3JpdGVCdWZmZXJzLCBieXBhc3NlZCBtb2NrLWZzIHBhdGNoZWQgd3JpdGVCdWZmZXJzLlxuICpcbiAqICBjb25zdCB7d3JpdGVCdWZmZXJzfSA9IGludGVybmFsQmluZGluZygnZnMnKTtcbiAqICBmdW5jdGlvbiB3cml0ZXYoZmQsIGNodW5rcywgcG9zaXRpb24sIGNhbGxiYWNrKSB7XG4gKiAgICAvLyAuLi5cbiAqICAgIHdyaXRlQnVmZmVycyhmZCwgY2h1bmtzLCBwb3NpdGlvbiwgcmVxKTtcbiAqICB9XG4gKlxuICogTHVja2lseSBfd3JpdGV2IGlzIGFuIG9wdGlvbmFsIG1ldGhvZCBvbiBXcml0ZWFibGUgc3RyZWFtIGltcGxlbWVudGF0aW9uLlxuICogV2hlbiBfd3JpdGV2IGlzIG1pc3NpbmcsIGl0IHdpbGwgZmFsbCBiYWNrIHRvIG1ha2UgbXVsdGlwbGUgX3dyaXRlIGNhbGxzLlxuICovXG5mdW5jdGlvbiBvdmVycmlkZUNyZWF0ZVdyaXRlU3RyZWFtKCkge1xuICBmcy5jcmVhdGVXcml0ZVN0cmVhbSA9IGZ1bmN0aW9uKHBhdGgsIG9wdGlvbnMpIHtcbiAgICBjb25zdCBvdXRwdXQgPSByZWFsQ3JlYXRlV3JpdGVTdHJlYW0ocGF0aCwgb3B0aW9ucyk7XG4gICAgLy8gZGlzYWJsZSBfd3JpdGV2LCB0aGlzIHdpbGwgb3ZlciBzaGFkb3cgV3JpdGVTdHJlYW0ucHJvdG90eXBlLl93cml0ZXZcbiAgICBpZiAocmVhbEJpbmRpbmcuX21vY2tlZEJpbmRpbmcpIHtcbiAgICAgIG91dHB1dC5fd3JpdGV2ID0gdW5kZWZpbmVkO1xuICAgIH1cbiAgICByZXR1cm4gb3V0cHV0O1xuICB9O1xufVxuXG5mdW5jdGlvbiByZXN0b3JlQmluZGluZygpIHtcbiAgZGVsZXRlIHJlYWxCaW5kaW5nLl9tb2NrZWRCaW5kaW5nO1xuICByZWFsQmluZGluZy5TdGF0cyA9IHJlYWxTdGF0cztcbiAgcmVhbEJpbmRpbmcuU3RhdFdhdGNoZXIgPSByZWFsU3RhdFdhdGNoZXI7XG59XG5cbmZ1bmN0aW9uIHJlc3RvcmVQcm9jZXNzKCkge1xuICBmb3IgKGNvbnN0IGtleSBpbiByZWFsUHJvY2Vzc1Byb3BzKSB7XG4gICAgcHJvY2Vzc1trZXldID0gcmVhbFByb2Nlc3NQcm9wc1trZXldO1xuICB9XG59XG5cbmZ1bmN0aW9uIHJlc3RvcmVDcmVhdGVXcml0ZVN0cmVhbSgpIHtcbiAgZnMuY3JlYXRlV3JpdGVTdHJlYW0gPSByZWFsQ3JlYXRlV3JpdGVTdHJlYW07XG59XG5cbi8qKlxuICogU3dhcCBvdXQgdGhlIGZzIGJpbmRpbmdzIGZvciBhIG1vY2sgZmlsZSBzeXN0ZW0uXG4gKiBAcGFyYW0ge09iamVjdH0gY29uZmlnIE1vY2sgZmlsZSBzeXN0ZW0gY29uZmlndXJhdGlvbi5cbiAqIEBwYXJhbSB7T2JqZWN0fSBvcHRpb25zIEFueSBmaWxlc3lzdGVtIG9wdGlvbnMuXG4gKiBAcGFyYW0ge2Jvb2xlYW59IG9wdGlvbnMuY3JlYXRlQ3dkIENyZWF0ZSBhIGRpcmVjdG9yeSBmb3IgYHByb2Nlc3MuY3dkKClgXG4gKiAgICAgKGRlZmF1bHRzIHRvIGB0cnVlYCkuXG4gKiBAcGFyYW0ge2Jvb2xlYW59IG9wdGlvbnMuY3JlYXRlVG1wIENyZWF0ZSBhIGRpcmVjdG9yeSBmb3IgYG9zLnRtcGRpcigpYFxuICogICAgIChkZWZhdWx0cyB0byBgdHJ1ZWApLlxuICovXG5leHBvcnRzID0gbW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbiBtb2NrKGNvbmZpZywgb3B0aW9ucykge1xuICBjb25zdCBzeXN0ZW0gPSBGaWxlU3lzdGVtLmNyZWF0ZShjb25maWcsIG9wdGlvbnMpO1xuICBjb25zdCBiaW5kaW5nID0gbmV3IEJpbmRpbmcoc3lzdGVtKTtcblxuICBvdmVycmlkZUJpbmRpbmcoYmluZGluZyk7XG5cbiAgbGV0IGN1cnJlbnRQYXRoID0gcHJvY2Vzcy5jd2QoKTtcbiAgb3ZlcnJpZGVQcm9jZXNzKFxuICAgIGZ1bmN0aW9uIGN3ZCgpIHtcbiAgICAgIGlmIChyZWFsQmluZGluZy5fbW9ja2VkQmluZGluZykge1xuICAgICAgICByZXR1cm4gY3VycmVudFBhdGg7XG4gICAgICB9XG4gICAgICByZXR1cm4gcmVhbFByb2Nlc3NQcm9wcy5jd2QoKTtcbiAgICB9LFxuICAgIGZ1bmN0aW9uIGNoZGlyKGRpcmVjdG9yeSkge1xuICAgICAgaWYgKHJlYWxCaW5kaW5nLl9tb2NrZWRCaW5kaW5nKSB7XG4gICAgICAgIGlmICghYmluZGluZy5zdGF0KHRvTmFtZXNwYWNlZFBhdGgoZGlyZWN0b3J5KSkuaXNEaXJlY3RvcnkoKSkge1xuICAgICAgICAgIHRocm93IG5ldyBGU0Vycm9yKCdFTk9URElSJyk7XG4gICAgICAgIH1cbiAgICAgICAgY3VycmVudFBhdGggPSBwYXRoLnJlc29sdmUoY3VycmVudFBhdGgsIGRpcmVjdG9yeSk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICByZXR1cm4gcmVhbFByb2Nlc3NQcm9wcy5jaGRpcihkaXJlY3RvcnkpO1xuICAgICAgfVxuICAgIH1cbiAgKTtcblxuICBvdmVycmlkZUNyZWF0ZVdyaXRlU3RyZWFtKCk7XG59O1xuXG4vKipcbiAqIEdldCBob2xkIG9mIHRoZSBtb2NrZWQgZmlsZXN5c3RlbSdzICdyb290J1xuICogSWYgZnMgaGFzbid0IGN1cnJlbnRseSBiZWVuIHJlcGxhY2VkLCB0aGlzIHdpbGwgcmV0dXJuIGFuIGVtcHR5IG9iamVjdFxuICovXG5leHBvcnRzLmdldE1vY2tSb290ID0gZnVuY3Rpb24oKSB7XG4gIGlmIChyZWFsQmluZGluZy5fbW9ja2VkQmluZGluZykge1xuICAgIHJldHVybiByZWFsQmluZGluZy5fbW9ja2VkQmluZGluZy5nZXRTeXN0ZW0oKS5nZXRSb290KCk7XG4gIH0gZWxzZSB7XG4gICAgcmV0dXJuIHt9O1xuICB9XG59O1xuXG4vKipcbiAqIFJlc3RvcmUgdGhlIGZzIGJpbmRpbmdzIGZvciB0aGUgcmVhbCBmaWxlIHN5c3RlbS5cbiAqL1xuZXhwb3J0cy5yZXN0b3JlID0gZnVuY3Rpb24oKSB7XG4gIHJlc3RvcmVCaW5kaW5nKCk7XG4gIHJlc3RvcmVQcm9jZXNzKCk7XG4gIHJlc3RvcmVDcmVhdGVXcml0ZVN0cmVhbSgpO1xufTtcblxuLyoqXG4gKiBDcmVhdGUgYSBmaWxlIGZhY3RvcnkuXG4gKi9cbmV4cG9ydHMuZmlsZSA9IEZpbGVTeXN0ZW0uZmlsZTtcblxuLyoqXG4gKiBDcmVhdGUgYSBkaXJlY3RvcnkgZmFjdG9yeS5cbiAqL1xuZXhwb3J0cy5kaXJlY3RvcnkgPSBGaWxlU3lzdGVtLmRpcmVjdG9yeTtcblxuLyoqXG4gKiBDcmVhdGUgYSBzeW1ib2xpYyBsaW5rIGZhY3RvcnkuXG4gKi9cbmV4cG9ydHMuc3ltbGluayA9IEZpbGVTeXN0ZW0uc3ltbGluaztcblxuLyoqXG4gKiBBdXRvbWF0aWNhbGx5IG1hcHMgc3BlY2lmaWVkIHBhdGhzIChmb3IgdXNlIHdpdGggYG1vY2soKWApXG4gKi9cbmV4cG9ydHMubG9hZCA9IGxvYWRlci5sb2FkO1xuXG4vKipcbiAqIFBlcmZvcm0gYWN0aW9uLCBieXBhc3NpbmcgbW9jayBGU1xuICogQGV4YW1wbGVcbiAqIC8vIFRoaXMgZmlsZSBleGlzdHMgb24gdGhlIHJlYWwgRlMsIG5vdCBvbiB0aGUgbW9ja2VkIEZTXG4gKiBjb25zdCBmaWxlUGF0aCA9ICcvcGF0aC9maWxlLmpzb24nO1xuICogY29uc3QgZGF0YSA9IG1vY2suYnlwYXNzKCgpID0+IGZzLnJlYWRGaWxlU3luYyhmaWxlUGF0aCwgJ3V0Zi04JykpO1xuICovXG5leHBvcnRzLmJ5cGFzcyA9IGJ5cGFzcztcbiJdLCJuYW1lcyI6W10sImlnbm9yZUxpc3QiOlswXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/mock-fs/lib/index.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/mock-fs/lib/item.js":
/*!******************************************!*\
  !*** ./node_modules/mock-fs/lib/item.js ***!
  \******************************************/
/***/ ((module, exports) => {

"use strict";
eval("\n\nlet counter = 0;\n\n/**\n * Permissions.\n * @enum {number}\n */\nconst permissions = {\n  USER_READ: 256, // 0400\n  USER_WRITE: 128, // 0200\n  USER_EXEC: 64, // 0100\n  GROUP_READ: 32, // 0040\n  GROUP_WRITE: 16, // 0020\n  GROUP_EXEC: 8, // 0010\n  OTHER_READ: 4, // 0004\n  OTHER_WRITE: 2, // 0002\n  OTHER_EXEC: 1 // 0001\n};\n\nfunction getUid() {\n  // force NaN on windows.\n  return process.getuid ? process.getuid() : NaN;\n}\n\nfunction getGid() {\n  // force NaN on windows.\n  return process.getgid ? process.getgid() : NaN;\n}\n\n/**\n * A filesystem item.\n * @constructor\n */\nfunction Item() {\n  const now = Date.now();\n\n  /**\n   * Access time.\n   * @type {Date}\n   */\n  this._atime = new Date(now);\n\n  /**\n   * Change time.\n   * @type {Date}\n   */\n  this._ctime = new Date(now);\n\n  /**\n   * Birth time.\n   * @type {Date}\n   */\n  this._birthtime = new Date(now);\n\n  /**\n   * Modification time.\n   * @type {Date}\n   */\n  this._mtime = new Date(now);\n\n  /**\n   * Permissions.\n   */\n  this._mode = 438; // 0666\n\n  /**\n   * User id.\n   * @type {number}\n   */\n  this._uid = getUid();\n\n  /**\n   * Group id.\n   * @type {number}\n   */\n  this._gid = getGid();\n\n  /**\n   * Item number.\n   * @type {number}\n   */\n  this._id = ++counter;\n\n  /**\n   * Number of links to this item.\n   */\n  this.links = 0;\n}\n\n/**\n * Add execute if read allowed\n * See notes in index.js -> mapping#addDir\n */\nItem.fixWin32Permissions = mode =>\n  process.platform !== 'win32'\n    ? mode\n    : mode |\n      (mode & permissions.USER_READ && permissions.USER_EXEC) |\n      (mode & permissions.GROUP_READ && permissions.GROUP_EXEC) |\n      (mode & permissions.OTHER_READ && permissions.OTHER_EXEC);\n\n/**\n * Determine if the current user has read permission.\n * @return {boolean} The current user can read.\n */\nItem.prototype.canRead = function() {\n  const uid = getUid();\n  const gid = getGid();\n  let can = false;\n  if (uid === 0) {\n    can = true;\n  } else if (uid === this._uid || uid !== uid) {\n    // (uid !== uid) means uid is NaN, only for windows\n    can = (permissions.USER_READ & this._mode) === permissions.USER_READ;\n  } else if (gid === this._gid) {\n    can = (permissions.GROUP_READ & this._mode) === permissions.GROUP_READ;\n  } else {\n    can = (permissions.OTHER_READ & this._mode) === permissions.OTHER_READ;\n  }\n  return can;\n};\n\n/**\n * Determine if the current user has write permission.\n * @return {boolean} The current user can write.\n */\nItem.prototype.canWrite = function() {\n  const uid = getUid();\n  const gid = getGid();\n  let can = false;\n  if (uid === 0) {\n    can = true;\n  } else if (uid === this._uid || uid !== uid) {\n    // (uid !== uid) means uid is NaN, only for windows\n    can = (permissions.USER_WRITE & this._mode) === permissions.USER_WRITE;\n  } else if (gid === this._gid) {\n    can = (permissions.GROUP_WRITE & this._mode) === permissions.GROUP_WRITE;\n  } else {\n    can = (permissions.OTHER_WRITE & this._mode) === permissions.OTHER_WRITE;\n  }\n  return can;\n};\n\n/**\n * Determine if the current user has execute permission.\n * @return {boolean} The current user can execute.\n */\nItem.prototype.canExecute = function() {\n  const uid = getUid();\n  const gid = getGid();\n  let can = false;\n  if (uid === 0) {\n    can = true;\n  } else if (uid === this._uid || isNaN(uid)) {\n    // NaN occurs on windows\n    can = (permissions.USER_EXEC & this._mode) === permissions.USER_EXEC;\n  } else if (gid === this._gid) {\n    can = (permissions.GROUP_EXEC & this._mode) === permissions.GROUP_EXEC;\n  } else {\n    can = (permissions.OTHER_EXEC & this._mode) === permissions.OTHER_EXEC;\n  }\n  return can;\n};\n\n/**\n * Get access time.\n * @return {Date} Access time.\n */\nItem.prototype.getATime = function() {\n  return this._atime;\n};\n\n/**\n * Set access time.\n * @param {Date} atime Access time.\n */\nItem.prototype.setATime = function(atime) {\n  this._atime = atime;\n};\n\n/**\n * Get change time.\n * @return {Date} Change time.\n */\nItem.prototype.getCTime = function() {\n  return this._ctime;\n};\n\n/**\n * Set change time.\n * @param {Date} ctime Change time.\n */\nItem.prototype.setCTime = function(ctime) {\n  this._ctime = ctime;\n};\n\n/**\n * Get birth time.\n * @return {Date} Birth time.\n */\nItem.prototype.getBirthtime = function() {\n  return this._birthtime;\n};\n\n/**\n * Set change time.\n * @param {Date} birthtime Birth time.\n */\nItem.prototype.setBirthtime = function(birthtime) {\n  this._birthtime = birthtime;\n};\n\n/**\n * Get modification time.\n * @return {Date} Modification time.\n */\nItem.prototype.getMTime = function() {\n  return this._mtime;\n};\n\n/**\n * Set modification time.\n * @param {Date} mtime Modification time.\n */\nItem.prototype.setMTime = function(mtime) {\n  this._mtime = mtime;\n};\n\n/**\n * Get mode (permission only, e.g 0666).\n * @return {number} Mode.\n */\nItem.prototype.getMode = function() {\n  return this._mode;\n};\n\n/**\n * Set mode (permission only, e.g 0666).\n * @param {Date} mode Mode.\n */\nItem.prototype.setMode = function(mode) {\n  this.setCTime(new Date());\n  this._mode = mode;\n};\n\n/**\n * Get user id.\n * @return {number} User id.\n */\nItem.prototype.getUid = function() {\n  return this._uid;\n};\n\n/**\n * Set user id.\n * @param {number} uid User id.\n */\nItem.prototype.setUid = function(uid) {\n  this.setCTime(new Date());\n  this._uid = uid;\n};\n\n/**\n * Get group id.\n * @return {number} Group id.\n */\nItem.prototype.getGid = function() {\n  return this._gid;\n};\n\n/**\n * Set group id.\n * @param {number} gid Group id.\n */\nItem.prototype.setGid = function(gid) {\n  this.setCTime(new Date());\n  this._gid = gid;\n};\n\n/**\n * Get item stats.\n * @return {Object} Stats properties.\n */\nItem.prototype.getStats = function() {\n  return {\n    dev: 8675309,\n    nlink: this.links,\n    uid: this.getUid(),\n    gid: this.getGid(),\n    rdev: 0,\n    blksize: 4096,\n    ino: this._id,\n    atime: this.getATime(),\n    mtime: this.getMTime(),\n    ctime: this.getCTime(),\n    birthtime: this.getBirthtime(),\n    atimeMs: +this.getATime(),\n    mtimeMs: +this.getMTime(),\n    ctimeMs: +this.getCTime(),\n    birthtimeMs: +this.getBirthtime()\n  };\n};\n\n/**\n * Get the item's string representation.\n * @return {string} String representation.\n */\nItem.prototype.toString = function() {\n  return '[' + this.constructor.name + ']';\n};\n\n/**\n * Export the constructor.\n * @type {function()}\n */\nexports = module.exports = Item;\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvbW9jay1mcy9saWIvaXRlbS5qcyIsIm1hcHBpbmdzIjoiQUFBYTs7QUFFYjs7QUFFQTtBQUNBO0FBQ0EsVUFBVTtBQUNWO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLFlBQVk7QUFDWjtBQUNBOztBQUVBO0FBQ0E7QUFDQSxZQUFZO0FBQ1o7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsWUFBWTtBQUNaO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLFlBQVk7QUFDWjtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLG9CQUFvQjs7QUFFcEI7QUFDQTtBQUNBLFlBQVk7QUFDWjtBQUNBOztBQUVBO0FBQ0E7QUFDQSxZQUFZO0FBQ1o7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsWUFBWTtBQUNaO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxZQUFZLFNBQVM7QUFDckI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxJQUFJO0FBQ0o7QUFDQTtBQUNBLElBQUk7QUFDSjtBQUNBLElBQUk7QUFDSjtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsWUFBWSxTQUFTO0FBQ3JCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsSUFBSTtBQUNKO0FBQ0E7QUFDQSxJQUFJO0FBQ0o7QUFDQSxJQUFJO0FBQ0o7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLFlBQVksU0FBUztBQUNyQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLElBQUk7QUFDSjtBQUNBO0FBQ0EsSUFBSTtBQUNKO0FBQ0EsSUFBSTtBQUNKO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxZQUFZLE1BQU07QUFDbEI7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLFdBQVcsTUFBTTtBQUNqQjtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsWUFBWSxNQUFNO0FBQ2xCO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxXQUFXLE1BQU07QUFDakI7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLFlBQVksTUFBTTtBQUNsQjtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsV0FBVyxNQUFNO0FBQ2pCO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxZQUFZLE1BQU07QUFDbEI7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLFdBQVcsTUFBTTtBQUNqQjtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsWUFBWSxRQUFRO0FBQ3BCO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxXQUFXLE1BQU07QUFDakI7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsWUFBWSxRQUFRO0FBQ3BCO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxXQUFXLFFBQVE7QUFDbkI7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsWUFBWSxRQUFRO0FBQ3BCO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxXQUFXLFFBQVE7QUFDbkI7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsWUFBWSxRQUFRO0FBQ3BCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLFlBQVksUUFBUTtBQUNwQjtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsVUFBVTtBQUNWO0FBQ0EiLCJzb3VyY2VzIjpbIi9Vc2Vycy9wYW56YS9Eb2N1bWVudHMvUGVyc29uYWxQcm9qZWN0cy9wcmVkaWsvbm9kZV9tb2R1bGVzL21vY2stZnMvbGliL2l0ZW0uanMiXSwic291cmNlc0NvbnRlbnQiOlsiJ3VzZSBzdHJpY3QnO1xuXG5sZXQgY291bnRlciA9IDA7XG5cbi8qKlxuICogUGVybWlzc2lvbnMuXG4gKiBAZW51bSB7bnVtYmVyfVxuICovXG5jb25zdCBwZXJtaXNzaW9ucyA9IHtcbiAgVVNFUl9SRUFEOiAyNTYsIC8vIDA0MDBcbiAgVVNFUl9XUklURTogMTI4LCAvLyAwMjAwXG4gIFVTRVJfRVhFQzogNjQsIC8vIDAxMDBcbiAgR1JPVVBfUkVBRDogMzIsIC8vIDAwNDBcbiAgR1JPVVBfV1JJVEU6IDE2LCAvLyAwMDIwXG4gIEdST1VQX0VYRUM6IDgsIC8vIDAwMTBcbiAgT1RIRVJfUkVBRDogNCwgLy8gMDAwNFxuICBPVEhFUl9XUklURTogMiwgLy8gMDAwMlxuICBPVEhFUl9FWEVDOiAxIC8vIDAwMDFcbn07XG5cbmZ1bmN0aW9uIGdldFVpZCgpIHtcbiAgLy8gZm9yY2UgTmFOIG9uIHdpbmRvd3MuXG4gIHJldHVybiBwcm9jZXNzLmdldHVpZCA/IHByb2Nlc3MuZ2V0dWlkKCkgOiBOYU47XG59XG5cbmZ1bmN0aW9uIGdldEdpZCgpIHtcbiAgLy8gZm9yY2UgTmFOIG9uIHdpbmRvd3MuXG4gIHJldHVybiBwcm9jZXNzLmdldGdpZCA/IHByb2Nlc3MuZ2V0Z2lkKCkgOiBOYU47XG59XG5cbi8qKlxuICogQSBmaWxlc3lzdGVtIGl0ZW0uXG4gKiBAY29uc3RydWN0b3JcbiAqL1xuZnVuY3Rpb24gSXRlbSgpIHtcbiAgY29uc3Qgbm93ID0gRGF0ZS5ub3coKTtcblxuICAvKipcbiAgICogQWNjZXNzIHRpbWUuXG4gICAqIEB0eXBlIHtEYXRlfVxuICAgKi9cbiAgdGhpcy5fYXRpbWUgPSBuZXcgRGF0ZShub3cpO1xuXG4gIC8qKlxuICAgKiBDaGFuZ2UgdGltZS5cbiAgICogQHR5cGUge0RhdGV9XG4gICAqL1xuICB0aGlzLl9jdGltZSA9IG5ldyBEYXRlKG5vdyk7XG5cbiAgLyoqXG4gICAqIEJpcnRoIHRpbWUuXG4gICAqIEB0eXBlIHtEYXRlfVxuICAgKi9cbiAgdGhpcy5fYmlydGh0aW1lID0gbmV3IERhdGUobm93KTtcblxuICAvKipcbiAgICogTW9kaWZpY2F0aW9uIHRpbWUuXG4gICAqIEB0eXBlIHtEYXRlfVxuICAgKi9cbiAgdGhpcy5fbXRpbWUgPSBuZXcgRGF0ZShub3cpO1xuXG4gIC8qKlxuICAgKiBQZXJtaXNzaW9ucy5cbiAgICovXG4gIHRoaXMuX21vZGUgPSA0Mzg7IC8vIDA2NjZcblxuICAvKipcbiAgICogVXNlciBpZC5cbiAgICogQHR5cGUge251bWJlcn1cbiAgICovXG4gIHRoaXMuX3VpZCA9IGdldFVpZCgpO1xuXG4gIC8qKlxuICAgKiBHcm91cCBpZC5cbiAgICogQHR5cGUge251bWJlcn1cbiAgICovXG4gIHRoaXMuX2dpZCA9IGdldEdpZCgpO1xuXG4gIC8qKlxuICAgKiBJdGVtIG51bWJlci5cbiAgICogQHR5cGUge251bWJlcn1cbiAgICovXG4gIHRoaXMuX2lkID0gKytjb3VudGVyO1xuXG4gIC8qKlxuICAgKiBOdW1iZXIgb2YgbGlua3MgdG8gdGhpcyBpdGVtLlxuICAgKi9cbiAgdGhpcy5saW5rcyA9IDA7XG59XG5cbi8qKlxuICogQWRkIGV4ZWN1dGUgaWYgcmVhZCBhbGxvd2VkXG4gKiBTZWUgbm90ZXMgaW4gaW5kZXguanMgLT4gbWFwcGluZyNhZGREaXJcbiAqL1xuSXRlbS5maXhXaW4zMlBlcm1pc3Npb25zID0gbW9kZSA9PlxuICBwcm9jZXNzLnBsYXRmb3JtICE9PSAnd2luMzInXG4gICAgPyBtb2RlXG4gICAgOiBtb2RlIHxcbiAgICAgIChtb2RlICYgcGVybWlzc2lvbnMuVVNFUl9SRUFEICYmIHBlcm1pc3Npb25zLlVTRVJfRVhFQykgfFxuICAgICAgKG1vZGUgJiBwZXJtaXNzaW9ucy5HUk9VUF9SRUFEICYmIHBlcm1pc3Npb25zLkdST1VQX0VYRUMpIHxcbiAgICAgIChtb2RlICYgcGVybWlzc2lvbnMuT1RIRVJfUkVBRCAmJiBwZXJtaXNzaW9ucy5PVEhFUl9FWEVDKTtcblxuLyoqXG4gKiBEZXRlcm1pbmUgaWYgdGhlIGN1cnJlbnQgdXNlciBoYXMgcmVhZCBwZXJtaXNzaW9uLlxuICogQHJldHVybiB7Ym9vbGVhbn0gVGhlIGN1cnJlbnQgdXNlciBjYW4gcmVhZC5cbiAqL1xuSXRlbS5wcm90b3R5cGUuY2FuUmVhZCA9IGZ1bmN0aW9uKCkge1xuICBjb25zdCB1aWQgPSBnZXRVaWQoKTtcbiAgY29uc3QgZ2lkID0gZ2V0R2lkKCk7XG4gIGxldCBjYW4gPSBmYWxzZTtcbiAgaWYgKHVpZCA9PT0gMCkge1xuICAgIGNhbiA9IHRydWU7XG4gIH0gZWxzZSBpZiAodWlkID09PSB0aGlzLl91aWQgfHwgdWlkICE9PSB1aWQpIHtcbiAgICAvLyAodWlkICE9PSB1aWQpIG1lYW5zIHVpZCBpcyBOYU4sIG9ubHkgZm9yIHdpbmRvd3NcbiAgICBjYW4gPSAocGVybWlzc2lvbnMuVVNFUl9SRUFEICYgdGhpcy5fbW9kZSkgPT09IHBlcm1pc3Npb25zLlVTRVJfUkVBRDtcbiAgfSBlbHNlIGlmIChnaWQgPT09IHRoaXMuX2dpZCkge1xuICAgIGNhbiA9IChwZXJtaXNzaW9ucy5HUk9VUF9SRUFEICYgdGhpcy5fbW9kZSkgPT09IHBlcm1pc3Npb25zLkdST1VQX1JFQUQ7XG4gIH0gZWxzZSB7XG4gICAgY2FuID0gKHBlcm1pc3Npb25zLk9USEVSX1JFQUQgJiB0aGlzLl9tb2RlKSA9PT0gcGVybWlzc2lvbnMuT1RIRVJfUkVBRDtcbiAgfVxuICByZXR1cm4gY2FuO1xufTtcblxuLyoqXG4gKiBEZXRlcm1pbmUgaWYgdGhlIGN1cnJlbnQgdXNlciBoYXMgd3JpdGUgcGVybWlzc2lvbi5cbiAqIEByZXR1cm4ge2Jvb2xlYW59IFRoZSBjdXJyZW50IHVzZXIgY2FuIHdyaXRlLlxuICovXG5JdGVtLnByb3RvdHlwZS5jYW5Xcml0ZSA9IGZ1bmN0aW9uKCkge1xuICBjb25zdCB1aWQgPSBnZXRVaWQoKTtcbiAgY29uc3QgZ2lkID0gZ2V0R2lkKCk7XG4gIGxldCBjYW4gPSBmYWxzZTtcbiAgaWYgKHVpZCA9PT0gMCkge1xuICAgIGNhbiA9IHRydWU7XG4gIH0gZWxzZSBpZiAodWlkID09PSB0aGlzLl91aWQgfHwgdWlkICE9PSB1aWQpIHtcbiAgICAvLyAodWlkICE9PSB1aWQpIG1lYW5zIHVpZCBpcyBOYU4sIG9ubHkgZm9yIHdpbmRvd3NcbiAgICBjYW4gPSAocGVybWlzc2lvbnMuVVNFUl9XUklURSAmIHRoaXMuX21vZGUpID09PSBwZXJtaXNzaW9ucy5VU0VSX1dSSVRFO1xuICB9IGVsc2UgaWYgKGdpZCA9PT0gdGhpcy5fZ2lkKSB7XG4gICAgY2FuID0gKHBlcm1pc3Npb25zLkdST1VQX1dSSVRFICYgdGhpcy5fbW9kZSkgPT09IHBlcm1pc3Npb25zLkdST1VQX1dSSVRFO1xuICB9IGVsc2Uge1xuICAgIGNhbiA9IChwZXJtaXNzaW9ucy5PVEhFUl9XUklURSAmIHRoaXMuX21vZGUpID09PSBwZXJtaXNzaW9ucy5PVEhFUl9XUklURTtcbiAgfVxuICByZXR1cm4gY2FuO1xufTtcblxuLyoqXG4gKiBEZXRlcm1pbmUgaWYgdGhlIGN1cnJlbnQgdXNlciBoYXMgZXhlY3V0ZSBwZXJtaXNzaW9uLlxuICogQHJldHVybiB7Ym9vbGVhbn0gVGhlIGN1cnJlbnQgdXNlciBjYW4gZXhlY3V0ZS5cbiAqL1xuSXRlbS5wcm90b3R5cGUuY2FuRXhlY3V0ZSA9IGZ1bmN0aW9uKCkge1xuICBjb25zdCB1aWQgPSBnZXRVaWQoKTtcbiAgY29uc3QgZ2lkID0gZ2V0R2lkKCk7XG4gIGxldCBjYW4gPSBmYWxzZTtcbiAgaWYgKHVpZCA9PT0gMCkge1xuICAgIGNhbiA9IHRydWU7XG4gIH0gZWxzZSBpZiAodWlkID09PSB0aGlzLl91aWQgfHwgaXNOYU4odWlkKSkge1xuICAgIC8vIE5hTiBvY2N1cnMgb24gd2luZG93c1xuICAgIGNhbiA9IChwZXJtaXNzaW9ucy5VU0VSX0VYRUMgJiB0aGlzLl9tb2RlKSA9PT0gcGVybWlzc2lvbnMuVVNFUl9FWEVDO1xuICB9IGVsc2UgaWYgKGdpZCA9PT0gdGhpcy5fZ2lkKSB7XG4gICAgY2FuID0gKHBlcm1pc3Npb25zLkdST1VQX0VYRUMgJiB0aGlzLl9tb2RlKSA9PT0gcGVybWlzc2lvbnMuR1JPVVBfRVhFQztcbiAgfSBlbHNlIHtcbiAgICBjYW4gPSAocGVybWlzc2lvbnMuT1RIRVJfRVhFQyAmIHRoaXMuX21vZGUpID09PSBwZXJtaXNzaW9ucy5PVEhFUl9FWEVDO1xuICB9XG4gIHJldHVybiBjYW47XG59O1xuXG4vKipcbiAqIEdldCBhY2Nlc3MgdGltZS5cbiAqIEByZXR1cm4ge0RhdGV9IEFjY2VzcyB0aW1lLlxuICovXG5JdGVtLnByb3RvdHlwZS5nZXRBVGltZSA9IGZ1bmN0aW9uKCkge1xuICByZXR1cm4gdGhpcy5fYXRpbWU7XG59O1xuXG4vKipcbiAqIFNldCBhY2Nlc3MgdGltZS5cbiAqIEBwYXJhbSB7RGF0ZX0gYXRpbWUgQWNjZXNzIHRpbWUuXG4gKi9cbkl0ZW0ucHJvdG90eXBlLnNldEFUaW1lID0gZnVuY3Rpb24oYXRpbWUpIHtcbiAgdGhpcy5fYXRpbWUgPSBhdGltZTtcbn07XG5cbi8qKlxuICogR2V0IGNoYW5nZSB0aW1lLlxuICogQHJldHVybiB7RGF0ZX0gQ2hhbmdlIHRpbWUuXG4gKi9cbkl0ZW0ucHJvdG90eXBlLmdldENUaW1lID0gZnVuY3Rpb24oKSB7XG4gIHJldHVybiB0aGlzLl9jdGltZTtcbn07XG5cbi8qKlxuICogU2V0IGNoYW5nZSB0aW1lLlxuICogQHBhcmFtIHtEYXRlfSBjdGltZSBDaGFuZ2UgdGltZS5cbiAqL1xuSXRlbS5wcm90b3R5cGUuc2V0Q1RpbWUgPSBmdW5jdGlvbihjdGltZSkge1xuICB0aGlzLl9jdGltZSA9IGN0aW1lO1xufTtcblxuLyoqXG4gKiBHZXQgYmlydGggdGltZS5cbiAqIEByZXR1cm4ge0RhdGV9IEJpcnRoIHRpbWUuXG4gKi9cbkl0ZW0ucHJvdG90eXBlLmdldEJpcnRodGltZSA9IGZ1bmN0aW9uKCkge1xuICByZXR1cm4gdGhpcy5fYmlydGh0aW1lO1xufTtcblxuLyoqXG4gKiBTZXQgY2hhbmdlIHRpbWUuXG4gKiBAcGFyYW0ge0RhdGV9IGJpcnRodGltZSBCaXJ0aCB0aW1lLlxuICovXG5JdGVtLnByb3RvdHlwZS5zZXRCaXJ0aHRpbWUgPSBmdW5jdGlvbihiaXJ0aHRpbWUpIHtcbiAgdGhpcy5fYmlydGh0aW1lID0gYmlydGh0aW1lO1xufTtcblxuLyoqXG4gKiBHZXQgbW9kaWZpY2F0aW9uIHRpbWUuXG4gKiBAcmV0dXJuIHtEYXRlfSBNb2RpZmljYXRpb24gdGltZS5cbiAqL1xuSXRlbS5wcm90b3R5cGUuZ2V0TVRpbWUgPSBmdW5jdGlvbigpIHtcbiAgcmV0dXJuIHRoaXMuX210aW1lO1xufTtcblxuLyoqXG4gKiBTZXQgbW9kaWZpY2F0aW9uIHRpbWUuXG4gKiBAcGFyYW0ge0RhdGV9IG10aW1lIE1vZGlmaWNhdGlvbiB0aW1lLlxuICovXG5JdGVtLnByb3RvdHlwZS5zZXRNVGltZSA9IGZ1bmN0aW9uKG10aW1lKSB7XG4gIHRoaXMuX210aW1lID0gbXRpbWU7XG59O1xuXG4vKipcbiAqIEdldCBtb2RlIChwZXJtaXNzaW9uIG9ubHksIGUuZyAwNjY2KS5cbiAqIEByZXR1cm4ge251bWJlcn0gTW9kZS5cbiAqL1xuSXRlbS5wcm90b3R5cGUuZ2V0TW9kZSA9IGZ1bmN0aW9uKCkge1xuICByZXR1cm4gdGhpcy5fbW9kZTtcbn07XG5cbi8qKlxuICogU2V0IG1vZGUgKHBlcm1pc3Npb24gb25seSwgZS5nIDA2NjYpLlxuICogQHBhcmFtIHtEYXRlfSBtb2RlIE1vZGUuXG4gKi9cbkl0ZW0ucHJvdG90eXBlLnNldE1vZGUgPSBmdW5jdGlvbihtb2RlKSB7XG4gIHRoaXMuc2V0Q1RpbWUobmV3IERhdGUoKSk7XG4gIHRoaXMuX21vZGUgPSBtb2RlO1xufTtcblxuLyoqXG4gKiBHZXQgdXNlciBpZC5cbiAqIEByZXR1cm4ge251bWJlcn0gVXNlciBpZC5cbiAqL1xuSXRlbS5wcm90b3R5cGUuZ2V0VWlkID0gZnVuY3Rpb24oKSB7XG4gIHJldHVybiB0aGlzLl91aWQ7XG59O1xuXG4vKipcbiAqIFNldCB1c2VyIGlkLlxuICogQHBhcmFtIHtudW1iZXJ9IHVpZCBVc2VyIGlkLlxuICovXG5JdGVtLnByb3RvdHlwZS5zZXRVaWQgPSBmdW5jdGlvbih1aWQpIHtcbiAgdGhpcy5zZXRDVGltZShuZXcgRGF0ZSgpKTtcbiAgdGhpcy5fdWlkID0gdWlkO1xufTtcblxuLyoqXG4gKiBHZXQgZ3JvdXAgaWQuXG4gKiBAcmV0dXJuIHtudW1iZXJ9IEdyb3VwIGlkLlxuICovXG5JdGVtLnByb3RvdHlwZS5nZXRHaWQgPSBmdW5jdGlvbigpIHtcbiAgcmV0dXJuIHRoaXMuX2dpZDtcbn07XG5cbi8qKlxuICogU2V0IGdyb3VwIGlkLlxuICogQHBhcmFtIHtudW1iZXJ9IGdpZCBHcm91cCBpZC5cbiAqL1xuSXRlbS5wcm90b3R5cGUuc2V0R2lkID0gZnVuY3Rpb24oZ2lkKSB7XG4gIHRoaXMuc2V0Q1RpbWUobmV3IERhdGUoKSk7XG4gIHRoaXMuX2dpZCA9IGdpZDtcbn07XG5cbi8qKlxuICogR2V0IGl0ZW0gc3RhdHMuXG4gKiBAcmV0dXJuIHtPYmplY3R9IFN0YXRzIHByb3BlcnRpZXMuXG4gKi9cbkl0ZW0ucHJvdG90eXBlLmdldFN0YXRzID0gZnVuY3Rpb24oKSB7XG4gIHJldHVybiB7XG4gICAgZGV2OiA4Njc1MzA5LFxuICAgIG5saW5rOiB0aGlzLmxpbmtzLFxuICAgIHVpZDogdGhpcy5nZXRVaWQoKSxcbiAgICBnaWQ6IHRoaXMuZ2V0R2lkKCksXG4gICAgcmRldjogMCxcbiAgICBibGtzaXplOiA0MDk2LFxuICAgIGlubzogdGhpcy5faWQsXG4gICAgYXRpbWU6IHRoaXMuZ2V0QVRpbWUoKSxcbiAgICBtdGltZTogdGhpcy5nZXRNVGltZSgpLFxuICAgIGN0aW1lOiB0aGlzLmdldENUaW1lKCksXG4gICAgYmlydGh0aW1lOiB0aGlzLmdldEJpcnRodGltZSgpLFxuICAgIGF0aW1lTXM6ICt0aGlzLmdldEFUaW1lKCksXG4gICAgbXRpbWVNczogK3RoaXMuZ2V0TVRpbWUoKSxcbiAgICBjdGltZU1zOiArdGhpcy5nZXRDVGltZSgpLFxuICAgIGJpcnRodGltZU1zOiArdGhpcy5nZXRCaXJ0aHRpbWUoKVxuICB9O1xufTtcblxuLyoqXG4gKiBHZXQgdGhlIGl0ZW0ncyBzdHJpbmcgcmVwcmVzZW50YXRpb24uXG4gKiBAcmV0dXJuIHtzdHJpbmd9IFN0cmluZyByZXByZXNlbnRhdGlvbi5cbiAqL1xuSXRlbS5wcm90b3R5cGUudG9TdHJpbmcgPSBmdW5jdGlvbigpIHtcbiAgcmV0dXJuICdbJyArIHRoaXMuY29uc3RydWN0b3IubmFtZSArICddJztcbn07XG5cbi8qKlxuICogRXhwb3J0IHRoZSBjb25zdHJ1Y3Rvci5cbiAqIEB0eXBlIHtmdW5jdGlvbigpfVxuICovXG5leHBvcnRzID0gbW9kdWxlLmV4cG9ydHMgPSBJdGVtO1xuIl0sIm5hbWVzIjpbXSwiaWdub3JlTGlzdCI6WzBdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/mock-fs/lib/item.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/mock-fs/lib/loader.js":
/*!********************************************!*\
  !*** ./node_modules/mock-fs/lib/loader.js ***!
  \********************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

eval("const {fixWin32Permissions} = __webpack_require__(/*! ./item */ \"(ssr)/./node_modules/mock-fs/lib/item.js\");\nconst path = __webpack_require__(/*! path */ \"path\");\nconst FileSystem = __webpack_require__(/*! ./filesystem */ \"(ssr)/./node_modules/mock-fs/lib/filesystem.js\");\nconst fs = __webpack_require__(/*! fs */ \"fs\");\nconst bypass = __webpack_require__(/*! ./bypass */ \"(ssr)/./node_modules/mock-fs/lib/bypass.js\");\n\nconst createContext = ({output, options = {}, target}, newContext) =>\n  Object.assign(\n    {\n      // Assign options and set defaults if needed\n      options: {\n        recursive: options.recursive !== false,\n        lazy: options.lazy !== false\n      },\n      output,\n      target\n    },\n    newContext\n  );\n\nfunction addFile(context, stats, isRoot) {\n  const {output, target} = context;\n  const {lazy} = context.options;\n\n  if (!stats.isFile()) {\n    throw new Error(`${target} is not a valid file!`);\n  }\n\n  const outputPropKey = isRoot ? target : path.basename(target);\n\n  output[outputPropKey] = () => {\n    const content = !lazy ? fs.readFileSync(target) : '';\n    const file = FileSystem.file(Object.assign({}, stats, {content}))();\n\n    if (lazy) {\n      Object.defineProperty(file, '_content', {\n        get() {\n          const res = bypass(() => fs.readFileSync(target));\n          Object.defineProperty(file, '_content', {\n            value: res,\n            writable: true\n          });\n          return res;\n        },\n        set(data) {\n          Object.defineProperty(file, '_content', {\n            value: data,\n            writable: true\n          });\n        },\n        configurable: true\n      });\n    }\n\n    return file;\n  };\n\n  return output[outputPropKey];\n}\n\nfunction addDir(context, stats, isRoot) {\n  const {target, output} = context;\n  const {recursive} = context.options;\n\n  if (!stats.isDirectory()) {\n    throw new Error(`${target} is not a valid directory!`);\n  }\n\n  stats = Object.assign({}, stats);\n  const outputPropKey = isRoot ? target : path.basename(target);\n\n  // On windows platforms, directories do not have the executable flag, which causes FileSystem.prototype.getItem\n  // to think that the directory cannot be traversed. This is a workaround, however, a better solution may be to\n  // re-think the logic in FileSystem.prototype.getItem\n  // This workaround adds executable privileges if read privileges are found\n  stats.mode = fixWin32Permissions(stats.mode);\n\n  // Create directory factory\n  const directoryItems = {};\n  output[outputPropKey] = FileSystem.directory(\n    Object.assign(stats, {items: directoryItems})\n  );\n\n  fs.readdirSync(target).forEach(p => {\n    const absPath = path.join(target, p);\n    const stats = fs.statSync(absPath);\n    const newContext = createContext(context, {\n      target: absPath,\n      output: directoryItems\n    });\n\n    if (recursive && stats.isDirectory()) {\n      addDir(newContext, stats);\n    } else if (stats.isFile()) {\n      addFile(newContext, stats);\n    }\n  });\n\n  return output[outputPropKey];\n}\n\n/**\n * Load directory or file from real FS\n */\nexports.load = function(p, options) {\n  return bypass(() => {\n    p = path.resolve(p);\n\n    const stats = fs.statSync(p);\n    const context = createContext({output: {}, options, target: p});\n\n    if (stats.isDirectory()) {\n      return addDir(context, stats, true);\n    } else if (stats.isFile()) {\n      return addFile(context, stats, true);\n    }\n  });\n};\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvbW9jay1mcy9saWIvbG9hZGVyLmpzIiwibWFwcGluZ3MiOiJBQUFBLE9BQU8scUJBQXFCLEVBQUUsbUJBQU8sQ0FBQyx3REFBUTtBQUM5QyxhQUFhLG1CQUFPLENBQUMsa0JBQU07QUFDM0IsbUJBQW1CLG1CQUFPLENBQUMsb0VBQWM7QUFDekMsV0FBVyxtQkFBTyxDQUFDLGNBQUk7QUFDdkIsZUFBZSxtQkFBTyxDQUFDLDREQUFVOztBQUVqQyx3QkFBd0Isb0JBQW9CLFNBQVM7QUFDckQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTs7QUFFQTtBQUNBLFNBQVMsZ0JBQWdCO0FBQ3pCLFNBQVMsTUFBTTs7QUFFZjtBQUNBLHVCQUF1QixRQUFRO0FBQy9COztBQUVBOztBQUVBO0FBQ0E7QUFDQSxpREFBaUQsVUFBVSxRQUFROztBQUVuRTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFdBQVc7QUFDWDtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBLFdBQVc7QUFDWCxTQUFTO0FBQ1Q7QUFDQSxPQUFPO0FBQ1A7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0EsU0FBUyxnQkFBZ0I7QUFDekIsU0FBUyxXQUFXOztBQUVwQjtBQUNBLHVCQUF1QixRQUFRO0FBQy9COztBQUVBLDBCQUEwQjtBQUMxQjs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLDBCQUEwQixzQkFBc0I7QUFDaEQ7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSzs7QUFFTDtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQSxHQUFHOztBQUVIO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsWUFBWTtBQUNaO0FBQ0E7O0FBRUE7QUFDQSxtQ0FBbUMsVUFBVSxxQkFBcUI7O0FBRWxFO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBLEdBQUc7QUFDSCIsInNvdXJjZXMiOlsiL1VzZXJzL3BhbnphL0RvY3VtZW50cy9QZXJzb25hbFByb2plY3RzL3ByZWRpay9ub2RlX21vZHVsZXMvbW9jay1mcy9saWIvbG9hZGVyLmpzIl0sInNvdXJjZXNDb250ZW50IjpbImNvbnN0IHtmaXhXaW4zMlBlcm1pc3Npb25zfSA9IHJlcXVpcmUoJy4vaXRlbScpO1xuY29uc3QgcGF0aCA9IHJlcXVpcmUoJ3BhdGgnKTtcbmNvbnN0IEZpbGVTeXN0ZW0gPSByZXF1aXJlKCcuL2ZpbGVzeXN0ZW0nKTtcbmNvbnN0IGZzID0gcmVxdWlyZSgnZnMnKTtcbmNvbnN0IGJ5cGFzcyA9IHJlcXVpcmUoJy4vYnlwYXNzJyk7XG5cbmNvbnN0IGNyZWF0ZUNvbnRleHQgPSAoe291dHB1dCwgb3B0aW9ucyA9IHt9LCB0YXJnZXR9LCBuZXdDb250ZXh0KSA9PlxuICBPYmplY3QuYXNzaWduKFxuICAgIHtcbiAgICAgIC8vIEFzc2lnbiBvcHRpb25zIGFuZCBzZXQgZGVmYXVsdHMgaWYgbmVlZGVkXG4gICAgICBvcHRpb25zOiB7XG4gICAgICAgIHJlY3Vyc2l2ZTogb3B0aW9ucy5yZWN1cnNpdmUgIT09IGZhbHNlLFxuICAgICAgICBsYXp5OiBvcHRpb25zLmxhenkgIT09IGZhbHNlXG4gICAgICB9LFxuICAgICAgb3V0cHV0LFxuICAgICAgdGFyZ2V0XG4gICAgfSxcbiAgICBuZXdDb250ZXh0XG4gICk7XG5cbmZ1bmN0aW9uIGFkZEZpbGUoY29udGV4dCwgc3RhdHMsIGlzUm9vdCkge1xuICBjb25zdCB7b3V0cHV0LCB0YXJnZXR9ID0gY29udGV4dDtcbiAgY29uc3Qge2xhenl9ID0gY29udGV4dC5vcHRpb25zO1xuXG4gIGlmICghc3RhdHMuaXNGaWxlKCkpIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoYCR7dGFyZ2V0fSBpcyBub3QgYSB2YWxpZCBmaWxlIWApO1xuICB9XG5cbiAgY29uc3Qgb3V0cHV0UHJvcEtleSA9IGlzUm9vdCA/IHRhcmdldCA6IHBhdGguYmFzZW5hbWUodGFyZ2V0KTtcblxuICBvdXRwdXRbb3V0cHV0UHJvcEtleV0gPSAoKSA9PiB7XG4gICAgY29uc3QgY29udGVudCA9ICFsYXp5ID8gZnMucmVhZEZpbGVTeW5jKHRhcmdldCkgOiAnJztcbiAgICBjb25zdCBmaWxlID0gRmlsZVN5c3RlbS5maWxlKE9iamVjdC5hc3NpZ24oe30sIHN0YXRzLCB7Y29udGVudH0pKSgpO1xuXG4gICAgaWYgKGxhenkpIHtcbiAgICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShmaWxlLCAnX2NvbnRlbnQnLCB7XG4gICAgICAgIGdldCgpIHtcbiAgICAgICAgICBjb25zdCByZXMgPSBieXBhc3MoKCkgPT4gZnMucmVhZEZpbGVTeW5jKHRhcmdldCkpO1xuICAgICAgICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShmaWxlLCAnX2NvbnRlbnQnLCB7XG4gICAgICAgICAgICB2YWx1ZTogcmVzLFxuICAgICAgICAgICAgd3JpdGFibGU6IHRydWVcbiAgICAgICAgICB9KTtcbiAgICAgICAgICByZXR1cm4gcmVzO1xuICAgICAgICB9LFxuICAgICAgICBzZXQoZGF0YSkge1xuICAgICAgICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShmaWxlLCAnX2NvbnRlbnQnLCB7XG4gICAgICAgICAgICB2YWx1ZTogZGF0YSxcbiAgICAgICAgICAgIHdyaXRhYmxlOiB0cnVlXG4gICAgICAgICAgfSk7XG4gICAgICAgIH0sXG4gICAgICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZVxuICAgICAgfSk7XG4gICAgfVxuXG4gICAgcmV0dXJuIGZpbGU7XG4gIH07XG5cbiAgcmV0dXJuIG91dHB1dFtvdXRwdXRQcm9wS2V5XTtcbn1cblxuZnVuY3Rpb24gYWRkRGlyKGNvbnRleHQsIHN0YXRzLCBpc1Jvb3QpIHtcbiAgY29uc3Qge3RhcmdldCwgb3V0cHV0fSA9IGNvbnRleHQ7XG4gIGNvbnN0IHtyZWN1cnNpdmV9ID0gY29udGV4dC5vcHRpb25zO1xuXG4gIGlmICghc3RhdHMuaXNEaXJlY3RvcnkoKSkge1xuICAgIHRocm93IG5ldyBFcnJvcihgJHt0YXJnZXR9IGlzIG5vdCBhIHZhbGlkIGRpcmVjdG9yeSFgKTtcbiAgfVxuXG4gIHN0YXRzID0gT2JqZWN0LmFzc2lnbih7fSwgc3RhdHMpO1xuICBjb25zdCBvdXRwdXRQcm9wS2V5ID0gaXNSb290ID8gdGFyZ2V0IDogcGF0aC5iYXNlbmFtZSh0YXJnZXQpO1xuXG4gIC8vIE9uIHdpbmRvd3MgcGxhdGZvcm1zLCBkaXJlY3RvcmllcyBkbyBub3QgaGF2ZSB0aGUgZXhlY3V0YWJsZSBmbGFnLCB3aGljaCBjYXVzZXMgRmlsZVN5c3RlbS5wcm90b3R5cGUuZ2V0SXRlbVxuICAvLyB0byB0aGluayB0aGF0IHRoZSBkaXJlY3RvcnkgY2Fubm90IGJlIHRyYXZlcnNlZC4gVGhpcyBpcyBhIHdvcmthcm91bmQsIGhvd2V2ZXIsIGEgYmV0dGVyIHNvbHV0aW9uIG1heSBiZSB0b1xuICAvLyByZS10aGluayB0aGUgbG9naWMgaW4gRmlsZVN5c3RlbS5wcm90b3R5cGUuZ2V0SXRlbVxuICAvLyBUaGlzIHdvcmthcm91bmQgYWRkcyBleGVjdXRhYmxlIHByaXZpbGVnZXMgaWYgcmVhZCBwcml2aWxlZ2VzIGFyZSBmb3VuZFxuICBzdGF0cy5tb2RlID0gZml4V2luMzJQZXJtaXNzaW9ucyhzdGF0cy5tb2RlKTtcblxuICAvLyBDcmVhdGUgZGlyZWN0b3J5IGZhY3RvcnlcbiAgY29uc3QgZGlyZWN0b3J5SXRlbXMgPSB7fTtcbiAgb3V0cHV0W291dHB1dFByb3BLZXldID0gRmlsZVN5c3RlbS5kaXJlY3RvcnkoXG4gICAgT2JqZWN0LmFzc2lnbihzdGF0cywge2l0ZW1zOiBkaXJlY3RvcnlJdGVtc30pXG4gICk7XG5cbiAgZnMucmVhZGRpclN5bmModGFyZ2V0KS5mb3JFYWNoKHAgPT4ge1xuICAgIGNvbnN0IGFic1BhdGggPSBwYXRoLmpvaW4odGFyZ2V0LCBwKTtcbiAgICBjb25zdCBzdGF0cyA9IGZzLnN0YXRTeW5jKGFic1BhdGgpO1xuICAgIGNvbnN0IG5ld0NvbnRleHQgPSBjcmVhdGVDb250ZXh0KGNvbnRleHQsIHtcbiAgICAgIHRhcmdldDogYWJzUGF0aCxcbiAgICAgIG91dHB1dDogZGlyZWN0b3J5SXRlbXNcbiAgICB9KTtcblxuICAgIGlmIChyZWN1cnNpdmUgJiYgc3RhdHMuaXNEaXJlY3RvcnkoKSkge1xuICAgICAgYWRkRGlyKG5ld0NvbnRleHQsIHN0YXRzKTtcbiAgICB9IGVsc2UgaWYgKHN0YXRzLmlzRmlsZSgpKSB7XG4gICAgICBhZGRGaWxlKG5ld0NvbnRleHQsIHN0YXRzKTtcbiAgICB9XG4gIH0pO1xuXG4gIHJldHVybiBvdXRwdXRbb3V0cHV0UHJvcEtleV07XG59XG5cbi8qKlxuICogTG9hZCBkaXJlY3Rvcnkgb3IgZmlsZSBmcm9tIHJlYWwgRlNcbiAqL1xuZXhwb3J0cy5sb2FkID0gZnVuY3Rpb24ocCwgb3B0aW9ucykge1xuICByZXR1cm4gYnlwYXNzKCgpID0+IHtcbiAgICBwID0gcGF0aC5yZXNvbHZlKHApO1xuXG4gICAgY29uc3Qgc3RhdHMgPSBmcy5zdGF0U3luYyhwKTtcbiAgICBjb25zdCBjb250ZXh0ID0gY3JlYXRlQ29udGV4dCh7b3V0cHV0OiB7fSwgb3B0aW9ucywgdGFyZ2V0OiBwfSk7XG5cbiAgICBpZiAoc3RhdHMuaXNEaXJlY3RvcnkoKSkge1xuICAgICAgcmV0dXJuIGFkZERpcihjb250ZXh0LCBzdGF0cywgdHJ1ZSk7XG4gICAgfSBlbHNlIGlmIChzdGF0cy5pc0ZpbGUoKSkge1xuICAgICAgcmV0dXJuIGFkZEZpbGUoY29udGV4dCwgc3RhdHMsIHRydWUpO1xuICAgIH1cbiAgfSk7XG59O1xuIl0sIm5hbWVzIjpbXSwiaWdub3JlTGlzdCI6WzBdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/mock-fs/lib/loader.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/mock-fs/lib/symlink.js":
/*!*********************************************!*\
  !*** ./node_modules/mock-fs/lib/symlink.js ***!
  \*********************************************/
/***/ ((module, exports, __webpack_require__) => {

"use strict";
eval("\n\nconst util = __webpack_require__(/*! util */ \"util\");\n\nconst Item = __webpack_require__(/*! ./item */ \"(ssr)/./node_modules/mock-fs/lib/item.js\");\n\nconst constants = __webpack_require__(/*! constants */ \"constants\");\n\n/**\n * A directory.\n * @constructor\n */\nfunction SymbolicLink() {\n  Item.call(this);\n\n  /**\n   * Relative path to source.\n   * @type {string}\n   */\n  this._path = undefined;\n}\nutil.inherits(SymbolicLink, Item);\n\n/**\n * Set the path to the source.\n * @param {string} pathname Path to source.\n */\nSymbolicLink.prototype.setPath = function(pathname) {\n  this._path = pathname;\n};\n\n/**\n * Get the path to the source.\n * @return {string} Path to source.\n */\nSymbolicLink.prototype.getPath = function() {\n  return this._path;\n};\n\n/**\n * Get symbolic link stats.\n * @return {Object} Stats properties.\n */\nSymbolicLink.prototype.getStats = function() {\n  const size = this._path.length;\n  const stats = Item.prototype.getStats.call(this);\n  stats.mode = this.getMode() | constants.S_IFLNK;\n  stats.size = size;\n  stats.blocks = Math.ceil(size / 512);\n  return stats;\n};\n\n/**\n * Export the constructor.\n * @type {function()}\n */\nexports = module.exports = SymbolicLink;\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvbW9jay1mcy9saWIvc3ltbGluay5qcyIsIm1hcHBpbmdzIjoiQUFBYTs7QUFFYixhQUFhLG1CQUFPLENBQUMsa0JBQU07O0FBRTNCLGFBQWEsbUJBQU8sQ0FBQyx3REFBUTs7QUFFN0Isa0JBQWtCLG1CQUFPLENBQUMsNEJBQVc7O0FBRXJDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsWUFBWTtBQUNaO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxXQUFXLFFBQVE7QUFDbkI7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLFlBQVksUUFBUTtBQUNwQjtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsWUFBWSxRQUFRO0FBQ3BCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsVUFBVTtBQUNWO0FBQ0EiLCJzb3VyY2VzIjpbIi9Vc2Vycy9wYW56YS9Eb2N1bWVudHMvUGVyc29uYWxQcm9qZWN0cy9wcmVkaWsvbm9kZV9tb2R1bGVzL21vY2stZnMvbGliL3N5bWxpbmsuanMiXSwic291cmNlc0NvbnRlbnQiOlsiJ3VzZSBzdHJpY3QnO1xuXG5jb25zdCB1dGlsID0gcmVxdWlyZSgndXRpbCcpO1xuXG5jb25zdCBJdGVtID0gcmVxdWlyZSgnLi9pdGVtJyk7XG5cbmNvbnN0IGNvbnN0YW50cyA9IHJlcXVpcmUoJ2NvbnN0YW50cycpO1xuXG4vKipcbiAqIEEgZGlyZWN0b3J5LlxuICogQGNvbnN0cnVjdG9yXG4gKi9cbmZ1bmN0aW9uIFN5bWJvbGljTGluaygpIHtcbiAgSXRlbS5jYWxsKHRoaXMpO1xuXG4gIC8qKlxuICAgKiBSZWxhdGl2ZSBwYXRoIHRvIHNvdXJjZS5cbiAgICogQHR5cGUge3N0cmluZ31cbiAgICovXG4gIHRoaXMuX3BhdGggPSB1bmRlZmluZWQ7XG59XG51dGlsLmluaGVyaXRzKFN5bWJvbGljTGluaywgSXRlbSk7XG5cbi8qKlxuICogU2V0IHRoZSBwYXRoIHRvIHRoZSBzb3VyY2UuXG4gKiBAcGFyYW0ge3N0cmluZ30gcGF0aG5hbWUgUGF0aCB0byBzb3VyY2UuXG4gKi9cblN5bWJvbGljTGluay5wcm90b3R5cGUuc2V0UGF0aCA9IGZ1bmN0aW9uKHBhdGhuYW1lKSB7XG4gIHRoaXMuX3BhdGggPSBwYXRobmFtZTtcbn07XG5cbi8qKlxuICogR2V0IHRoZSBwYXRoIHRvIHRoZSBzb3VyY2UuXG4gKiBAcmV0dXJuIHtzdHJpbmd9IFBhdGggdG8gc291cmNlLlxuICovXG5TeW1ib2xpY0xpbmsucHJvdG90eXBlLmdldFBhdGggPSBmdW5jdGlvbigpIHtcbiAgcmV0dXJuIHRoaXMuX3BhdGg7XG59O1xuXG4vKipcbiAqIEdldCBzeW1ib2xpYyBsaW5rIHN0YXRzLlxuICogQHJldHVybiB7T2JqZWN0fSBTdGF0cyBwcm9wZXJ0aWVzLlxuICovXG5TeW1ib2xpY0xpbmsucHJvdG90eXBlLmdldFN0YXRzID0gZnVuY3Rpb24oKSB7XG4gIGNvbnN0IHNpemUgPSB0aGlzLl9wYXRoLmxlbmd0aDtcbiAgY29uc3Qgc3RhdHMgPSBJdGVtLnByb3RvdHlwZS5nZXRTdGF0cy5jYWxsKHRoaXMpO1xuICBzdGF0cy5tb2RlID0gdGhpcy5nZXRNb2RlKCkgfCBjb25zdGFudHMuU19JRkxOSztcbiAgc3RhdHMuc2l6ZSA9IHNpemU7XG4gIHN0YXRzLmJsb2NrcyA9IE1hdGguY2VpbChzaXplIC8gNTEyKTtcbiAgcmV0dXJuIHN0YXRzO1xufTtcblxuLyoqXG4gKiBFeHBvcnQgdGhlIGNvbnN0cnVjdG9yLlxuICogQHR5cGUge2Z1bmN0aW9uKCl9XG4gKi9cbmV4cG9ydHMgPSBtb2R1bGUuZXhwb3J0cyA9IFN5bWJvbGljTGluaztcbiJdLCJuYW1lcyI6W10sImlnbm9yZUxpc3QiOlswXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/mock-fs/lib/symlink.js\n");

/***/ })

};
;
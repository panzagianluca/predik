/*
 * ATTENTION: An "eval-source-map" devtool has been used.
 * This devtool is neither made for production nor for readable output files.
 * It uses "eval()" calls to create a separate source file with attached SourceMaps in the browser devtools.
 * If you are trying to read the output file, select a different devtool (https://webpack.js.org/configuration/devtool/)
 * or disable the default devtool with "devtool: false".
 * If you are looking for production-ready output files, see mode: "production" (https://webpack.js.org/configuration/mode/).
 */
exports.id = "vendor-chunks/swarm-js";
exports.ids = ["vendor-chunks/swarm-js"];
exports.modules = {

/***/ "(ssr)/./node_modules/swarm-js/archives/archives.json":
/*!******************************************************!*\
  !*** ./node_modules/swarm-js/archives/archives.json ***!
  \******************************************************/
/***/ ((module) => {

"use strict";
module.exports = /*#__PURE__*/JSON.parse('{"windows-amd64":{"archive":"swarm-windows-amd64-1.6.7.exe","binaryMD5":"c2d827dc4553d9b91a7d6c1d5a6140fd","archiveMD5":"059196d21548060a18a12e17cc0ee59a"},"linux-amd64":{"archive":"swarm-linux-amd64-1.6.7","binaryMD5":"85002d79b8ebc2d2f2f10fb198636a81","archiveMD5":"3e8874299ab8c0e3043d70ebb6673879"},"linux-386":{"archive":"swarm-linux-386-1.6.7","binaryMD5":"35bc2ab976f60f96a2cede117e0df19d","archiveMD5":"7868a86c9cbdf8ac7ac2e5682b4ce40f"},"darwin-amd64":{"archive":"swarm-darwin-amd64-1.6.7","binaryMD5":"c499b186645229260dd6ab685dd58f07","archiveMD5":"0794d111e5018eac3b657bcb29851121"},"linux-arm5":{"archive":"swarm-linux-arm5-1.6.7","binaryMD5":"516fcd85246c905529442cd9b689c12f","archiveMD5":"47312708d417cb196b07ba0af1d3abb4"},"linux-arm6":{"archive":"swarm-linux-arm6-1.6.7","binaryMD5":"82ff7bdbe388b4a190f4101c5150d3b4","archiveMD5":"350276de7bb175a15c314cfc4cb7f8fd"},"linux-mips":{"archive":"swarm-linux-mips-1.6.7","binaryMD5":"e1e95280441c0ca35633927792ef5317","archiveMD5":"8fb4b64e94cd73aa718db787b9d4c53e"},"linux-arm7":{"archive":"swarm-linux-arm7-1.6.7","binaryMD5":"bfc0b4d1c86d8a975af052fc7854bdd3","archiveMD5":"4378641d8e1e1fbb947f941c8fca8613"},"linux-arm64":{"archive":"swarm-linux-arm64-1.6.7","binaryMD5":"bbac21a6c6fa8208f67ca4123d3f948a","archiveMD5":"4e503160327c5fbcca0414f17c54e5ee"},"linux-mipsle":{"archive":"swarm-linux-mipsle-1.6.7","binaryMD5":"a82f191b2f9d2c470d0273219c820657","archiveMD5":"3016bdb6d237ae654c0cdf36fe85dc7c"},"windows-386":{"archive":"swarm-windows-386-1.6.7.exe","binaryMD5":"ce0b34640642e58068ae5a359faef102","archiveMD5":"640aede4da08a3a9d8a6ac0434ba7c0f"},"linux-mips64":{"archive":"swarm-linux-mips64-1.6.7","binaryMD5":"9da967664f384817adb5083fd1ffe8f1","archiveMD5":"357a33be470f8f89ba2619957a08deff"},"linux-mips64le":{"archive":"swarm-linux-mips64le-1.6.7","binaryMD5":"ec1abcf7b216e87645ec83954d8344cd","archiveMD5":"a81fd0158190d99813c738ffa4f87627"}}');

/***/ }),

/***/ "(ssr)/./node_modules/swarm-js/lib/api-node.js":
/*!***********************************************!*\
  !*** ./node_modules/swarm-js/lib/api-node.js ***!
  \***********************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

eval("var fs = __webpack_require__(/*! fs-extra */ \"(ssr)/./node_modules/fs-extra/lib/index.js\");\n\nvar files = __webpack_require__(/*! ./files.js */ \"(ssr)/./node_modules/swarm-js/lib/files.js\");\n\nvar os = __webpack_require__(/*! os */ \"os\");\n\nvar path = __webpack_require__(/*! path */ \"path\");\n\nvar child_process = __webpack_require__(/*! child_process */ \"child_process\");\n\nvar mimetype = __webpack_require__(/*! mime-types */ \"(ssr)/./node_modules/mime-types/index.js\");\n\nvar defaultArchives = __webpack_require__(/*! ./../archives/archives.json */ \"(ssr)/./node_modules/swarm-js/archives/archives.json\");\n\nvar requester = __webpack_require__(/*! xhr-request */ \"(ssr)/./node_modules/xhr-request/index.js\");\n\nvar downloadUrl = \"http://ethereum-mist.s3.amazonaws.com/swarm/\";\n\nvar bytes = __webpack_require__(/*! eth-lib/lib/bytes */ \"(ssr)/./node_modules/eth-lib/lib/bytes.js\");\n\nvar hash = __webpack_require__(/*! ./swarm-hash.js */ \"(ssr)/./node_modules/swarm-js/lib/swarm-hash.js\");\n\nvar pick = __webpack_require__(/*! ./pick.js */ \"(ssr)/./node_modules/swarm-js/lib/pick.js\");\n\nvar swarm = __webpack_require__(/*! ./swarm */ \"(ssr)/./node_modules/swarm-js/lib/swarm.js\"); // Fixes issue that causes xhr-request-promise on Node.js to only accept Buffer\n\n\nvar request = function request(url, params, callback) {\n  var newParams = {};\n\n  for (var key in params) {\n    newParams[key] = params[key];\n  }\n\n  if (typeof newParams.body !== \"undefined\") {\n    newParams.body = newParams.body instanceof Buffer ? newParams.body : new Buffer(newParams.body);\n  }\n\n  return requester(url, newParams, callback);\n};\n\nmodule.exports = swarm({\n  fs: fs,\n  files: files,\n  os: os,\n  path: path,\n  child_process: child_process,\n  defaultArchives: defaultArchives,\n  mimetype: mimetype,\n  request: request,\n  downloadUrl: downloadUrl,\n  bytes: bytes,\n  hash: hash,\n  pick: pick\n});//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvc3dhcm0tanMvbGliL2FwaS1ub2RlLmpzIiwibWFwcGluZ3MiOiJBQUFBLFNBQVMsbUJBQU8sQ0FBQyw0REFBVTs7QUFFM0IsWUFBWSxtQkFBTyxDQUFDLDhEQUFZOztBQUVoQyxTQUFTLG1CQUFPLENBQUMsY0FBSTs7QUFFckIsV0FBVyxtQkFBTyxDQUFDLGtCQUFNOztBQUV6QixvQkFBb0IsbUJBQU8sQ0FBQyxvQ0FBZTs7QUFFM0MsZUFBZSxtQkFBTyxDQUFDLDREQUFZOztBQUVuQyxzQkFBc0IsbUJBQU8sQ0FBQyx5RkFBNkI7O0FBRTNELGdCQUFnQixtQkFBTyxDQUFDLDhEQUFhOztBQUVyQzs7QUFFQSxZQUFZLG1CQUFPLENBQUMsb0VBQW1COztBQUV2QyxXQUFXLG1CQUFPLENBQUMsd0VBQWlCOztBQUVwQyxXQUFXLG1CQUFPLENBQUMsNERBQVc7O0FBRTlCLFlBQVksbUJBQU8sQ0FBQywyREFBUyxHQUFHOzs7QUFHaEM7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDIiwic291cmNlcyI6WyIvVXNlcnMvcGFuemEvRG9jdW1lbnRzL1BlcnNvbmFsUHJvamVjdHMvcHJlZGlrL25vZGVfbW9kdWxlcy9zd2FybS1qcy9saWIvYXBpLW5vZGUuanMiXSwic291cmNlc0NvbnRlbnQiOlsidmFyIGZzID0gcmVxdWlyZShcImZzLWV4dHJhXCIpO1xuXG52YXIgZmlsZXMgPSByZXF1aXJlKFwiLi9maWxlcy5qc1wiKTtcblxudmFyIG9zID0gcmVxdWlyZShcIm9zXCIpO1xuXG52YXIgcGF0aCA9IHJlcXVpcmUoXCJwYXRoXCIpO1xuXG52YXIgY2hpbGRfcHJvY2VzcyA9IHJlcXVpcmUoXCJjaGlsZF9wcm9jZXNzXCIpO1xuXG52YXIgbWltZXR5cGUgPSByZXF1aXJlKCdtaW1lLXR5cGVzJyk7XG5cbnZhciBkZWZhdWx0QXJjaGl2ZXMgPSByZXF1aXJlKFwiLi8uLi9hcmNoaXZlcy9hcmNoaXZlcy5qc29uXCIpO1xuXG52YXIgcmVxdWVzdGVyID0gcmVxdWlyZShcInhoci1yZXF1ZXN0XCIpO1xuXG52YXIgZG93bmxvYWRVcmwgPSBcImh0dHA6Ly9ldGhlcmV1bS1taXN0LnMzLmFtYXpvbmF3cy5jb20vc3dhcm0vXCI7XG5cbnZhciBieXRlcyA9IHJlcXVpcmUoXCJldGgtbGliL2xpYi9ieXRlc1wiKTtcblxudmFyIGhhc2ggPSByZXF1aXJlKFwiLi9zd2FybS1oYXNoLmpzXCIpO1xuXG52YXIgcGljayA9IHJlcXVpcmUoXCIuL3BpY2suanNcIik7XG5cbnZhciBzd2FybSA9IHJlcXVpcmUoXCIuL3N3YXJtXCIpOyAvLyBGaXhlcyBpc3N1ZSB0aGF0IGNhdXNlcyB4aHItcmVxdWVzdC1wcm9taXNlIG9uIE5vZGUuanMgdG8gb25seSBhY2NlcHQgQnVmZmVyXG5cblxudmFyIHJlcXVlc3QgPSBmdW5jdGlvbiByZXF1ZXN0KHVybCwgcGFyYW1zLCBjYWxsYmFjaykge1xuICB2YXIgbmV3UGFyYW1zID0ge307XG5cbiAgZm9yICh2YXIga2V5IGluIHBhcmFtcykge1xuICAgIG5ld1BhcmFtc1trZXldID0gcGFyYW1zW2tleV07XG4gIH1cblxuICBpZiAodHlwZW9mIG5ld1BhcmFtcy5ib2R5ICE9PSBcInVuZGVmaW5lZFwiKSB7XG4gICAgbmV3UGFyYW1zLmJvZHkgPSBuZXdQYXJhbXMuYm9keSBpbnN0YW5jZW9mIEJ1ZmZlciA/IG5ld1BhcmFtcy5ib2R5IDogbmV3IEJ1ZmZlcihuZXdQYXJhbXMuYm9keSk7XG4gIH1cblxuICByZXR1cm4gcmVxdWVzdGVyKHVybCwgbmV3UGFyYW1zLCBjYWxsYmFjayk7XG59O1xuXG5tb2R1bGUuZXhwb3J0cyA9IHN3YXJtKHtcbiAgZnM6IGZzLFxuICBmaWxlczogZmlsZXMsXG4gIG9zOiBvcyxcbiAgcGF0aDogcGF0aCxcbiAgY2hpbGRfcHJvY2VzczogY2hpbGRfcHJvY2VzcyxcbiAgZGVmYXVsdEFyY2hpdmVzOiBkZWZhdWx0QXJjaGl2ZXMsXG4gIG1pbWV0eXBlOiBtaW1ldHlwZSxcbiAgcmVxdWVzdDogcmVxdWVzdCxcbiAgZG93bmxvYWRVcmw6IGRvd25sb2FkVXJsLFxuICBieXRlczogYnl0ZXMsXG4gIGhhc2g6IGhhc2gsXG4gIHBpY2s6IHBpY2tcbn0pOyJdLCJuYW1lcyI6W10sImlnbm9yZUxpc3QiOlswXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/swarm-js/lib/api-node.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/swarm-js/lib/files.js":
/*!********************************************!*\
  !*** ./node_modules/swarm-js/lib/files.js ***!
  \********************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

eval("// This module implements some file download utils. Its most important export\n// is `safeDownloadTargzFile`, which, given a file, its md5, a tar.gz url, its\n// md5 and a path, returns a Promise that will only resolve once the exact file\n// you expect is available on that path.\nvar Q = __webpack_require__(/*! bluebird */ \"(ssr)/./node_modules/bluebird/js/release/bluebird.js\");\n\nvar assert = __webpack_require__(/*! assert */ \"assert\");\n\nvar crypto = __webpack_require__(/*! crypto */ \"crypto\");\n\nvar fs = __webpack_require__(/*! fs-extra */ \"(ssr)/./node_modules/fs-extra/lib/index.js\");\n\nvar got = __webpack_require__(/*! got */ \"(ssr)/./node_modules/swarm-js/node_modules/got/dist/source/index.js\");\n\nvar mkdirp = __webpack_require__(/*! mkdirp-promise */ \"(ssr)/./node_modules/mkdirp-promise/lib/index.js\");\n\nvar path = __webpack_require__(/*! path */ \"path\");\n\nvar tar = __webpack_require__(/*! tar */ \"(ssr)/./node_modules/swarm-js/node_modules/tar/index.js\"); // String -> String ~> Promise String\n//   Downloads a file from an url to a path.\n//   Returns a promise containing the path.\n\n\nvar download = function download(url) {\n  return function (filePath) {\n    var promise = Q.resolve(mkdirp(path.dirname(filePath))).then(function () {\n      return new Q(function (resolve, reject) {\n        var writeStream = fs.createWriteStream(filePath);\n        var downloadStream = got.stream(url);\n        downloadStream.on(\"end\", function () {\n          return resolve(filePath);\n        });\n        downloadStream.on(\"data\", function (chunk) {\n          return promise.onDataCallback(chunk);\n        });\n        downloadStream.on(\"error\", reject);\n        downloadStream.pipe(writeStream);\n      });\n    });\n\n    promise.onDataCallback = function () {};\n\n    promise.onData = function (callback) {\n      promise.onDataCallback = callback || function () {};\n\n      return promise;\n    };\n\n    return promise;\n  };\n}; // String -> String ~> Promise String\n//   Hashes a file using the given algorithm (ex: \"md5\").\n//   Returns a promise containing the hashed string.\n\n\nvar hash = function hash(algorithm) {\n  return function (path) {\n    return new Q(function (resolve, reject) {\n      var readStream = fs.ReadStream(path);\n      var hash = crypto.createHash(algorithm);\n      readStream.on(\"data\", function (d) {\n        return hash.update(d);\n      });\n      readStream.on(\"end\", function () {\n        return resolve(hash.digest(\"hex\"));\n      });\n      readStream.on(\"error\", reject);\n    });\n  };\n}; // String -> String ~> Promise ()\n//   Asserts a file matches this md5 hash.\n//   Returns a promise containing its path.\n\n\nvar checksum = function checksum(fileHash) {\n  return function (path) {\n    return hash(\"md5\")(path).then(function (actualHash) {\n      return actualHash === fileHash;\n    }).then(assert).then(function () {\n      return path;\n    });\n  };\n}; // String ~> String ~> String ~> Promise String\n//   Downloads a file to a directory, check.\n//   Checks if the md5 hash matches.\n//   Returns a promise containing the path.\n\n\nvar downloadAndCheck = function downloadAndCheck(url) {\n  return function (path) {\n    return function (fileHash) {\n      return download(url)(path).then(checksum(fileHash));\n    };\n  };\n}; // String -> String ~> Promise String\n//   TODO: work for zip and other types\n\n\nvar extract = function extract(fromPath) {\n  return function (toPath) {\n    return tar.x(fromPath, toPath).then(function () {\n      return toPath;\n    });\n  };\n}; // String ~> Promise String\n//   Reads a file as an UTF8 string.\n//   Returns a promise containing that string.\n\n\nvar readUTF8 = function readUTF8(path) {\n  return fs.readFile(path, {\n    encoding: \"utf8\"\n  });\n}; // String ~> Promise Bool\n\n\nvar isDirectory = function isDirectory(path) {\n  return fs.exists(path).then(assert).then(function () {\n    return fs.lstat(path);\n  }).then(function (stats) {\n    return stats.isDirectory();\n  })[\"catch\"](function () {\n    return false;\n  });\n}; // String -> Promise String\n\n\nvar directoryTree = function directoryTree(dirPath) {\n  var paths = [];\n\n  var search = function search(dirPath) {\n    return isDirectory(dirPath).then(function (isDir) {\n      if (isDir) {\n        var searchOnDir = function searchOnDir(dir) {\n          return search(path.join(dirPath, dir));\n        };\n\n        return Q.all(Q.map(fs.readdir(dirPath), searchOnDir));\n      } else {\n        paths.push(dirPath);\n      }\n\n      ;\n    });\n  };\n\n  return Q.all(search(dirPath)).then(function () {\n    return paths;\n  });\n}; // Regex -> String ~> Promise (Array String)\n\n\nvar search = function search(regex) {\n  return function (dirPath) {\n    return directoryTree(dirPath).then(function (tree) {\n      return tree.filter(function (path) {\n        return regex.test(path);\n      });\n    });\n  };\n}; // String -> String -> String -> String ~> Promise String\n//   Downloads a file inside a tar.gz and places it at `filePath`.\n//   Checks the md5 hash of the tar before extracting it.\n//   Checks the md5 hash of the file after extracting it.\n//   If all is OK, returns a promise containing the file path.\n\n\nvar safeDownloadArchived = function safeDownloadArchived(url) {\n  return function (archiveHash) {\n    return function (fileHash) {\n      return function (filePath) {\n        var fileDir = path.dirname(filePath);\n        var fileName = path.basename(filePath);\n        var archivePath = path.join(fileDir, \".swarm_downloads/files.tar.gz\");\n        var archiveDir = path.dirname(archivePath);\n        var promise = Q.resolve(mkdirp(archiveDir)).then(function () {\n          return checksum(fileHash)(filePath);\n        }).then(function () {\n          return filePath;\n        })[\"catch\"](function () {\n          return fs.exists(archiveDir).then(function (exists) {\n            return !exists ? fs.mkdir(archiveDir) : null;\n          }).then(function () {\n            return download(url)(archivePath).onData(promise.onDataCallback);\n          }).then(function () {\n            return hash(\"md5\")(archivePath);\n          }).then(function () {\n            return archiveHash ? checksum(archiveHash)(archivePath) : null;\n          }).then(function () {\n            return extract(archivePath)(archiveDir);\n          }).then(function () {\n            return search(new RegExp(fileName + \"$\"))(archiveDir);\n          }).then(function (fp) {\n            return fs.rename(fp[0], filePath);\n          }).then(function () {\n            return fs.unlink(archivePath);\n          }).then(function () {\n            return fileHash ? checksum(fileHash)(filePath) : null;\n          }).then(function () {\n            return filePath;\n          });\n        });\n\n        promise.onDataCallback = function () {};\n\n        promise.onData = function (callback) {\n          promise.onDataCallback = callback || function () {};\n\n          return promise;\n        };\n\n        return promise;\n      };\n    };\n  };\n}; // String -> String ~> Promise String\n//   Like `safeDownloadArchivedFile`, but without the checksums.\n\n\nvar downloadArchived = function downloadArchived(url) {\n  return function (path) {\n    return safeDownloadArchived(url)(null)(null)(path);\n  };\n}; // () => Promise Bool\n//   Tests the implementation by downloading a predetermined tar.gz\n//   from a mocked HTTP-server into a mocked filesystem. Does some\n//   redundancy tests such as checking the file constents and double\n//   checking its MD5 hash.\n//   Returns a promise containing a boolean, true if tests passed.\n\n\nvar test = function test() {\n  var filePath = \"/swarm/foo.txt\";\n  var fileHash = \"d3b07384d113edec49eaa6238ad5ff00\";\n  var archiveUrl = \"http://localhost:12534\";\n  var archiveHash = \"7fa45f946bb2a696bdd9972e0fbceac2\";\n  var archiveData = new Buffer([0x1f, 0x8b, 0x08, 0x00, 0xf1, 0x34, 0xaf, 0x58, 0x00, 0x03, 0xed, 0xcf, 0x3d, 0x0e, 0x83, 0x30, 0x0c, 0x86, 0x61, 0x66, 0x4e, 0xe1, 0x13, 0x54, 0xce, 0x0f, 0xc9, 0x79, 0x58, 0xb2, 0x46, 0x82, 0x14, 0x71, 0x7c, 0xd2, 0x06, 0x31, 0x52, 0x75, 0x40, 0x08, 0xe9, 0x7d, 0x96, 0x4f, 0x96, 0x3d, 0x7c, 0x4e, 0x39, 0xbf, 0xca, 0x5a, 0xba, 0x2b, 0xa9, 0x6a, 0xf0, 0x5e, 0x3e, 0x19, 0xc3, 0xf0, 0x4d, 0xb5, 0x6d, 0xde, 0x79, 0x31, 0x4e, 0x07, 0x17, 0x9c, 0xb5, 0x31, 0x8a, 0x1a, 0xab, 0xc6, 0x77, 0xa2, 0x97, 0xb6, 0xda, 0xbd, 0xe7, 0x32, 0x4e, 0xb5, 0xca, 0xf2, 0xe3, 0xae, 0x9e, 0xa5, 0x74, 0xb2, 0x6f, 0x8f, 0xc8, 0x91, 0x0f, 0x91, 0x72, 0xee, 0xef, 0xee, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0xf8, 0xdf, 0x06, 0xb3, 0x2a, 0xda, 0xed, 0x00, 0x28, 0x00, 0x00]);\n\n  var crypto = __webpack_require__(/*! crypto */ \"crypto\");\n\n  var fsMock = __webpack_require__(/*! mock-fs */ \"(ssr)/./node_modules/mock-fs/lib/index.js\")({\n    \"/swarm\": {}\n  });\n\n  var httpMock = (__webpack_require__(/*! http */ \"http\").createServer)(function (_, res) {\n    return res.end(archiveData);\n  }).listen(12534);\n\n  return safeDownloadArchived(archiveUrl)(archiveHash)(fileHash)(filePath).then(checksum(fileHash)).then(readUTF8).then(function (text) {\n    return text === \"foo\\n\";\n  }).then(assert).then(function () {\n    return safeDownloadArchived(archiveUrl)(archiveHash)(fileHash)(filePath);\n  }).then(function () {\n    return true;\n  })[\"catch\"](false)[\"finally\"](function () {\n    return httpMock.close();\n  });\n};\n\nmodule.exports = {\n  download: download,\n  hash: hash,\n  checksum: checksum,\n  downloadAndCheck: downloadAndCheck,\n  extract: extract,\n  readUTF8: readUTF8,\n  safeDownloadArchived: safeDownloadArchived,\n  directoryTree: directoryTree,\n  downloadArchived: downloadArchived,\n  search: search,\n  test: test\n};//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvc3dhcm0tanMvbGliL2ZpbGVzLmpzIiwibWFwcGluZ3MiOiJBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsUUFBUSxtQkFBTyxDQUFDLHNFQUFVOztBQUUxQixhQUFhLG1CQUFPLENBQUMsc0JBQVE7O0FBRTdCLGFBQWEsbUJBQU8sQ0FBQyxzQkFBUTs7QUFFN0IsU0FBUyxtQkFBTyxDQUFDLDREQUFVOztBQUUzQixVQUFVLG1CQUFPLENBQUMsZ0ZBQUs7O0FBRXZCLGFBQWEsbUJBQU8sQ0FBQyx3RUFBZ0I7O0FBRXJDLFdBQVcsbUJBQU8sQ0FBQyxrQkFBTTs7QUFFekIsVUFBVSxtQkFBTyxDQUFDLG9FQUFLLEdBQUc7QUFDMUI7QUFDQTs7O0FBR0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQSxPQUFPO0FBQ1AsS0FBSzs7QUFFTDs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBOzs7QUFHQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0EsS0FBSztBQUNMO0FBQ0EsR0FBRztBQUNIO0FBQ0E7OztBQUdBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0EsS0FBSztBQUNMO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTs7O0FBR0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIOzs7QUFHQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBLEdBQUc7QUFDSDtBQUNBOzs7QUFHQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0gsR0FBRzs7O0FBR0g7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0EsR0FBRztBQUNIO0FBQ0EsR0FBRztBQUNILEdBQUc7OztBQUdIO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0EsUUFBUTtBQUNSO0FBQ0E7O0FBRUE7QUFDQSxLQUFLO0FBQ0w7O0FBRUE7QUFDQTtBQUNBLEdBQUc7QUFDSCxHQUFHOzs7QUFHSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQLEtBQUs7QUFDTDtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTs7O0FBR0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBLFdBQVc7QUFDWDtBQUNBLFdBQVc7QUFDWDtBQUNBLFdBQVc7QUFDWDtBQUNBLFdBQVc7QUFDWDtBQUNBLFdBQVc7QUFDWDtBQUNBLFdBQVc7QUFDWDtBQUNBLFdBQVc7QUFDWDtBQUNBLFdBQVc7QUFDWDtBQUNBLFdBQVc7QUFDWDtBQUNBLFdBQVc7QUFDWCxTQUFTOztBQUVUOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDs7O0FBR0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7O0FBR0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBLGVBQWUsbUJBQU8sQ0FBQyxzQkFBUTs7QUFFL0IsZUFBZSxtQkFBTyxDQUFDLDBEQUFTO0FBQ2hDO0FBQ0EsR0FBRzs7QUFFSCxpQkFBaUIsc0RBQTRCO0FBQzdDO0FBQ0EsR0FBRzs7QUFFSDtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0EsR0FBRztBQUNIO0FBQ0EsR0FBRztBQUNIO0FBQ0EsR0FBRztBQUNIOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBIiwic291cmNlcyI6WyIvVXNlcnMvcGFuemEvRG9jdW1lbnRzL1BlcnNvbmFsUHJvamVjdHMvcHJlZGlrL25vZGVfbW9kdWxlcy9zd2FybS1qcy9saWIvZmlsZXMuanMiXSwic291cmNlc0NvbnRlbnQiOlsiLy8gVGhpcyBtb2R1bGUgaW1wbGVtZW50cyBzb21lIGZpbGUgZG93bmxvYWQgdXRpbHMuIEl0cyBtb3N0IGltcG9ydGFudCBleHBvcnRcbi8vIGlzIGBzYWZlRG93bmxvYWRUYXJnekZpbGVgLCB3aGljaCwgZ2l2ZW4gYSBmaWxlLCBpdHMgbWQ1LCBhIHRhci5neiB1cmwsIGl0c1xuLy8gbWQ1IGFuZCBhIHBhdGgsIHJldHVybnMgYSBQcm9taXNlIHRoYXQgd2lsbCBvbmx5IHJlc29sdmUgb25jZSB0aGUgZXhhY3QgZmlsZVxuLy8geW91IGV4cGVjdCBpcyBhdmFpbGFibGUgb24gdGhhdCBwYXRoLlxudmFyIFEgPSByZXF1aXJlKFwiYmx1ZWJpcmRcIik7XG5cbnZhciBhc3NlcnQgPSByZXF1aXJlKFwiYXNzZXJ0XCIpO1xuXG52YXIgY3J5cHRvID0gcmVxdWlyZShcImNyeXB0b1wiKTtcblxudmFyIGZzID0gcmVxdWlyZShcImZzLWV4dHJhXCIpO1xuXG52YXIgZ290ID0gcmVxdWlyZShcImdvdFwiKTtcblxudmFyIG1rZGlycCA9IHJlcXVpcmUoXCJta2RpcnAtcHJvbWlzZVwiKTtcblxudmFyIHBhdGggPSByZXF1aXJlKFwicGF0aFwiKTtcblxudmFyIHRhciA9IHJlcXVpcmUoXCJ0YXJcIik7IC8vIFN0cmluZyAtPiBTdHJpbmcgfj4gUHJvbWlzZSBTdHJpbmdcbi8vICAgRG93bmxvYWRzIGEgZmlsZSBmcm9tIGFuIHVybCB0byBhIHBhdGguXG4vLyAgIFJldHVybnMgYSBwcm9taXNlIGNvbnRhaW5pbmcgdGhlIHBhdGguXG5cblxudmFyIGRvd25sb2FkID0gZnVuY3Rpb24gZG93bmxvYWQodXJsKSB7XG4gIHJldHVybiBmdW5jdGlvbiAoZmlsZVBhdGgpIHtcbiAgICB2YXIgcHJvbWlzZSA9IFEucmVzb2x2ZShta2RpcnAocGF0aC5kaXJuYW1lKGZpbGVQYXRoKSkpLnRoZW4oZnVuY3Rpb24gKCkge1xuICAgICAgcmV0dXJuIG5ldyBRKGZ1bmN0aW9uIChyZXNvbHZlLCByZWplY3QpIHtcbiAgICAgICAgdmFyIHdyaXRlU3RyZWFtID0gZnMuY3JlYXRlV3JpdGVTdHJlYW0oZmlsZVBhdGgpO1xuICAgICAgICB2YXIgZG93bmxvYWRTdHJlYW0gPSBnb3Quc3RyZWFtKHVybCk7XG4gICAgICAgIGRvd25sb2FkU3RyZWFtLm9uKFwiZW5kXCIsIGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICByZXR1cm4gcmVzb2x2ZShmaWxlUGF0aCk7XG4gICAgICAgIH0pO1xuICAgICAgICBkb3dubG9hZFN0cmVhbS5vbihcImRhdGFcIiwgZnVuY3Rpb24gKGNodW5rKSB7XG4gICAgICAgICAgcmV0dXJuIHByb21pc2Uub25EYXRhQ2FsbGJhY2soY2h1bmspO1xuICAgICAgICB9KTtcbiAgICAgICAgZG93bmxvYWRTdHJlYW0ub24oXCJlcnJvclwiLCByZWplY3QpO1xuICAgICAgICBkb3dubG9hZFN0cmVhbS5waXBlKHdyaXRlU3RyZWFtKTtcbiAgICAgIH0pO1xuICAgIH0pO1xuXG4gICAgcHJvbWlzZS5vbkRhdGFDYWxsYmFjayA9IGZ1bmN0aW9uICgpIHt9O1xuXG4gICAgcHJvbWlzZS5vbkRhdGEgPSBmdW5jdGlvbiAoY2FsbGJhY2spIHtcbiAgICAgIHByb21pc2Uub25EYXRhQ2FsbGJhY2sgPSBjYWxsYmFjayB8fCBmdW5jdGlvbiAoKSB7fTtcblxuICAgICAgcmV0dXJuIHByb21pc2U7XG4gICAgfTtcblxuICAgIHJldHVybiBwcm9taXNlO1xuICB9O1xufTsgLy8gU3RyaW5nIC0+IFN0cmluZyB+PiBQcm9taXNlIFN0cmluZ1xuLy8gICBIYXNoZXMgYSBmaWxlIHVzaW5nIHRoZSBnaXZlbiBhbGdvcml0aG0gKGV4OiBcIm1kNVwiKS5cbi8vICAgUmV0dXJucyBhIHByb21pc2UgY29udGFpbmluZyB0aGUgaGFzaGVkIHN0cmluZy5cblxuXG52YXIgaGFzaCA9IGZ1bmN0aW9uIGhhc2goYWxnb3JpdGhtKSB7XG4gIHJldHVybiBmdW5jdGlvbiAocGF0aCkge1xuICAgIHJldHVybiBuZXcgUShmdW5jdGlvbiAocmVzb2x2ZSwgcmVqZWN0KSB7XG4gICAgICB2YXIgcmVhZFN0cmVhbSA9IGZzLlJlYWRTdHJlYW0ocGF0aCk7XG4gICAgICB2YXIgaGFzaCA9IGNyeXB0by5jcmVhdGVIYXNoKGFsZ29yaXRobSk7XG4gICAgICByZWFkU3RyZWFtLm9uKFwiZGF0YVwiLCBmdW5jdGlvbiAoZCkge1xuICAgICAgICByZXR1cm4gaGFzaC51cGRhdGUoZCk7XG4gICAgICB9KTtcbiAgICAgIHJlYWRTdHJlYW0ub24oXCJlbmRcIiwgZnVuY3Rpb24gKCkge1xuICAgICAgICByZXR1cm4gcmVzb2x2ZShoYXNoLmRpZ2VzdChcImhleFwiKSk7XG4gICAgICB9KTtcbiAgICAgIHJlYWRTdHJlYW0ub24oXCJlcnJvclwiLCByZWplY3QpO1xuICAgIH0pO1xuICB9O1xufTsgLy8gU3RyaW5nIC0+IFN0cmluZyB+PiBQcm9taXNlICgpXG4vLyAgIEFzc2VydHMgYSBmaWxlIG1hdGNoZXMgdGhpcyBtZDUgaGFzaC5cbi8vICAgUmV0dXJucyBhIHByb21pc2UgY29udGFpbmluZyBpdHMgcGF0aC5cblxuXG52YXIgY2hlY2tzdW0gPSBmdW5jdGlvbiBjaGVja3N1bShmaWxlSGFzaCkge1xuICByZXR1cm4gZnVuY3Rpb24gKHBhdGgpIHtcbiAgICByZXR1cm4gaGFzaChcIm1kNVwiKShwYXRoKS50aGVuKGZ1bmN0aW9uIChhY3R1YWxIYXNoKSB7XG4gICAgICByZXR1cm4gYWN0dWFsSGFzaCA9PT0gZmlsZUhhc2g7XG4gICAgfSkudGhlbihhc3NlcnQpLnRoZW4oZnVuY3Rpb24gKCkge1xuICAgICAgcmV0dXJuIHBhdGg7XG4gICAgfSk7XG4gIH07XG59OyAvLyBTdHJpbmcgfj4gU3RyaW5nIH4+IFN0cmluZyB+PiBQcm9taXNlIFN0cmluZ1xuLy8gICBEb3dubG9hZHMgYSBmaWxlIHRvIGEgZGlyZWN0b3J5LCBjaGVjay5cbi8vICAgQ2hlY2tzIGlmIHRoZSBtZDUgaGFzaCBtYXRjaGVzLlxuLy8gICBSZXR1cm5zIGEgcHJvbWlzZSBjb250YWluaW5nIHRoZSBwYXRoLlxuXG5cbnZhciBkb3dubG9hZEFuZENoZWNrID0gZnVuY3Rpb24gZG93bmxvYWRBbmRDaGVjayh1cmwpIHtcbiAgcmV0dXJuIGZ1bmN0aW9uIChwYXRoKSB7XG4gICAgcmV0dXJuIGZ1bmN0aW9uIChmaWxlSGFzaCkge1xuICAgICAgcmV0dXJuIGRvd25sb2FkKHVybCkocGF0aCkudGhlbihjaGVja3N1bShmaWxlSGFzaCkpO1xuICAgIH07XG4gIH07XG59OyAvLyBTdHJpbmcgLT4gU3RyaW5nIH4+IFByb21pc2UgU3RyaW5nXG4vLyAgIFRPRE86IHdvcmsgZm9yIHppcCBhbmQgb3RoZXIgdHlwZXNcblxuXG52YXIgZXh0cmFjdCA9IGZ1bmN0aW9uIGV4dHJhY3QoZnJvbVBhdGgpIHtcbiAgcmV0dXJuIGZ1bmN0aW9uICh0b1BhdGgpIHtcbiAgICByZXR1cm4gdGFyLngoZnJvbVBhdGgsIHRvUGF0aCkudGhlbihmdW5jdGlvbiAoKSB7XG4gICAgICByZXR1cm4gdG9QYXRoO1xuICAgIH0pO1xuICB9O1xufTsgLy8gU3RyaW5nIH4+IFByb21pc2UgU3RyaW5nXG4vLyAgIFJlYWRzIGEgZmlsZSBhcyBhbiBVVEY4IHN0cmluZy5cbi8vICAgUmV0dXJucyBhIHByb21pc2UgY29udGFpbmluZyB0aGF0IHN0cmluZy5cblxuXG52YXIgcmVhZFVURjggPSBmdW5jdGlvbiByZWFkVVRGOChwYXRoKSB7XG4gIHJldHVybiBmcy5yZWFkRmlsZShwYXRoLCB7XG4gICAgZW5jb2Rpbmc6IFwidXRmOFwiXG4gIH0pO1xufTsgLy8gU3RyaW5nIH4+IFByb21pc2UgQm9vbFxuXG5cbnZhciBpc0RpcmVjdG9yeSA9IGZ1bmN0aW9uIGlzRGlyZWN0b3J5KHBhdGgpIHtcbiAgcmV0dXJuIGZzLmV4aXN0cyhwYXRoKS50aGVuKGFzc2VydCkudGhlbihmdW5jdGlvbiAoKSB7XG4gICAgcmV0dXJuIGZzLmxzdGF0KHBhdGgpO1xuICB9KS50aGVuKGZ1bmN0aW9uIChzdGF0cykge1xuICAgIHJldHVybiBzdGF0cy5pc0RpcmVjdG9yeSgpO1xuICB9KVtcImNhdGNoXCJdKGZ1bmN0aW9uICgpIHtcbiAgICByZXR1cm4gZmFsc2U7XG4gIH0pO1xufTsgLy8gU3RyaW5nIC0+IFByb21pc2UgU3RyaW5nXG5cblxudmFyIGRpcmVjdG9yeVRyZWUgPSBmdW5jdGlvbiBkaXJlY3RvcnlUcmVlKGRpclBhdGgpIHtcbiAgdmFyIHBhdGhzID0gW107XG5cbiAgdmFyIHNlYXJjaCA9IGZ1bmN0aW9uIHNlYXJjaChkaXJQYXRoKSB7XG4gICAgcmV0dXJuIGlzRGlyZWN0b3J5KGRpclBhdGgpLnRoZW4oZnVuY3Rpb24gKGlzRGlyKSB7XG4gICAgICBpZiAoaXNEaXIpIHtcbiAgICAgICAgdmFyIHNlYXJjaE9uRGlyID0gZnVuY3Rpb24gc2VhcmNoT25EaXIoZGlyKSB7XG4gICAgICAgICAgcmV0dXJuIHNlYXJjaChwYXRoLmpvaW4oZGlyUGF0aCwgZGlyKSk7XG4gICAgICAgIH07XG5cbiAgICAgICAgcmV0dXJuIFEuYWxsKFEubWFwKGZzLnJlYWRkaXIoZGlyUGF0aCksIHNlYXJjaE9uRGlyKSk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBwYXRocy5wdXNoKGRpclBhdGgpO1xuICAgICAgfVxuXG4gICAgICA7XG4gICAgfSk7XG4gIH07XG5cbiAgcmV0dXJuIFEuYWxsKHNlYXJjaChkaXJQYXRoKSkudGhlbihmdW5jdGlvbiAoKSB7XG4gICAgcmV0dXJuIHBhdGhzO1xuICB9KTtcbn07IC8vIFJlZ2V4IC0+IFN0cmluZyB+PiBQcm9taXNlIChBcnJheSBTdHJpbmcpXG5cblxudmFyIHNlYXJjaCA9IGZ1bmN0aW9uIHNlYXJjaChyZWdleCkge1xuICByZXR1cm4gZnVuY3Rpb24gKGRpclBhdGgpIHtcbiAgICByZXR1cm4gZGlyZWN0b3J5VHJlZShkaXJQYXRoKS50aGVuKGZ1bmN0aW9uICh0cmVlKSB7XG4gICAgICByZXR1cm4gdHJlZS5maWx0ZXIoZnVuY3Rpb24gKHBhdGgpIHtcbiAgICAgICAgcmV0dXJuIHJlZ2V4LnRlc3QocGF0aCk7XG4gICAgICB9KTtcbiAgICB9KTtcbiAgfTtcbn07IC8vIFN0cmluZyAtPiBTdHJpbmcgLT4gU3RyaW5nIC0+IFN0cmluZyB+PiBQcm9taXNlIFN0cmluZ1xuLy8gICBEb3dubG9hZHMgYSBmaWxlIGluc2lkZSBhIHRhci5neiBhbmQgcGxhY2VzIGl0IGF0IGBmaWxlUGF0aGAuXG4vLyAgIENoZWNrcyB0aGUgbWQ1IGhhc2ggb2YgdGhlIHRhciBiZWZvcmUgZXh0cmFjdGluZyBpdC5cbi8vICAgQ2hlY2tzIHRoZSBtZDUgaGFzaCBvZiB0aGUgZmlsZSBhZnRlciBleHRyYWN0aW5nIGl0LlxuLy8gICBJZiBhbGwgaXMgT0ssIHJldHVybnMgYSBwcm9taXNlIGNvbnRhaW5pbmcgdGhlIGZpbGUgcGF0aC5cblxuXG52YXIgc2FmZURvd25sb2FkQXJjaGl2ZWQgPSBmdW5jdGlvbiBzYWZlRG93bmxvYWRBcmNoaXZlZCh1cmwpIHtcbiAgcmV0dXJuIGZ1bmN0aW9uIChhcmNoaXZlSGFzaCkge1xuICAgIHJldHVybiBmdW5jdGlvbiAoZmlsZUhhc2gpIHtcbiAgICAgIHJldHVybiBmdW5jdGlvbiAoZmlsZVBhdGgpIHtcbiAgICAgICAgdmFyIGZpbGVEaXIgPSBwYXRoLmRpcm5hbWUoZmlsZVBhdGgpO1xuICAgICAgICB2YXIgZmlsZU5hbWUgPSBwYXRoLmJhc2VuYW1lKGZpbGVQYXRoKTtcbiAgICAgICAgdmFyIGFyY2hpdmVQYXRoID0gcGF0aC5qb2luKGZpbGVEaXIsIFwiLnN3YXJtX2Rvd25sb2Fkcy9maWxlcy50YXIuZ3pcIik7XG4gICAgICAgIHZhciBhcmNoaXZlRGlyID0gcGF0aC5kaXJuYW1lKGFyY2hpdmVQYXRoKTtcbiAgICAgICAgdmFyIHByb21pc2UgPSBRLnJlc29sdmUobWtkaXJwKGFyY2hpdmVEaXIpKS50aGVuKGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICByZXR1cm4gY2hlY2tzdW0oZmlsZUhhc2gpKGZpbGVQYXRoKTtcbiAgICAgICAgfSkudGhlbihmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgcmV0dXJuIGZpbGVQYXRoO1xuICAgICAgICB9KVtcImNhdGNoXCJdKGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICByZXR1cm4gZnMuZXhpc3RzKGFyY2hpdmVEaXIpLnRoZW4oZnVuY3Rpb24gKGV4aXN0cykge1xuICAgICAgICAgICAgcmV0dXJuICFleGlzdHMgPyBmcy5ta2RpcihhcmNoaXZlRGlyKSA6IG51bGw7XG4gICAgICAgICAgfSkudGhlbihmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICByZXR1cm4gZG93bmxvYWQodXJsKShhcmNoaXZlUGF0aCkub25EYXRhKHByb21pc2Uub25EYXRhQ2FsbGJhY2spO1xuICAgICAgICAgIH0pLnRoZW4oZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgcmV0dXJuIGhhc2goXCJtZDVcIikoYXJjaGl2ZVBhdGgpO1xuICAgICAgICAgIH0pLnRoZW4oZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgcmV0dXJuIGFyY2hpdmVIYXNoID8gY2hlY2tzdW0oYXJjaGl2ZUhhc2gpKGFyY2hpdmVQYXRoKSA6IG51bGw7XG4gICAgICAgICAgfSkudGhlbihmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICByZXR1cm4gZXh0cmFjdChhcmNoaXZlUGF0aCkoYXJjaGl2ZURpcik7XG4gICAgICAgICAgfSkudGhlbihmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICByZXR1cm4gc2VhcmNoKG5ldyBSZWdFeHAoZmlsZU5hbWUgKyBcIiRcIikpKGFyY2hpdmVEaXIpO1xuICAgICAgICAgIH0pLnRoZW4oZnVuY3Rpb24gKGZwKSB7XG4gICAgICAgICAgICByZXR1cm4gZnMucmVuYW1lKGZwWzBdLCBmaWxlUGF0aCk7XG4gICAgICAgICAgfSkudGhlbihmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICByZXR1cm4gZnMudW5saW5rKGFyY2hpdmVQYXRoKTtcbiAgICAgICAgICB9KS50aGVuKGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIHJldHVybiBmaWxlSGFzaCA/IGNoZWNrc3VtKGZpbGVIYXNoKShmaWxlUGF0aCkgOiBudWxsO1xuICAgICAgICAgIH0pLnRoZW4oZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgcmV0dXJuIGZpbGVQYXRoO1xuICAgICAgICAgIH0pO1xuICAgICAgICB9KTtcblxuICAgICAgICBwcm9taXNlLm9uRGF0YUNhbGxiYWNrID0gZnVuY3Rpb24gKCkge307XG5cbiAgICAgICAgcHJvbWlzZS5vbkRhdGEgPSBmdW5jdGlvbiAoY2FsbGJhY2spIHtcbiAgICAgICAgICBwcm9taXNlLm9uRGF0YUNhbGxiYWNrID0gY2FsbGJhY2sgfHwgZnVuY3Rpb24gKCkge307XG5cbiAgICAgICAgICByZXR1cm4gcHJvbWlzZTtcbiAgICAgICAgfTtcblxuICAgICAgICByZXR1cm4gcHJvbWlzZTtcbiAgICAgIH07XG4gICAgfTtcbiAgfTtcbn07IC8vIFN0cmluZyAtPiBTdHJpbmcgfj4gUHJvbWlzZSBTdHJpbmdcbi8vICAgTGlrZSBgc2FmZURvd25sb2FkQXJjaGl2ZWRGaWxlYCwgYnV0IHdpdGhvdXQgdGhlIGNoZWNrc3Vtcy5cblxuXG52YXIgZG93bmxvYWRBcmNoaXZlZCA9IGZ1bmN0aW9uIGRvd25sb2FkQXJjaGl2ZWQodXJsKSB7XG4gIHJldHVybiBmdW5jdGlvbiAocGF0aCkge1xuICAgIHJldHVybiBzYWZlRG93bmxvYWRBcmNoaXZlZCh1cmwpKG51bGwpKG51bGwpKHBhdGgpO1xuICB9O1xufTsgLy8gKCkgPT4gUHJvbWlzZSBCb29sXG4vLyAgIFRlc3RzIHRoZSBpbXBsZW1lbnRhdGlvbiBieSBkb3dubG9hZGluZyBhIHByZWRldGVybWluZWQgdGFyLmd6XG4vLyAgIGZyb20gYSBtb2NrZWQgSFRUUC1zZXJ2ZXIgaW50byBhIG1vY2tlZCBmaWxlc3lzdGVtLiBEb2VzIHNvbWVcbi8vICAgcmVkdW5kYW5jeSB0ZXN0cyBzdWNoIGFzIGNoZWNraW5nIHRoZSBmaWxlIGNvbnN0ZW50cyBhbmQgZG91YmxlXG4vLyAgIGNoZWNraW5nIGl0cyBNRDUgaGFzaC5cbi8vICAgUmV0dXJucyBhIHByb21pc2UgY29udGFpbmluZyBhIGJvb2xlYW4sIHRydWUgaWYgdGVzdHMgcGFzc2VkLlxuXG5cbnZhciB0ZXN0ID0gZnVuY3Rpb24gdGVzdCgpIHtcbiAgdmFyIGZpbGVQYXRoID0gXCIvc3dhcm0vZm9vLnR4dFwiO1xuICB2YXIgZmlsZUhhc2ggPSBcImQzYjA3Mzg0ZDExM2VkZWM0OWVhYTYyMzhhZDVmZjAwXCI7XG4gIHZhciBhcmNoaXZlVXJsID0gXCJodHRwOi8vbG9jYWxob3N0OjEyNTM0XCI7XG4gIHZhciBhcmNoaXZlSGFzaCA9IFwiN2ZhNDVmOTQ2YmIyYTY5NmJkZDk5NzJlMGZiY2VhYzJcIjtcbiAgdmFyIGFyY2hpdmVEYXRhID0gbmV3IEJ1ZmZlcihbMHgxZiwgMHg4YiwgMHgwOCwgMHgwMCwgMHhmMSwgMHgzNCwgMHhhZiwgMHg1OCwgMHgwMCwgMHgwMywgMHhlZCwgMHhjZiwgMHgzZCwgMHgwZSwgMHg4MywgMHgzMCwgMHgwYywgMHg4NiwgMHg2MSwgMHg2NiwgMHg0ZSwgMHhlMSwgMHgxMywgMHg1NCwgMHhjZSwgMHgwZiwgMHhjOSwgMHg3OSwgMHg1OCwgMHhiMiwgMHg0NiwgMHg4MiwgMHgxNCwgMHg3MSwgMHg3YywgMHhkMiwgMHgwNiwgMHgzMSwgMHg1MiwgMHg3NSwgMHg0MCwgMHgwOCwgMHhlOSwgMHg3ZCwgMHg5NiwgMHg0ZiwgMHg5NiwgMHgzZCwgMHg3YywgMHg0ZSwgMHgzOSwgMHhiZiwgMHhjYSwgMHg1YSwgMHhiYSwgMHgyYiwgMHhhOSwgMHg2YSwgMHhmMCwgMHg1ZSwgMHgzZSwgMHgxOSwgMHhjMywgMHhmMCwgMHg0ZCwgMHhiNSwgMHg2ZCwgMHhkZSwgMHg3OSwgMHgzMSwgMHg0ZSwgMHgwNywgMHgxNywgMHg5YywgMHhiNSwgMHgzMSwgMHg4YSwgMHgxYSwgMHhhYiwgMHhjNiwgMHg3NywgMHhhMiwgMHg5NywgMHhiNiwgMHhkYSwgMHhiZCwgMHhlNywgMHgzMiwgMHg0ZSwgMHhiNSwgMHhjYSwgMHhmMiwgMHhlMywgMHhhZSwgMHg5ZSwgMHhhNSwgMHg3NCwgMHhiMiwgMHg2ZiwgMHg4ZiwgMHhjOCwgMHg5MSwgMHgwZiwgMHg5MSwgMHg3MiwgMHhlZSwgMHhlZiwgMHhlZSwgMHgwMCwgMHgwMCwgMHgwMCwgMHgwMCwgMHgwMCwgMHgwMCwgMHgwMCwgMHgwMCwgMHgwMCwgMHgwMCwgMHgwMCwgMHgwMCwgMHgwMCwgMHgwMCwgMHhmOCwgMHhkZiwgMHgwNiwgMHhiMywgMHgyYSwgMHhkYSwgMHhlZCwgMHgwMCwgMHgyOCwgMHgwMCwgMHgwMF0pO1xuXG4gIHZhciBjcnlwdG8gPSByZXF1aXJlKFwiY3J5cHRvXCIpO1xuXG4gIHZhciBmc01vY2sgPSByZXF1aXJlKFwibW9jay1mc1wiKSh7XG4gICAgXCIvc3dhcm1cIjoge31cbiAgfSk7XG5cbiAgdmFyIGh0dHBNb2NrID0gcmVxdWlyZShcImh0dHBcIikuY3JlYXRlU2VydmVyKGZ1bmN0aW9uIChfLCByZXMpIHtcbiAgICByZXR1cm4gcmVzLmVuZChhcmNoaXZlRGF0YSk7XG4gIH0pLmxpc3RlbigxMjUzNCk7XG5cbiAgcmV0dXJuIHNhZmVEb3dubG9hZEFyY2hpdmVkKGFyY2hpdmVVcmwpKGFyY2hpdmVIYXNoKShmaWxlSGFzaCkoZmlsZVBhdGgpLnRoZW4oY2hlY2tzdW0oZmlsZUhhc2gpKS50aGVuKHJlYWRVVEY4KS50aGVuKGZ1bmN0aW9uICh0ZXh0KSB7XG4gICAgcmV0dXJuIHRleHQgPT09IFwiZm9vXFxuXCI7XG4gIH0pLnRoZW4oYXNzZXJ0KS50aGVuKGZ1bmN0aW9uICgpIHtcbiAgICByZXR1cm4gc2FmZURvd25sb2FkQXJjaGl2ZWQoYXJjaGl2ZVVybCkoYXJjaGl2ZUhhc2gpKGZpbGVIYXNoKShmaWxlUGF0aCk7XG4gIH0pLnRoZW4oZnVuY3Rpb24gKCkge1xuICAgIHJldHVybiB0cnVlO1xuICB9KVtcImNhdGNoXCJdKGZhbHNlKVtcImZpbmFsbHlcIl0oZnVuY3Rpb24gKCkge1xuICAgIHJldHVybiBodHRwTW9jay5jbG9zZSgpO1xuICB9KTtcbn07XG5cbm1vZHVsZS5leHBvcnRzID0ge1xuICBkb3dubG9hZDogZG93bmxvYWQsXG4gIGhhc2g6IGhhc2gsXG4gIGNoZWNrc3VtOiBjaGVja3N1bSxcbiAgZG93bmxvYWRBbmRDaGVjazogZG93bmxvYWRBbmRDaGVjayxcbiAgZXh0cmFjdDogZXh0cmFjdCxcbiAgcmVhZFVURjg6IHJlYWRVVEY4LFxuICBzYWZlRG93bmxvYWRBcmNoaXZlZDogc2FmZURvd25sb2FkQXJjaGl2ZWQsXG4gIGRpcmVjdG9yeVRyZWU6IGRpcmVjdG9yeVRyZWUsXG4gIGRvd25sb2FkQXJjaGl2ZWQ6IGRvd25sb2FkQXJjaGl2ZWQsXG4gIHNlYXJjaDogc2VhcmNoLFxuICB0ZXN0OiB0ZXN0XG59OyJdLCJuYW1lcyI6W10sImlnbm9yZUxpc3QiOlswXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/swarm-js/lib/files.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/swarm-js/lib/pick.js":
/*!*******************************************!*\
  !*** ./node_modules/swarm-js/lib/pick.js ***!
  \*******************************************/
/***/ ((module) => {

eval("var picker = function picker(type) {\n  return function () {\n    return new Promise(function (resolve, reject) {\n      var fileLoader = function fileLoader(e) {\n        var directory = {};\n        var totalFiles = e.target.files.length;\n        var loadedFiles = 0;\n        [].map.call(e.target.files, function (file) {\n          var reader = new FileReader();\n\n          reader.onload = function (e) {\n            var data = new Uint8Array(e.target.result);\n\n            if (type === \"directory\") {\n              var path = file.webkitRelativePath;\n              directory[path.slice(path.indexOf(\"/\") + 1)] = {\n                type: \"text/plain\",\n                data: data\n              };\n              if (++loadedFiles === totalFiles) resolve(directory);\n            } else if (type === \"file\") {\n              var _path = file.webkitRelativePath;\n              resolve({\n                \"type\": mimetype.lookup(_path),\n                \"data\": data\n              });\n            } else {\n              resolve(data);\n            }\n          };\n\n          reader.readAsArrayBuffer(file);\n        });\n      };\n\n      var fileInput;\n\n      if (type === \"directory\") {\n        fileInput = document.createElement(\"input\");\n        fileInput.addEventListener(\"change\", fileLoader);\n        fileInput.type = \"file\";\n        fileInput.webkitdirectory = true;\n        fileInput.mozdirectory = true;\n        fileInput.msdirectory = true;\n        fileInput.odirectory = true;\n        fileInput.directory = true;\n      } else {\n        fileInput = document.createElement(\"input\");\n        fileInput.addEventListener(\"change\", fileLoader);\n        fileInput.type = \"file\";\n      }\n\n      ;\n      var mouseEvent = document.createEvent(\"MouseEvents\");\n      mouseEvent.initEvent(\"click\", true, false);\n      fileInput.dispatchEvent(mouseEvent);\n    });\n  };\n};\n\nmodule.exports = {\n  data: picker(\"data\"),\n  file: picker(\"file\"),\n  directory: picker(\"directory\")\n};//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvc3dhcm0tanMvbGliL3BpY2suanMiLCJtYXBwaW5ncyI6IkFBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxjQUFjO0FBQ2Q7QUFDQTtBQUNBO0FBQ0E7QUFDQSxlQUFlO0FBQ2YsY0FBYztBQUNkO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLFNBQVM7QUFDVDs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxRQUFRO0FBQ1I7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBIiwic291cmNlcyI6WyIvVXNlcnMvcGFuemEvRG9jdW1lbnRzL1BlcnNvbmFsUHJvamVjdHMvcHJlZGlrL25vZGVfbW9kdWxlcy9zd2FybS1qcy9saWIvcGljay5qcyJdLCJzb3VyY2VzQ29udGVudCI6WyJ2YXIgcGlja2VyID0gZnVuY3Rpb24gcGlja2VyKHR5cGUpIHtcbiAgcmV0dXJuIGZ1bmN0aW9uICgpIHtcbiAgICByZXR1cm4gbmV3IFByb21pc2UoZnVuY3Rpb24gKHJlc29sdmUsIHJlamVjdCkge1xuICAgICAgdmFyIGZpbGVMb2FkZXIgPSBmdW5jdGlvbiBmaWxlTG9hZGVyKGUpIHtcbiAgICAgICAgdmFyIGRpcmVjdG9yeSA9IHt9O1xuICAgICAgICB2YXIgdG90YWxGaWxlcyA9IGUudGFyZ2V0LmZpbGVzLmxlbmd0aDtcbiAgICAgICAgdmFyIGxvYWRlZEZpbGVzID0gMDtcbiAgICAgICAgW10ubWFwLmNhbGwoZS50YXJnZXQuZmlsZXMsIGZ1bmN0aW9uIChmaWxlKSB7XG4gICAgICAgICAgdmFyIHJlYWRlciA9IG5ldyBGaWxlUmVhZGVyKCk7XG5cbiAgICAgICAgICByZWFkZXIub25sb2FkID0gZnVuY3Rpb24gKGUpIHtcbiAgICAgICAgICAgIHZhciBkYXRhID0gbmV3IFVpbnQ4QXJyYXkoZS50YXJnZXQucmVzdWx0KTtcblxuICAgICAgICAgICAgaWYgKHR5cGUgPT09IFwiZGlyZWN0b3J5XCIpIHtcbiAgICAgICAgICAgICAgdmFyIHBhdGggPSBmaWxlLndlYmtpdFJlbGF0aXZlUGF0aDtcbiAgICAgICAgICAgICAgZGlyZWN0b3J5W3BhdGguc2xpY2UocGF0aC5pbmRleE9mKFwiL1wiKSArIDEpXSA9IHtcbiAgICAgICAgICAgICAgICB0eXBlOiBcInRleHQvcGxhaW5cIixcbiAgICAgICAgICAgICAgICBkYXRhOiBkYXRhXG4gICAgICAgICAgICAgIH07XG4gICAgICAgICAgICAgIGlmICgrK2xvYWRlZEZpbGVzID09PSB0b3RhbEZpbGVzKSByZXNvbHZlKGRpcmVjdG9yeSk7XG4gICAgICAgICAgICB9IGVsc2UgaWYgKHR5cGUgPT09IFwiZmlsZVwiKSB7XG4gICAgICAgICAgICAgIHZhciBfcGF0aCA9IGZpbGUud2Via2l0UmVsYXRpdmVQYXRoO1xuICAgICAgICAgICAgICByZXNvbHZlKHtcbiAgICAgICAgICAgICAgICBcInR5cGVcIjogbWltZXR5cGUubG9va3VwKF9wYXRoKSxcbiAgICAgICAgICAgICAgICBcImRhdGFcIjogZGF0YVxuICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgIHJlc29sdmUoZGF0YSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfTtcblxuICAgICAgICAgIHJlYWRlci5yZWFkQXNBcnJheUJ1ZmZlcihmaWxlKTtcbiAgICAgICAgfSk7XG4gICAgICB9O1xuXG4gICAgICB2YXIgZmlsZUlucHV0O1xuXG4gICAgICBpZiAodHlwZSA9PT0gXCJkaXJlY3RvcnlcIikge1xuICAgICAgICBmaWxlSW5wdXQgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KFwiaW5wdXRcIik7XG4gICAgICAgIGZpbGVJbnB1dC5hZGRFdmVudExpc3RlbmVyKFwiY2hhbmdlXCIsIGZpbGVMb2FkZXIpO1xuICAgICAgICBmaWxlSW5wdXQudHlwZSA9IFwiZmlsZVwiO1xuICAgICAgICBmaWxlSW5wdXQud2Via2l0ZGlyZWN0b3J5ID0gdHJ1ZTtcbiAgICAgICAgZmlsZUlucHV0Lm1vemRpcmVjdG9yeSA9IHRydWU7XG4gICAgICAgIGZpbGVJbnB1dC5tc2RpcmVjdG9yeSA9IHRydWU7XG4gICAgICAgIGZpbGVJbnB1dC5vZGlyZWN0b3J5ID0gdHJ1ZTtcbiAgICAgICAgZmlsZUlucHV0LmRpcmVjdG9yeSA9IHRydWU7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBmaWxlSW5wdXQgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KFwiaW5wdXRcIik7XG4gICAgICAgIGZpbGVJbnB1dC5hZGRFdmVudExpc3RlbmVyKFwiY2hhbmdlXCIsIGZpbGVMb2FkZXIpO1xuICAgICAgICBmaWxlSW5wdXQudHlwZSA9IFwiZmlsZVwiO1xuICAgICAgfVxuXG4gICAgICA7XG4gICAgICB2YXIgbW91c2VFdmVudCA9IGRvY3VtZW50LmNyZWF0ZUV2ZW50KFwiTW91c2VFdmVudHNcIik7XG4gICAgICBtb3VzZUV2ZW50LmluaXRFdmVudChcImNsaWNrXCIsIHRydWUsIGZhbHNlKTtcbiAgICAgIGZpbGVJbnB1dC5kaXNwYXRjaEV2ZW50KG1vdXNlRXZlbnQpO1xuICAgIH0pO1xuICB9O1xufTtcblxubW9kdWxlLmV4cG9ydHMgPSB7XG4gIGRhdGE6IHBpY2tlcihcImRhdGFcIiksXG4gIGZpbGU6IHBpY2tlcihcImZpbGVcIiksXG4gIGRpcmVjdG9yeTogcGlja2VyKFwiZGlyZWN0b3J5XCIpXG59OyJdLCJuYW1lcyI6W10sImlnbm9yZUxpc3QiOlswXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/swarm-js/lib/pick.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/swarm-js/lib/swarm-hash.js":
/*!*************************************************!*\
  !*** ./node_modules/swarm-js/lib/swarm-hash.js ***!
  \*************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

eval("// Thanks https://github.com/axic/swarmhash\nvar keccak = (__webpack_require__(/*! eth-lib/lib/hash */ \"(ssr)/./node_modules/eth-lib/lib/hash.js\").keccak256);\n\nvar Bytes = __webpack_require__(/*! eth-lib/lib/bytes */ \"(ssr)/./node_modules/eth-lib/lib/bytes.js\");\n\nvar swarmHashBlock = function swarmHashBlock(length, data) {\n  var lengthEncoded = Bytes.reverse(Bytes.pad(6, Bytes.fromNumber(length)));\n  var bytes = Bytes.flatten([lengthEncoded, \"0x0000\", data]);\n  return keccak(bytes).slice(2);\n}; // (Bytes | Uint8Array | String) -> String\n\n\nvar swarmHash = function swarmHash(data) {\n  if (typeof data === \"string\" && data.slice(0, 2) !== \"0x\") {\n    data = Bytes.fromString(data);\n  } else if (typeof data !== \"string\" && data.length !== undefined) {\n    data = Bytes.fromUint8Array(data);\n  }\n\n  var length = Bytes.length(data);\n\n  if (length <= 4096) {\n    return swarmHashBlock(length, data);\n  }\n\n  var maxSize = 4096;\n\n  while (maxSize * (4096 / 32) < length) {\n    maxSize *= 4096 / 32;\n  }\n\n  var innerNodes = [];\n\n  for (var i = 0; i < length; i += maxSize) {\n    var size = maxSize < length - i ? maxSize : length - i;\n    innerNodes.push(swarmHash(Bytes.slice(data, i, i + size)));\n  }\n\n  return swarmHashBlock(length, Bytes.flatten(innerNodes));\n};\n\nmodule.exports = swarmHash;//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvc3dhcm0tanMvbGliL3N3YXJtLWhhc2guanMiLCJtYXBwaW5ncyI6IkFBQUE7QUFDQSxhQUFhLG1HQUFxQzs7QUFFbEQsWUFBWSxtQkFBTyxDQUFDLG9FQUFtQjs7QUFFdkM7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHOzs7QUFHSDtBQUNBO0FBQ0E7QUFDQSxJQUFJO0FBQ0o7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBOztBQUVBOztBQUVBLGtCQUFrQixZQUFZO0FBQzlCO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBIiwic291cmNlcyI6WyIvVXNlcnMvcGFuemEvRG9jdW1lbnRzL1BlcnNvbmFsUHJvamVjdHMvcHJlZGlrL25vZGVfbW9kdWxlcy9zd2FybS1qcy9saWIvc3dhcm0taGFzaC5qcyJdLCJzb3VyY2VzQ29udGVudCI6WyIvLyBUaGFua3MgaHR0cHM6Ly9naXRodWIuY29tL2F4aWMvc3dhcm1oYXNoXG52YXIga2VjY2FrID0gcmVxdWlyZShcImV0aC1saWIvbGliL2hhc2hcIikua2VjY2FrMjU2O1xuXG52YXIgQnl0ZXMgPSByZXF1aXJlKFwiZXRoLWxpYi9saWIvYnl0ZXNcIik7XG5cbnZhciBzd2FybUhhc2hCbG9jayA9IGZ1bmN0aW9uIHN3YXJtSGFzaEJsb2NrKGxlbmd0aCwgZGF0YSkge1xuICB2YXIgbGVuZ3RoRW5jb2RlZCA9IEJ5dGVzLnJldmVyc2UoQnl0ZXMucGFkKDYsIEJ5dGVzLmZyb21OdW1iZXIobGVuZ3RoKSkpO1xuICB2YXIgYnl0ZXMgPSBCeXRlcy5mbGF0dGVuKFtsZW5ndGhFbmNvZGVkLCBcIjB4MDAwMFwiLCBkYXRhXSk7XG4gIHJldHVybiBrZWNjYWsoYnl0ZXMpLnNsaWNlKDIpO1xufTsgLy8gKEJ5dGVzIHwgVWludDhBcnJheSB8IFN0cmluZykgLT4gU3RyaW5nXG5cblxudmFyIHN3YXJtSGFzaCA9IGZ1bmN0aW9uIHN3YXJtSGFzaChkYXRhKSB7XG4gIGlmICh0eXBlb2YgZGF0YSA9PT0gXCJzdHJpbmdcIiAmJiBkYXRhLnNsaWNlKDAsIDIpICE9PSBcIjB4XCIpIHtcbiAgICBkYXRhID0gQnl0ZXMuZnJvbVN0cmluZyhkYXRhKTtcbiAgfSBlbHNlIGlmICh0eXBlb2YgZGF0YSAhPT0gXCJzdHJpbmdcIiAmJiBkYXRhLmxlbmd0aCAhPT0gdW5kZWZpbmVkKSB7XG4gICAgZGF0YSA9IEJ5dGVzLmZyb21VaW50OEFycmF5KGRhdGEpO1xuICB9XG5cbiAgdmFyIGxlbmd0aCA9IEJ5dGVzLmxlbmd0aChkYXRhKTtcblxuICBpZiAobGVuZ3RoIDw9IDQwOTYpIHtcbiAgICByZXR1cm4gc3dhcm1IYXNoQmxvY2sobGVuZ3RoLCBkYXRhKTtcbiAgfVxuXG4gIHZhciBtYXhTaXplID0gNDA5NjtcblxuICB3aGlsZSAobWF4U2l6ZSAqICg0MDk2IC8gMzIpIDwgbGVuZ3RoKSB7XG4gICAgbWF4U2l6ZSAqPSA0MDk2IC8gMzI7XG4gIH1cblxuICB2YXIgaW5uZXJOb2RlcyA9IFtdO1xuXG4gIGZvciAodmFyIGkgPSAwOyBpIDwgbGVuZ3RoOyBpICs9IG1heFNpemUpIHtcbiAgICB2YXIgc2l6ZSA9IG1heFNpemUgPCBsZW5ndGggLSBpID8gbWF4U2l6ZSA6IGxlbmd0aCAtIGk7XG4gICAgaW5uZXJOb2Rlcy5wdXNoKHN3YXJtSGFzaChCeXRlcy5zbGljZShkYXRhLCBpLCBpICsgc2l6ZSkpKTtcbiAgfVxuXG4gIHJldHVybiBzd2FybUhhc2hCbG9jayhsZW5ndGgsIEJ5dGVzLmZsYXR0ZW4oaW5uZXJOb2RlcykpO1xufTtcblxubW9kdWxlLmV4cG9ydHMgPSBzd2FybUhhc2g7Il0sIm5hbWVzIjpbXSwiaWdub3JlTGlzdCI6WzBdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/swarm-js/lib/swarm-hash.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/swarm-js/lib/swarm.js":
/*!********************************************!*\
  !*** ./node_modules/swarm-js/lib/swarm.js ***!
  \********************************************/
/***/ ((module) => {

eval("// TODO: this is a temporary fix to hide those libraries from the browser. A\n// slightly better long-term solution would be to split this file into two,\n// separating the functions that are used on Node.js from the functions that\n// are used only on the browser.\nmodule.exports = function (_ref) {\n  var fs = _ref.fs,\n      files = _ref.files,\n      os = _ref.os,\n      path = _ref.path,\n      child_process = _ref.child_process,\n      mimetype = _ref.mimetype,\n      defaultArchives = _ref.defaultArchives,\n      request = _ref.request,\n      downloadUrl = _ref.downloadUrl,\n      bytes = _ref.bytes,\n      hash = _ref.hash,\n      pick = _ref.pick;\n\n  // ∀ a . String -> JSON -> Map String a -o Map String a\n  //   Inserts a key/val pair in an object impurely.\n  var impureInsert = function impureInsert(key) {\n    return function (val) {\n      return function (map) {\n        return map[key] = val, map;\n      };\n    };\n  }; // String -> JSON -> Map String JSON\n  //   Merges an array of keys and an array of vals into an object.\n\n\n  var toMap = function toMap(keys) {\n    return function (vals) {\n      var map = {};\n\n      for (var i = 0, l = keys.length; i < l; ++i) {\n        map[keys[i]] = vals[i];\n      }\n\n      return map;\n    };\n  }; // ∀ a . Map String a -> Map String a -> Map String a\n  //   Merges two maps into one.\n\n\n  var merge = function merge(a) {\n    return function (b) {\n      var map = {};\n\n      for (var key in a) {\n        map[key] = a[key];\n      }\n\n      for (var _key in b) {\n        map[_key] = b[_key];\n      }\n\n      return map;\n    };\n  }; // ∀ a . [a] -> [a] -> Bool\n\n\n  var equals = function equals(a) {\n    return function (b) {\n      if (a.length !== b.length) {\n        return false;\n      } else {\n        for (var i = 0, l = a.length; i < l; ++i) {\n          if (a[i] !== b[i]) return false;\n        }\n      }\n\n      return true;\n    };\n  }; // String -> String -> String\n\n\n  var rawUrl = function rawUrl(swarmUrl) {\n    return function (hash) {\n      return \"\".concat(swarmUrl, \"/bzz-raw:/\").concat(hash);\n    };\n  }; // String -> String -> Promise Uint8Array\n  //   Gets the raw contents of a Swarm hash address.\n\n\n  var downloadData = function downloadData(swarmUrl) {\n    return function (hash) {\n      return new Promise(function (resolve, reject) {\n        request(rawUrl(swarmUrl)(hash), {\n          responseType: \"arraybuffer\"\n        }, function (err, arrayBuffer, response) {\n          if (err) {\n            return reject(err);\n          }\n\n          if (response.statusCode >= 400) {\n            return reject(new Error(\"Error \".concat(response.statusCode, \".\")));\n          }\n\n          return resolve(new Uint8Array(arrayBuffer));\n        });\n      });\n    };\n  }; // type Entry = {\"type\": String, \"hash\": String}\n  // type File = {\"type\": String, \"data\": Uint8Array}\n  // String -> String -> Promise (Map String Entry)\n  //   Solves the manifest of a Swarm address recursively.\n  //   Returns a map from full paths to entries.\n\n\n  var downloadEntries = function downloadEntries(swarmUrl) {\n    return function (hash) {\n      var search = function search(hash) {\n        return function (path) {\n          return function (routes) {\n            // Formats an entry to the Swarm.js type.\n            var format = function format(entry) {\n              return {\n                type: entry.contentType,\n                hash: entry.hash\n              };\n            }; // To download a single entry:\n            //   if type is bzz-manifest, go deeper\n            //   if not, add it to the routing table\n\n\n            var downloadEntry = function downloadEntry(entry) {\n              if (entry.path === undefined) {\n                return Promise.resolve();\n              } else {\n                return entry.contentType === \"application/bzz-manifest+json\" ? search(entry.hash)(path + entry.path)(routes) : Promise.resolve(impureInsert(path + entry.path)(format(entry))(routes));\n              }\n            }; // Downloads the initial manifest and then each entry.\n\n\n            return downloadData(swarmUrl)(hash).then(function (text) {\n              return JSON.parse(toString(text)).entries;\n            }).then(function (entries) {\n              return Promise.all(entries.map(downloadEntry));\n            }).then(function () {\n              return routes;\n            });\n          };\n        };\n      };\n\n      return search(hash)(\"\")({});\n    };\n  }; // String -> String -> Promise (Map String String)\n  //   Same as `downloadEntries`, but returns only hashes (no types).\n\n\n  var downloadRoutes = function downloadRoutes(swarmUrl) {\n    return function (hash) {\n      return downloadEntries(swarmUrl)(hash).then(function (entries) {\n        return toMap(Object.keys(entries))(Object.keys(entries).map(function (route) {\n          return entries[route].hash;\n        }));\n      });\n    };\n  }; // String -> String -> Promise (Map String File)\n  //   Gets the entire directory tree in a Swarm address.\n  //   Returns a promise mapping paths to file contents.\n\n\n  var downloadDirectory = function downloadDirectory(swarmUrl) {\n    return function (hash) {\n      return downloadEntries(swarmUrl)(hash).then(function (entries) {\n        var paths = Object.keys(entries);\n        var hashs = paths.map(function (path) {\n          return entries[path].hash;\n        });\n        var types = paths.map(function (path) {\n          return entries[path].type;\n        });\n        var datas = hashs.map(downloadData(swarmUrl));\n\n        var files = function files(datas) {\n          return datas.map(function (data, i) {\n            return {\n              type: types[i],\n              data: data\n            };\n          });\n        };\n\n        return Promise.all(datas).then(function (datas) {\n          return toMap(paths)(files(datas));\n        });\n      });\n    };\n  }; // String -> String -> String -> Promise String\n  //   Gets the raw contents of a Swarm hash address.\n  //   Returns a promise with the downloaded file path.\n\n\n  var downloadDataToDisk = function downloadDataToDisk(swarmUrl) {\n    return function (hash) {\n      return function (filePath) {\n        return files.download(rawUrl(swarmUrl)(hash))(filePath);\n      };\n    };\n  }; // String -> String -> String -> Promise (Map String String)\n  //   Gets the entire directory tree in a Swarm address.\n  //   Returns a promise mapping paths to file contents.\n\n\n  var downloadDirectoryToDisk = function downloadDirectoryToDisk(swarmUrl) {\n    return function (hash) {\n      return function (dirPath) {\n        return downloadRoutes(swarmUrl)(hash).then(function (routingTable) {\n          var downloads = [];\n\n          for (var route in routingTable) {\n            if (route.length > 0) {\n              var filePath = path.join(dirPath, route);\n              downloads.push(downloadDataToDisk(swarmUrl)(routingTable[route])(filePath));\n            }\n\n            ;\n          }\n\n          ;\n          return Promise.all(downloads).then(function () {\n            return dirPath;\n          });\n        });\n      };\n    };\n  }; // String -> Uint8Array -> Promise String\n  //   Uploads raw data to Swarm.\n  //   Returns a promise with the uploaded hash.\n\n\n  var uploadData = function uploadData(swarmUrl) {\n    return function (data) {\n      return new Promise(function (resolve, reject) {\n        var params = {\n          body: typeof data === \"string\" ? fromString(data) : data,\n          method: \"POST\"\n        };\n        request(\"\".concat(swarmUrl, \"/bzz-raw:/\"), params, function (err, data) {\n          if (err) {\n            return reject(err);\n          }\n\n          return resolve(data);\n        });\n      });\n    };\n  }; // String -> String -> String -> File -> Promise String\n  //   Uploads a file to the Swarm manifest at a given hash, under a specific\n  //   route. Returns a promise containing the uploaded hash.\n  //   FIXME: for some reasons Swarm-Gateways is sometimes returning\n  //   error 404 (bad request), so we retry up to 3 times. Why?\n\n\n  var uploadToManifest = function uploadToManifest(swarmUrl) {\n    return function (hash) {\n      return function (route) {\n        return function (file) {\n          var attempt = function attempt(n) {\n            var slashRoute = route[0] === \"/\" ? route : \"/\" + route;\n            var url = \"\".concat(swarmUrl, \"/bzz:/\").concat(hash).concat(slashRoute);\n            var opt = {\n              method: \"PUT\",\n              headers: {\n                \"Content-Type\": file.type\n              },\n              body: file.data\n            };\n            return new Promise(function (resolve, reject) {\n              request(url, opt, function (err, data) {\n                if (err) {\n                  return reject(err);\n                }\n\n                if (data.indexOf(\"error\") !== -1) {\n                  return reject(data);\n                }\n\n                return resolve(data);\n              });\n            })[\"catch\"](function (e) {\n              return n > 0 && attempt(n - 1);\n            });\n          };\n\n          return attempt(3);\n        };\n      };\n    };\n  }; // String -> {type: String, data: Uint8Array} -> Promise String\n\n\n  var uploadFile = function uploadFile(swarmUrl) {\n    return function (file) {\n      return uploadDirectory(swarmUrl)({\n        \"\": file\n      });\n    };\n  }; // String -> String -> Promise String\n\n\n  var uploadFileFromDisk = function uploadFileFromDisk(swarmUrl) {\n    return function (filePath) {\n      return fs.readFile(filePath).then(function (data) {\n        return uploadFile(swarmUrl)({\n          type: mimetype.lookup(filePath),\n          data: data\n        });\n      });\n    };\n  }; // String -> Map String File -> Promise String\n  //   Uploads a directory to Swarm. The directory is\n  //   represented as a map of routes and files.\n  //   A default path is encoded by having a \"\" route.\n\n\n  var uploadDirectory = function uploadDirectory(swarmUrl) {\n    return function (directory) {\n      return uploadData(swarmUrl)(\"{}\").then(function (hash) {\n        var uploadRoute = function uploadRoute(route) {\n          return function (hash) {\n            return uploadToManifest(swarmUrl)(hash)(route)(directory[route]);\n          };\n        };\n\n        var uploadToHash = function uploadToHash(hash, route) {\n          return hash.then(uploadRoute(route));\n        };\n\n        return Object.keys(directory).reduce(uploadToHash, Promise.resolve(hash));\n      });\n    };\n  }; // String -> Promise String\n\n\n  var uploadDataFromDisk = function uploadDataFromDisk(swarmUrl) {\n    return function (filePath) {\n      return fs.readFile(filePath).then(uploadData(swarmUrl));\n    };\n  }; // String -> Nullable String -> String -> Promise String\n\n\n  var uploadDirectoryFromDisk = function uploadDirectoryFromDisk(swarmUrl) {\n    return function (defaultPath) {\n      return function (dirPath) {\n        return files.directoryTree(dirPath).then(function (fullPaths) {\n          return Promise.all(fullPaths.map(function (path) {\n            return fs.readFile(path);\n          })).then(function (datas) {\n            var paths = fullPaths.map(function (path) {\n              return path.slice(dirPath.length);\n            });\n            var types = fullPaths.map(function (path) {\n              return mimetype.lookup(path) || \"text/plain\";\n            });\n            return toMap(paths)(datas.map(function (data, i) {\n              return {\n                type: types[i],\n                data: data\n              };\n            }));\n          });\n        }).then(function (directory) {\n          return merge(defaultPath ? {\n            \"\": directory[defaultPath]\n          } : {})(directory);\n        }).then(uploadDirectory(swarmUrl));\n      };\n    };\n  }; // String -> UploadInfo -> Promise String\n  //   Simplified multi-type upload which calls the correct\n  //   one based on the type of the argument given.\n\n\n  var _upload = function upload(swarmUrl) {\n    return function (arg) {\n      // Upload raw data from browser\n      if (arg.pick === \"data\") {\n        return pick.data().then(uploadData(swarmUrl)); // Upload a file from browser\n      } else if (arg.pick === \"file\") {\n        return pick.file().then(uploadFile(swarmUrl)); // Upload a directory from browser\n      } else if (arg.pick === \"directory\") {\n        return pick.directory().then(uploadDirectory(swarmUrl)); // Upload directory/file from disk\n      } else if (arg.path) {\n        switch (arg.kind) {\n          case \"data\":\n            return uploadDataFromDisk(swarmUrl)(arg.path);\n\n          case \"file\":\n            return uploadFileFromDisk(swarmUrl)(arg.path);\n\n          case \"directory\":\n            return uploadDirectoryFromDisk(swarmUrl)(arg.defaultFile)(arg.path);\n        }\n\n        ; // Upload UTF-8 string or raw data (buffer)\n      } else if (arg.length || typeof arg === \"string\") {\n        return uploadData(swarmUrl)(arg); // Upload directory with JSON\n      } else if (arg instanceof Object) {\n        return uploadDirectory(swarmUrl)(arg);\n      }\n\n      return Promise.reject(new Error(\"Bad arguments\"));\n    };\n  }; // String -> String -> Nullable String -> Promise (String | Uint8Array | Map String Uint8Array)\n  //   Simplified multi-type download which calls the correct function based on\n  //   the type of the argument given, and on whether the Swwarm address has a\n  //   directory or a file.\n\n\n  var _download = function download(swarmUrl) {\n    return function (hash) {\n      return function (path) {\n        return isDirectory(swarmUrl)(hash).then(function (isDir) {\n          if (isDir) {\n            return path ? downloadDirectoryToDisk(swarmUrl)(hash)(path) : downloadDirectory(swarmUrl)(hash);\n          } else {\n            return path ? downloadDataToDisk(swarmUrl)(hash)(path) : downloadData(swarmUrl)(hash);\n          }\n        });\n      };\n    };\n  }; // String -> Promise String\n  //   Downloads the Swarm binaries into a path. Returns a promise that only\n  //   resolves when the exact Swarm file is there, and verified to be correct.\n  //   If it was already there to begin with, skips the download.\n\n\n  var downloadBinary = function downloadBinary(path, archives) {\n    var system = os.platform().replace(\"win32\", \"windows\") + \"-\" + (os.arch() === \"x64\" ? \"amd64\" : \"386\");\n    var archive = (archives || defaultArchives)[system];\n    var archiveUrl = downloadUrl + archive.archive + \".tar.gz\";\n    var archiveMD5 = archive.archiveMD5;\n    var binaryMD5 = archive.binaryMD5;\n    return files.safeDownloadArchived(archiveUrl)(archiveMD5)(binaryMD5)(path);\n  }; // type SwarmSetup = {\n  //   account : String,\n  //   password : String,\n  //   dataDir : String,\n  //   binPath : String,\n  //   ensApi : String,\n  //   onDownloadProgress : Number ~> (),\n  //   archives : [{\n  //     archive: String,\n  //     binaryMD5: String,\n  //     archiveMD5: String\n  //   }]\n  // }\n  // SwarmSetup ~> Promise Process\n  //   Starts the Swarm process.\n\n\n  var startProcess = function startProcess(swarmSetup) {\n    return new Promise(function (resolve, reject) {\n      var spawn = child_process.spawn;\n\n      var hasString = function hasString(str) {\n        return function (buffer) {\n          return ('' + buffer).indexOf(str) !== -1;\n        };\n      };\n\n      var account = swarmSetup.account,\n          password = swarmSetup.password,\n          dataDir = swarmSetup.dataDir,\n          ensApi = swarmSetup.ensApi,\n          privateKey = swarmSetup.privateKey;\n      var STARTUP_TIMEOUT_SECS = 3;\n      var WAITING_PASSWORD = 0;\n      var STARTING = 1;\n      var LISTENING = 2;\n      var PASSWORD_PROMPT_HOOK = \"Passphrase\";\n      var LISTENING_HOOK = \"Swarm http proxy started\";\n      var state = WAITING_PASSWORD;\n      var swarmProcess = spawn(swarmSetup.binPath, ['--bzzaccount', account || privateKey, '--datadir', dataDir, '--ens-api', ensApi]);\n\n      var handleProcessOutput = function handleProcessOutput(data) {\n        if (state === WAITING_PASSWORD && hasString(PASSWORD_PROMPT_HOOK)(data)) {\n          setTimeout(function () {\n            state = STARTING;\n            swarmProcess.stdin.write(password + '\\n');\n          }, 500);\n        } else if (hasString(LISTENING_HOOK)(data)) {\n          state = LISTENING;\n          clearTimeout(timeout);\n          resolve(swarmProcess);\n        }\n      };\n\n      swarmProcess.stdout.on('data', handleProcessOutput);\n      swarmProcess.stderr.on('data', handleProcessOutput); //swarmProcess.on('close', () => setTimeout(restart, 2000));\n\n      var restart = function restart() {\n        return startProcess(swarmSetup).then(resolve)[\"catch\"](reject);\n      };\n\n      var error = function error() {\n        return reject(new Error(\"Couldn't start swarm process.\"));\n      };\n\n      var timeout = setTimeout(error, 20000);\n    });\n  }; // Process ~> Promise ()\n  //   Stops the Swarm process.\n\n\n  var stopProcess = function stopProcess(process) {\n    return new Promise(function (resolve, reject) {\n      process.stderr.removeAllListeners('data');\n      process.stdout.removeAllListeners('data');\n      process.stdin.removeAllListeners('error');\n      process.removeAllListeners('error');\n      process.removeAllListeners('exit');\n      process.kill('SIGINT');\n      var killTimeout = setTimeout(function () {\n        return process.kill('SIGKILL');\n      }, 8000);\n      process.once('close', function () {\n        clearTimeout(killTimeout);\n        resolve();\n      });\n    });\n  }; // SwarmSetup -> (SwarmAPI -> Promise ()) -> Promise ()\n  //   Receives a Swarm configuration object and a callback function. It then\n  //   checks if a local Swarm node is running. If no local Swarm is found, it\n  //   downloads the Swarm binaries to the dataDir (if not there), checksums,\n  //   starts the Swarm process and calls the callback function with an API\n  //   object using the local node. That callback must return a promise which\n  //   will resolve when it is done using the API, so that this function can\n  //   close the Swarm process properly. Returns a promise that resolves when the\n  //   user is done with the API and the Swarm process is closed.\n  //   TODO: check if Swarm process is already running (improve `isAvailable`)\n\n\n  var local = function local(swarmSetup) {\n    return function (useAPI) {\n      return _isAvailable(\"http://localhost:8500\").then(function (isAvailable) {\n        return isAvailable ? useAPI(at(\"http://localhost:8500\")).then(function () {}) : downloadBinary(swarmSetup.binPath, swarmSetup.archives).onData(function (data) {\n          return (swarmSetup.onProgress || function () {})(data.length);\n        }).then(function () {\n          return startProcess(swarmSetup);\n        }).then(function (process) {\n          return useAPI(at(\"http://localhost:8500\")).then(function () {\n            return process;\n          });\n        }).then(stopProcess);\n      });\n    };\n  }; // String ~> Promise Bool\n  //   Returns true if Swarm is available on `url`.\n  //   Perfoms a test upload to determine that.\n  //   TODO: improve this?\n\n\n  var _isAvailable = function isAvailable(swarmUrl) {\n    var testFile = \"test\";\n    var testHash = \"c9a99c7d326dcc6316f32fe2625b311f6dc49a175e6877681ded93137d3569e7\";\n    return uploadData(swarmUrl)(testFile).then(function (hash) {\n      return hash === testHash;\n    })[\"catch\"](function () {\n      return false;\n    });\n  }; // String -> String ~> Promise Bool\n  //   Returns a Promise which is true if that Swarm address is a directory.\n  //   Determines that by checking that it (i) is a JSON, (ii) has a .entries.\n  //   TODO: improve this?\n\n\n  var isDirectory = function isDirectory(swarmUrl) {\n    return function (hash) {\n      return downloadData(swarmUrl)(hash).then(function (data) {\n        try {\n          return !!JSON.parse(toString(data)).entries;\n        } catch (e) {\n          return false;\n        }\n      });\n    };\n  }; // Uncurries a function; used to allow the f(x,y,z) style on exports.\n\n\n  var uncurry = function uncurry(f) {\n    return function (a, b, c, d, e) {\n      var p; // Hardcoded because efficiency (`arguments` is very slow).\n\n      if (typeof a !== \"undefined\") p = f(a);\n      if (typeof b !== \"undefined\") p = f(b);\n      if (typeof c !== \"undefined\") p = f(c);\n      if (typeof d !== \"undefined\") p = f(d);\n      if (typeof e !== \"undefined\") p = f(e);\n      return p;\n    };\n  }; // () -> Promise Bool\n  //   Not sure how to mock Swarm to test it properly. Ideas?\n\n\n  var test = function test() {\n    return Promise.resolve(true);\n  }; // Uint8Array -> String\n\n\n  var toString = function toString(uint8Array) {\n    return bytes.toString(bytes.fromUint8Array(uint8Array));\n  }; // String -> Uint8Array\n\n\n  var fromString = function fromString(string) {\n    return bytes.toUint8Array(bytes.fromString(string));\n  }; // String -> SwarmAPI\n  //   Fixes the `swarmUrl`, returning an API where you don't have to pass it.\n\n\n  var at = function at(swarmUrl) {\n    return {\n      download: function download(hash, path) {\n        return _download(swarmUrl)(hash)(path);\n      },\n      downloadData: uncurry(downloadData(swarmUrl)),\n      downloadDataToDisk: uncurry(downloadDataToDisk(swarmUrl)),\n      downloadDirectory: uncurry(downloadDirectory(swarmUrl)),\n      downloadDirectoryToDisk: uncurry(downloadDirectoryToDisk(swarmUrl)),\n      downloadEntries: uncurry(downloadEntries(swarmUrl)),\n      downloadRoutes: uncurry(downloadRoutes(swarmUrl)),\n      isAvailable: function isAvailable() {\n        return _isAvailable(swarmUrl);\n      },\n      upload: function upload(arg) {\n        return _upload(swarmUrl)(arg);\n      },\n      uploadData: uncurry(uploadData(swarmUrl)),\n      uploadFile: uncurry(uploadFile(swarmUrl)),\n      uploadFileFromDisk: uncurry(uploadFile(swarmUrl)),\n      uploadDataFromDisk: uncurry(uploadDataFromDisk(swarmUrl)),\n      uploadDirectory: uncurry(uploadDirectory(swarmUrl)),\n      uploadDirectoryFromDisk: uncurry(uploadDirectoryFromDisk(swarmUrl)),\n      uploadToManifest: uncurry(uploadToManifest(swarmUrl)),\n      pick: pick,\n      hash: hash,\n      fromString: fromString,\n      toString: toString\n    };\n  };\n\n  return {\n    at: at,\n    local: local,\n    download: _download,\n    downloadBinary: downloadBinary,\n    downloadData: downloadData,\n    downloadDataToDisk: downloadDataToDisk,\n    downloadDirectory: downloadDirectory,\n    downloadDirectoryToDisk: downloadDirectoryToDisk,\n    downloadEntries: downloadEntries,\n    downloadRoutes: downloadRoutes,\n    isAvailable: _isAvailable,\n    startProcess: startProcess,\n    stopProcess: stopProcess,\n    upload: _upload,\n    uploadData: uploadData,\n    uploadDataFromDisk: uploadDataFromDisk,\n    uploadFile: uploadFile,\n    uploadFileFromDisk: uploadFileFromDisk,\n    uploadDirectory: uploadDirectory,\n    uploadDirectoryFromDisk: uploadDirectoryFromDisk,\n    uploadToManifest: uploadToManifest,\n    pick: pick,\n    hash: hash,\n    fromString: fromString,\n    toString: toString\n  };\n};//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvc3dhcm0tanMvbGliL3N3YXJtLmpzIiwibWFwcGluZ3MiOiJBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDs7O0FBR0E7QUFDQTtBQUNBOztBQUVBLHVDQUF1QyxPQUFPO0FBQzlDO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLEtBQUs7QUFDTDs7O0FBR0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLEtBQUs7OztBQUdMO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsUUFBUTtBQUNSLHNDQUFzQyxPQUFPO0FBQzdDO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsS0FBSzs7O0FBR0w7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7OztBQUdBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLFNBQVM7QUFDVCxPQUFPO0FBQ1A7QUFDQSxLQUFLLGlCQUFpQjtBQUN0QixrQkFBa0I7QUFDbEI7QUFDQTtBQUNBOzs7QUFHQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZUFBZTtBQUNmO0FBQ0E7OztBQUdBO0FBQ0E7QUFDQTtBQUNBLGdCQUFnQjtBQUNoQjtBQUNBO0FBQ0EsZUFBZTs7O0FBR2Y7QUFDQTtBQUNBLGFBQWE7QUFDYjtBQUNBLGFBQWE7QUFDYjtBQUNBLGFBQWE7QUFDYjtBQUNBO0FBQ0E7O0FBRUEsZ0NBQWdDO0FBQ2hDO0FBQ0EsS0FBSztBQUNMOzs7QUFHQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNULE9B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QUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EiLCJzb3VyY2VzIjpbIi9Vc2Vycy9wYW56YS9Eb2N1bWVudHMvUGVyc29uYWxQcm9qZWN0cy9wcmVkaWsvbm9kZV9tb2R1bGVzL3N3YXJtLWpzL2xpYi9zd2FybS5qcyJdLCJzb3VyY2VzQ29udGVudCI6WyIvLyBUT0RPOiB0aGlzIGlzIGEgdGVtcG9yYXJ5IGZpeCB0byBoaWRlIHRob3NlIGxpYnJhcmllcyBmcm9tIHRoZSBicm93c2VyLiBBXG4vLyBzbGlnaHRseSBiZXR0ZXIgbG9uZy10ZXJtIHNvbHV0aW9uIHdvdWxkIGJlIHRvIHNwbGl0IHRoaXMgZmlsZSBpbnRvIHR3byxcbi8vIHNlcGFyYXRpbmcgdGhlIGZ1bmN0aW9ucyB0aGF0IGFyZSB1c2VkIG9uIE5vZGUuanMgZnJvbSB0aGUgZnVuY3Rpb25zIHRoYXRcbi8vIGFyZSB1c2VkIG9ubHkgb24gdGhlIGJyb3dzZXIuXG5tb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uIChfcmVmKSB7XG4gIHZhciBmcyA9IF9yZWYuZnMsXG4gICAgICBmaWxlcyA9IF9yZWYuZmlsZXMsXG4gICAgICBvcyA9IF9yZWYub3MsXG4gICAgICBwYXRoID0gX3JlZi5wYXRoLFxuICAgICAgY2hpbGRfcHJvY2VzcyA9IF9yZWYuY2hpbGRfcHJvY2VzcyxcbiAgICAgIG1pbWV0eXBlID0gX3JlZi5taW1ldHlwZSxcbiAgICAgIGRlZmF1bHRBcmNoaXZlcyA9IF9yZWYuZGVmYXVsdEFyY2hpdmVzLFxuICAgICAgcmVxdWVzdCA9IF9yZWYucmVxdWVzdCxcbiAgICAgIGRvd25sb2FkVXJsID0gX3JlZi5kb3dubG9hZFVybCxcbiAgICAgIGJ5dGVzID0gX3JlZi5ieXRlcyxcbiAgICAgIGhhc2ggPSBfcmVmLmhhc2gsXG4gICAgICBwaWNrID0gX3JlZi5waWNrO1xuXG4gIC8vIOKIgCBhIC4gU3RyaW5nIC0+IEpTT04gLT4gTWFwIFN0cmluZyBhIC1vIE1hcCBTdHJpbmcgYVxuICAvLyAgIEluc2VydHMgYSBrZXkvdmFsIHBhaXIgaW4gYW4gb2JqZWN0IGltcHVyZWx5LlxuICB2YXIgaW1wdXJlSW5zZXJ0ID0gZnVuY3Rpb24gaW1wdXJlSW5zZXJ0KGtleSkge1xuICAgIHJldHVybiBmdW5jdGlvbiAodmFsKSB7XG4gICAgICByZXR1cm4gZnVuY3Rpb24gKG1hcCkge1xuICAgICAgICByZXR1cm4gbWFwW2tleV0gPSB2YWwsIG1hcDtcbiAgICAgIH07XG4gICAgfTtcbiAgfTsgLy8gU3RyaW5nIC0+IEpTT04gLT4gTWFwIFN0cmluZyBKU09OXG4gIC8vICAgTWVyZ2VzIGFuIGFycmF5IG9mIGtleXMgYW5kIGFuIGFycmF5IG9mIHZhbHMgaW50byBhbiBvYmplY3QuXG5cblxuICB2YXIgdG9NYXAgPSBmdW5jdGlvbiB0b01hcChrZXlzKSB7XG4gICAgcmV0dXJuIGZ1bmN0aW9uICh2YWxzKSB7XG4gICAgICB2YXIgbWFwID0ge307XG5cbiAgICAgIGZvciAodmFyIGkgPSAwLCBsID0ga2V5cy5sZW5ndGg7IGkgPCBsOyArK2kpIHtcbiAgICAgICAgbWFwW2tleXNbaV1dID0gdmFsc1tpXTtcbiAgICAgIH1cblxuICAgICAgcmV0dXJuIG1hcDtcbiAgICB9O1xuICB9OyAvLyDiiIAgYSAuIE1hcCBTdHJpbmcgYSAtPiBNYXAgU3RyaW5nIGEgLT4gTWFwIFN0cmluZyBhXG4gIC8vICAgTWVyZ2VzIHR3byBtYXBzIGludG8gb25lLlxuXG5cbiAgdmFyIG1lcmdlID0gZnVuY3Rpb24gbWVyZ2UoYSkge1xuICAgIHJldHVybiBmdW5jdGlvbiAoYikge1xuICAgICAgdmFyIG1hcCA9IHt9O1xuXG4gICAgICBmb3IgKHZhciBrZXkgaW4gYSkge1xuICAgICAgICBtYXBba2V5XSA9IGFba2V5XTtcbiAgICAgIH1cblxuICAgICAgZm9yICh2YXIgX2tleSBpbiBiKSB7XG4gICAgICAgIG1hcFtfa2V5XSA9IGJbX2tleV07XG4gICAgICB9XG5cbiAgICAgIHJldHVybiBtYXA7XG4gICAgfTtcbiAgfTsgLy8g4oiAIGEgLiBbYV0gLT4gW2FdIC0+IEJvb2xcblxuXG4gIHZhciBlcXVhbHMgPSBmdW5jdGlvbiBlcXVhbHMoYSkge1xuICAgIHJldHVybiBmdW5jdGlvbiAoYikge1xuICAgICAgaWYgKGEubGVuZ3RoICE9PSBiLmxlbmd0aCkge1xuICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBmb3IgKHZhciBpID0gMCwgbCA9IGEubGVuZ3RoOyBpIDwgbDsgKytpKSB7XG4gICAgICAgICAgaWYgKGFbaV0gIT09IGJbaV0pIHJldHVybiBmYWxzZTtcbiAgICAgICAgfVxuICAgICAgfVxuXG4gICAgICByZXR1cm4gdHJ1ZTtcbiAgICB9O1xuICB9OyAvLyBTdHJpbmcgLT4gU3RyaW5nIC0+IFN0cmluZ1xuXG5cbiAgdmFyIHJhd1VybCA9IGZ1bmN0aW9uIHJhd1VybChzd2FybVVybCkge1xuICAgIHJldHVybiBmdW5jdGlvbiAoaGFzaCkge1xuICAgICAgcmV0dXJuIFwiXCIuY29uY2F0KHN3YXJtVXJsLCBcIi9ienotcmF3Oi9cIikuY29uY2F0KGhhc2gpO1xuICAgIH07XG4gIH07IC8vIFN0cmluZyAtPiBTdHJpbmcgLT4gUHJvbWlzZSBVaW50OEFycmF5XG4gIC8vICAgR2V0cyB0aGUgcmF3IGNvbnRlbnRzIG9mIGEgU3dhcm0gaGFzaCBhZGRyZXNzLlxuXG5cbiAgdmFyIGRvd25sb2FkRGF0YSA9IGZ1bmN0aW9uIGRvd25sb2FkRGF0YShzd2FybVVybCkge1xuICAgIHJldHVybiBmdW5jdGlvbiAoaGFzaCkge1xuICAgICAgcmV0dXJuIG5ldyBQcm9taXNlKGZ1bmN0aW9uIChyZXNvbHZlLCByZWplY3QpIHtcbiAgICAgICAgcmVxdWVzdChyYXdVcmwoc3dhcm1VcmwpKGhhc2gpLCB7XG4gICAgICAgICAgcmVzcG9uc2VUeXBlOiBcImFycmF5YnVmZmVyXCJcbiAgICAgICAgfSwgZnVuY3Rpb24gKGVyciwgYXJyYXlCdWZmZXIsIHJlc3BvbnNlKSB7XG4gICAgICAgICAgaWYgKGVycikge1xuICAgICAgICAgICAgcmV0dXJuIHJlamVjdChlcnIpO1xuICAgICAgICAgIH1cblxuICAgICAgICAgIGlmIChyZXNwb25zZS5zdGF0dXNDb2RlID49IDQwMCkge1xuICAgICAgICAgICAgcmV0dXJuIHJlamVjdChuZXcgRXJyb3IoXCJFcnJvciBcIi5jb25jYXQocmVzcG9uc2Uuc3RhdHVzQ29kZSwgXCIuXCIpKSk7XG4gICAgICAgICAgfVxuXG4gICAgICAgICAgcmV0dXJuIHJlc29sdmUobmV3IFVpbnQ4QXJyYXkoYXJyYXlCdWZmZXIpKTtcbiAgICAgICAgfSk7XG4gICAgICB9KTtcbiAgICB9O1xuICB9OyAvLyB0eXBlIEVudHJ5ID0ge1widHlwZVwiOiBTdHJpbmcsIFwiaGFzaFwiOiBTdHJpbmd9XG4gIC8vIHR5cGUgRmlsZSA9IHtcInR5cGVcIjogU3RyaW5nLCBcImRhdGFcIjogVWludDhBcnJheX1cbiAgLy8gU3RyaW5nIC0+IFN0cmluZyAtPiBQcm9taXNlIChNYXAgU3RyaW5nIEVudHJ5KVxuICAvLyAgIFNvbHZlcyB0aGUgbWFuaWZlc3Qgb2YgYSBTd2FybSBhZGRyZXNzIHJlY3Vyc2l2ZWx5LlxuICAvLyAgIFJldHVybnMgYSBtYXAgZnJvbSBmdWxsIHBhdGhzIHRvIGVudHJpZXMuXG5cblxuICB2YXIgZG93bmxvYWRFbnRyaWVzID0gZnVuY3Rpb24gZG93bmxvYWRFbnRyaWVzKHN3YXJtVXJsKSB7XG4gICAgcmV0dXJuIGZ1bmN0aW9uIChoYXNoKSB7XG4gICAgICB2YXIgc2VhcmNoID0gZnVuY3Rpb24gc2VhcmNoKGhhc2gpIHtcbiAgICAgICAgcmV0dXJuIGZ1bmN0aW9uIChwYXRoKSB7XG4gICAgICAgICAgcmV0dXJuIGZ1bmN0aW9uIChyb3V0ZXMpIHtcbiAgICAgICAgICAgIC8vIEZvcm1hdHMgYW4gZW50cnkgdG8gdGhlIFN3YXJtLmpzIHR5cGUuXG4gICAgICAgICAgICB2YXIgZm9ybWF0ID0gZnVuY3Rpb24gZm9ybWF0KGVudHJ5KSB7XG4gICAgICAgICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICAgICAgdHlwZTogZW50cnkuY29udGVudFR5cGUsXG4gICAgICAgICAgICAgICAgaGFzaDogZW50cnkuaGFzaFxuICAgICAgICAgICAgICB9O1xuICAgICAgICAgICAgfTsgLy8gVG8gZG93bmxvYWQgYSBzaW5nbGUgZW50cnk6XG4gICAgICAgICAgICAvLyAgIGlmIHR5cGUgaXMgYnp6LW1hbmlmZXN0LCBnbyBkZWVwZXJcbiAgICAgICAgICAgIC8vICAgaWYgbm90LCBhZGQgaXQgdG8gdGhlIHJvdXRpbmcgdGFibGVcblxuXG4gICAgICAgICAgICB2YXIgZG93bmxvYWRFbnRyeSA9IGZ1bmN0aW9uIGRvd25sb2FkRW50cnkoZW50cnkpIHtcbiAgICAgICAgICAgICAgaWYgKGVudHJ5LnBhdGggPT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgICAgIHJldHVybiBQcm9taXNlLnJlc29sdmUoKTtcbiAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gZW50cnkuY29udGVudFR5cGUgPT09IFwiYXBwbGljYXRpb24vYnp6LW1hbmlmZXN0K2pzb25cIiA/IHNlYXJjaChlbnRyeS5oYXNoKShwYXRoICsgZW50cnkucGF0aCkocm91dGVzKSA6IFByb21pc2UucmVzb2x2ZShpbXB1cmVJbnNlcnQocGF0aCArIGVudHJ5LnBhdGgpKGZvcm1hdChlbnRyeSkpKHJvdXRlcykpO1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9OyAvLyBEb3dubG9hZHMgdGhlIGluaXRpYWwgbWFuaWZlc3QgYW5kIHRoZW4gZWFjaCBlbnRyeS5cblxuXG4gICAgICAgICAgICByZXR1cm4gZG93bmxvYWREYXRhKHN3YXJtVXJsKShoYXNoKS50aGVuKGZ1bmN0aW9uICh0ZXh0KSB7XG4gICAgICAgICAgICAgIHJldHVybiBKU09OLnBhcnNlKHRvU3RyaW5nKHRleHQpKS5lbnRyaWVzO1xuICAgICAgICAgICAgfSkudGhlbihmdW5jdGlvbiAoZW50cmllcykge1xuICAgICAgICAgICAgICByZXR1cm4gUHJvbWlzZS5hbGwoZW50cmllcy5tYXAoZG93bmxvYWRFbnRyeSkpO1xuICAgICAgICAgICAgfSkudGhlbihmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICAgIHJldHVybiByb3V0ZXM7XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgICB9O1xuICAgICAgICB9O1xuICAgICAgfTtcblxuICAgICAgcmV0dXJuIHNlYXJjaChoYXNoKShcIlwiKSh7fSk7XG4gICAgfTtcbiAgfTsgLy8gU3RyaW5nIC0+IFN0cmluZyAtPiBQcm9taXNlIChNYXAgU3RyaW5nIFN0cmluZylcbiAgLy8gICBTYW1lIGFzIGBkb3dubG9hZEVudHJpZXNgLCBidXQgcmV0dXJucyBvbmx5IGhhc2hlcyAobm8gdHlwZXMpLlxuXG5cbiAgdmFyIGRvd25sb2FkUm91dGVzID0gZnVuY3Rpb24gZG93bmxvYWRSb3V0ZXMoc3dhcm1VcmwpIHtcbiAgICByZXR1cm4gZnVuY3Rpb24gKGhhc2gpIHtcbiAgICAgIHJldHVybiBkb3dubG9hZEVudHJpZXMoc3dhcm1VcmwpKGhhc2gpLnRoZW4oZnVuY3Rpb24gKGVudHJpZXMpIHtcbiAgICAgICAgcmV0dXJuIHRvTWFwKE9iamVjdC5rZXlzKGVudHJpZXMpKShPYmplY3Qua2V5cyhlbnRyaWVzKS5tYXAoZnVuY3Rpb24gKHJvdXRlKSB7XG4gICAgICAgICAgcmV0dXJuIGVudHJpZXNbcm91dGVdLmhhc2g7XG4gICAgICAgIH0pKTtcbiAgICAgIH0pO1xuICAgIH07XG4gIH07IC8vIFN0cmluZyAtPiBTdHJpbmcgLT4gUHJvbWlzZSAoTWFwIFN0cmluZyBGaWxlKVxuICAvLyAgIEdldHMgdGhlIGVudGlyZSBkaXJlY3RvcnkgdHJlZSBpbiBhIFN3YXJtIGFkZHJlc3MuXG4gIC8vICAgUmV0dXJucyBhIHByb21pc2UgbWFwcGluZyBwYXRocyB0byBmaWxlIGNvbnRlbnRzLlxuXG5cbiAgdmFyIGRvd25sb2FkRGlyZWN0b3J5ID0gZnVuY3Rpb24gZG93bmxvYWREaXJlY3Rvcnkoc3dhcm1VcmwpIHtcbiAgICByZXR1cm4gZnVuY3Rpb24gKGhhc2gpIHtcbiAgICAgIHJldHVybiBkb3dubG9hZEVudHJpZXMoc3dhcm1VcmwpKGhhc2gpLnRoZW4oZnVuY3Rpb24gKGVudHJpZXMpIHtcbiAgICAgICAgdmFyIHBhdGhzID0gT2JqZWN0LmtleXMoZW50cmllcyk7XG4gICAgICAgIHZhciBoYXNocyA9IHBhdGhzLm1hcChmdW5jdGlvbiAocGF0aCkge1xuICAgICAgICAgIHJldHVybiBlbnRyaWVzW3BhdGhdLmhhc2g7XG4gICAgICAgIH0pO1xuICAgICAgICB2YXIgdHlwZXMgPSBwYXRocy5tYXAoZnVuY3Rpb24gKHBhdGgpIHtcbiAgICAgICAgICByZXR1cm4gZW50cmllc1twYXRoXS50eXBlO1xuICAgICAgICB9KTtcbiAgICAgICAgdmFyIGRhdGFzID0gaGFzaHMubWFwKGRvd25sb2FkRGF0YShzd2FybVVybCkpO1xuXG4gICAgICAgIHZhciBmaWxlcyA9IGZ1bmN0aW9uIGZpbGVzKGRhdGFzKSB7XG4gICAgICAgICAgcmV0dXJuIGRhdGFzLm1hcChmdW5jdGlvbiAoZGF0YSwgaSkge1xuICAgICAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgICAgdHlwZTogdHlwZXNbaV0sXG4gICAgICAgICAgICAgIGRhdGE6IGRhdGFcbiAgICAgICAgICAgIH07XG4gICAgICAgICAgfSk7XG4gICAgICAgIH07XG5cbiAgICAgICAgcmV0dXJuIFByb21pc2UuYWxsKGRhdGFzKS50aGVuKGZ1bmN0aW9uIChkYXRhcykge1xuICAgICAgICAgIHJldHVybiB0b01hcChwYXRocykoZmlsZXMoZGF0YXMpKTtcbiAgICAgICAgfSk7XG4gICAgICB9KTtcbiAgICB9O1xuICB9OyAvLyBTdHJpbmcgLT4gU3RyaW5nIC0+IFN0cmluZyAtPiBQcm9taXNlIFN0cmluZ1xuICAvLyAgIEdldHMgdGhlIHJhdyBjb250ZW50cyBvZiBhIFN3YXJtIGhhc2ggYWRkcmVzcy5cbiAgLy8gICBSZXR1cm5zIGEgcHJvbWlzZSB3aXRoIHRoZSBkb3dubG9hZGVkIGZpbGUgcGF0aC5cblxuXG4gIHZhciBkb3dubG9hZERhdGFUb0Rpc2sgPSBmdW5jdGlvbiBkb3dubG9hZERhdGFUb0Rpc2soc3dhcm1VcmwpIHtcbiAgICByZXR1cm4gZnVuY3Rpb24gKGhhc2gpIHtcbiAgICAgIHJldHVybiBmdW5jdGlvbiAoZmlsZVBhdGgpIHtcbiAgICAgICAgcmV0dXJuIGZpbGVzLmRvd25sb2FkKHJhd1VybChzd2FybVVybCkoaGFzaCkpKGZpbGVQYXRoKTtcbiAgICAgIH07XG4gICAgfTtcbiAgfTsgLy8gU3RyaW5nIC0+IFN0cmluZyAtPiBTdHJpbmcgLT4gUHJvbWlzZSAoTWFwIFN0cmluZyBTdHJpbmcpXG4gIC8vICAgR2V0cyB0aGUgZW50aXJlIGRpcmVjdG9yeSB0cmVlIGluIGEgU3dhcm0gYWRkcmVzcy5cbiAgLy8gICBSZXR1cm5zIGEgcHJvbWlzZSBtYXBwaW5nIHBhdGhzIHRvIGZpbGUgY29udGVudHMuXG5cblxuICB2YXIgZG93bmxvYWREaXJlY3RvcnlUb0Rpc2sgPSBmdW5jdGlvbiBkb3dubG9hZERpcmVjdG9yeVRvRGlzayhzd2FybVVybCkge1xuICAgIHJldHVybiBmdW5jdGlvbiAoaGFzaCkge1xuICAgICAgcmV0dXJuIGZ1bmN0aW9uIChkaXJQYXRoKSB7XG4gICAgICAgIHJldHVybiBkb3dubG9hZFJvdXRlcyhzd2FybVVybCkoaGFzaCkudGhlbihmdW5jdGlvbiAocm91dGluZ1RhYmxlKSB7XG4gICAgICAgICAgdmFyIGRvd25sb2FkcyA9IFtdO1xuXG4gICAgICAgICAgZm9yICh2YXIgcm91dGUgaW4gcm91dGluZ1RhYmxlKSB7XG4gICAgICAgICAgICBpZiAocm91dGUubGVuZ3RoID4gMCkge1xuICAgICAgICAgICAgICB2YXIgZmlsZVBhdGggPSBwYXRoLmpvaW4oZGlyUGF0aCwgcm91dGUpO1xuICAgICAgICAgICAgICBkb3dubG9hZHMucHVzaChkb3dubG9hZERhdGFUb0Rpc2soc3dhcm1VcmwpKHJvdXRpbmdUYWJsZVtyb3V0ZV0pKGZpbGVQYXRoKSk7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIDtcbiAgICAgICAgICB9XG5cbiAgICAgICAgICA7XG4gICAgICAgICAgcmV0dXJuIFByb21pc2UuYWxsKGRvd25sb2FkcykudGhlbihmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICByZXR1cm4gZGlyUGF0aDtcbiAgICAgICAgICB9KTtcbiAgICAgICAgfSk7XG4gICAgICB9O1xuICAgIH07XG4gIH07IC8vIFN0cmluZyAtPiBVaW50OEFycmF5IC0+IFByb21pc2UgU3RyaW5nXG4gIC8vICAgVXBsb2FkcyByYXcgZGF0YSB0byBTd2FybS5cbiAgLy8gICBSZXR1cm5zIGEgcHJvbWlzZSB3aXRoIHRoZSB1cGxvYWRlZCBoYXNoLlxuXG5cbiAgdmFyIHVwbG9hZERhdGEgPSBmdW5jdGlvbiB1cGxvYWREYXRhKHN3YXJtVXJsKSB7XG4gICAgcmV0dXJuIGZ1bmN0aW9uIChkYXRhKSB7XG4gICAgICByZXR1cm4gbmV3IFByb21pc2UoZnVuY3Rpb24gKHJlc29sdmUsIHJlamVjdCkge1xuICAgICAgICB2YXIgcGFyYW1zID0ge1xuICAgICAgICAgIGJvZHk6IHR5cGVvZiBkYXRhID09PSBcInN0cmluZ1wiID8gZnJvbVN0cmluZyhkYXRhKSA6IGRhdGEsXG4gICAgICAgICAgbWV0aG9kOiBcIlBPU1RcIlxuICAgICAgICB9O1xuICAgICAgICByZXF1ZXN0KFwiXCIuY29uY2F0KHN3YXJtVXJsLCBcIi9ienotcmF3Oi9cIiksIHBhcmFtcywgZnVuY3Rpb24gKGVyciwgZGF0YSkge1xuICAgICAgICAgIGlmIChlcnIpIHtcbiAgICAgICAgICAgIHJldHVybiByZWplY3QoZXJyKTtcbiAgICAgICAgICB9XG5cbiAgICAgICAgICByZXR1cm4gcmVzb2x2ZShkYXRhKTtcbiAgICAgICAgfSk7XG4gICAgICB9KTtcbiAgICB9O1xuICB9OyAvLyBTdHJpbmcgLT4gU3RyaW5nIC0+IFN0cmluZyAtPiBGaWxlIC0+IFByb21pc2UgU3RyaW5nXG4gIC8vICAgVXBsb2FkcyBhIGZpbGUgdG8gdGhlIFN3YXJtIG1hbmlmZXN0IGF0IGEgZ2l2ZW4gaGFzaCwgdW5kZXIgYSBzcGVjaWZpY1xuICAvLyAgIHJvdXRlLiBSZXR1cm5zIGEgcHJvbWlzZSBjb250YWluaW5nIHRoZSB1cGxvYWRlZCBoYXNoLlxuICAvLyAgIEZJWE1FOiBmb3Igc29tZSByZWFzb25zIFN3YXJtLUdhdGV3YXlzIGlzIHNvbWV0aW1lcyByZXR1cm5pbmdcbiAgLy8gICBlcnJvciA0MDTCoChiYWQgcmVxdWVzdCksIHNvIHdlIHJldHJ5IHVwIHRvIDMgdGltZXMuIFdoeT9cblxuXG4gIHZhciB1cGxvYWRUb01hbmlmZXN0ID0gZnVuY3Rpb24gdXBsb2FkVG9NYW5pZmVzdChzd2FybVVybCkge1xuICAgIHJldHVybiBmdW5jdGlvbiAoaGFzaCkge1xuICAgICAgcmV0dXJuIGZ1bmN0aW9uIChyb3V0ZSkge1xuICAgICAgICByZXR1cm4gZnVuY3Rpb24gKGZpbGUpIHtcbiAgICAgICAgICB2YXIgYXR0ZW1wdCA9IGZ1bmN0aW9uIGF0dGVtcHQobikge1xuICAgICAgICAgICAgdmFyIHNsYXNoUm91dGUgPSByb3V0ZVswXSA9PT0gXCIvXCIgPyByb3V0ZSA6IFwiL1wiICsgcm91dGU7XG4gICAgICAgICAgICB2YXIgdXJsID0gXCJcIi5jb25jYXQoc3dhcm1VcmwsIFwiL2J6ejovXCIpLmNvbmNhdChoYXNoKS5jb25jYXQoc2xhc2hSb3V0ZSk7XG4gICAgICAgICAgICB2YXIgb3B0ID0ge1xuICAgICAgICAgICAgICBtZXRob2Q6IFwiUFVUXCIsXG4gICAgICAgICAgICAgIGhlYWRlcnM6IHtcbiAgICAgICAgICAgICAgICBcIkNvbnRlbnQtVHlwZVwiOiBmaWxlLnR5cGVcbiAgICAgICAgICAgICAgfSxcbiAgICAgICAgICAgICAgYm9keTogZmlsZS5kYXRhXG4gICAgICAgICAgICB9O1xuICAgICAgICAgICAgcmV0dXJuIG5ldyBQcm9taXNlKGZ1bmN0aW9uIChyZXNvbHZlLCByZWplY3QpIHtcbiAgICAgICAgICAgICAgcmVxdWVzdCh1cmwsIG9wdCwgZnVuY3Rpb24gKGVyciwgZGF0YSkge1xuICAgICAgICAgICAgICAgIGlmIChlcnIpIHtcbiAgICAgICAgICAgICAgICAgIHJldHVybiByZWplY3QoZXJyKTtcbiAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICBpZiAoZGF0YS5pbmRleE9mKFwiZXJyb3JcIikgIT09IC0xKSB7XG4gICAgICAgICAgICAgICAgICByZXR1cm4gcmVqZWN0KGRhdGEpO1xuICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgIHJldHVybiByZXNvbHZlKGRhdGEpO1xuICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIH0pW1wiY2F0Y2hcIl0oZnVuY3Rpb24gKGUpIHtcbiAgICAgICAgICAgICAgcmV0dXJuIG4gPiAwICYmIGF0dGVtcHQobiAtIDEpO1xuICAgICAgICAgICAgfSk7XG4gICAgICAgICAgfTtcblxuICAgICAgICAgIHJldHVybiBhdHRlbXB0KDMpO1xuICAgICAgICB9O1xuICAgICAgfTtcbiAgICB9O1xuICB9OyAvLyBTdHJpbmcgLT4ge3R5cGU6IFN0cmluZywgZGF0YTogVWludDhBcnJheX0gLT4gUHJvbWlzZSBTdHJpbmdcblxuXG4gIHZhciB1cGxvYWRGaWxlID0gZnVuY3Rpb24gdXBsb2FkRmlsZShzd2FybVVybCkge1xuICAgIHJldHVybiBmdW5jdGlvbiAoZmlsZSkge1xuICAgICAgcmV0dXJuIHVwbG9hZERpcmVjdG9yeShzd2FybVVybCkoe1xuICAgICAgICBcIlwiOiBmaWxlXG4gICAgICB9KTtcbiAgICB9O1xuICB9OyAvLyBTdHJpbmcgLT4gU3RyaW5nIC0+IFByb21pc2UgU3RyaW5nXG5cblxuICB2YXIgdXBsb2FkRmlsZUZyb21EaXNrID0gZnVuY3Rpb24gdXBsb2FkRmlsZUZyb21EaXNrKHN3YXJtVXJsKSB7XG4gICAgcmV0dXJuIGZ1bmN0aW9uIChmaWxlUGF0aCkge1xuICAgICAgcmV0dXJuIGZzLnJlYWRGaWxlKGZpbGVQYXRoKS50aGVuKGZ1bmN0aW9uIChkYXRhKSB7XG4gICAgICAgIHJldHVybiB1cGxvYWRGaWxlKHN3YXJtVXJsKSh7XG4gICAgICAgICAgdHlwZTogbWltZXR5cGUubG9va3VwKGZpbGVQYXRoKSxcbiAgICAgICAgICBkYXRhOiBkYXRhXG4gICAgICAgIH0pO1xuICAgICAgfSk7XG4gICAgfTtcbiAgfTsgLy8gU3RyaW5nIC0+IE1hcCBTdHJpbmcgRmlsZSAtPiBQcm9taXNlIFN0cmluZ1xuICAvLyAgIFVwbG9hZHMgYSBkaXJlY3RvcnkgdG8gU3dhcm0uIFRoZSBkaXJlY3RvcnkgaXNcbiAgLy8gICByZXByZXNlbnRlZCBhcyBhIG1hcCBvZiByb3V0ZXMgYW5kIGZpbGVzLlxuICAvLyAgIEEgZGVmYXVsdCBwYXRoIGlzIGVuY29kZWQgYnkgaGF2aW5nIGEgXCJcIiByb3V0ZS5cblxuXG4gIHZhciB1cGxvYWREaXJlY3RvcnkgPSBmdW5jdGlvbiB1cGxvYWREaXJlY3Rvcnkoc3dhcm1VcmwpIHtcbiAgICByZXR1cm4gZnVuY3Rpb24gKGRpcmVjdG9yeSkge1xuICAgICAgcmV0dXJuIHVwbG9hZERhdGEoc3dhcm1VcmwpKFwie31cIikudGhlbihmdW5jdGlvbiAoaGFzaCkge1xuICAgICAgICB2YXIgdXBsb2FkUm91dGUgPSBmdW5jdGlvbiB1cGxvYWRSb3V0ZShyb3V0ZSkge1xuICAgICAgICAgIHJldHVybiBmdW5jdGlvbiAoaGFzaCkge1xuICAgICAgICAgICAgcmV0dXJuIHVwbG9hZFRvTWFuaWZlc3Qoc3dhcm1VcmwpKGhhc2gpKHJvdXRlKShkaXJlY3Rvcnlbcm91dGVdKTtcbiAgICAgICAgICB9O1xuICAgICAgICB9O1xuXG4gICAgICAgIHZhciB1cGxvYWRUb0hhc2ggPSBmdW5jdGlvbiB1cGxvYWRUb0hhc2goaGFzaCwgcm91dGUpIHtcbiAgICAgICAgICByZXR1cm4gaGFzaC50aGVuKHVwbG9hZFJvdXRlKHJvdXRlKSk7XG4gICAgICAgIH07XG5cbiAgICAgICAgcmV0dXJuIE9iamVjdC5rZXlzKGRpcmVjdG9yeSkucmVkdWNlKHVwbG9hZFRvSGFzaCwgUHJvbWlzZS5yZXNvbHZlKGhhc2gpKTtcbiAgICAgIH0pO1xuICAgIH07XG4gIH07IC8vIFN0cmluZyAtPiBQcm9taXNlIFN0cmluZ1xuXG5cbiAgdmFyIHVwbG9hZERhdGFGcm9tRGlzayA9IGZ1bmN0aW9uIHVwbG9hZERhdGFGcm9tRGlzayhzd2FybVVybCkge1xuICAgIHJldHVybiBmdW5jdGlvbiAoZmlsZVBhdGgpIHtcbiAgICAgIHJldHVybiBmcy5yZWFkRmlsZShmaWxlUGF0aCkudGhlbih1cGxvYWREYXRhKHN3YXJtVXJsKSk7XG4gICAgfTtcbiAgfTsgLy8gU3RyaW5nIC0+IE51bGxhYmxlIFN0cmluZyAtPiBTdHJpbmcgLT4gUHJvbWlzZSBTdHJpbmdcblxuXG4gIHZhciB1cGxvYWREaXJlY3RvcnlGcm9tRGlzayA9IGZ1bmN0aW9uIHVwbG9hZERpcmVjdG9yeUZyb21EaXNrKHN3YXJtVXJsKSB7XG4gICAgcmV0dXJuIGZ1bmN0aW9uIChkZWZhdWx0UGF0aCkge1xuICAgICAgcmV0dXJuIGZ1bmN0aW9uIChkaXJQYXRoKSB7XG4gICAgICAgIHJldHVybiBmaWxlcy5kaXJlY3RvcnlUcmVlKGRpclBhdGgpLnRoZW4oZnVuY3Rpb24gKGZ1bGxQYXRocykge1xuICAgICAgICAgIHJldHVybiBQcm9taXNlLmFsbChmdWxsUGF0aHMubWFwKGZ1bmN0aW9uIChwYXRoKSB7XG4gICAgICAgICAgICByZXR1cm4gZnMucmVhZEZpbGUocGF0aCk7XG4gICAgICAgICAgfSkpLnRoZW4oZnVuY3Rpb24gKGRhdGFzKSB7XG4gICAgICAgICAgICB2YXIgcGF0aHMgPSBmdWxsUGF0aHMubWFwKGZ1bmN0aW9uIChwYXRoKSB7XG4gICAgICAgICAgICAgIHJldHVybiBwYXRoLnNsaWNlKGRpclBhdGgubGVuZ3RoKTtcbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgdmFyIHR5cGVzID0gZnVsbFBhdGhzLm1hcChmdW5jdGlvbiAocGF0aCkge1xuICAgICAgICAgICAgICByZXR1cm4gbWltZXR5cGUubG9va3VwKHBhdGgpIHx8IFwidGV4dC9wbGFpblwiO1xuICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICByZXR1cm4gdG9NYXAocGF0aHMpKGRhdGFzLm1hcChmdW5jdGlvbiAoZGF0YSwgaSkge1xuICAgICAgICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgICAgIHR5cGU6IHR5cGVzW2ldLFxuICAgICAgICAgICAgICAgIGRhdGE6IGRhdGFcbiAgICAgICAgICAgICAgfTtcbiAgICAgICAgICAgIH0pKTtcbiAgICAgICAgICB9KTtcbiAgICAgICAgfSkudGhlbihmdW5jdGlvbiAoZGlyZWN0b3J5KSB7XG4gICAgICAgICAgcmV0dXJuIG1lcmdlKGRlZmF1bHRQYXRoID8ge1xuICAgICAgICAgICAgXCJcIjogZGlyZWN0b3J5W2RlZmF1bHRQYXRoXVxuICAgICAgICAgIH0gOiB7fSkoZGlyZWN0b3J5KTtcbiAgICAgICAgfSkudGhlbih1cGxvYWREaXJlY3Rvcnkoc3dhcm1VcmwpKTtcbiAgICAgIH07XG4gICAgfTtcbiAgfTsgLy8gU3RyaW5nIC0+IFVwbG9hZEluZm8gLT4gUHJvbWlzZSBTdHJpbmdcbiAgLy8gICBTaW1wbGlmaWVkIG11bHRpLXR5cGUgdXBsb2FkIHdoaWNoIGNhbGxzIHRoZSBjb3JyZWN0XG4gIC8vICAgb25lIGJhc2VkIG9uIHRoZSB0eXBlIG9mIHRoZSBhcmd1bWVudCBnaXZlbi5cblxuXG4gIHZhciBfdXBsb2FkID0gZnVuY3Rpb24gdXBsb2FkKHN3YXJtVXJsKSB7XG4gICAgcmV0dXJuIGZ1bmN0aW9uIChhcmcpIHtcbiAgICAgIC8vIFVwbG9hZCByYXcgZGF0YSBmcm9tIGJyb3dzZXJcbiAgICAgIGlmIChhcmcucGljayA9PT0gXCJkYXRhXCIpIHtcbiAgICAgICAgcmV0dXJuIHBpY2suZGF0YSgpLnRoZW4odXBsb2FkRGF0YShzd2FybVVybCkpOyAvLyBVcGxvYWQgYSBmaWxlIGZyb20gYnJvd3NlclxuICAgICAgfSBlbHNlIGlmIChhcmcucGljayA9PT0gXCJmaWxlXCIpIHtcbiAgICAgICAgcmV0dXJuIHBpY2suZmlsZSgpLnRoZW4odXBsb2FkRmlsZShzd2FybVVybCkpOyAvLyBVcGxvYWQgYSBkaXJlY3RvcnkgZnJvbSBicm93c2VyXG4gICAgICB9IGVsc2UgaWYgKGFyZy5waWNrID09PSBcImRpcmVjdG9yeVwiKSB7XG4gICAgICAgIHJldHVybiBwaWNrLmRpcmVjdG9yeSgpLnRoZW4odXBsb2FkRGlyZWN0b3J5KHN3YXJtVXJsKSk7IC8vIFVwbG9hZCBkaXJlY3RvcnkvZmlsZSBmcm9tIGRpc2tcbiAgICAgIH0gZWxzZSBpZiAoYXJnLnBhdGgpIHtcbiAgICAgICAgc3dpdGNoIChhcmcua2luZCkge1xuICAgICAgICAgIGNhc2UgXCJkYXRhXCI6XG4gICAgICAgICAgICByZXR1cm4gdXBsb2FkRGF0YUZyb21EaXNrKHN3YXJtVXJsKShhcmcucGF0aCk7XG5cbiAgICAgICAgICBjYXNlIFwiZmlsZVwiOlxuICAgICAgICAgICAgcmV0dXJuIHVwbG9hZEZpbGVGcm9tRGlzayhzd2FybVVybCkoYXJnLnBhdGgpO1xuXG4gICAgICAgICAgY2FzZSBcImRpcmVjdG9yeVwiOlxuICAgICAgICAgICAgcmV0dXJuIHVwbG9hZERpcmVjdG9yeUZyb21EaXNrKHN3YXJtVXJsKShhcmcuZGVmYXVsdEZpbGUpKGFyZy5wYXRoKTtcbiAgICAgICAgfVxuXG4gICAgICAgIDsgLy8gVXBsb2FkIFVURi04IHN0cmluZyBvciByYXcgZGF0YSAoYnVmZmVyKVxuICAgICAgfSBlbHNlIGlmIChhcmcubGVuZ3RoIHx8IHR5cGVvZiBhcmcgPT09IFwic3RyaW5nXCIpIHtcbiAgICAgICAgcmV0dXJuIHVwbG9hZERhdGEoc3dhcm1VcmwpKGFyZyk7IC8vIFVwbG9hZCBkaXJlY3Rvcnkgd2l0aCBKU09OXG4gICAgICB9IGVsc2UgaWYgKGFyZyBpbnN0YW5jZW9mIE9iamVjdCkge1xuICAgICAgICByZXR1cm4gdXBsb2FkRGlyZWN0b3J5KHN3YXJtVXJsKShhcmcpO1xuICAgICAgfVxuXG4gICAgICByZXR1cm4gUHJvbWlzZS5yZWplY3QobmV3IEVycm9yKFwiQmFkIGFyZ3VtZW50c1wiKSk7XG4gICAgfTtcbiAgfTsgLy8gU3RyaW5nIC0+IFN0cmluZyAtPiBOdWxsYWJsZSBTdHJpbmcgLT4gUHJvbWlzZSAoU3RyaW5nIHwgVWludDhBcnJheSB8IE1hcCBTdHJpbmcgVWludDhBcnJheSlcbiAgLy8gICBTaW1wbGlmaWVkIG11bHRpLXR5cGUgZG93bmxvYWQgd2hpY2ggY2FsbHMgdGhlIGNvcnJlY3QgZnVuY3Rpb24gYmFzZWQgb25cbiAgLy8gICB0aGUgdHlwZSBvZiB0aGUgYXJndW1lbnQgZ2l2ZW4sIGFuZCBvbiB3aGV0aGVyIHRoZSBTd3dhcm0gYWRkcmVzcyBoYXMgYVxuICAvLyAgIGRpcmVjdG9yeSBvciBhIGZpbGUuXG5cblxuICB2YXIgX2Rvd25sb2FkID0gZnVuY3Rpb24gZG93bmxvYWQoc3dhcm1VcmwpIHtcbiAgICByZXR1cm4gZnVuY3Rpb24gKGhhc2gpIHtcbiAgICAgIHJldHVybiBmdW5jdGlvbiAocGF0aCkge1xuICAgICAgICByZXR1cm4gaXNEaXJlY3Rvcnkoc3dhcm1VcmwpKGhhc2gpLnRoZW4oZnVuY3Rpb24gKGlzRGlyKSB7XG4gICAgICAgICAgaWYgKGlzRGlyKSB7XG4gICAgICAgICAgICByZXR1cm4gcGF0aCA/IGRvd25sb2FkRGlyZWN0b3J5VG9EaXNrKHN3YXJtVXJsKShoYXNoKShwYXRoKSA6IGRvd25sb2FkRGlyZWN0b3J5KHN3YXJtVXJsKShoYXNoKTtcbiAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgcmV0dXJuIHBhdGggPyBkb3dubG9hZERhdGFUb0Rpc2soc3dhcm1VcmwpKGhhc2gpKHBhdGgpIDogZG93bmxvYWREYXRhKHN3YXJtVXJsKShoYXNoKTtcbiAgICAgICAgICB9XG4gICAgICAgIH0pO1xuICAgICAgfTtcbiAgICB9O1xuICB9OyAvLyBTdHJpbmcgLT4gUHJvbWlzZSBTdHJpbmdcbiAgLy8gICBEb3dubG9hZHMgdGhlIFN3YXJtIGJpbmFyaWVzIGludG8gYSBwYXRoLiBSZXR1cm5zIGEgcHJvbWlzZSB0aGF0IG9ubHlcbiAgLy8gICByZXNvbHZlcyB3aGVuIHRoZSBleGFjdCBTd2FybSBmaWxlIGlzIHRoZXJlLCBhbmQgdmVyaWZpZWQgdG8gYmUgY29ycmVjdC5cbiAgLy8gICBJZiBpdCB3YXMgYWxyZWFkeSB0aGVyZSB0byBiZWdpbiB3aXRoLCBza2lwcyB0aGUgZG93bmxvYWQuXG5cblxuICB2YXIgZG93bmxvYWRCaW5hcnkgPSBmdW5jdGlvbiBkb3dubG9hZEJpbmFyeShwYXRoLCBhcmNoaXZlcykge1xuICAgIHZhciBzeXN0ZW0gPSBvcy5wbGF0Zm9ybSgpLnJlcGxhY2UoXCJ3aW4zMlwiLCBcIndpbmRvd3NcIikgKyBcIi1cIiArIChvcy5hcmNoKCkgPT09IFwieDY0XCIgPyBcImFtZDY0XCIgOiBcIjM4NlwiKTtcbiAgICB2YXIgYXJjaGl2ZSA9IChhcmNoaXZlcyB8fCBkZWZhdWx0QXJjaGl2ZXMpW3N5c3RlbV07XG4gICAgdmFyIGFyY2hpdmVVcmwgPSBkb3dubG9hZFVybCArIGFyY2hpdmUuYXJjaGl2ZSArIFwiLnRhci5nelwiO1xuICAgIHZhciBhcmNoaXZlTUQ1ID0gYXJjaGl2ZS5hcmNoaXZlTUQ1O1xuICAgIHZhciBiaW5hcnlNRDUgPSBhcmNoaXZlLmJpbmFyeU1ENTtcbiAgICByZXR1cm4gZmlsZXMuc2FmZURvd25sb2FkQXJjaGl2ZWQoYXJjaGl2ZVVybCkoYXJjaGl2ZU1ENSkoYmluYXJ5TUQ1KShwYXRoKTtcbiAgfTsgLy8gdHlwZSBTd2FybVNldHVwID0ge1xuICAvLyAgIGFjY291bnQgOiBTdHJpbmcsXG4gIC8vICAgcGFzc3dvcmQgOiBTdHJpbmcsXG4gIC8vICAgZGF0YURpciA6IFN0cmluZyxcbiAgLy8gICBiaW5QYXRoIDogU3RyaW5nLFxuICAvLyAgIGVuc0FwaSA6IFN0cmluZyxcbiAgLy8gICBvbkRvd25sb2FkUHJvZ3Jlc3MgOiBOdW1iZXIgfj4gKCksXG4gIC8vICAgYXJjaGl2ZXMgOiBbe1xuICAvLyAgICAgYXJjaGl2ZTogU3RyaW5nLFxuICAvLyAgICAgYmluYXJ5TUQ1OiBTdHJpbmcsXG4gIC8vICAgICBhcmNoaXZlTUQ1OiBTdHJpbmdcbiAgLy8gICB9XVxuICAvLyB9XG4gIC8vIFN3YXJtU2V0dXAgfj4gUHJvbWlzZSBQcm9jZXNzXG4gIC8vICAgU3RhcnRzIHRoZSBTd2FybSBwcm9jZXNzLlxuXG5cbiAgdmFyIHN0YXJ0UHJvY2VzcyA9IGZ1bmN0aW9uIHN0YXJ0UHJvY2Vzcyhzd2FybVNldHVwKSB7XG4gICAgcmV0dXJuIG5ldyBQcm9taXNlKGZ1bmN0aW9uIChyZXNvbHZlLCByZWplY3QpIHtcbiAgICAgIHZhciBzcGF3biA9IGNoaWxkX3Byb2Nlc3Muc3Bhd247XG5cbiAgICAgIHZhciBoYXNTdHJpbmcgPSBmdW5jdGlvbiBoYXNTdHJpbmcoc3RyKSB7XG4gICAgICAgIHJldHVybiBmdW5jdGlvbiAoYnVmZmVyKSB7XG4gICAgICAgICAgcmV0dXJuICgnJyArIGJ1ZmZlcikuaW5kZXhPZihzdHIpICE9PSAtMTtcbiAgICAgICAgfTtcbiAgICAgIH07XG5cbiAgICAgIHZhciBhY2NvdW50ID0gc3dhcm1TZXR1cC5hY2NvdW50LFxuICAgICAgICAgIHBhc3N3b3JkID0gc3dhcm1TZXR1cC5wYXNzd29yZCxcbiAgICAgICAgICBkYXRhRGlyID0gc3dhcm1TZXR1cC5kYXRhRGlyLFxuICAgICAgICAgIGVuc0FwaSA9IHN3YXJtU2V0dXAuZW5zQXBpLFxuICAgICAgICAgIHByaXZhdGVLZXkgPSBzd2FybVNldHVwLnByaXZhdGVLZXk7XG4gICAgICB2YXIgU1RBUlRVUF9USU1FT1VUX1NFQ1MgPSAzO1xuICAgICAgdmFyIFdBSVRJTkdfUEFTU1dPUkQgPSAwO1xuICAgICAgdmFyIFNUQVJUSU5HID0gMTtcbiAgICAgIHZhciBMSVNURU5JTkcgPSAyO1xuICAgICAgdmFyIFBBU1NXT1JEX1BST01QVF9IT09LID0gXCJQYXNzcGhyYXNlXCI7XG4gICAgICB2YXIgTElTVEVOSU5HX0hPT0sgPSBcIlN3YXJtIGh0dHAgcHJveHkgc3RhcnRlZFwiO1xuICAgICAgdmFyIHN0YXRlID0gV0FJVElOR19QQVNTV09SRDtcbiAgICAgIHZhciBzd2FybVByb2Nlc3MgPSBzcGF3bihzd2FybVNldHVwLmJpblBhdGgsIFsnLS1ienphY2NvdW50JywgYWNjb3VudCB8fCBwcml2YXRlS2V5LCAnLS1kYXRhZGlyJywgZGF0YURpciwgJy0tZW5zLWFwaScsIGVuc0FwaV0pO1xuXG4gICAgICB2YXIgaGFuZGxlUHJvY2Vzc091dHB1dCA9IGZ1bmN0aW9uIGhhbmRsZVByb2Nlc3NPdXRwdXQoZGF0YSkge1xuICAgICAgICBpZiAoc3RhdGUgPT09IFdBSVRJTkdfUEFTU1dPUkQgJiYgaGFzU3RyaW5nKFBBU1NXT1JEX1BST01QVF9IT09LKShkYXRhKSkge1xuICAgICAgICAgIHNldFRpbWVvdXQoZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgc3RhdGUgPSBTVEFSVElORztcbiAgICAgICAgICAgIHN3YXJtUHJvY2Vzcy5zdGRpbi53cml0ZShwYXNzd29yZCArICdcXG4nKTtcbiAgICAgICAgICB9LCA1MDApO1xuICAgICAgICB9IGVsc2UgaWYgKGhhc1N0cmluZyhMSVNURU5JTkdfSE9PSykoZGF0YSkpIHtcbiAgICAgICAgICBzdGF0ZSA9IExJU1RFTklORztcbiAgICAgICAgICBjbGVhclRpbWVvdXQodGltZW91dCk7XG4gICAgICAgICAgcmVzb2x2ZShzd2FybVByb2Nlc3MpO1xuICAgICAgICB9XG4gICAgICB9O1xuXG4gICAgICBzd2FybVByb2Nlc3Muc3Rkb3V0Lm9uKCdkYXRhJywgaGFuZGxlUHJvY2Vzc091dHB1dCk7XG4gICAgICBzd2FybVByb2Nlc3Muc3RkZXJyLm9uKCdkYXRhJywgaGFuZGxlUHJvY2Vzc091dHB1dCk7IC8vc3dhcm1Qcm9jZXNzLm9uKCdjbG9zZScsICgpID0+IHNldFRpbWVvdXQocmVzdGFydCwgMjAwMCkpO1xuXG4gICAgICB2YXIgcmVzdGFydCA9IGZ1bmN0aW9uIHJlc3RhcnQoKSB7XG4gICAgICAgIHJldHVybiBzdGFydFByb2Nlc3Moc3dhcm1TZXR1cCkudGhlbihyZXNvbHZlKVtcImNhdGNoXCJdKHJlamVjdCk7XG4gICAgICB9O1xuXG4gICAgICB2YXIgZXJyb3IgPSBmdW5jdGlvbiBlcnJvcigpIHtcbiAgICAgICAgcmV0dXJuIHJlamVjdChuZXcgRXJyb3IoXCJDb3VsZG4ndCBzdGFydCBzd2FybSBwcm9jZXNzLlwiKSk7XG4gICAgICB9O1xuXG4gICAgICB2YXIgdGltZW91dCA9IHNldFRpbWVvdXQoZXJyb3IsIDIwMDAwKTtcbiAgICB9KTtcbiAgfTsgLy8gUHJvY2VzcyB+PiBQcm9taXNlICgpXG4gIC8vICAgU3RvcHMgdGhlIFN3YXJtIHByb2Nlc3MuXG5cblxuICB2YXIgc3RvcFByb2Nlc3MgPSBmdW5jdGlvbiBzdG9wUHJvY2Vzcyhwcm9jZXNzKSB7XG4gICAgcmV0dXJuIG5ldyBQcm9taXNlKGZ1bmN0aW9uIChyZXNvbHZlLCByZWplY3QpIHtcbiAgICAgIHByb2Nlc3Muc3RkZXJyLnJlbW92ZUFsbExpc3RlbmVycygnZGF0YScpO1xuICAgICAgcHJvY2Vzcy5zdGRvdXQucmVtb3ZlQWxsTGlzdGVuZXJzKCdkYXRhJyk7XG4gICAgICBwcm9jZXNzLnN0ZGluLnJlbW92ZUFsbExpc3RlbmVycygnZXJyb3InKTtcbiAgICAgIHByb2Nlc3MucmVtb3ZlQWxsTGlzdGVuZXJzKCdlcnJvcicpO1xuICAgICAgcHJvY2Vzcy5yZW1vdmVBbGxMaXN0ZW5lcnMoJ2V4aXQnKTtcbiAgICAgIHByb2Nlc3Mua2lsbCgnU0lHSU5UJyk7XG4gICAgICB2YXIga2lsbFRpbWVvdXQgPSBzZXRUaW1lb3V0KGZ1bmN0aW9uICgpIHtcbiAgICAgICAgcmV0dXJuIHByb2Nlc3Mua2lsbCgnU0lHS0lMTCcpO1xuICAgICAgfSwgODAwMCk7XG4gICAgICBwcm9jZXNzLm9uY2UoJ2Nsb3NlJywgZnVuY3Rpb24gKCkge1xuICAgICAgICBjbGVhclRpbWVvdXQoa2lsbFRpbWVvdXQpO1xuICAgICAgICByZXNvbHZlKCk7XG4gICAgICB9KTtcbiAgICB9KTtcbiAgfTsgLy8gU3dhcm1TZXR1cCAtPiAoU3dhcm1BUEkgLT4gUHJvbWlzZSAoKSkgLT4gUHJvbWlzZSAoKVxuICAvLyAgIFJlY2VpdmVzIGEgU3dhcm0gY29uZmlndXJhdGlvbiBvYmplY3QgYW5kIGEgY2FsbGJhY2sgZnVuY3Rpb24uIEl0IHRoZW5cbiAgLy8gICBjaGVja3MgaWYgYSBsb2NhbCBTd2FybSBub2RlIGlzIHJ1bm5pbmcuIElmIG5vIGxvY2FsIFN3YXJtIGlzIGZvdW5kLCBpdFxuICAvLyAgIGRvd25sb2FkcyB0aGUgU3dhcm0gYmluYXJpZXMgdG8gdGhlIGRhdGFEaXIgKGlmIG5vdCB0aGVyZSksIGNoZWNrc3VtcyxcbiAgLy8gICBzdGFydHMgdGhlIFN3YXJtIHByb2Nlc3MgYW5kIGNhbGxzIHRoZSBjYWxsYmFjayBmdW5jdGlvbiB3aXRoIGFuIEFQSVxuICAvLyAgIG9iamVjdCB1c2luZyB0aGUgbG9jYWwgbm9kZS4gVGhhdCBjYWxsYmFjayBtdXN0IHJldHVybiBhIHByb21pc2Ugd2hpY2hcbiAgLy8gICB3aWxsIHJlc29sdmUgd2hlbiBpdCBpcyBkb25lIHVzaW5nIHRoZSBBUEksIHNvIHRoYXQgdGhpcyBmdW5jdGlvbiBjYW5cbiAgLy8gICBjbG9zZSB0aGUgU3dhcm0gcHJvY2VzcyBwcm9wZXJseS4gUmV0dXJucyBhIHByb21pc2UgdGhhdCByZXNvbHZlcyB3aGVuIHRoZVxuICAvLyAgIHVzZXIgaXMgZG9uZSB3aXRoIHRoZSBBUEkgYW5kIHRoZSBTd2FybSBwcm9jZXNzIGlzIGNsb3NlZC5cbiAgLy8gICBUT0RPOiBjaGVjayBpZiBTd2FybSBwcm9jZXNzIGlzIGFscmVhZHkgcnVubmluZyAoaW1wcm92ZSBgaXNBdmFpbGFibGVgKVxuXG5cbiAgdmFyIGxvY2FsID0gZnVuY3Rpb24gbG9jYWwoc3dhcm1TZXR1cCkge1xuICAgIHJldHVybiBmdW5jdGlvbiAodXNlQVBJKSB7XG4gICAgICByZXR1cm4gX2lzQXZhaWxhYmxlKFwiaHR0cDovL2xvY2FsaG9zdDo4NTAwXCIpLnRoZW4oZnVuY3Rpb24gKGlzQXZhaWxhYmxlKSB7XG4gICAgICAgIHJldHVybiBpc0F2YWlsYWJsZSA/IHVzZUFQSShhdChcImh0dHA6Ly9sb2NhbGhvc3Q6ODUwMFwiKSkudGhlbihmdW5jdGlvbiAoKSB7fSkgOiBkb3dubG9hZEJpbmFyeShzd2FybVNldHVwLmJpblBhdGgsIHN3YXJtU2V0dXAuYXJjaGl2ZXMpLm9uRGF0YShmdW5jdGlvbiAoZGF0YSkge1xuICAgICAgICAgIHJldHVybiAoc3dhcm1TZXR1cC5vblByb2dyZXNzIHx8IGZ1bmN0aW9uICgpIHt9KShkYXRhLmxlbmd0aCk7XG4gICAgICAgIH0pLnRoZW4oZnVuY3Rpb24gKCkge1xuICAgICAgICAgIHJldHVybiBzdGFydFByb2Nlc3Moc3dhcm1TZXR1cCk7XG4gICAgICAgIH0pLnRoZW4oZnVuY3Rpb24gKHByb2Nlc3MpIHtcbiAgICAgICAgICByZXR1cm4gdXNlQVBJKGF0KFwiaHR0cDovL2xvY2FsaG9zdDo4NTAwXCIpKS50aGVuKGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIHJldHVybiBwcm9jZXNzO1xuICAgICAgICAgIH0pO1xuICAgICAgICB9KS50aGVuKHN0b3BQcm9jZXNzKTtcbiAgICAgIH0pO1xuICAgIH07XG4gIH07IC8vIFN0cmluZyB+PiBQcm9taXNlIEJvb2xcbiAgLy8gICBSZXR1cm5zIHRydWUgaWYgU3dhcm0gaXMgYXZhaWxhYmxlIG9uIGB1cmxgLlxuICAvLyAgIFBlcmZvbXMgYSB0ZXN0IHVwbG9hZCB0byBkZXRlcm1pbmUgdGhhdC5cbiAgLy8gICBUT0RPOiBpbXByb3ZlIHRoaXM/XG5cblxuICB2YXIgX2lzQXZhaWxhYmxlID0gZnVuY3Rpb24gaXNBdmFpbGFibGUoc3dhcm1VcmwpIHtcbiAgICB2YXIgdGVzdEZpbGUgPSBcInRlc3RcIjtcbiAgICB2YXIgdGVzdEhhc2ggPSBcImM5YTk5YzdkMzI2ZGNjNjMxNmYzMmZlMjYyNWIzMTFmNmRjNDlhMTc1ZTY4Nzc2ODFkZWQ5MzEzN2QzNTY5ZTdcIjtcbiAgICByZXR1cm4gdXBsb2FkRGF0YShzd2FybVVybCkodGVzdEZpbGUpLnRoZW4oZnVuY3Rpb24gKGhhc2gpIHtcbiAgICAgIHJldHVybiBoYXNoID09PSB0ZXN0SGFzaDtcbiAgICB9KVtcImNhdGNoXCJdKGZ1bmN0aW9uICgpIHtcbiAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9KTtcbiAgfTsgLy8gU3RyaW5nIC0+IFN0cmluZyB+PiBQcm9taXNlIEJvb2xcbiAgLy8gICBSZXR1cm5zIGEgUHJvbWlzZSB3aGljaCBpcyB0cnVlIGlmIHRoYXQgU3dhcm0gYWRkcmVzcyBpcyBhIGRpcmVjdG9yeS5cbiAgLy8gICBEZXRlcm1pbmVzIHRoYXQgYnkgY2hlY2tpbmcgdGhhdCBpdCAoaSkgaXMgYSBKU09OLCAoaWkpIGhhcyBhIC5lbnRyaWVzLlxuICAvLyAgIFRPRE86IGltcHJvdmUgdGhpcz9cblxuXG4gIHZhciBpc0RpcmVjdG9yeSA9IGZ1bmN0aW9uIGlzRGlyZWN0b3J5KHN3YXJtVXJsKSB7XG4gICAgcmV0dXJuIGZ1bmN0aW9uIChoYXNoKSB7XG4gICAgICByZXR1cm4gZG93bmxvYWREYXRhKHN3YXJtVXJsKShoYXNoKS50aGVuKGZ1bmN0aW9uIChkYXRhKSB7XG4gICAgICAgIHRyeSB7XG4gICAgICAgICAgcmV0dXJuICEhSlNPTi5wYXJzZSh0b1N0cmluZyhkYXRhKSkuZW50cmllcztcbiAgICAgICAgfSBjYXRjaCAoZSkge1xuICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgfVxuICAgICAgfSk7XG4gICAgfTtcbiAgfTsgLy8gVW5jdXJyaWVzIGEgZnVuY3Rpb247IHVzZWQgdG8gYWxsb3cgdGhlIGYoeCx5LHopIHN0eWxlIG9uIGV4cG9ydHMuXG5cblxuICB2YXIgdW5jdXJyeSA9IGZ1bmN0aW9uIHVuY3VycnkoZikge1xuICAgIHJldHVybiBmdW5jdGlvbiAoYSwgYiwgYywgZCwgZSkge1xuICAgICAgdmFyIHA7IC8vIEhhcmRjb2RlZCBiZWNhdXNlIGVmZmljaWVuY3kgKGBhcmd1bWVudHNgIGlzIHZlcnkgc2xvdykuXG5cbiAgICAgIGlmICh0eXBlb2YgYSAhPT0gXCJ1bmRlZmluZWRcIikgcCA9IGYoYSk7XG4gICAgICBpZiAodHlwZW9mIGIgIT09IFwidW5kZWZpbmVkXCIpIHAgPSBmKGIpO1xuICAgICAgaWYgKHR5cGVvZiBjICE9PSBcInVuZGVmaW5lZFwiKSBwID0gZihjKTtcbiAgICAgIGlmICh0eXBlb2YgZCAhPT0gXCJ1bmRlZmluZWRcIikgcCA9IGYoZCk7XG4gICAgICBpZiAodHlwZW9mIGUgIT09IFwidW5kZWZpbmVkXCIpIHAgPSBmKGUpO1xuICAgICAgcmV0dXJuIHA7XG4gICAgfTtcbiAgfTsgLy8gKCkgLT4gUHJvbWlzZSBCb29sXG4gIC8vICAgTm90IHN1cmUgaG93IHRvIG1vY2sgU3dhcm0gdG8gdGVzdCBpdCBwcm9wZXJseS4gSWRlYXM/XG5cblxuICB2YXIgdGVzdCA9IGZ1bmN0aW9uIHRlc3QoKSB7XG4gICAgcmV0dXJuIFByb21pc2UucmVzb2x2ZSh0cnVlKTtcbiAgfTsgLy8gVWludDhBcnJheSAtPiBTdHJpbmdcblxuXG4gIHZhciB0b1N0cmluZyA9IGZ1bmN0aW9uIHRvU3RyaW5nKHVpbnQ4QXJyYXkpIHtcbiAgICByZXR1cm4gYnl0ZXMudG9TdHJpbmcoYnl0ZXMuZnJvbVVpbnQ4QXJyYXkodWludDhBcnJheSkpO1xuICB9OyAvLyBTdHJpbmcgLT4gVWludDhBcnJheVxuXG5cbiAgdmFyIGZyb21TdHJpbmcgPSBmdW5jdGlvbiBmcm9tU3RyaW5nKHN0cmluZykge1xuICAgIHJldHVybiBieXRlcy50b1VpbnQ4QXJyYXkoYnl0ZXMuZnJvbVN0cmluZyhzdHJpbmcpKTtcbiAgfTsgLy8gU3RyaW5nIC0+IFN3YXJtQVBJXG4gIC8vICAgRml4ZXMgdGhlIGBzd2FybVVybGAsIHJldHVybmluZyBhbiBBUEkgd2hlcmUgeW91IGRvbid0IGhhdmUgdG8gcGFzcyBpdC5cblxuXG4gIHZhciBhdCA9IGZ1bmN0aW9uIGF0KHN3YXJtVXJsKSB7XG4gICAgcmV0dXJuIHtcbiAgICAgIGRvd25sb2FkOiBmdW5jdGlvbiBkb3dubG9hZChoYXNoLCBwYXRoKSB7XG4gICAgICAgIHJldHVybiBfZG93bmxvYWQoc3dhcm1VcmwpKGhhc2gpKHBhdGgpO1xuICAgICAgfSxcbiAgICAgIGRvd25sb2FkRGF0YTogdW5jdXJyeShkb3dubG9hZERhdGEoc3dhcm1VcmwpKSxcbiAgICAgIGRvd25sb2FkRGF0YVRvRGlzazogdW5jdXJyeShkb3dubG9hZERhdGFUb0Rpc2soc3dhcm1VcmwpKSxcbiAgICAgIGRvd25sb2FkRGlyZWN0b3J5OiB1bmN1cnJ5KGRvd25sb2FkRGlyZWN0b3J5KHN3YXJtVXJsKSksXG4gICAgICBkb3dubG9hZERpcmVjdG9yeVRvRGlzazogdW5jdXJyeShkb3dubG9hZERpcmVjdG9yeVRvRGlzayhzd2FybVVybCkpLFxuICAgICAgZG93bmxvYWRFbnRyaWVzOiB1bmN1cnJ5KGRvd25sb2FkRW50cmllcyhzd2FybVVybCkpLFxuICAgICAgZG93bmxvYWRSb3V0ZXM6IHVuY3VycnkoZG93bmxvYWRSb3V0ZXMoc3dhcm1VcmwpKSxcbiAgICAgIGlzQXZhaWxhYmxlOiBmdW5jdGlvbiBpc0F2YWlsYWJsZSgpIHtcbiAgICAgICAgcmV0dXJuIF9pc0F2YWlsYWJsZShzd2FybVVybCk7XG4gICAgICB9LFxuICAgICAgdXBsb2FkOiBmdW5jdGlvbiB1cGxvYWQoYXJnKSB7XG4gICAgICAgIHJldHVybiBfdXBsb2FkKHN3YXJtVXJsKShhcmcpO1xuICAgICAgfSxcbiAgICAgIHVwbG9hZERhdGE6IHVuY3VycnkodXBsb2FkRGF0YShzd2FybVVybCkpLFxuICAgICAgdXBsb2FkRmlsZTogdW5jdXJyeSh1cGxvYWRGaWxlKHN3YXJtVXJsKSksXG4gICAgICB1cGxvYWRGaWxlRnJvbURpc2s6IHVuY3VycnkodXBsb2FkRmlsZShzd2FybVVybCkpLFxuICAgICAgdXBsb2FkRGF0YUZyb21EaXNrOiB1bmN1cnJ5KHVwbG9hZERhdGFGcm9tRGlzayhzd2FybVVybCkpLFxuICAgICAgdXBsb2FkRGlyZWN0b3J5OiB1bmN1cnJ5KHVwbG9hZERpcmVjdG9yeShzd2FybVVybCkpLFxuICAgICAgdXBsb2FkRGlyZWN0b3J5RnJvbURpc2s6IHVuY3VycnkodXBsb2FkRGlyZWN0b3J5RnJvbURpc2soc3dhcm1VcmwpKSxcbiAgICAgIHVwbG9hZFRvTWFuaWZlc3Q6IHVuY3VycnkodXBsb2FkVG9NYW5pZmVzdChzd2FybVVybCkpLFxuICAgICAgcGljazogcGljayxcbiAgICAgIGhhc2g6IGhhc2gsXG4gICAgICBmcm9tU3RyaW5nOiBmcm9tU3RyaW5nLFxuICAgICAgdG9TdHJpbmc6IHRvU3RyaW5nXG4gICAgfTtcbiAgfTtcblxuICByZXR1cm4ge1xuICAgIGF0OiBhdCxcbiAgICBsb2NhbDogbG9jYWwsXG4gICAgZG93bmxvYWQ6IF9kb3dubG9hZCxcbiAgICBkb3dubG9hZEJpbmFyeTogZG93bmxvYWRCaW5hcnksXG4gICAgZG93bmxvYWREYXRhOiBkb3dubG9hZERhdGEsXG4gICAgZG93bmxvYWREYXRhVG9EaXNrOiBkb3dubG9hZERhdGFUb0Rpc2ssXG4gICAgZG93bmxvYWREaXJlY3Rvcnk6IGRvd25sb2FkRGlyZWN0b3J5LFxuICAgIGRvd25sb2FkRGlyZWN0b3J5VG9EaXNrOiBkb3dubG9hZERpcmVjdG9yeVRvRGlzayxcbiAgICBkb3dubG9hZEVudHJpZXM6IGRvd25sb2FkRW50cmllcyxcbiAgICBkb3dubG9hZFJvdXRlczogZG93bmxvYWRSb3V0ZXMsXG4gICAgaXNBdmFpbGFibGU6IF9pc0F2YWlsYWJsZSxcbiAgICBzdGFydFByb2Nlc3M6IHN0YXJ0UHJvY2VzcyxcbiAgICBzdG9wUHJvY2Vzczogc3RvcFByb2Nlc3MsXG4gICAgdXBsb2FkOiBfdXBsb2FkLFxuICAgIHVwbG9hZERhdGE6IHVwbG9hZERhdGEsXG4gICAgdXBsb2FkRGF0YUZyb21EaXNrOiB1cGxvYWREYXRhRnJvbURpc2ssXG4gICAgdXBsb2FkRmlsZTogdXBsb2FkRmlsZSxcbiAgICB1cGxvYWRGaWxlRnJvbURpc2s6IHVwbG9hZEZpbGVGcm9tRGlzayxcbiAgICB1cGxvYWREaXJlY3Rvcnk6IHVwbG9hZERpcmVjdG9yeSxcbiAgICB1cGxvYWREaXJlY3RvcnlGcm9tRGlzazogdXBsb2FkRGlyZWN0b3J5RnJvbURpc2ssXG4gICAgdXBsb2FkVG9NYW5pZmVzdDogdXBsb2FkVG9NYW5pZmVzdCxcbiAgICBwaWNrOiBwaWNrLFxuICAgIGhhc2g6IGhhc2gsXG4gICAgZnJvbVN0cmluZzogZnJvbVN0cmluZyxcbiAgICB0b1N0cmluZzogdG9TdHJpbmdcbiAgfTtcbn07Il0sIm5hbWVzIjpbXSwiaWdub3JlTGlzdCI6WzBdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/swarm-js/lib/swarm.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/swarm-js/node_modules/@szmarczak/http-timer/dist/source/index.js":
/*!***************************************************************************************!*\
  !*** ./node_modules/swarm-js/node_modules/@szmarczak/http-timer/dist/source/index.js ***!
  \***************************************************************************************/
/***/ ((module, exports, __webpack_require__) => {

"use strict";
eval("\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nconst defer_to_connect_1 = __webpack_require__(/*! defer-to-connect */ \"(ssr)/./node_modules/defer-to-connect/dist/source/index.js\");\nconst util_1 = __webpack_require__(/*! util */ \"util\");\nconst nodejsMajorVersion = Number(process.versions.node.split('.')[0]);\nconst timer = (request) => {\n    if (request.timings) {\n        return request.timings;\n    }\n    const timings = {\n        start: Date.now(),\n        socket: undefined,\n        lookup: undefined,\n        connect: undefined,\n        secureConnect: undefined,\n        upload: undefined,\n        response: undefined,\n        end: undefined,\n        error: undefined,\n        abort: undefined,\n        phases: {\n            wait: undefined,\n            dns: undefined,\n            tcp: undefined,\n            tls: undefined,\n            request: undefined,\n            firstByte: undefined,\n            download: undefined,\n            total: undefined\n        }\n    };\n    request.timings = timings;\n    const handleError = (origin) => {\n        const emit = origin.emit.bind(origin);\n        origin.emit = (event, ...args) => {\n            // Catches the `error` event\n            if (event === 'error') {\n                timings.error = Date.now();\n                timings.phases.total = timings.error - timings.start;\n                origin.emit = emit;\n            }\n            // Saves the original behavior\n            return emit(event, ...args);\n        };\n    };\n    handleError(request);\n    const onAbort = () => {\n        timings.abort = Date.now();\n        // Let the `end` response event be responsible for setting the total phase,\n        // unless the Node.js major version is >= 13.\n        if (!timings.response || nodejsMajorVersion >= 13) {\n            timings.phases.total = Date.now() - timings.start;\n        }\n    };\n    request.prependOnceListener('abort', onAbort);\n    const onSocket = (socket) => {\n        timings.socket = Date.now();\n        timings.phases.wait = timings.socket - timings.start;\n        if (util_1.types.isProxy(socket)) {\n            return;\n        }\n        const lookupListener = () => {\n            timings.lookup = Date.now();\n            timings.phases.dns = timings.lookup - timings.socket;\n        };\n        socket.prependOnceListener('lookup', lookupListener);\n        defer_to_connect_1.default(socket, {\n            connect: () => {\n                timings.connect = Date.now();\n                if (timings.lookup === undefined) {\n                    socket.removeListener('lookup', lookupListener);\n                    timings.lookup = timings.connect;\n                    timings.phases.dns = timings.lookup - timings.socket;\n                }\n                timings.phases.tcp = timings.connect - timings.lookup;\n                // This callback is called before flushing any data,\n                // so we don't need to set `timings.phases.request` here.\n            },\n            secureConnect: () => {\n                timings.secureConnect = Date.now();\n                timings.phases.tls = timings.secureConnect - timings.connect;\n            }\n        });\n    };\n    if (request.socket) {\n        onSocket(request.socket);\n    }\n    else {\n        request.prependOnceListener('socket', onSocket);\n    }\n    const onUpload = () => {\n        var _a;\n        timings.upload = Date.now();\n        timings.phases.request = timings.upload - ((_a = timings.secureConnect) !== null && _a !== void 0 ? _a : timings.connect);\n    };\n    const writableFinished = () => {\n        if (typeof request.writableFinished === 'boolean') {\n            return request.writableFinished;\n        }\n        // Node.js doesn't have `request.writableFinished` property\n        return request.finished && request.outputSize === 0 && (!request.socket || request.socket.writableLength === 0);\n    };\n    if (writableFinished()) {\n        onUpload();\n    }\n    else {\n        request.prependOnceListener('finish', onUpload);\n    }\n    request.prependOnceListener('response', (response) => {\n        timings.response = Date.now();\n        timings.phases.firstByte = timings.response - timings.upload;\n        response.timings = timings;\n        handleError(response);\n        response.prependOnceListener('end', () => {\n            timings.end = Date.now();\n            timings.phases.download = timings.end - timings.response;\n            timings.phases.total = timings.end - timings.start;\n        });\n        response.prependOnceListener('aborted', onAbort);\n    });\n    return timings;\n};\nexports[\"default\"] = timer;\n// For CommonJS default export support\nmodule.exports = timer;\nmodule.exports[\"default\"] = timer;\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvc3dhcm0tanMvbm9kZV9tb2R1bGVzL0Bzem1hcmN6YWsvaHR0cC10aW1lci9kaXN0L3NvdXJjZS9pbmRleC5qcyIsIm1hcHBpbmdzIjoiQUFBYTtBQUNiLDhDQUE2QyxFQUFFLGFBQWEsRUFBQztBQUM3RCwyQkFBMkIsbUJBQU8sQ0FBQyxvRkFBa0I7QUFDckQsZUFBZSxtQkFBTyxDQUFDLGtCQUFNO0FBQzdCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQSxrQkFBZTtBQUNmO0FBQ0E7QUFDQSx5QkFBc0IiLCJzb3VyY2VzIjpbIi9Vc2Vycy9wYW56YS9Eb2N1bWVudHMvUGVyc29uYWxQcm9qZWN0cy9wcmVkaWsvbm9kZV9tb2R1bGVzL3N3YXJtLWpzL25vZGVfbW9kdWxlcy9Ac3ptYXJjemFrL2h0dHAtdGltZXIvZGlzdC9zb3VyY2UvaW5kZXguanMiXSwic291cmNlc0NvbnRlbnQiOlsiXCJ1c2Ugc3RyaWN0XCI7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XG5jb25zdCBkZWZlcl90b19jb25uZWN0XzEgPSByZXF1aXJlKFwiZGVmZXItdG8tY29ubmVjdFwiKTtcbmNvbnN0IHV0aWxfMSA9IHJlcXVpcmUoXCJ1dGlsXCIpO1xuY29uc3Qgbm9kZWpzTWFqb3JWZXJzaW9uID0gTnVtYmVyKHByb2Nlc3MudmVyc2lvbnMubm9kZS5zcGxpdCgnLicpWzBdKTtcbmNvbnN0IHRpbWVyID0gKHJlcXVlc3QpID0+IHtcbiAgICBpZiAocmVxdWVzdC50aW1pbmdzKSB7XG4gICAgICAgIHJldHVybiByZXF1ZXN0LnRpbWluZ3M7XG4gICAgfVxuICAgIGNvbnN0IHRpbWluZ3MgPSB7XG4gICAgICAgIHN0YXJ0OiBEYXRlLm5vdygpLFxuICAgICAgICBzb2NrZXQ6IHVuZGVmaW5lZCxcbiAgICAgICAgbG9va3VwOiB1bmRlZmluZWQsXG4gICAgICAgIGNvbm5lY3Q6IHVuZGVmaW5lZCxcbiAgICAgICAgc2VjdXJlQ29ubmVjdDogdW5kZWZpbmVkLFxuICAgICAgICB1cGxvYWQ6IHVuZGVmaW5lZCxcbiAgICAgICAgcmVzcG9uc2U6IHVuZGVmaW5lZCxcbiAgICAgICAgZW5kOiB1bmRlZmluZWQsXG4gICAgICAgIGVycm9yOiB1bmRlZmluZWQsXG4gICAgICAgIGFib3J0OiB1bmRlZmluZWQsXG4gICAgICAgIHBoYXNlczoge1xuICAgICAgICAgICAgd2FpdDogdW5kZWZpbmVkLFxuICAgICAgICAgICAgZG5zOiB1bmRlZmluZWQsXG4gICAgICAgICAgICB0Y3A6IHVuZGVmaW5lZCxcbiAgICAgICAgICAgIHRsczogdW5kZWZpbmVkLFxuICAgICAgICAgICAgcmVxdWVzdDogdW5kZWZpbmVkLFxuICAgICAgICAgICAgZmlyc3RCeXRlOiB1bmRlZmluZWQsXG4gICAgICAgICAgICBkb3dubG9hZDogdW5kZWZpbmVkLFxuICAgICAgICAgICAgdG90YWw6IHVuZGVmaW5lZFxuICAgICAgICB9XG4gICAgfTtcbiAgICByZXF1ZXN0LnRpbWluZ3MgPSB0aW1pbmdzO1xuICAgIGNvbnN0IGhhbmRsZUVycm9yID0gKG9yaWdpbikgPT4ge1xuICAgICAgICBjb25zdCBlbWl0ID0gb3JpZ2luLmVtaXQuYmluZChvcmlnaW4pO1xuICAgICAgICBvcmlnaW4uZW1pdCA9IChldmVudCwgLi4uYXJncykgPT4ge1xuICAgICAgICAgICAgLy8gQ2F0Y2hlcyB0aGUgYGVycm9yYCBldmVudFxuICAgICAgICAgICAgaWYgKGV2ZW50ID09PSAnZXJyb3InKSB7XG4gICAgICAgICAgICAgICAgdGltaW5ncy5lcnJvciA9IERhdGUubm93KCk7XG4gICAgICAgICAgICAgICAgdGltaW5ncy5waGFzZXMudG90YWwgPSB0aW1pbmdzLmVycm9yIC0gdGltaW5ncy5zdGFydDtcbiAgICAgICAgICAgICAgICBvcmlnaW4uZW1pdCA9IGVtaXQ7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICAvLyBTYXZlcyB0aGUgb3JpZ2luYWwgYmVoYXZpb3JcbiAgICAgICAgICAgIHJldHVybiBlbWl0KGV2ZW50LCAuLi5hcmdzKTtcbiAgICAgICAgfTtcbiAgICB9O1xuICAgIGhhbmRsZUVycm9yKHJlcXVlc3QpO1xuICAgIGNvbnN0IG9uQWJvcnQgPSAoKSA9PiB7XG4gICAgICAgIHRpbWluZ3MuYWJvcnQgPSBEYXRlLm5vdygpO1xuICAgICAgICAvLyBMZXQgdGhlIGBlbmRgIHJlc3BvbnNlIGV2ZW50IGJlIHJlc3BvbnNpYmxlIGZvciBzZXR0aW5nIHRoZSB0b3RhbCBwaGFzZSxcbiAgICAgICAgLy8gdW5sZXNzIHRoZSBOb2RlLmpzIG1ham9yIHZlcnNpb24gaXMgPj0gMTMuXG4gICAgICAgIGlmICghdGltaW5ncy5yZXNwb25zZSB8fCBub2RlanNNYWpvclZlcnNpb24gPj0gMTMpIHtcbiAgICAgICAgICAgIHRpbWluZ3MucGhhc2VzLnRvdGFsID0gRGF0ZS5ub3coKSAtIHRpbWluZ3Muc3RhcnQ7XG4gICAgICAgIH1cbiAgICB9O1xuICAgIHJlcXVlc3QucHJlcGVuZE9uY2VMaXN0ZW5lcignYWJvcnQnLCBvbkFib3J0KTtcbiAgICBjb25zdCBvblNvY2tldCA9IChzb2NrZXQpID0+IHtcbiAgICAgICAgdGltaW5ncy5zb2NrZXQgPSBEYXRlLm5vdygpO1xuICAgICAgICB0aW1pbmdzLnBoYXNlcy53YWl0ID0gdGltaW5ncy5zb2NrZXQgLSB0aW1pbmdzLnN0YXJ0O1xuICAgICAgICBpZiAodXRpbF8xLnR5cGVzLmlzUHJveHkoc29ja2V0KSkge1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICAgIGNvbnN0IGxvb2t1cExpc3RlbmVyID0gKCkgPT4ge1xuICAgICAgICAgICAgdGltaW5ncy5sb29rdXAgPSBEYXRlLm5vdygpO1xuICAgICAgICAgICAgdGltaW5ncy5waGFzZXMuZG5zID0gdGltaW5ncy5sb29rdXAgLSB0aW1pbmdzLnNvY2tldDtcbiAgICAgICAgfTtcbiAgICAgICAgc29ja2V0LnByZXBlbmRPbmNlTGlzdGVuZXIoJ2xvb2t1cCcsIGxvb2t1cExpc3RlbmVyKTtcbiAgICAgICAgZGVmZXJfdG9fY29ubmVjdF8xLmRlZmF1bHQoc29ja2V0LCB7XG4gICAgICAgICAgICBjb25uZWN0OiAoKSA9PiB7XG4gICAgICAgICAgICAgICAgdGltaW5ncy5jb25uZWN0ID0gRGF0ZS5ub3coKTtcbiAgICAgICAgICAgICAgICBpZiAodGltaW5ncy5sb29rdXAgPT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgICAgICAgICBzb2NrZXQucmVtb3ZlTGlzdGVuZXIoJ2xvb2t1cCcsIGxvb2t1cExpc3RlbmVyKTtcbiAgICAgICAgICAgICAgICAgICAgdGltaW5ncy5sb29rdXAgPSB0aW1pbmdzLmNvbm5lY3Q7XG4gICAgICAgICAgICAgICAgICAgIHRpbWluZ3MucGhhc2VzLmRucyA9IHRpbWluZ3MubG9va3VwIC0gdGltaW5ncy5zb2NrZXQ7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIHRpbWluZ3MucGhhc2VzLnRjcCA9IHRpbWluZ3MuY29ubmVjdCAtIHRpbWluZ3MubG9va3VwO1xuICAgICAgICAgICAgICAgIC8vIFRoaXMgY2FsbGJhY2sgaXMgY2FsbGVkIGJlZm9yZSBmbHVzaGluZyBhbnkgZGF0YSxcbiAgICAgICAgICAgICAgICAvLyBzbyB3ZSBkb24ndCBuZWVkIHRvIHNldCBgdGltaW5ncy5waGFzZXMucmVxdWVzdGAgaGVyZS5cbiAgICAgICAgICAgIH0sXG4gICAgICAgICAgICBzZWN1cmVDb25uZWN0OiAoKSA9PiB7XG4gICAgICAgICAgICAgICAgdGltaW5ncy5zZWN1cmVDb25uZWN0ID0gRGF0ZS5ub3coKTtcbiAgICAgICAgICAgICAgICB0aW1pbmdzLnBoYXNlcy50bHMgPSB0aW1pbmdzLnNlY3VyZUNvbm5lY3QgLSB0aW1pbmdzLmNvbm5lY3Q7XG4gICAgICAgICAgICB9XG4gICAgICAgIH0pO1xuICAgIH07XG4gICAgaWYgKHJlcXVlc3Quc29ja2V0KSB7XG4gICAgICAgIG9uU29ja2V0KHJlcXVlc3Quc29ja2V0KTtcbiAgICB9XG4gICAgZWxzZSB7XG4gICAgICAgIHJlcXVlc3QucHJlcGVuZE9uY2VMaXN0ZW5lcignc29ja2V0Jywgb25Tb2NrZXQpO1xuICAgIH1cbiAgICBjb25zdCBvblVwbG9hZCA9ICgpID0+IHtcbiAgICAgICAgdmFyIF9hO1xuICAgICAgICB0aW1pbmdzLnVwbG9hZCA9IERhdGUubm93KCk7XG4gICAgICAgIHRpbWluZ3MucGhhc2VzLnJlcXVlc3QgPSB0aW1pbmdzLnVwbG9hZCAtICgoX2EgPSB0aW1pbmdzLnNlY3VyZUNvbm5lY3QpICE9PSBudWxsICYmIF9hICE9PSB2b2lkIDAgPyBfYSA6IHRpbWluZ3MuY29ubmVjdCk7XG4gICAgfTtcbiAgICBjb25zdCB3cml0YWJsZUZpbmlzaGVkID0gKCkgPT4ge1xuICAgICAgICBpZiAodHlwZW9mIHJlcXVlc3Qud3JpdGFibGVGaW5pc2hlZCA9PT0gJ2Jvb2xlYW4nKSB7XG4gICAgICAgICAgICByZXR1cm4gcmVxdWVzdC53cml0YWJsZUZpbmlzaGVkO1xuICAgICAgICB9XG4gICAgICAgIC8vIE5vZGUuanMgZG9lc24ndCBoYXZlIGByZXF1ZXN0LndyaXRhYmxlRmluaXNoZWRgIHByb3BlcnR5XG4gICAgICAgIHJldHVybiByZXF1ZXN0LmZpbmlzaGVkICYmIHJlcXVlc3Qub3V0cHV0U2l6ZSA9PT0gMCAmJiAoIXJlcXVlc3Quc29ja2V0IHx8IHJlcXVlc3Quc29ja2V0LndyaXRhYmxlTGVuZ3RoID09PSAwKTtcbiAgICB9O1xuICAgIGlmICh3cml0YWJsZUZpbmlzaGVkKCkpIHtcbiAgICAgICAgb25VcGxvYWQoKTtcbiAgICB9XG4gICAgZWxzZSB7XG4gICAgICAgIHJlcXVlc3QucHJlcGVuZE9uY2VMaXN0ZW5lcignZmluaXNoJywgb25VcGxvYWQpO1xuICAgIH1cbiAgICByZXF1ZXN0LnByZXBlbmRPbmNlTGlzdGVuZXIoJ3Jlc3BvbnNlJywgKHJlc3BvbnNlKSA9PiB7XG4gICAgICAgIHRpbWluZ3MucmVzcG9uc2UgPSBEYXRlLm5vdygpO1xuICAgICAgICB0aW1pbmdzLnBoYXNlcy5maXJzdEJ5dGUgPSB0aW1pbmdzLnJlc3BvbnNlIC0gdGltaW5ncy51cGxvYWQ7XG4gICAgICAgIHJlc3BvbnNlLnRpbWluZ3MgPSB0aW1pbmdzO1xuICAgICAgICBoYW5kbGVFcnJvcihyZXNwb25zZSk7XG4gICAgICAgIHJlc3BvbnNlLnByZXBlbmRPbmNlTGlzdGVuZXIoJ2VuZCcsICgpID0+IHtcbiAgICAgICAgICAgIHRpbWluZ3MuZW5kID0gRGF0ZS5ub3coKTtcbiAgICAgICAgICAgIHRpbWluZ3MucGhhc2VzLmRvd25sb2FkID0gdGltaW5ncy5lbmQgLSB0aW1pbmdzLnJlc3BvbnNlO1xuICAgICAgICAgICAgdGltaW5ncy5waGFzZXMudG90YWwgPSB0aW1pbmdzLmVuZCAtIHRpbWluZ3Muc3RhcnQ7XG4gICAgICAgIH0pO1xuICAgICAgICByZXNwb25zZS5wcmVwZW5kT25jZUxpc3RlbmVyKCdhYm9ydGVkJywgb25BYm9ydCk7XG4gICAgfSk7XG4gICAgcmV0dXJuIHRpbWluZ3M7XG59O1xuZXhwb3J0cy5kZWZhdWx0ID0gdGltZXI7XG4vLyBGb3IgQ29tbW9uSlMgZGVmYXVsdCBleHBvcnQgc3VwcG9ydFxubW9kdWxlLmV4cG9ydHMgPSB0aW1lcjtcbm1vZHVsZS5leHBvcnRzLmRlZmF1bHQgPSB0aW1lcjtcbiJdLCJuYW1lcyI6W10sImlnbm9yZUxpc3QiOlswXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/swarm-js/node_modules/@szmarczak/http-timer/dist/source/index.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/swarm-js/node_modules/cacheable-lookup/source/index.js":
/*!*****************************************************************************!*\
  !*** ./node_modules/swarm-js/node_modules/cacheable-lookup/source/index.js ***!
  \*****************************************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";
eval("\nconst {\n\tV4MAPPED,\n\tADDRCONFIG,\n\tALL,\n\tpromises: {\n\t\tResolver: AsyncResolver\n\t},\n\tlookup: dnsLookup\n} = __webpack_require__(/*! dns */ \"dns\");\nconst {promisify} = __webpack_require__(/*! util */ \"util\");\nconst os = __webpack_require__(/*! os */ \"os\");\n\nconst kCacheableLookupCreateConnection = Symbol('cacheableLookupCreateConnection');\nconst kCacheableLookupInstance = Symbol('cacheableLookupInstance');\nconst kExpires = Symbol('expires');\n\nconst supportsALL = typeof ALL === 'number';\n\nconst verifyAgent = agent => {\n\tif (!(agent && typeof agent.createConnection === 'function')) {\n\t\tthrow new Error('Expected an Agent instance as the first argument');\n\t}\n};\n\nconst map4to6 = entries => {\n\tfor (const entry of entries) {\n\t\tif (entry.family === 6) {\n\t\t\tcontinue;\n\t\t}\n\n\t\tentry.address = `::ffff:${entry.address}`;\n\t\tentry.family = 6;\n\t}\n};\n\nconst getIfaceInfo = () => {\n\tlet has4 = false;\n\tlet has6 = false;\n\n\tfor (const device of Object.values(os.networkInterfaces())) {\n\t\tfor (const iface of device) {\n\t\t\tif (iface.internal) {\n\t\t\t\tcontinue;\n\t\t\t}\n\n\t\t\tif (iface.family === 'IPv6') {\n\t\t\t\thas6 = true;\n\t\t\t} else {\n\t\t\t\thas4 = true;\n\t\t\t}\n\n\t\t\tif (has4 && has6) {\n\t\t\t\treturn {has4, has6};\n\t\t\t}\n\t\t}\n\t}\n\n\treturn {has4, has6};\n};\n\nconst isIterable = map => {\n\treturn Symbol.iterator in map;\n};\n\nconst ttl = {ttl: true};\nconst all = {all: true};\n\nclass CacheableLookup {\n\tconstructor({\n\t\tcache = new Map(),\n\t\tmaxTtl = Infinity,\n\t\tfallbackDuration = 3600,\n\t\terrorTtl = 0.15,\n\t\tresolver = new AsyncResolver(),\n\t\tlookup = dnsLookup\n\t} = {}) {\n\t\tthis.maxTtl = maxTtl;\n\t\tthis.errorTtl = errorTtl;\n\n\t\tthis._cache = cache;\n\t\tthis._resolver = resolver;\n\t\tthis._dnsLookup = promisify(lookup);\n\n\t\tif (this._resolver instanceof AsyncResolver) {\n\t\t\tthis._resolve4 = this._resolver.resolve4.bind(this._resolver);\n\t\t\tthis._resolve6 = this._resolver.resolve6.bind(this._resolver);\n\t\t} else {\n\t\t\tthis._resolve4 = promisify(this._resolver.resolve4.bind(this._resolver));\n\t\t\tthis._resolve6 = promisify(this._resolver.resolve6.bind(this._resolver));\n\t\t}\n\n\t\tthis._iface = getIfaceInfo();\n\n\t\tthis._pending = {};\n\t\tthis._nextRemovalTime = false;\n\t\tthis._hostnamesToFallback = new Set();\n\n\t\tif (fallbackDuration < 1) {\n\t\t\tthis._fallback = false;\n\t\t} else {\n\t\t\tthis._fallback = true;\n\n\t\t\tconst interval = setInterval(() => {\n\t\t\t\tthis._hostnamesToFallback.clear();\n\t\t\t}, fallbackDuration * 1000);\n\n\t\t\t/* istanbul ignore next: There is no `interval.unref()` when running inside an Electron renderer */\n\t\t\tif (interval.unref) {\n\t\t\t\tinterval.unref();\n\t\t\t}\n\t\t}\n\n\t\tthis.lookup = this.lookup.bind(this);\n\t\tthis.lookupAsync = this.lookupAsync.bind(this);\n\t}\n\n\tset servers(servers) {\n\t\tthis.clear();\n\n\t\tthis._resolver.setServers(servers);\n\t}\n\n\tget servers() {\n\t\treturn this._resolver.getServers();\n\t}\n\n\tlookup(hostname, options, callback) {\n\t\tif (typeof options === 'function') {\n\t\t\tcallback = options;\n\t\t\toptions = {};\n\t\t} else if (typeof options === 'number') {\n\t\t\toptions = {\n\t\t\t\tfamily: options\n\t\t\t};\n\t\t}\n\n\t\tif (!callback) {\n\t\t\tthrow new Error('Callback must be a function.');\n\t\t}\n\n\t\t// eslint-disable-next-line promise/prefer-await-to-then\n\t\tthis.lookupAsync(hostname, options).then(result => {\n\t\t\tif (options.all) {\n\t\t\t\tcallback(null, result);\n\t\t\t} else {\n\t\t\t\tcallback(null, result.address, result.family, result.expires, result.ttl);\n\t\t\t}\n\t\t}, callback);\n\t}\n\n\tasync lookupAsync(hostname, options = {}) {\n\t\tif (typeof options === 'number') {\n\t\t\toptions = {\n\t\t\t\tfamily: options\n\t\t\t};\n\t\t}\n\n\t\tlet cached = await this.query(hostname);\n\n\t\tif (options.family === 6) {\n\t\t\tconst filtered = cached.filter(entry => entry.family === 6);\n\n\t\t\tif (options.hints & V4MAPPED) {\n\t\t\t\tif ((supportsALL && options.hints & ALL) || filtered.length === 0) {\n\t\t\t\t\tmap4to6(cached);\n\t\t\t\t} else {\n\t\t\t\t\tcached = filtered;\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\tcached = filtered;\n\t\t\t}\n\t\t} else if (options.family === 4) {\n\t\t\tcached = cached.filter(entry => entry.family === 4);\n\t\t}\n\n\t\tif (options.hints & ADDRCONFIG) {\n\t\t\tconst {_iface} = this;\n\t\t\tcached = cached.filter(entry => entry.family === 6 ? _iface.has6 : _iface.has4);\n\t\t}\n\n\t\tif (cached.length === 0) {\n\t\t\tconst error = new Error(`cacheableLookup ENOTFOUND ${hostname}`);\n\t\t\terror.code = 'ENOTFOUND';\n\t\t\terror.hostname = hostname;\n\n\t\t\tthrow error;\n\t\t}\n\n\t\tif (options.all) {\n\t\t\treturn cached;\n\t\t}\n\n\t\treturn cached[0];\n\t}\n\n\tasync query(hostname) {\n\t\tlet cached = await this._cache.get(hostname);\n\n\t\tif (!cached) {\n\t\t\tconst pending = this._pending[hostname];\n\n\t\t\tif (pending) {\n\t\t\t\tcached = await pending;\n\t\t\t} else {\n\t\t\t\tconst newPromise = this.queryAndCache(hostname);\n\t\t\t\tthis._pending[hostname] = newPromise;\n\n\t\t\t\ttry {\n\t\t\t\t\tcached = await newPromise;\n\t\t\t\t} finally {\n\t\t\t\t\tdelete this._pending[hostname];\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\tcached = cached.map(entry => {\n\t\t\treturn {...entry};\n\t\t});\n\n\t\treturn cached;\n\t}\n\n\tasync _resolve(hostname) {\n\t\tconst wrap = async promise => {\n\t\t\ttry {\n\t\t\t\treturn await promise;\n\t\t\t} catch (error) {\n\t\t\t\tif (error.code === 'ENODATA' || error.code === 'ENOTFOUND') {\n\t\t\t\t\treturn [];\n\t\t\t\t}\n\n\t\t\t\tthrow error;\n\t\t\t}\n\t\t};\n\n\t\t// ANY is unsafe as it doesn't trigger new queries in the underlying server.\n\t\tconst [A, AAAA] = await Promise.all([\n\t\t\tthis._resolve4(hostname, ttl),\n\t\t\tthis._resolve6(hostname, ttl)\n\t\t].map(promise => wrap(promise)));\n\n\t\tlet aTtl = 0;\n\t\tlet aaaaTtl = 0;\n\t\tlet cacheTtl = 0;\n\n\t\tconst now = Date.now();\n\n\t\tfor (const entry of A) {\n\t\t\tentry.family = 4;\n\t\t\tentry.expires = now + (entry.ttl * 1000);\n\n\t\t\taTtl = Math.max(aTtl, entry.ttl);\n\t\t}\n\n\t\tfor (const entry of AAAA) {\n\t\t\tentry.family = 6;\n\t\t\tentry.expires = now + (entry.ttl * 1000);\n\n\t\t\taaaaTtl = Math.max(aaaaTtl, entry.ttl);\n\t\t}\n\n\t\tif (A.length > 0) {\n\t\t\tif (AAAA.length > 0) {\n\t\t\t\tcacheTtl = Math.min(aTtl, aaaaTtl);\n\t\t\t} else {\n\t\t\t\tcacheTtl = aTtl;\n\t\t\t}\n\t\t} else {\n\t\t\tcacheTtl = aaaaTtl;\n\t\t}\n\n\t\treturn {\n\t\t\tentries: [\n\t\t\t\t...A,\n\t\t\t\t...AAAA\n\t\t\t],\n\t\t\tcacheTtl\n\t\t};\n\t}\n\n\tasync _lookup(hostname) {\n\t\ttry {\n\t\t\tconst entries = await this._dnsLookup(hostname, {\n\t\t\t\tall: true\n\t\t\t});\n\n\t\t\treturn {\n\t\t\t\tentries,\n\t\t\t\tcacheTtl: 0\n\t\t\t};\n\t\t} catch (_) {\n\t\t\treturn {\n\t\t\t\tentries: [],\n\t\t\t\tcacheTtl: 0\n\t\t\t};\n\t\t}\n\t}\n\n\tasync _set(hostname, data, cacheTtl) {\n\t\tif (this.maxTtl > 0 && cacheTtl > 0) {\n\t\t\tcacheTtl = Math.min(cacheTtl, this.maxTtl) * 1000;\n\t\t\tdata[kExpires] = Date.now() + cacheTtl;\n\n\t\t\ttry {\n\t\t\t\tawait this._cache.set(hostname, data, cacheTtl);\n\t\t\t} catch (error) {\n\t\t\t\tthis.lookupAsync = async () => {\n\t\t\t\t\tconst cacheError = new Error('Cache Error. Please recreate the CacheableLookup instance.');\n\t\t\t\t\tcacheError.cause = error;\n\n\t\t\t\t\tthrow cacheError;\n\t\t\t\t};\n\t\t\t}\n\n\t\t\tif (isIterable(this._cache)) {\n\t\t\t\tthis._tick(cacheTtl);\n\t\t\t}\n\t\t}\n\t}\n\n\tasync queryAndCache(hostname) {\n\t\tif (this._hostnamesToFallback.has(hostname)) {\n\t\t\treturn this._dnsLookup(hostname, all);\n\t\t}\n\n\t\tlet query = await this._resolve(hostname);\n\n\t\tif (query.entries.length === 0 && this._fallback) {\n\t\t\tquery = await this._lookup(hostname);\n\n\t\t\tif (query.entries.length !== 0) {\n\t\t\t\t// Use `dns.lookup(...)` for that particular hostname\n\t\t\t\tthis._hostnamesToFallback.add(hostname);\n\t\t\t}\n\t\t}\n\n\t\tconst cacheTtl = query.entries.length === 0 ? this.errorTtl : query.cacheTtl;\n\t\tawait this._set(hostname, query.entries, cacheTtl);\n\n\t\treturn query.entries;\n\t}\n\n\t_tick(ms) {\n\t\tconst nextRemovalTime = this._nextRemovalTime;\n\n\t\tif (!nextRemovalTime || ms < nextRemovalTime) {\n\t\t\tclearTimeout(this._removalTimeout);\n\n\t\t\tthis._nextRemovalTime = ms;\n\n\t\t\tthis._removalTimeout = setTimeout(() => {\n\t\t\t\tthis._nextRemovalTime = false;\n\n\t\t\t\tlet nextExpiry = Infinity;\n\n\t\t\t\tconst now = Date.now();\n\n\t\t\t\tfor (const [hostname, entries] of this._cache) {\n\t\t\t\t\tconst expires = entries[kExpires];\n\n\t\t\t\t\tif (now >= expires) {\n\t\t\t\t\t\tthis._cache.delete(hostname);\n\t\t\t\t\t} else if (expires < nextExpiry) {\n\t\t\t\t\t\tnextExpiry = expires;\n\t\t\t\t\t}\n\t\t\t\t}\n\n\t\t\t\tif (nextExpiry !== Infinity) {\n\t\t\t\t\tthis._tick(nextExpiry - now);\n\t\t\t\t}\n\t\t\t}, ms);\n\n\t\t\t/* istanbul ignore next: There is no `timeout.unref()` when running inside an Electron renderer */\n\t\t\tif (this._removalTimeout.unref) {\n\t\t\t\tthis._removalTimeout.unref();\n\t\t\t}\n\t\t}\n\t}\n\n\tinstall(agent) {\n\t\tverifyAgent(agent);\n\n\t\tif (kCacheableLookupCreateConnection in agent) {\n\t\t\tthrow new Error('CacheableLookup has been already installed');\n\t\t}\n\n\t\tagent[kCacheableLookupCreateConnection] = agent.createConnection;\n\t\tagent[kCacheableLookupInstance] = this;\n\n\t\tagent.createConnection = (options, callback) => {\n\t\t\tif (!('lookup' in options)) {\n\t\t\t\toptions.lookup = this.lookup;\n\t\t\t}\n\n\t\t\treturn agent[kCacheableLookupCreateConnection](options, callback);\n\t\t};\n\t}\n\n\tuninstall(agent) {\n\t\tverifyAgent(agent);\n\n\t\tif (agent[kCacheableLookupCreateConnection]) {\n\t\t\tif (agent[kCacheableLookupInstance] !== this) {\n\t\t\t\tthrow new Error('The agent is not owned by this CacheableLookup instance');\n\t\t\t}\n\n\t\t\tagent.createConnection = agent[kCacheableLookupCreateConnection];\n\n\t\t\tdelete agent[kCacheableLookupCreateConnection];\n\t\t\tdelete agent[kCacheableLookupInstance];\n\t\t}\n\t}\n\n\tupdateInterfaceInfo() {\n\t\tconst {_iface} = this;\n\n\t\tthis._iface = getIfaceInfo();\n\n\t\tif ((_iface.has4 && !this._iface.has4) || (_iface.has6 && !this._iface.has6)) {\n\t\t\tthis._cache.clear();\n\t\t}\n\t}\n\n\tclear(hostname) {\n\t\tif (hostname) {\n\t\t\tthis._cache.delete(hostname);\n\t\t\treturn;\n\t\t}\n\n\t\tthis._cache.clear();\n\t}\n}\n\nmodule.exports = CacheableLookup;\nmodule.exports[\"default\"] = CacheableLookup;\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvc3dhcm0tanMvbm9kZV9tb2R1bGVzL2NhY2hlYWJsZS1sb29rdXAvc291cmNlL2luZGV4LmpzIiwibWFwcGluZ3MiOiJBQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsRUFBRTtBQUNGO0FBQ0EsRUFBRSxFQUFFLG1CQUFPLENBQUMsZ0JBQUs7QUFDakIsT0FBTyxXQUFXLEVBQUUsbUJBQU8sQ0FBQyxrQkFBTTtBQUNsQyxXQUFXLG1CQUFPLENBQUMsY0FBSTs7QUFFdkI7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQSw0QkFBNEIsY0FBYztBQUMxQztBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBOztBQUVBO0FBQ0EsWUFBWTtBQUNaO0FBQ0E7QUFDQTs7QUFFQSxTQUFTO0FBQ1Q7O0FBRUE7QUFDQTtBQUNBOztBQUVBLGFBQWE7QUFDYixhQUFhOztBQUViO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHLElBQUk7QUFDUDtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxJQUFJO0FBQ0o7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsSUFBSTtBQUNKOztBQUVBO0FBQ0E7QUFDQSxJQUFJOztBQUVKO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxJQUFJO0FBQ0o7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7O0FBRUEseUNBQXlDO0FBQ3pDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0EsSUFBSTtBQUNKO0FBQ0E7O0FBRUE7QUFDQSxVQUFVLFFBQVE7QUFDbEI7QUFDQTs7QUFFQTtBQUNBLHdEQUF3RCxTQUFTO0FBQ2pFO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBOztBQUVBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxXQUFXO0FBQ1gsR0FBRzs7QUFFSDtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQSxJQUFJO0FBQ0o7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsSUFBSTs7QUFFSjtBQUNBO0FBQ0E7QUFDQTtBQUNBLElBQUk7QUFDSjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLElBQUk7O0FBRUo7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxTQUFTLFFBQVE7O0FBRWpCOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0EseUJBQXNCIiwic291cmNlcyI6WyIvVXNlcnMvcGFuemEvRG9jdW1lbnRzL1BlcnNvbmFsUHJvamVjdHMvcHJlZGlrL25vZGVfbW9kdWxlcy9zd2FybS1qcy9ub2RlX21vZHVsZXMvY2FjaGVhYmxlLWxvb2t1cC9zb3VyY2UvaW5kZXguanMiXSwic291cmNlc0NvbnRlbnQiOlsiJ3VzZSBzdHJpY3QnO1xuY29uc3Qge1xuXHRWNE1BUFBFRCxcblx0QUREUkNPTkZJRyxcblx0QUxMLFxuXHRwcm9taXNlczoge1xuXHRcdFJlc29sdmVyOiBBc3luY1Jlc29sdmVyXG5cdH0sXG5cdGxvb2t1cDogZG5zTG9va3VwXG59ID0gcmVxdWlyZSgnZG5zJyk7XG5jb25zdCB7cHJvbWlzaWZ5fSA9IHJlcXVpcmUoJ3V0aWwnKTtcbmNvbnN0IG9zID0gcmVxdWlyZSgnb3MnKTtcblxuY29uc3Qga0NhY2hlYWJsZUxvb2t1cENyZWF0ZUNvbm5lY3Rpb24gPSBTeW1ib2woJ2NhY2hlYWJsZUxvb2t1cENyZWF0ZUNvbm5lY3Rpb24nKTtcbmNvbnN0IGtDYWNoZWFibGVMb29rdXBJbnN0YW5jZSA9IFN5bWJvbCgnY2FjaGVhYmxlTG9va3VwSW5zdGFuY2UnKTtcbmNvbnN0IGtFeHBpcmVzID0gU3ltYm9sKCdleHBpcmVzJyk7XG5cbmNvbnN0IHN1cHBvcnRzQUxMID0gdHlwZW9mIEFMTCA9PT0gJ251bWJlcic7XG5cbmNvbnN0IHZlcmlmeUFnZW50ID0gYWdlbnQgPT4ge1xuXHRpZiAoIShhZ2VudCAmJiB0eXBlb2YgYWdlbnQuY3JlYXRlQ29ubmVjdGlvbiA9PT0gJ2Z1bmN0aW9uJykpIHtcblx0XHR0aHJvdyBuZXcgRXJyb3IoJ0V4cGVjdGVkIGFuIEFnZW50IGluc3RhbmNlIGFzIHRoZSBmaXJzdCBhcmd1bWVudCcpO1xuXHR9XG59O1xuXG5jb25zdCBtYXA0dG82ID0gZW50cmllcyA9PiB7XG5cdGZvciAoY29uc3QgZW50cnkgb2YgZW50cmllcykge1xuXHRcdGlmIChlbnRyeS5mYW1pbHkgPT09IDYpIHtcblx0XHRcdGNvbnRpbnVlO1xuXHRcdH1cblxuXHRcdGVudHJ5LmFkZHJlc3MgPSBgOjpmZmZmOiR7ZW50cnkuYWRkcmVzc31gO1xuXHRcdGVudHJ5LmZhbWlseSA9IDY7XG5cdH1cbn07XG5cbmNvbnN0IGdldElmYWNlSW5mbyA9ICgpID0+IHtcblx0bGV0IGhhczQgPSBmYWxzZTtcblx0bGV0IGhhczYgPSBmYWxzZTtcblxuXHRmb3IgKGNvbnN0IGRldmljZSBvZiBPYmplY3QudmFsdWVzKG9zLm5ldHdvcmtJbnRlcmZhY2VzKCkpKSB7XG5cdFx0Zm9yIChjb25zdCBpZmFjZSBvZiBkZXZpY2UpIHtcblx0XHRcdGlmIChpZmFjZS5pbnRlcm5hbCkge1xuXHRcdFx0XHRjb250aW51ZTtcblx0XHRcdH1cblxuXHRcdFx0aWYgKGlmYWNlLmZhbWlseSA9PT0gJ0lQdjYnKSB7XG5cdFx0XHRcdGhhczYgPSB0cnVlO1xuXHRcdFx0fSBlbHNlIHtcblx0XHRcdFx0aGFzNCA9IHRydWU7XG5cdFx0XHR9XG5cblx0XHRcdGlmIChoYXM0ICYmIGhhczYpIHtcblx0XHRcdFx0cmV0dXJuIHtoYXM0LCBoYXM2fTtcblx0XHRcdH1cblx0XHR9XG5cdH1cblxuXHRyZXR1cm4ge2hhczQsIGhhczZ9O1xufTtcblxuY29uc3QgaXNJdGVyYWJsZSA9IG1hcCA9PiB7XG5cdHJldHVybiBTeW1ib2wuaXRlcmF0b3IgaW4gbWFwO1xufTtcblxuY29uc3QgdHRsID0ge3R0bDogdHJ1ZX07XG5jb25zdCBhbGwgPSB7YWxsOiB0cnVlfTtcblxuY2xhc3MgQ2FjaGVhYmxlTG9va3VwIHtcblx0Y29uc3RydWN0b3Ioe1xuXHRcdGNhY2hlID0gbmV3IE1hcCgpLFxuXHRcdG1heFR0bCA9IEluZmluaXR5LFxuXHRcdGZhbGxiYWNrRHVyYXRpb24gPSAzNjAwLFxuXHRcdGVycm9yVHRsID0gMC4xNSxcblx0XHRyZXNvbHZlciA9IG5ldyBBc3luY1Jlc29sdmVyKCksXG5cdFx0bG9va3VwID0gZG5zTG9va3VwXG5cdH0gPSB7fSkge1xuXHRcdHRoaXMubWF4VHRsID0gbWF4VHRsO1xuXHRcdHRoaXMuZXJyb3JUdGwgPSBlcnJvclR0bDtcblxuXHRcdHRoaXMuX2NhY2hlID0gY2FjaGU7XG5cdFx0dGhpcy5fcmVzb2x2ZXIgPSByZXNvbHZlcjtcblx0XHR0aGlzLl9kbnNMb29rdXAgPSBwcm9taXNpZnkobG9va3VwKTtcblxuXHRcdGlmICh0aGlzLl9yZXNvbHZlciBpbnN0YW5jZW9mIEFzeW5jUmVzb2x2ZXIpIHtcblx0XHRcdHRoaXMuX3Jlc29sdmU0ID0gdGhpcy5fcmVzb2x2ZXIucmVzb2x2ZTQuYmluZCh0aGlzLl9yZXNvbHZlcik7XG5cdFx0XHR0aGlzLl9yZXNvbHZlNiA9IHRoaXMuX3Jlc29sdmVyLnJlc29sdmU2LmJpbmQodGhpcy5fcmVzb2x2ZXIpO1xuXHRcdH0gZWxzZSB7XG5cdFx0XHR0aGlzLl9yZXNvbHZlNCA9IHByb21pc2lmeSh0aGlzLl9yZXNvbHZlci5yZXNvbHZlNC5iaW5kKHRoaXMuX3Jlc29sdmVyKSk7XG5cdFx0XHR0aGlzLl9yZXNvbHZlNiA9IHByb21pc2lmeSh0aGlzLl9yZXNvbHZlci5yZXNvbHZlNi5iaW5kKHRoaXMuX3Jlc29sdmVyKSk7XG5cdFx0fVxuXG5cdFx0dGhpcy5faWZhY2UgPSBnZXRJZmFjZUluZm8oKTtcblxuXHRcdHRoaXMuX3BlbmRpbmcgPSB7fTtcblx0XHR0aGlzLl9uZXh0UmVtb3ZhbFRpbWUgPSBmYWxzZTtcblx0XHR0aGlzLl9ob3N0bmFtZXNUb0ZhbGxiYWNrID0gbmV3IFNldCgpO1xuXG5cdFx0aWYgKGZhbGxiYWNrRHVyYXRpb24gPCAxKSB7XG5cdFx0XHR0aGlzLl9mYWxsYmFjayA9IGZhbHNlO1xuXHRcdH0gZWxzZSB7XG5cdFx0XHR0aGlzLl9mYWxsYmFjayA9IHRydWU7XG5cblx0XHRcdGNvbnN0IGludGVydmFsID0gc2V0SW50ZXJ2YWwoKCkgPT4ge1xuXHRcdFx0XHR0aGlzLl9ob3N0bmFtZXNUb0ZhbGxiYWNrLmNsZWFyKCk7XG5cdFx0XHR9LCBmYWxsYmFja0R1cmF0aW9uICogMTAwMCk7XG5cblx0XHRcdC8qIGlzdGFuYnVsIGlnbm9yZSBuZXh0OiBUaGVyZSBpcyBubyBgaW50ZXJ2YWwudW5yZWYoKWAgd2hlbiBydW5uaW5nIGluc2lkZSBhbiBFbGVjdHJvbiByZW5kZXJlciAqL1xuXHRcdFx0aWYgKGludGVydmFsLnVucmVmKSB7XG5cdFx0XHRcdGludGVydmFsLnVucmVmKCk7XG5cdFx0XHR9XG5cdFx0fVxuXG5cdFx0dGhpcy5sb29rdXAgPSB0aGlzLmxvb2t1cC5iaW5kKHRoaXMpO1xuXHRcdHRoaXMubG9va3VwQXN5bmMgPSB0aGlzLmxvb2t1cEFzeW5jLmJpbmQodGhpcyk7XG5cdH1cblxuXHRzZXQgc2VydmVycyhzZXJ2ZXJzKSB7XG5cdFx0dGhpcy5jbGVhcigpO1xuXG5cdFx0dGhpcy5fcmVzb2x2ZXIuc2V0U2VydmVycyhzZXJ2ZXJzKTtcblx0fVxuXG5cdGdldCBzZXJ2ZXJzKCkge1xuXHRcdHJldHVybiB0aGlzLl9yZXNvbHZlci5nZXRTZXJ2ZXJzKCk7XG5cdH1cblxuXHRsb29rdXAoaG9zdG5hbWUsIG9wdGlvbnMsIGNhbGxiYWNrKSB7XG5cdFx0aWYgKHR5cGVvZiBvcHRpb25zID09PSAnZnVuY3Rpb24nKSB7XG5cdFx0XHRjYWxsYmFjayA9IG9wdGlvbnM7XG5cdFx0XHRvcHRpb25zID0ge307XG5cdFx0fSBlbHNlIGlmICh0eXBlb2Ygb3B0aW9ucyA9PT0gJ251bWJlcicpIHtcblx0XHRcdG9wdGlvbnMgPSB7XG5cdFx0XHRcdGZhbWlseTogb3B0aW9uc1xuXHRcdFx0fTtcblx0XHR9XG5cblx0XHRpZiAoIWNhbGxiYWNrKSB7XG5cdFx0XHR0aHJvdyBuZXcgRXJyb3IoJ0NhbGxiYWNrIG11c3QgYmUgYSBmdW5jdGlvbi4nKTtcblx0XHR9XG5cblx0XHQvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgcHJvbWlzZS9wcmVmZXItYXdhaXQtdG8tdGhlblxuXHRcdHRoaXMubG9va3VwQXN5bmMoaG9zdG5hbWUsIG9wdGlvbnMpLnRoZW4ocmVzdWx0ID0+IHtcblx0XHRcdGlmIChvcHRpb25zLmFsbCkge1xuXHRcdFx0XHRjYWxsYmFjayhudWxsLCByZXN1bHQpO1xuXHRcdFx0fSBlbHNlIHtcblx0XHRcdFx0Y2FsbGJhY2sobnVsbCwgcmVzdWx0LmFkZHJlc3MsIHJlc3VsdC5mYW1pbHksIHJlc3VsdC5leHBpcmVzLCByZXN1bHQudHRsKTtcblx0XHRcdH1cblx0XHR9LCBjYWxsYmFjayk7XG5cdH1cblxuXHRhc3luYyBsb29rdXBBc3luYyhob3N0bmFtZSwgb3B0aW9ucyA9IHt9KSB7XG5cdFx0aWYgKHR5cGVvZiBvcHRpb25zID09PSAnbnVtYmVyJykge1xuXHRcdFx0b3B0aW9ucyA9IHtcblx0XHRcdFx0ZmFtaWx5OiBvcHRpb25zXG5cdFx0XHR9O1xuXHRcdH1cblxuXHRcdGxldCBjYWNoZWQgPSBhd2FpdCB0aGlzLnF1ZXJ5KGhvc3RuYW1lKTtcblxuXHRcdGlmIChvcHRpb25zLmZhbWlseSA9PT0gNikge1xuXHRcdFx0Y29uc3QgZmlsdGVyZWQgPSBjYWNoZWQuZmlsdGVyKGVudHJ5ID0+IGVudHJ5LmZhbWlseSA9PT0gNik7XG5cblx0XHRcdGlmIChvcHRpb25zLmhpbnRzICYgVjRNQVBQRUQpIHtcblx0XHRcdFx0aWYgKChzdXBwb3J0c0FMTCAmJiBvcHRpb25zLmhpbnRzICYgQUxMKSB8fCBmaWx0ZXJlZC5sZW5ndGggPT09IDApIHtcblx0XHRcdFx0XHRtYXA0dG82KGNhY2hlZCk7XG5cdFx0XHRcdH0gZWxzZSB7XG5cdFx0XHRcdFx0Y2FjaGVkID0gZmlsdGVyZWQ7XG5cdFx0XHRcdH1cblx0XHRcdH0gZWxzZSB7XG5cdFx0XHRcdGNhY2hlZCA9IGZpbHRlcmVkO1xuXHRcdFx0fVxuXHRcdH0gZWxzZSBpZiAob3B0aW9ucy5mYW1pbHkgPT09IDQpIHtcblx0XHRcdGNhY2hlZCA9IGNhY2hlZC5maWx0ZXIoZW50cnkgPT4gZW50cnkuZmFtaWx5ID09PSA0KTtcblx0XHR9XG5cblx0XHRpZiAob3B0aW9ucy5oaW50cyAmIEFERFJDT05GSUcpIHtcblx0XHRcdGNvbnN0IHtfaWZhY2V9ID0gdGhpcztcblx0XHRcdGNhY2hlZCA9IGNhY2hlZC5maWx0ZXIoZW50cnkgPT4gZW50cnkuZmFtaWx5ID09PSA2ID8gX2lmYWNlLmhhczYgOiBfaWZhY2UuaGFzNCk7XG5cdFx0fVxuXG5cdFx0aWYgKGNhY2hlZC5sZW5ndGggPT09IDApIHtcblx0XHRcdGNvbnN0IGVycm9yID0gbmV3IEVycm9yKGBjYWNoZWFibGVMb29rdXAgRU5PVEZPVU5EICR7aG9zdG5hbWV9YCk7XG5cdFx0XHRlcnJvci5jb2RlID0gJ0VOT1RGT1VORCc7XG5cdFx0XHRlcnJvci5ob3N0bmFtZSA9IGhvc3RuYW1lO1xuXG5cdFx0XHR0aHJvdyBlcnJvcjtcblx0XHR9XG5cblx0XHRpZiAob3B0aW9ucy5hbGwpIHtcblx0XHRcdHJldHVybiBjYWNoZWQ7XG5cdFx0fVxuXG5cdFx0cmV0dXJuIGNhY2hlZFswXTtcblx0fVxuXG5cdGFzeW5jIHF1ZXJ5KGhvc3RuYW1lKSB7XG5cdFx0bGV0IGNhY2hlZCA9IGF3YWl0IHRoaXMuX2NhY2hlLmdldChob3N0bmFtZSk7XG5cblx0XHRpZiAoIWNhY2hlZCkge1xuXHRcdFx0Y29uc3QgcGVuZGluZyA9IHRoaXMuX3BlbmRpbmdbaG9zdG5hbWVdO1xuXG5cdFx0XHRpZiAocGVuZGluZykge1xuXHRcdFx0XHRjYWNoZWQgPSBhd2FpdCBwZW5kaW5nO1xuXHRcdFx0fSBlbHNlIHtcblx0XHRcdFx0Y29uc3QgbmV3UHJvbWlzZSA9IHRoaXMucXVlcnlBbmRDYWNoZShob3N0bmFtZSk7XG5cdFx0XHRcdHRoaXMuX3BlbmRpbmdbaG9zdG5hbWVdID0gbmV3UHJvbWlzZTtcblxuXHRcdFx0XHR0cnkge1xuXHRcdFx0XHRcdGNhY2hlZCA9IGF3YWl0IG5ld1Byb21pc2U7XG5cdFx0XHRcdH0gZmluYWxseSB7XG5cdFx0XHRcdFx0ZGVsZXRlIHRoaXMuX3BlbmRpbmdbaG9zdG5hbWVdO1xuXHRcdFx0XHR9XG5cdFx0XHR9XG5cdFx0fVxuXG5cdFx0Y2FjaGVkID0gY2FjaGVkLm1hcChlbnRyeSA9PiB7XG5cdFx0XHRyZXR1cm4gey4uLmVudHJ5fTtcblx0XHR9KTtcblxuXHRcdHJldHVybiBjYWNoZWQ7XG5cdH1cblxuXHRhc3luYyBfcmVzb2x2ZShob3N0bmFtZSkge1xuXHRcdGNvbnN0IHdyYXAgPSBhc3luYyBwcm9taXNlID0+IHtcblx0XHRcdHRyeSB7XG5cdFx0XHRcdHJldHVybiBhd2FpdCBwcm9taXNlO1xuXHRcdFx0fSBjYXRjaCAoZXJyb3IpIHtcblx0XHRcdFx0aWYgKGVycm9yLmNvZGUgPT09ICdFTk9EQVRBJyB8fCBlcnJvci5jb2RlID09PSAnRU5PVEZPVU5EJykge1xuXHRcdFx0XHRcdHJldHVybiBbXTtcblx0XHRcdFx0fVxuXG5cdFx0XHRcdHRocm93IGVycm9yO1xuXHRcdFx0fVxuXHRcdH07XG5cblx0XHQvLyBBTlkgaXMgdW5zYWZlIGFzIGl0IGRvZXNuJ3QgdHJpZ2dlciBuZXcgcXVlcmllcyBpbiB0aGUgdW5kZXJseWluZyBzZXJ2ZXIuXG5cdFx0Y29uc3QgW0EsIEFBQUFdID0gYXdhaXQgUHJvbWlzZS5hbGwoW1xuXHRcdFx0dGhpcy5fcmVzb2x2ZTQoaG9zdG5hbWUsIHR0bCksXG5cdFx0XHR0aGlzLl9yZXNvbHZlNihob3N0bmFtZSwgdHRsKVxuXHRcdF0ubWFwKHByb21pc2UgPT4gd3JhcChwcm9taXNlKSkpO1xuXG5cdFx0bGV0IGFUdGwgPSAwO1xuXHRcdGxldCBhYWFhVHRsID0gMDtcblx0XHRsZXQgY2FjaGVUdGwgPSAwO1xuXG5cdFx0Y29uc3Qgbm93ID0gRGF0ZS5ub3coKTtcblxuXHRcdGZvciAoY29uc3QgZW50cnkgb2YgQSkge1xuXHRcdFx0ZW50cnkuZmFtaWx5ID0gNDtcblx0XHRcdGVudHJ5LmV4cGlyZXMgPSBub3cgKyAoZW50cnkudHRsICogMTAwMCk7XG5cblx0XHRcdGFUdGwgPSBNYXRoLm1heChhVHRsLCBlbnRyeS50dGwpO1xuXHRcdH1cblxuXHRcdGZvciAoY29uc3QgZW50cnkgb2YgQUFBQSkge1xuXHRcdFx0ZW50cnkuZmFtaWx5ID0gNjtcblx0XHRcdGVudHJ5LmV4cGlyZXMgPSBub3cgKyAoZW50cnkudHRsICogMTAwMCk7XG5cblx0XHRcdGFhYWFUdGwgPSBNYXRoLm1heChhYWFhVHRsLCBlbnRyeS50dGwpO1xuXHRcdH1cblxuXHRcdGlmIChBLmxlbmd0aCA+IDApIHtcblx0XHRcdGlmIChBQUFBLmxlbmd0aCA+IDApIHtcblx0XHRcdFx0Y2FjaGVUdGwgPSBNYXRoLm1pbihhVHRsLCBhYWFhVHRsKTtcblx0XHRcdH0gZWxzZSB7XG5cdFx0XHRcdGNhY2hlVHRsID0gYVR0bDtcblx0XHRcdH1cblx0XHR9IGVsc2Uge1xuXHRcdFx0Y2FjaGVUdGwgPSBhYWFhVHRsO1xuXHRcdH1cblxuXHRcdHJldHVybiB7XG5cdFx0XHRlbnRyaWVzOiBbXG5cdFx0XHRcdC4uLkEsXG5cdFx0XHRcdC4uLkFBQUFcblx0XHRcdF0sXG5cdFx0XHRjYWNoZVR0bFxuXHRcdH07XG5cdH1cblxuXHRhc3luYyBfbG9va3VwKGhvc3RuYW1lKSB7XG5cdFx0dHJ5IHtcblx0XHRcdGNvbnN0IGVudHJpZXMgPSBhd2FpdCB0aGlzLl9kbnNMb29rdXAoaG9zdG5hbWUsIHtcblx0XHRcdFx0YWxsOiB0cnVlXG5cdFx0XHR9KTtcblxuXHRcdFx0cmV0dXJuIHtcblx0XHRcdFx0ZW50cmllcyxcblx0XHRcdFx0Y2FjaGVUdGw6IDBcblx0XHRcdH07XG5cdFx0fSBjYXRjaCAoXykge1xuXHRcdFx0cmV0dXJuIHtcblx0XHRcdFx0ZW50cmllczogW10sXG5cdFx0XHRcdGNhY2hlVHRsOiAwXG5cdFx0XHR9O1xuXHRcdH1cblx0fVxuXG5cdGFzeW5jIF9zZXQoaG9zdG5hbWUsIGRhdGEsIGNhY2hlVHRsKSB7XG5cdFx0aWYgKHRoaXMubWF4VHRsID4gMCAmJiBjYWNoZVR0bCA+IDApIHtcblx0XHRcdGNhY2hlVHRsID0gTWF0aC5taW4oY2FjaGVUdGwsIHRoaXMubWF4VHRsKSAqIDEwMDA7XG5cdFx0XHRkYXRhW2tFeHBpcmVzXSA9IERhdGUubm93KCkgKyBjYWNoZVR0bDtcblxuXHRcdFx0dHJ5IHtcblx0XHRcdFx0YXdhaXQgdGhpcy5fY2FjaGUuc2V0KGhvc3RuYW1lLCBkYXRhLCBjYWNoZVR0bCk7XG5cdFx0XHR9IGNhdGNoIChlcnJvcikge1xuXHRcdFx0XHR0aGlzLmxvb2t1cEFzeW5jID0gYXN5bmMgKCkgPT4ge1xuXHRcdFx0XHRcdGNvbnN0IGNhY2hlRXJyb3IgPSBuZXcgRXJyb3IoJ0NhY2hlIEVycm9yLiBQbGVhc2UgcmVjcmVhdGUgdGhlIENhY2hlYWJsZUxvb2t1cCBpbnN0YW5jZS4nKTtcblx0XHRcdFx0XHRjYWNoZUVycm9yLmNhdXNlID0gZXJyb3I7XG5cblx0XHRcdFx0XHR0aHJvdyBjYWNoZUVycm9yO1xuXHRcdFx0XHR9O1xuXHRcdFx0fVxuXG5cdFx0XHRpZiAoaXNJdGVyYWJsZSh0aGlzLl9jYWNoZSkpIHtcblx0XHRcdFx0dGhpcy5fdGljayhjYWNoZVR0bCk7XG5cdFx0XHR9XG5cdFx0fVxuXHR9XG5cblx0YXN5bmMgcXVlcnlBbmRDYWNoZShob3N0bmFtZSkge1xuXHRcdGlmICh0aGlzLl9ob3N0bmFtZXNUb0ZhbGxiYWNrLmhhcyhob3N0bmFtZSkpIHtcblx0XHRcdHJldHVybiB0aGlzLl9kbnNMb29rdXAoaG9zdG5hbWUsIGFsbCk7XG5cdFx0fVxuXG5cdFx0bGV0IHF1ZXJ5ID0gYXdhaXQgdGhpcy5fcmVzb2x2ZShob3N0bmFtZSk7XG5cblx0XHRpZiAocXVlcnkuZW50cmllcy5sZW5ndGggPT09IDAgJiYgdGhpcy5fZmFsbGJhY2spIHtcblx0XHRcdHF1ZXJ5ID0gYXdhaXQgdGhpcy5fbG9va3VwKGhvc3RuYW1lKTtcblxuXHRcdFx0aWYgKHF1ZXJ5LmVudHJpZXMubGVuZ3RoICE9PSAwKSB7XG5cdFx0XHRcdC8vIFVzZSBgZG5zLmxvb2t1cCguLi4pYCBmb3IgdGhhdCBwYXJ0aWN1bGFyIGhvc3RuYW1lXG5cdFx0XHRcdHRoaXMuX2hvc3RuYW1lc1RvRmFsbGJhY2suYWRkKGhvc3RuYW1lKTtcblx0XHRcdH1cblx0XHR9XG5cblx0XHRjb25zdCBjYWNoZVR0bCA9IHF1ZXJ5LmVudHJpZXMubGVuZ3RoID09PSAwID8gdGhpcy5lcnJvclR0bCA6IHF1ZXJ5LmNhY2hlVHRsO1xuXHRcdGF3YWl0IHRoaXMuX3NldChob3N0bmFtZSwgcXVlcnkuZW50cmllcywgY2FjaGVUdGwpO1xuXG5cdFx0cmV0dXJuIHF1ZXJ5LmVudHJpZXM7XG5cdH1cblxuXHRfdGljayhtcykge1xuXHRcdGNvbnN0IG5leHRSZW1vdmFsVGltZSA9IHRoaXMuX25leHRSZW1vdmFsVGltZTtcblxuXHRcdGlmICghbmV4dFJlbW92YWxUaW1lIHx8IG1zIDwgbmV4dFJlbW92YWxUaW1lKSB7XG5cdFx0XHRjbGVhclRpbWVvdXQodGhpcy5fcmVtb3ZhbFRpbWVvdXQpO1xuXG5cdFx0XHR0aGlzLl9uZXh0UmVtb3ZhbFRpbWUgPSBtcztcblxuXHRcdFx0dGhpcy5fcmVtb3ZhbFRpbWVvdXQgPSBzZXRUaW1lb3V0KCgpID0+IHtcblx0XHRcdFx0dGhpcy5fbmV4dFJlbW92YWxUaW1lID0gZmFsc2U7XG5cblx0XHRcdFx0bGV0IG5leHRFeHBpcnkgPSBJbmZpbml0eTtcblxuXHRcdFx0XHRjb25zdCBub3cgPSBEYXRlLm5vdygpO1xuXG5cdFx0XHRcdGZvciAoY29uc3QgW2hvc3RuYW1lLCBlbnRyaWVzXSBvZiB0aGlzLl9jYWNoZSkge1xuXHRcdFx0XHRcdGNvbnN0IGV4cGlyZXMgPSBlbnRyaWVzW2tFeHBpcmVzXTtcblxuXHRcdFx0XHRcdGlmIChub3cgPj0gZXhwaXJlcykge1xuXHRcdFx0XHRcdFx0dGhpcy5fY2FjaGUuZGVsZXRlKGhvc3RuYW1lKTtcblx0XHRcdFx0XHR9IGVsc2UgaWYgKGV4cGlyZXMgPCBuZXh0RXhwaXJ5KSB7XG5cdFx0XHRcdFx0XHRuZXh0RXhwaXJ5ID0gZXhwaXJlcztcblx0XHRcdFx0XHR9XG5cdFx0XHRcdH1cblxuXHRcdFx0XHRpZiAobmV4dEV4cGlyeSAhPT0gSW5maW5pdHkpIHtcblx0XHRcdFx0XHR0aGlzLl90aWNrKG5leHRFeHBpcnkgLSBub3cpO1xuXHRcdFx0XHR9XG5cdFx0XHR9LCBtcyk7XG5cblx0XHRcdC8qIGlzdGFuYnVsIGlnbm9yZSBuZXh0OiBUaGVyZSBpcyBubyBgdGltZW91dC51bnJlZigpYCB3aGVuIHJ1bm5pbmcgaW5zaWRlIGFuIEVsZWN0cm9uIHJlbmRlcmVyICovXG5cdFx0XHRpZiAodGhpcy5fcmVtb3ZhbFRpbWVvdXQudW5yZWYpIHtcblx0XHRcdFx0dGhpcy5fcmVtb3ZhbFRpbWVvdXQudW5yZWYoKTtcblx0XHRcdH1cblx0XHR9XG5cdH1cblxuXHRpbnN0YWxsKGFnZW50KSB7XG5cdFx0dmVyaWZ5QWdlbnQoYWdlbnQpO1xuXG5cdFx0aWYgKGtDYWNoZWFibGVMb29rdXBDcmVhdGVDb25uZWN0aW9uIGluIGFnZW50KSB7XG5cdFx0XHR0aHJvdyBuZXcgRXJyb3IoJ0NhY2hlYWJsZUxvb2t1cCBoYXMgYmVlbiBhbHJlYWR5IGluc3RhbGxlZCcpO1xuXHRcdH1cblxuXHRcdGFnZW50W2tDYWNoZWFibGVMb29rdXBDcmVhdGVDb25uZWN0aW9uXSA9IGFnZW50LmNyZWF0ZUNvbm5lY3Rpb247XG5cdFx0YWdlbnRba0NhY2hlYWJsZUxvb2t1cEluc3RhbmNlXSA9IHRoaXM7XG5cblx0XHRhZ2VudC5jcmVhdGVDb25uZWN0aW9uID0gKG9wdGlvbnMsIGNhbGxiYWNrKSA9PiB7XG5cdFx0XHRpZiAoISgnbG9va3VwJyBpbiBvcHRpb25zKSkge1xuXHRcdFx0XHRvcHRpb25zLmxvb2t1cCA9IHRoaXMubG9va3VwO1xuXHRcdFx0fVxuXG5cdFx0XHRyZXR1cm4gYWdlbnRba0NhY2hlYWJsZUxvb2t1cENyZWF0ZUNvbm5lY3Rpb25dKG9wdGlvbnMsIGNhbGxiYWNrKTtcblx0XHR9O1xuXHR9XG5cblx0dW5pbnN0YWxsKGFnZW50KSB7XG5cdFx0dmVyaWZ5QWdlbnQoYWdlbnQpO1xuXG5cdFx0aWYgKGFnZW50W2tDYWNoZWFibGVMb29rdXBDcmVhdGVDb25uZWN0aW9uXSkge1xuXHRcdFx0aWYgKGFnZW50W2tDYWNoZWFibGVMb29rdXBJbnN0YW5jZV0gIT09IHRoaXMpIHtcblx0XHRcdFx0dGhyb3cgbmV3IEVycm9yKCdUaGUgYWdlbnQgaXMgbm90IG93bmVkIGJ5IHRoaXMgQ2FjaGVhYmxlTG9va3VwIGluc3RhbmNlJyk7XG5cdFx0XHR9XG5cblx0XHRcdGFnZW50LmNyZWF0ZUNvbm5lY3Rpb24gPSBhZ2VudFtrQ2FjaGVhYmxlTG9va3VwQ3JlYXRlQ29ubmVjdGlvbl07XG5cblx0XHRcdGRlbGV0ZSBhZ2VudFtrQ2FjaGVhYmxlTG9va3VwQ3JlYXRlQ29ubmVjdGlvbl07XG5cdFx0XHRkZWxldGUgYWdlbnRba0NhY2hlYWJsZUxvb2t1cEluc3RhbmNlXTtcblx0XHR9XG5cdH1cblxuXHR1cGRhdGVJbnRlcmZhY2VJbmZvKCkge1xuXHRcdGNvbnN0IHtfaWZhY2V9ID0gdGhpcztcblxuXHRcdHRoaXMuX2lmYWNlID0gZ2V0SWZhY2VJbmZvKCk7XG5cblx0XHRpZiAoKF9pZmFjZS5oYXM0ICYmICF0aGlzLl9pZmFjZS5oYXM0KSB8fCAoX2lmYWNlLmhhczYgJiYgIXRoaXMuX2lmYWNlLmhhczYpKSB7XG5cdFx0XHR0aGlzLl9jYWNoZS5jbGVhcigpO1xuXHRcdH1cblx0fVxuXG5cdGNsZWFyKGhvc3RuYW1lKSB7XG5cdFx0aWYgKGhvc3RuYW1lKSB7XG5cdFx0XHR0aGlzLl9jYWNoZS5kZWxldGUoaG9zdG5hbWUpO1xuXHRcdFx0cmV0dXJuO1xuXHRcdH1cblxuXHRcdHRoaXMuX2NhY2hlLmNsZWFyKCk7XG5cdH1cbn1cblxubW9kdWxlLmV4cG9ydHMgPSBDYWNoZWFibGVMb29rdXA7XG5tb2R1bGUuZXhwb3J0cy5kZWZhdWx0ID0gQ2FjaGVhYmxlTG9va3VwO1xuIl0sIm5hbWVzIjpbXSwiaWdub3JlTGlzdCI6WzBdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/swarm-js/node_modules/cacheable-lookup/source/index.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/swarm-js/node_modules/chownr/chownr.js":
/*!*************************************************************!*\
  !*** ./node_modules/swarm-js/node_modules/chownr/chownr.js ***!
  \*************************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";
eval("\nconst fs = __webpack_require__(/*! fs */ \"fs\")\nconst path = __webpack_require__(/*! path */ \"path\")\n\n/* istanbul ignore next */\nconst LCHOWN = fs.lchown ? 'lchown' : 'chown'\n/* istanbul ignore next */\nconst LCHOWNSYNC = fs.lchownSync ? 'lchownSync' : 'chownSync'\n\n/* istanbul ignore next */\nconst needEISDIRHandled = fs.lchown &&\n  !process.version.match(/v1[1-9]+\\./) &&\n  !process.version.match(/v10\\.[6-9]/)\n\nconst lchownSync = (path, uid, gid) => {\n  try {\n    return fs[LCHOWNSYNC](path, uid, gid)\n  } catch (er) {\n    if (er.code !== 'ENOENT')\n      throw er\n  }\n}\n\n/* istanbul ignore next */\nconst chownSync = (path, uid, gid) => {\n  try {\n    return fs.chownSync(path, uid, gid)\n  } catch (er) {\n    if (er.code !== 'ENOENT')\n      throw er\n  }\n}\n\n/* istanbul ignore next */\nconst handleEISDIR =\n  needEISDIRHandled ? (path, uid, gid, cb) => er => {\n    // Node prior to v10 had a very questionable implementation of\n    // fs.lchown, which would always try to call fs.open on a directory\n    // Fall back to fs.chown in those cases.\n    if (!er || er.code !== 'EISDIR')\n      cb(er)\n    else\n      fs.chown(path, uid, gid, cb)\n  }\n  : (_, __, ___, cb) => cb\n\n/* istanbul ignore next */\nconst handleEISDirSync =\n  needEISDIRHandled ? (path, uid, gid) => {\n    try {\n      return lchownSync(path, uid, gid)\n    } catch (er) {\n      if (er.code !== 'EISDIR')\n        throw er\n      chownSync(path, uid, gid)\n    }\n  }\n  : (path, uid, gid) => lchownSync(path, uid, gid)\n\n// fs.readdir could only accept an options object as of node v6\nconst nodeVersion = process.version\nlet readdir = (path, options, cb) => fs.readdir(path, options, cb)\nlet readdirSync = (path, options) => fs.readdirSync(path, options)\n/* istanbul ignore next */\nif (/^v4\\./.test(nodeVersion))\n  readdir = (path, options, cb) => fs.readdir(path, cb)\n\nconst chown = (cpath, uid, gid, cb) => {\n  fs[LCHOWN](cpath, uid, gid, handleEISDIR(cpath, uid, gid, er => {\n    // Skip ENOENT error\n    cb(er && er.code !== 'ENOENT' ? er : null)\n  }))\n}\n\nconst chownrKid = (p, child, uid, gid, cb) => {\n  if (typeof child === 'string')\n    return fs.lstat(path.resolve(p, child), (er, stats) => {\n      // Skip ENOENT error\n      if (er)\n        return cb(er.code !== 'ENOENT' ? er : null)\n      stats.name = child\n      chownrKid(p, stats, uid, gid, cb)\n    })\n\n  if (child.isDirectory()) {\n    chownr(path.resolve(p, child.name), uid, gid, er => {\n      if (er)\n        return cb(er)\n      const cpath = path.resolve(p, child.name)\n      chown(cpath, uid, gid, cb)\n    })\n  } else {\n    const cpath = path.resolve(p, child.name)\n    chown(cpath, uid, gid, cb)\n  }\n}\n\n\nconst chownr = (p, uid, gid, cb) => {\n  readdir(p, { withFileTypes: true }, (er, children) => {\n    // any error other than ENOTDIR or ENOTSUP means it's not readable,\n    // or doesn't exist.  give up.\n    if (er) {\n      if (er.code === 'ENOENT')\n        return cb()\n      else if (er.code !== 'ENOTDIR' && er.code !== 'ENOTSUP')\n        return cb(er)\n    }\n    if (er || !children.length)\n      return chown(p, uid, gid, cb)\n\n    let len = children.length\n    let errState = null\n    const then = er => {\n      if (errState)\n        return\n      if (er)\n        return cb(errState = er)\n      if (-- len === 0)\n        return chown(p, uid, gid, cb)\n    }\n\n    children.forEach(child => chownrKid(p, child, uid, gid, then))\n  })\n}\n\nconst chownrKidSync = (p, child, uid, gid) => {\n  if (typeof child === 'string') {\n    try {\n      const stats = fs.lstatSync(path.resolve(p, child))\n      stats.name = child\n      child = stats\n    } catch (er) {\n      if (er.code === 'ENOENT')\n        return\n      else\n        throw er\n    }\n  }\n\n  if (child.isDirectory())\n    chownrSync(path.resolve(p, child.name), uid, gid)\n\n  handleEISDirSync(path.resolve(p, child.name), uid, gid)\n}\n\nconst chownrSync = (p, uid, gid) => {\n  let children\n  try {\n    children = readdirSync(p, { withFileTypes: true })\n  } catch (er) {\n    if (er.code === 'ENOENT')\n      return\n    else if (er.code === 'ENOTDIR' || er.code === 'ENOTSUP')\n      return handleEISDirSync(p, uid, gid)\n    else\n      throw er\n  }\n\n  if (children && children.length)\n    children.forEach(child => chownrKidSync(p, child, uid, gid))\n\n  return handleEISDirSync(p, uid, gid)\n}\n\nmodule.exports = chownr\nchownr.sync = chownrSync\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvc3dhcm0tanMvbm9kZV9tb2R1bGVzL2Nob3duci9jaG93bnIuanMiLCJtYXBwaW5ncyI6IkFBQVk7QUFDWixXQUFXLG1CQUFPLENBQUMsY0FBSTtBQUN2QixhQUFhLG1CQUFPLENBQUMsa0JBQU07O0FBRTNCO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLElBQUk7QUFDSjtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLElBQUk7QUFDSjtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7O0FBRUw7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMLElBQUk7QUFDSjtBQUNBO0FBQ0E7QUFDQTs7O0FBR0E7QUFDQSxlQUFlLHFCQUFxQjtBQUNwQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLEdBQUc7QUFDSDs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxnQ0FBZ0MscUJBQXFCO0FBQ3JELElBQUk7QUFDSjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQSIsInNvdXJjZXMiOlsiL1VzZXJzL3BhbnphL0RvY3VtZW50cy9QZXJzb25hbFByb2plY3RzL3ByZWRpay9ub2RlX21vZHVsZXMvc3dhcm0tanMvbm9kZV9tb2R1bGVzL2Nob3duci9jaG93bnIuanMiXSwic291cmNlc0NvbnRlbnQiOlsiJ3VzZSBzdHJpY3QnXG5jb25zdCBmcyA9IHJlcXVpcmUoJ2ZzJylcbmNvbnN0IHBhdGggPSByZXF1aXJlKCdwYXRoJylcblxuLyogaXN0YW5idWwgaWdub3JlIG5leHQgKi9cbmNvbnN0IExDSE9XTiA9IGZzLmxjaG93biA/ICdsY2hvd24nIDogJ2Nob3duJ1xuLyogaXN0YW5idWwgaWdub3JlIG5leHQgKi9cbmNvbnN0IExDSE9XTlNZTkMgPSBmcy5sY2hvd25TeW5jID8gJ2xjaG93blN5bmMnIDogJ2Nob3duU3luYydcblxuLyogaXN0YW5idWwgaWdub3JlIG5leHQgKi9cbmNvbnN0IG5lZWRFSVNESVJIYW5kbGVkID0gZnMubGNob3duICYmXG4gICFwcm9jZXNzLnZlcnNpb24ubWF0Y2goL3YxWzEtOV0rXFwuLykgJiZcbiAgIXByb2Nlc3MudmVyc2lvbi5tYXRjaCgvdjEwXFwuWzYtOV0vKVxuXG5jb25zdCBsY2hvd25TeW5jID0gKHBhdGgsIHVpZCwgZ2lkKSA9PiB7XG4gIHRyeSB7XG4gICAgcmV0dXJuIGZzW0xDSE9XTlNZTkNdKHBhdGgsIHVpZCwgZ2lkKVxuICB9IGNhdGNoIChlcikge1xuICAgIGlmIChlci5jb2RlICE9PSAnRU5PRU5UJylcbiAgICAgIHRocm93IGVyXG4gIH1cbn1cblxuLyogaXN0YW5idWwgaWdub3JlIG5leHQgKi9cbmNvbnN0IGNob3duU3luYyA9IChwYXRoLCB1aWQsIGdpZCkgPT4ge1xuICB0cnkge1xuICAgIHJldHVybiBmcy5jaG93blN5bmMocGF0aCwgdWlkLCBnaWQpXG4gIH0gY2F0Y2ggKGVyKSB7XG4gICAgaWYgKGVyLmNvZGUgIT09ICdFTk9FTlQnKVxuICAgICAgdGhyb3cgZXJcbiAgfVxufVxuXG4vKiBpc3RhbmJ1bCBpZ25vcmUgbmV4dCAqL1xuY29uc3QgaGFuZGxlRUlTRElSID1cbiAgbmVlZEVJU0RJUkhhbmRsZWQgPyAocGF0aCwgdWlkLCBnaWQsIGNiKSA9PiBlciA9PiB7XG4gICAgLy8gTm9kZSBwcmlvciB0byB2MTAgaGFkIGEgdmVyeSBxdWVzdGlvbmFibGUgaW1wbGVtZW50YXRpb24gb2ZcbiAgICAvLyBmcy5sY2hvd24sIHdoaWNoIHdvdWxkIGFsd2F5cyB0cnkgdG8gY2FsbCBmcy5vcGVuIG9uIGEgZGlyZWN0b3J5XG4gICAgLy8gRmFsbCBiYWNrIHRvIGZzLmNob3duIGluIHRob3NlIGNhc2VzLlxuICAgIGlmICghZXIgfHwgZXIuY29kZSAhPT0gJ0VJU0RJUicpXG4gICAgICBjYihlcilcbiAgICBlbHNlXG4gICAgICBmcy5jaG93bihwYXRoLCB1aWQsIGdpZCwgY2IpXG4gIH1cbiAgOiAoXywgX18sIF9fXywgY2IpID0+IGNiXG5cbi8qIGlzdGFuYnVsIGlnbm9yZSBuZXh0ICovXG5jb25zdCBoYW5kbGVFSVNEaXJTeW5jID1cbiAgbmVlZEVJU0RJUkhhbmRsZWQgPyAocGF0aCwgdWlkLCBnaWQpID0+IHtcbiAgICB0cnkge1xuICAgICAgcmV0dXJuIGxjaG93blN5bmMocGF0aCwgdWlkLCBnaWQpXG4gICAgfSBjYXRjaCAoZXIpIHtcbiAgICAgIGlmIChlci5jb2RlICE9PSAnRUlTRElSJylcbiAgICAgICAgdGhyb3cgZXJcbiAgICAgIGNob3duU3luYyhwYXRoLCB1aWQsIGdpZClcbiAgICB9XG4gIH1cbiAgOiAocGF0aCwgdWlkLCBnaWQpID0+IGxjaG93blN5bmMocGF0aCwgdWlkLCBnaWQpXG5cbi8vIGZzLnJlYWRkaXIgY291bGQgb25seSBhY2NlcHQgYW4gb3B0aW9ucyBvYmplY3QgYXMgb2Ygbm9kZSB2NlxuY29uc3Qgbm9kZVZlcnNpb24gPSBwcm9jZXNzLnZlcnNpb25cbmxldCByZWFkZGlyID0gKHBhdGgsIG9wdGlvbnMsIGNiKSA9PiBmcy5yZWFkZGlyKHBhdGgsIG9wdGlvbnMsIGNiKVxubGV0IHJlYWRkaXJTeW5jID0gKHBhdGgsIG9wdGlvbnMpID0+IGZzLnJlYWRkaXJTeW5jKHBhdGgsIG9wdGlvbnMpXG4vKiBpc3RhbmJ1bCBpZ25vcmUgbmV4dCAqL1xuaWYgKC9edjRcXC4vLnRlc3Qobm9kZVZlcnNpb24pKVxuICByZWFkZGlyID0gKHBhdGgsIG9wdGlvbnMsIGNiKSA9PiBmcy5yZWFkZGlyKHBhdGgsIGNiKVxuXG5jb25zdCBjaG93biA9IChjcGF0aCwgdWlkLCBnaWQsIGNiKSA9PiB7XG4gIGZzW0xDSE9XTl0oY3BhdGgsIHVpZCwgZ2lkLCBoYW5kbGVFSVNESVIoY3BhdGgsIHVpZCwgZ2lkLCBlciA9PiB7XG4gICAgLy8gU2tpcCBFTk9FTlQgZXJyb3JcbiAgICBjYihlciAmJiBlci5jb2RlICE9PSAnRU5PRU5UJyA/IGVyIDogbnVsbClcbiAgfSkpXG59XG5cbmNvbnN0IGNob3ducktpZCA9IChwLCBjaGlsZCwgdWlkLCBnaWQsIGNiKSA9PiB7XG4gIGlmICh0eXBlb2YgY2hpbGQgPT09ICdzdHJpbmcnKVxuICAgIHJldHVybiBmcy5sc3RhdChwYXRoLnJlc29sdmUocCwgY2hpbGQpLCAoZXIsIHN0YXRzKSA9PiB7XG4gICAgICAvLyBTa2lwIEVOT0VOVCBlcnJvclxuICAgICAgaWYgKGVyKVxuICAgICAgICByZXR1cm4gY2IoZXIuY29kZSAhPT0gJ0VOT0VOVCcgPyBlciA6IG51bGwpXG4gICAgICBzdGF0cy5uYW1lID0gY2hpbGRcbiAgICAgIGNob3ducktpZChwLCBzdGF0cywgdWlkLCBnaWQsIGNiKVxuICAgIH0pXG5cbiAgaWYgKGNoaWxkLmlzRGlyZWN0b3J5KCkpIHtcbiAgICBjaG93bnIocGF0aC5yZXNvbHZlKHAsIGNoaWxkLm5hbWUpLCB1aWQsIGdpZCwgZXIgPT4ge1xuICAgICAgaWYgKGVyKVxuICAgICAgICByZXR1cm4gY2IoZXIpXG4gICAgICBjb25zdCBjcGF0aCA9IHBhdGgucmVzb2x2ZShwLCBjaGlsZC5uYW1lKVxuICAgICAgY2hvd24oY3BhdGgsIHVpZCwgZ2lkLCBjYilcbiAgICB9KVxuICB9IGVsc2Uge1xuICAgIGNvbnN0IGNwYXRoID0gcGF0aC5yZXNvbHZlKHAsIGNoaWxkLm5hbWUpXG4gICAgY2hvd24oY3BhdGgsIHVpZCwgZ2lkLCBjYilcbiAgfVxufVxuXG5cbmNvbnN0IGNob3duciA9IChwLCB1aWQsIGdpZCwgY2IpID0+IHtcbiAgcmVhZGRpcihwLCB7IHdpdGhGaWxlVHlwZXM6IHRydWUgfSwgKGVyLCBjaGlsZHJlbikgPT4ge1xuICAgIC8vIGFueSBlcnJvciBvdGhlciB0aGFuIEVOT1RESVIgb3IgRU5PVFNVUCBtZWFucyBpdCdzIG5vdCByZWFkYWJsZSxcbiAgICAvLyBvciBkb2Vzbid0IGV4aXN0LiAgZ2l2ZSB1cC5cbiAgICBpZiAoZXIpIHtcbiAgICAgIGlmIChlci5jb2RlID09PSAnRU5PRU5UJylcbiAgICAgICAgcmV0dXJuIGNiKClcbiAgICAgIGVsc2UgaWYgKGVyLmNvZGUgIT09ICdFTk9URElSJyAmJiBlci5jb2RlICE9PSAnRU5PVFNVUCcpXG4gICAgICAgIHJldHVybiBjYihlcilcbiAgICB9XG4gICAgaWYgKGVyIHx8ICFjaGlsZHJlbi5sZW5ndGgpXG4gICAgICByZXR1cm4gY2hvd24ocCwgdWlkLCBnaWQsIGNiKVxuXG4gICAgbGV0IGxlbiA9IGNoaWxkcmVuLmxlbmd0aFxuICAgIGxldCBlcnJTdGF0ZSA9IG51bGxcbiAgICBjb25zdCB0aGVuID0gZXIgPT4ge1xuICAgICAgaWYgKGVyclN0YXRlKVxuICAgICAgICByZXR1cm5cbiAgICAgIGlmIChlcilcbiAgICAgICAgcmV0dXJuIGNiKGVyclN0YXRlID0gZXIpXG4gICAgICBpZiAoLS0gbGVuID09PSAwKVxuICAgICAgICByZXR1cm4gY2hvd24ocCwgdWlkLCBnaWQsIGNiKVxuICAgIH1cblxuICAgIGNoaWxkcmVuLmZvckVhY2goY2hpbGQgPT4gY2hvd25yS2lkKHAsIGNoaWxkLCB1aWQsIGdpZCwgdGhlbikpXG4gIH0pXG59XG5cbmNvbnN0IGNob3ducktpZFN5bmMgPSAocCwgY2hpbGQsIHVpZCwgZ2lkKSA9PiB7XG4gIGlmICh0eXBlb2YgY2hpbGQgPT09ICdzdHJpbmcnKSB7XG4gICAgdHJ5IHtcbiAgICAgIGNvbnN0IHN0YXRzID0gZnMubHN0YXRTeW5jKHBhdGgucmVzb2x2ZShwLCBjaGlsZCkpXG4gICAgICBzdGF0cy5uYW1lID0gY2hpbGRcbiAgICAgIGNoaWxkID0gc3RhdHNcbiAgICB9IGNhdGNoIChlcikge1xuICAgICAgaWYgKGVyLmNvZGUgPT09ICdFTk9FTlQnKVxuICAgICAgICByZXR1cm5cbiAgICAgIGVsc2VcbiAgICAgICAgdGhyb3cgZXJcbiAgICB9XG4gIH1cblxuICBpZiAoY2hpbGQuaXNEaXJlY3RvcnkoKSlcbiAgICBjaG93bnJTeW5jKHBhdGgucmVzb2x2ZShwLCBjaGlsZC5uYW1lKSwgdWlkLCBnaWQpXG5cbiAgaGFuZGxlRUlTRGlyU3luYyhwYXRoLnJlc29sdmUocCwgY2hpbGQubmFtZSksIHVpZCwgZ2lkKVxufVxuXG5jb25zdCBjaG93bnJTeW5jID0gKHAsIHVpZCwgZ2lkKSA9PiB7XG4gIGxldCBjaGlsZHJlblxuICB0cnkge1xuICAgIGNoaWxkcmVuID0gcmVhZGRpclN5bmMocCwgeyB3aXRoRmlsZVR5cGVzOiB0cnVlIH0pXG4gIH0gY2F0Y2ggKGVyKSB7XG4gICAgaWYgKGVyLmNvZGUgPT09ICdFTk9FTlQnKVxuICAgICAgcmV0dXJuXG4gICAgZWxzZSBpZiAoZXIuY29kZSA9PT0gJ0VOT1RESVInIHx8IGVyLmNvZGUgPT09ICdFTk9UU1VQJylcbiAgICAgIHJldHVybiBoYW5kbGVFSVNEaXJTeW5jKHAsIHVpZCwgZ2lkKVxuICAgIGVsc2VcbiAgICAgIHRocm93IGVyXG4gIH1cblxuICBpZiAoY2hpbGRyZW4gJiYgY2hpbGRyZW4ubGVuZ3RoKVxuICAgIGNoaWxkcmVuLmZvckVhY2goY2hpbGQgPT4gY2hvd25yS2lkU3luYyhwLCBjaGlsZCwgdWlkLCBnaWQpKVxuXG4gIHJldHVybiBoYW5kbGVFSVNEaXJTeW5jKHAsIHVpZCwgZ2lkKVxufVxuXG5tb2R1bGUuZXhwb3J0cyA9IGNob3duclxuY2hvd25yLnN5bmMgPSBjaG93bnJTeW5jXG4iXSwibmFtZXMiOltdLCJpZ25vcmVMaXN0IjpbMF0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/swarm-js/node_modules/chownr/chownr.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/swarm-js/node_modules/fs-minipass/index.js":
/*!*****************************************************************!*\
  !*** ./node_modules/swarm-js/node_modules/fs-minipass/index.js ***!
  \*****************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";
eval("\nconst MiniPass = __webpack_require__(/*! minipass */ \"(ssr)/./node_modules/swarm-js/node_modules/minipass/index.js\")\nconst EE = (__webpack_require__(/*! events */ \"events\").EventEmitter)\nconst fs = __webpack_require__(/*! fs */ \"fs\")\n\n// for writev\nconst binding = process.binding('fs')\nconst writeBuffers = binding.writeBuffers\n/* istanbul ignore next */\nconst FSReqWrap = binding.FSReqWrap || binding.FSReqCallback\n\nconst _autoClose = Symbol('_autoClose')\nconst _close = Symbol('_close')\nconst _ended = Symbol('_ended')\nconst _fd = Symbol('_fd')\nconst _finished = Symbol('_finished')\nconst _flags = Symbol('_flags')\nconst _flush = Symbol('_flush')\nconst _handleChunk = Symbol('_handleChunk')\nconst _makeBuf = Symbol('_makeBuf')\nconst _mode = Symbol('_mode')\nconst _needDrain = Symbol('_needDrain')\nconst _onerror = Symbol('_onerror')\nconst _onopen = Symbol('_onopen')\nconst _onread = Symbol('_onread')\nconst _onwrite = Symbol('_onwrite')\nconst _open = Symbol('_open')\nconst _path = Symbol('_path')\nconst _pos = Symbol('_pos')\nconst _queue = Symbol('_queue')\nconst _read = Symbol('_read')\nconst _readSize = Symbol('_readSize')\nconst _reading = Symbol('_reading')\nconst _remain = Symbol('_remain')\nconst _size = Symbol('_size')\nconst _write = Symbol('_write')\nconst _writing = Symbol('_writing')\nconst _defaultFlag = Symbol('_defaultFlag')\n\nclass ReadStream extends MiniPass {\n  constructor (path, opt) {\n    opt = opt || {}\n    super(opt)\n\n    this.writable = false\n\n    if (typeof path !== 'string')\n      throw new TypeError('path must be a string')\n\n    this[_fd] = typeof opt.fd === 'number' ? opt.fd : null\n    this[_path] = path\n    this[_readSize] = opt.readSize || 16*1024*1024\n    this[_reading] = false\n    this[_size] = typeof opt.size === 'number' ? opt.size : Infinity\n    this[_remain] = this[_size]\n    this[_autoClose] = typeof opt.autoClose === 'boolean' ?\n      opt.autoClose : true\n\n    if (typeof this[_fd] === 'number')\n      this[_read]()\n    else\n      this[_open]()\n  }\n\n  get fd () { return this[_fd] }\n  get path () { return this[_path] }\n\n  write () {\n    throw new TypeError('this is a readable stream')\n  }\n\n  end () {\n    throw new TypeError('this is a readable stream')\n  }\n\n  [_open] () {\n    fs.open(this[_path], 'r', (er, fd) => this[_onopen](er, fd))\n  }\n\n  [_onopen] (er, fd) {\n    if (er)\n      this[_onerror](er)\n    else {\n      this[_fd] = fd\n      this.emit('open', fd)\n      this[_read]()\n    }\n  }\n\n  [_makeBuf] () {\n    return Buffer.allocUnsafe(Math.min(this[_readSize], this[_remain]))\n  }\n\n  [_read] () {\n    if (!this[_reading]) {\n      this[_reading] = true\n      const buf = this[_makeBuf]()\n      /* istanbul ignore if */\n      if (buf.length === 0) return process.nextTick(() => this[_onread](null, 0, buf))\n      fs.read(this[_fd], buf, 0, buf.length, null, (er, br, buf) =>\n        this[_onread](er, br, buf))\n    }\n  }\n\n  [_onread] (er, br, buf) {\n    this[_reading] = false\n    if (er)\n      this[_onerror](er)\n    else if (this[_handleChunk](br, buf))\n      this[_read]()\n  }\n\n  [_close] () {\n    if (this[_autoClose] && typeof this[_fd] === 'number') {\n      fs.close(this[_fd], _ => this.emit('close'))\n      this[_fd] = null\n    }\n  }\n\n  [_onerror] (er) {\n    this[_reading] = true\n    this[_close]()\n    this.emit('error', er)\n  }\n\n  [_handleChunk] (br, buf) {\n    let ret = false\n    // no effect if infinite\n    this[_remain] -= br\n    if (br > 0)\n      ret = super.write(br < buf.length ? buf.slice(0, br) : buf)\n\n    if (br === 0 || this[_remain] <= 0) {\n      ret = false\n      this[_close]()\n      super.end()\n    }\n\n    return ret\n  }\n\n  emit (ev, data) {\n    switch (ev) {\n      case 'prefinish':\n      case 'finish':\n        break\n\n      case 'drain':\n        if (typeof this[_fd] === 'number')\n          this[_read]()\n        break\n\n      default:\n        return super.emit(ev, data)\n    }\n  }\n}\n\nclass ReadStreamSync extends ReadStream {\n  [_open] () {\n    let threw = true\n    try {\n      this[_onopen](null, fs.openSync(this[_path], 'r'))\n      threw = false\n    } finally {\n      if (threw)\n        this[_close]()\n    }\n  }\n\n  [_read] () {\n    let threw = true\n    try {\n      if (!this[_reading]) {\n        this[_reading] = true\n        do {\n          const buf = this[_makeBuf]()\n          /* istanbul ignore next */\n          const br = buf.length === 0 ? 0 : fs.readSync(this[_fd], buf, 0, buf.length, null)\n          if (!this[_handleChunk](br, buf))\n            break\n        } while (true)\n        this[_reading] = false\n      }\n      threw = false\n    } finally {\n      if (threw)\n        this[_close]()\n    }\n  }\n\n  [_close] () {\n    if (this[_autoClose] && typeof this[_fd] === 'number') {\n      try {\n        fs.closeSync(this[_fd])\n      } catch (er) {}\n      this[_fd] = null\n      this.emit('close')\n    }\n  }\n}\n\nclass WriteStream extends EE {\n  constructor (path, opt) {\n    opt = opt || {}\n    super(opt)\n    this.readable = false\n    this[_writing] = false\n    this[_ended] = false\n    this[_needDrain] = false\n    this[_queue] = []\n    this[_path] = path\n    this[_fd] = typeof opt.fd === 'number' ? opt.fd : null\n    this[_mode] = opt.mode === undefined ? 0o666 : opt.mode\n    this[_pos] = typeof opt.start === 'number' ? opt.start : null\n    this[_autoClose] = typeof opt.autoClose === 'boolean' ?\n      opt.autoClose : true\n\n    // truncating makes no sense when writing into the middle\n    const defaultFlag = this[_pos] !== null ? 'r+' : 'w'\n    this[_defaultFlag] = opt.flags === undefined\n    this[_flags] = this[_defaultFlag] ? defaultFlag : opt.flags\n\n    if (this[_fd] === null)\n      this[_open]()\n  }\n\n  get fd () { return this[_fd] }\n  get path () { return this[_path] }\n\n  [_onerror] (er) {\n    this[_close]()\n    this[_writing] = true\n    this.emit('error', er)\n  }\n\n  [_open] () {\n    fs.open(this[_path], this[_flags], this[_mode],\n      (er, fd) => this[_onopen](er, fd))\n  }\n\n  [_onopen] (er, fd) {\n    if (this[_defaultFlag] &&\n        this[_flags] === 'r+' &&\n        er && er.code === 'ENOENT') {\n      this[_flags] = 'w'\n      this[_open]()\n    } else if (er)\n      this[_onerror](er)\n    else {\n      this[_fd] = fd\n      this.emit('open', fd)\n      this[_flush]()\n    }\n  }\n\n  end (buf, enc) {\n    if (buf)\n      this.write(buf, enc)\n\n    this[_ended] = true\n\n    // synthetic after-write logic, where drain/finish live\n    if (!this[_writing] && !this[_queue].length &&\n        typeof this[_fd] === 'number')\n      this[_onwrite](null, 0)\n  }\n\n  write (buf, enc) {\n    if (typeof buf === 'string')\n      buf = new Buffer(buf, enc)\n\n    if (this[_ended]) {\n      this.emit('error', new Error('write() after end()'))\n      return false\n    }\n\n    if (this[_fd] === null || this[_writing] || this[_queue].length) {\n      this[_queue].push(buf)\n      this[_needDrain] = true\n      return false\n    }\n\n    this[_writing] = true\n    this[_write](buf)\n    return true\n  }\n\n  [_write] (buf) {\n    fs.write(this[_fd], buf, 0, buf.length, this[_pos], (er, bw) =>\n      this[_onwrite](er, bw))\n  }\n\n  [_onwrite] (er, bw) {\n    if (er)\n      this[_onerror](er)\n    else {\n      if (this[_pos] !== null)\n        this[_pos] += bw\n      if (this[_queue].length)\n        this[_flush]()\n      else {\n        this[_writing] = false\n\n        if (this[_ended] && !this[_finished]) {\n          this[_finished] = true\n          this[_close]()\n          this.emit('finish')\n        } else if (this[_needDrain]) {\n          this[_needDrain] = false\n          this.emit('drain')\n        }\n      }\n    }\n  }\n\n  [_flush] () {\n    if (this[_queue].length === 0) {\n      if (this[_ended])\n        this[_onwrite](null, 0)\n    } else if (this[_queue].length === 1)\n      this[_write](this[_queue].pop())\n    else {\n      const iovec = this[_queue]\n      this[_queue] = []\n      writev(this[_fd], iovec, this[_pos],\n        (er, bw) => this[_onwrite](er, bw))\n    }\n  }\n\n  [_close] () {\n    if (this[_autoClose] && typeof this[_fd] === 'number') {\n      fs.close(this[_fd], _ => this.emit('close'))\n      this[_fd] = null\n    }\n  }\n}\n\nclass WriteStreamSync extends WriteStream {\n  [_open] () {\n    let fd\n    try {\n      fd = fs.openSync(this[_path], this[_flags], this[_mode])\n    } catch (er) {\n      if (this[_defaultFlag] &&\n          this[_flags] === 'r+' &&\n          er && er.code === 'ENOENT') {\n        this[_flags] = 'w'\n        return this[_open]()\n      } else\n        throw er\n    }\n    this[_onopen](null, fd)\n  }\n\n  [_close] () {\n    if (this[_autoClose] && typeof this[_fd] === 'number') {\n      try {\n        fs.closeSync(this[_fd])\n      } catch (er) {}\n      this[_fd] = null\n      this.emit('close')\n    }\n  }\n\n  [_write] (buf) {\n    try {\n      this[_onwrite](null,\n        fs.writeSync(this[_fd], buf, 0, buf.length, this[_pos]))\n    } catch (er) {\n      this[_onwrite](er, 0)\n    }\n  }\n}\n\nconst writev = (fd, iovec, pos, cb) => {\n  const done = (er, bw) => cb(er, bw, iovec)\n  const req = new FSReqWrap()\n  req.oncomplete = done\n  binding.writeBuffers(fd, iovec, pos, req)\n}\n\nexports.ReadStream = ReadStream\nexports.ReadStreamSync = ReadStreamSync\n\nexports.WriteStream = WriteStream\nexports.WriteStreamSync = WriteStreamSync\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvc3dhcm0tanMvbm9kZV9tb2R1bGVzL2ZzLW1pbmlwYXNzL2luZGV4LmpzIiwibWFwcGluZ3MiOiJBQUFZO0FBQ1osaUJBQWlCLG1CQUFPLENBQUMsOEVBQVU7QUFDbkMsV0FBVywwREFBOEI7QUFDekMsV0FBVyxtQkFBTyxDQUFDLGNBQUk7O0FBRXZCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBLGNBQWM7QUFDZCxnQkFBZ0I7O0FBRWhCO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxVQUFVO0FBQ1Y7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsUUFBUTtBQUNSO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQSxjQUFjO0FBQ2QsZ0JBQWdCOztBQUVoQjtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFVBQVU7QUFDVjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxRQUFRO0FBQ1I7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxRQUFRO0FBQ1I7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBLGtCQUFrQjtBQUNsQixzQkFBc0I7O0FBRXRCLG1CQUFtQjtBQUNuQix1QkFBdUIiLCJzb3VyY2VzIjpbIi9Vc2Vycy9wYW56YS9Eb2N1bWVudHMvUGVyc29uYWxQcm9qZWN0cy9wcmVkaWsvbm9kZV9tb2R1bGVzL3N3YXJtLWpzL25vZGVfbW9kdWxlcy9mcy1taW5pcGFzcy9pbmRleC5qcyJdLCJzb3VyY2VzQ29udGVudCI6WyIndXNlIHN0cmljdCdcbmNvbnN0IE1pbmlQYXNzID0gcmVxdWlyZSgnbWluaXBhc3MnKVxuY29uc3QgRUUgPSByZXF1aXJlKCdldmVudHMnKS5FdmVudEVtaXR0ZXJcbmNvbnN0IGZzID0gcmVxdWlyZSgnZnMnKVxuXG4vLyBmb3Igd3JpdGV2XG5jb25zdCBiaW5kaW5nID0gcHJvY2Vzcy5iaW5kaW5nKCdmcycpXG5jb25zdCB3cml0ZUJ1ZmZlcnMgPSBiaW5kaW5nLndyaXRlQnVmZmVyc1xuLyogaXN0YW5idWwgaWdub3JlIG5leHQgKi9cbmNvbnN0IEZTUmVxV3JhcCA9IGJpbmRpbmcuRlNSZXFXcmFwIHx8IGJpbmRpbmcuRlNSZXFDYWxsYmFja1xuXG5jb25zdCBfYXV0b0Nsb3NlID0gU3ltYm9sKCdfYXV0b0Nsb3NlJylcbmNvbnN0IF9jbG9zZSA9IFN5bWJvbCgnX2Nsb3NlJylcbmNvbnN0IF9lbmRlZCA9IFN5bWJvbCgnX2VuZGVkJylcbmNvbnN0IF9mZCA9IFN5bWJvbCgnX2ZkJylcbmNvbnN0IF9maW5pc2hlZCA9IFN5bWJvbCgnX2ZpbmlzaGVkJylcbmNvbnN0IF9mbGFncyA9IFN5bWJvbCgnX2ZsYWdzJylcbmNvbnN0IF9mbHVzaCA9IFN5bWJvbCgnX2ZsdXNoJylcbmNvbnN0IF9oYW5kbGVDaHVuayA9IFN5bWJvbCgnX2hhbmRsZUNodW5rJylcbmNvbnN0IF9tYWtlQnVmID0gU3ltYm9sKCdfbWFrZUJ1ZicpXG5jb25zdCBfbW9kZSA9IFN5bWJvbCgnX21vZGUnKVxuY29uc3QgX25lZWREcmFpbiA9IFN5bWJvbCgnX25lZWREcmFpbicpXG5jb25zdCBfb25lcnJvciA9IFN5bWJvbCgnX29uZXJyb3InKVxuY29uc3QgX29ub3BlbiA9IFN5bWJvbCgnX29ub3BlbicpXG5jb25zdCBfb25yZWFkID0gU3ltYm9sKCdfb25yZWFkJylcbmNvbnN0IF9vbndyaXRlID0gU3ltYm9sKCdfb253cml0ZScpXG5jb25zdCBfb3BlbiA9IFN5bWJvbCgnX29wZW4nKVxuY29uc3QgX3BhdGggPSBTeW1ib2woJ19wYXRoJylcbmNvbnN0IF9wb3MgPSBTeW1ib2woJ19wb3MnKVxuY29uc3QgX3F1ZXVlID0gU3ltYm9sKCdfcXVldWUnKVxuY29uc3QgX3JlYWQgPSBTeW1ib2woJ19yZWFkJylcbmNvbnN0IF9yZWFkU2l6ZSA9IFN5bWJvbCgnX3JlYWRTaXplJylcbmNvbnN0IF9yZWFkaW5nID0gU3ltYm9sKCdfcmVhZGluZycpXG5jb25zdCBfcmVtYWluID0gU3ltYm9sKCdfcmVtYWluJylcbmNvbnN0IF9zaXplID0gU3ltYm9sKCdfc2l6ZScpXG5jb25zdCBfd3JpdGUgPSBTeW1ib2woJ193cml0ZScpXG5jb25zdCBfd3JpdGluZyA9IFN5bWJvbCgnX3dyaXRpbmcnKVxuY29uc3QgX2RlZmF1bHRGbGFnID0gU3ltYm9sKCdfZGVmYXVsdEZsYWcnKVxuXG5jbGFzcyBSZWFkU3RyZWFtIGV4dGVuZHMgTWluaVBhc3Mge1xuICBjb25zdHJ1Y3RvciAocGF0aCwgb3B0KSB7XG4gICAgb3B0ID0gb3B0IHx8IHt9XG4gICAgc3VwZXIob3B0KVxuXG4gICAgdGhpcy53cml0YWJsZSA9IGZhbHNlXG5cbiAgICBpZiAodHlwZW9mIHBhdGggIT09ICdzdHJpbmcnKVxuICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvcigncGF0aCBtdXN0IGJlIGEgc3RyaW5nJylcblxuICAgIHRoaXNbX2ZkXSA9IHR5cGVvZiBvcHQuZmQgPT09ICdudW1iZXInID8gb3B0LmZkIDogbnVsbFxuICAgIHRoaXNbX3BhdGhdID0gcGF0aFxuICAgIHRoaXNbX3JlYWRTaXplXSA9IG9wdC5yZWFkU2l6ZSB8fCAxNioxMDI0KjEwMjRcbiAgICB0aGlzW19yZWFkaW5nXSA9IGZhbHNlXG4gICAgdGhpc1tfc2l6ZV0gPSB0eXBlb2Ygb3B0LnNpemUgPT09ICdudW1iZXInID8gb3B0LnNpemUgOiBJbmZpbml0eVxuICAgIHRoaXNbX3JlbWFpbl0gPSB0aGlzW19zaXplXVxuICAgIHRoaXNbX2F1dG9DbG9zZV0gPSB0eXBlb2Ygb3B0LmF1dG9DbG9zZSA9PT0gJ2Jvb2xlYW4nID9cbiAgICAgIG9wdC5hdXRvQ2xvc2UgOiB0cnVlXG5cbiAgICBpZiAodHlwZW9mIHRoaXNbX2ZkXSA9PT0gJ251bWJlcicpXG4gICAgICB0aGlzW19yZWFkXSgpXG4gICAgZWxzZVxuICAgICAgdGhpc1tfb3Blbl0oKVxuICB9XG5cbiAgZ2V0IGZkICgpIHsgcmV0dXJuIHRoaXNbX2ZkXSB9XG4gIGdldCBwYXRoICgpIHsgcmV0dXJuIHRoaXNbX3BhdGhdIH1cblxuICB3cml0ZSAoKSB7XG4gICAgdGhyb3cgbmV3IFR5cGVFcnJvcigndGhpcyBpcyBhIHJlYWRhYmxlIHN0cmVhbScpXG4gIH1cblxuICBlbmQgKCkge1xuICAgIHRocm93IG5ldyBUeXBlRXJyb3IoJ3RoaXMgaXMgYSByZWFkYWJsZSBzdHJlYW0nKVxuICB9XG5cbiAgW19vcGVuXSAoKSB7XG4gICAgZnMub3Blbih0aGlzW19wYXRoXSwgJ3InLCAoZXIsIGZkKSA9PiB0aGlzW19vbm9wZW5dKGVyLCBmZCkpXG4gIH1cblxuICBbX29ub3Blbl0gKGVyLCBmZCkge1xuICAgIGlmIChlcilcbiAgICAgIHRoaXNbX29uZXJyb3JdKGVyKVxuICAgIGVsc2Uge1xuICAgICAgdGhpc1tfZmRdID0gZmRcbiAgICAgIHRoaXMuZW1pdCgnb3BlbicsIGZkKVxuICAgICAgdGhpc1tfcmVhZF0oKVxuICAgIH1cbiAgfVxuXG4gIFtfbWFrZUJ1Zl0gKCkge1xuICAgIHJldHVybiBCdWZmZXIuYWxsb2NVbnNhZmUoTWF0aC5taW4odGhpc1tfcmVhZFNpemVdLCB0aGlzW19yZW1haW5dKSlcbiAgfVxuXG4gIFtfcmVhZF0gKCkge1xuICAgIGlmICghdGhpc1tfcmVhZGluZ10pIHtcbiAgICAgIHRoaXNbX3JlYWRpbmddID0gdHJ1ZVxuICAgICAgY29uc3QgYnVmID0gdGhpc1tfbWFrZUJ1Zl0oKVxuICAgICAgLyogaXN0YW5idWwgaWdub3JlIGlmICovXG4gICAgICBpZiAoYnVmLmxlbmd0aCA9PT0gMCkgcmV0dXJuIHByb2Nlc3MubmV4dFRpY2soKCkgPT4gdGhpc1tfb25yZWFkXShudWxsLCAwLCBidWYpKVxuICAgICAgZnMucmVhZCh0aGlzW19mZF0sIGJ1ZiwgMCwgYnVmLmxlbmd0aCwgbnVsbCwgKGVyLCBiciwgYnVmKSA9PlxuICAgICAgICB0aGlzW19vbnJlYWRdKGVyLCBiciwgYnVmKSlcbiAgICB9XG4gIH1cblxuICBbX29ucmVhZF0gKGVyLCBiciwgYnVmKSB7XG4gICAgdGhpc1tfcmVhZGluZ10gPSBmYWxzZVxuICAgIGlmIChlcilcbiAgICAgIHRoaXNbX29uZXJyb3JdKGVyKVxuICAgIGVsc2UgaWYgKHRoaXNbX2hhbmRsZUNodW5rXShiciwgYnVmKSlcbiAgICAgIHRoaXNbX3JlYWRdKClcbiAgfVxuXG4gIFtfY2xvc2VdICgpIHtcbiAgICBpZiAodGhpc1tfYXV0b0Nsb3NlXSAmJiB0eXBlb2YgdGhpc1tfZmRdID09PSAnbnVtYmVyJykge1xuICAgICAgZnMuY2xvc2UodGhpc1tfZmRdLCBfID0+IHRoaXMuZW1pdCgnY2xvc2UnKSlcbiAgICAgIHRoaXNbX2ZkXSA9IG51bGxcbiAgICB9XG4gIH1cblxuICBbX29uZXJyb3JdIChlcikge1xuICAgIHRoaXNbX3JlYWRpbmddID0gdHJ1ZVxuICAgIHRoaXNbX2Nsb3NlXSgpXG4gICAgdGhpcy5lbWl0KCdlcnJvcicsIGVyKVxuICB9XG5cbiAgW19oYW5kbGVDaHVua10gKGJyLCBidWYpIHtcbiAgICBsZXQgcmV0ID0gZmFsc2VcbiAgICAvLyBubyBlZmZlY3QgaWYgaW5maW5pdGVcbiAgICB0aGlzW19yZW1haW5dIC09IGJyXG4gICAgaWYgKGJyID4gMClcbiAgICAgIHJldCA9IHN1cGVyLndyaXRlKGJyIDwgYnVmLmxlbmd0aCA/IGJ1Zi5zbGljZSgwLCBicikgOiBidWYpXG5cbiAgICBpZiAoYnIgPT09IDAgfHwgdGhpc1tfcmVtYWluXSA8PSAwKSB7XG4gICAgICByZXQgPSBmYWxzZVxuICAgICAgdGhpc1tfY2xvc2VdKClcbiAgICAgIHN1cGVyLmVuZCgpXG4gICAgfVxuXG4gICAgcmV0dXJuIHJldFxuICB9XG5cbiAgZW1pdCAoZXYsIGRhdGEpIHtcbiAgICBzd2l0Y2ggKGV2KSB7XG4gICAgICBjYXNlICdwcmVmaW5pc2gnOlxuICAgICAgY2FzZSAnZmluaXNoJzpcbiAgICAgICAgYnJlYWtcblxuICAgICAgY2FzZSAnZHJhaW4nOlxuICAgICAgICBpZiAodHlwZW9mIHRoaXNbX2ZkXSA9PT0gJ251bWJlcicpXG4gICAgICAgICAgdGhpc1tfcmVhZF0oKVxuICAgICAgICBicmVha1xuXG4gICAgICBkZWZhdWx0OlxuICAgICAgICByZXR1cm4gc3VwZXIuZW1pdChldiwgZGF0YSlcbiAgICB9XG4gIH1cbn1cblxuY2xhc3MgUmVhZFN0cmVhbVN5bmMgZXh0ZW5kcyBSZWFkU3RyZWFtIHtcbiAgW19vcGVuXSAoKSB7XG4gICAgbGV0IHRocmV3ID0gdHJ1ZVxuICAgIHRyeSB7XG4gICAgICB0aGlzW19vbm9wZW5dKG51bGwsIGZzLm9wZW5TeW5jKHRoaXNbX3BhdGhdLCAncicpKVxuICAgICAgdGhyZXcgPSBmYWxzZVxuICAgIH0gZmluYWxseSB7XG4gICAgICBpZiAodGhyZXcpXG4gICAgICAgIHRoaXNbX2Nsb3NlXSgpXG4gICAgfVxuICB9XG5cbiAgW19yZWFkXSAoKSB7XG4gICAgbGV0IHRocmV3ID0gdHJ1ZVxuICAgIHRyeSB7XG4gICAgICBpZiAoIXRoaXNbX3JlYWRpbmddKSB7XG4gICAgICAgIHRoaXNbX3JlYWRpbmddID0gdHJ1ZVxuICAgICAgICBkbyB7XG4gICAgICAgICAgY29uc3QgYnVmID0gdGhpc1tfbWFrZUJ1Zl0oKVxuICAgICAgICAgIC8qIGlzdGFuYnVsIGlnbm9yZSBuZXh0ICovXG4gICAgICAgICAgY29uc3QgYnIgPSBidWYubGVuZ3RoID09PSAwID8gMCA6IGZzLnJlYWRTeW5jKHRoaXNbX2ZkXSwgYnVmLCAwLCBidWYubGVuZ3RoLCBudWxsKVxuICAgICAgICAgIGlmICghdGhpc1tfaGFuZGxlQ2h1bmtdKGJyLCBidWYpKVxuICAgICAgICAgICAgYnJlYWtcbiAgICAgICAgfSB3aGlsZSAodHJ1ZSlcbiAgICAgICAgdGhpc1tfcmVhZGluZ10gPSBmYWxzZVxuICAgICAgfVxuICAgICAgdGhyZXcgPSBmYWxzZVxuICAgIH0gZmluYWxseSB7XG4gICAgICBpZiAodGhyZXcpXG4gICAgICAgIHRoaXNbX2Nsb3NlXSgpXG4gICAgfVxuICB9XG5cbiAgW19jbG9zZV0gKCkge1xuICAgIGlmICh0aGlzW19hdXRvQ2xvc2VdICYmIHR5cGVvZiB0aGlzW19mZF0gPT09ICdudW1iZXInKSB7XG4gICAgICB0cnkge1xuICAgICAgICBmcy5jbG9zZVN5bmModGhpc1tfZmRdKVxuICAgICAgfSBjYXRjaCAoZXIpIHt9XG4gICAgICB0aGlzW19mZF0gPSBudWxsXG4gICAgICB0aGlzLmVtaXQoJ2Nsb3NlJylcbiAgICB9XG4gIH1cbn1cblxuY2xhc3MgV3JpdGVTdHJlYW0gZXh0ZW5kcyBFRSB7XG4gIGNvbnN0cnVjdG9yIChwYXRoLCBvcHQpIHtcbiAgICBvcHQgPSBvcHQgfHwge31cbiAgICBzdXBlcihvcHQpXG4gICAgdGhpcy5yZWFkYWJsZSA9IGZhbHNlXG4gICAgdGhpc1tfd3JpdGluZ10gPSBmYWxzZVxuICAgIHRoaXNbX2VuZGVkXSA9IGZhbHNlXG4gICAgdGhpc1tfbmVlZERyYWluXSA9IGZhbHNlXG4gICAgdGhpc1tfcXVldWVdID0gW11cbiAgICB0aGlzW19wYXRoXSA9IHBhdGhcbiAgICB0aGlzW19mZF0gPSB0eXBlb2Ygb3B0LmZkID09PSAnbnVtYmVyJyA/IG9wdC5mZCA6IG51bGxcbiAgICB0aGlzW19tb2RlXSA9IG9wdC5tb2RlID09PSB1bmRlZmluZWQgPyAwbzY2NiA6IG9wdC5tb2RlXG4gICAgdGhpc1tfcG9zXSA9IHR5cGVvZiBvcHQuc3RhcnQgPT09ICdudW1iZXInID8gb3B0LnN0YXJ0IDogbnVsbFxuICAgIHRoaXNbX2F1dG9DbG9zZV0gPSB0eXBlb2Ygb3B0LmF1dG9DbG9zZSA9PT0gJ2Jvb2xlYW4nID9cbiAgICAgIG9wdC5hdXRvQ2xvc2UgOiB0cnVlXG5cbiAgICAvLyB0cnVuY2F0aW5nIG1ha2VzIG5vIHNlbnNlIHdoZW4gd3JpdGluZyBpbnRvIHRoZSBtaWRkbGVcbiAgICBjb25zdCBkZWZhdWx0RmxhZyA9IHRoaXNbX3Bvc10gIT09IG51bGwgPyAncisnIDogJ3cnXG4gICAgdGhpc1tfZGVmYXVsdEZsYWddID0gb3B0LmZsYWdzID09PSB1bmRlZmluZWRcbiAgICB0aGlzW19mbGFnc10gPSB0aGlzW19kZWZhdWx0RmxhZ10gPyBkZWZhdWx0RmxhZyA6IG9wdC5mbGFnc1xuXG4gICAgaWYgKHRoaXNbX2ZkXSA9PT0gbnVsbClcbiAgICAgIHRoaXNbX29wZW5dKClcbiAgfVxuXG4gIGdldCBmZCAoKSB7IHJldHVybiB0aGlzW19mZF0gfVxuICBnZXQgcGF0aCAoKSB7IHJldHVybiB0aGlzW19wYXRoXSB9XG5cbiAgW19vbmVycm9yXSAoZXIpIHtcbiAgICB0aGlzW19jbG9zZV0oKVxuICAgIHRoaXNbX3dyaXRpbmddID0gdHJ1ZVxuICAgIHRoaXMuZW1pdCgnZXJyb3InLCBlcilcbiAgfVxuXG4gIFtfb3Blbl0gKCkge1xuICAgIGZzLm9wZW4odGhpc1tfcGF0aF0sIHRoaXNbX2ZsYWdzXSwgdGhpc1tfbW9kZV0sXG4gICAgICAoZXIsIGZkKSA9PiB0aGlzW19vbm9wZW5dKGVyLCBmZCkpXG4gIH1cblxuICBbX29ub3Blbl0gKGVyLCBmZCkge1xuICAgIGlmICh0aGlzW19kZWZhdWx0RmxhZ10gJiZcbiAgICAgICAgdGhpc1tfZmxhZ3NdID09PSAncisnICYmXG4gICAgICAgIGVyICYmIGVyLmNvZGUgPT09ICdFTk9FTlQnKSB7XG4gICAgICB0aGlzW19mbGFnc10gPSAndydcbiAgICAgIHRoaXNbX29wZW5dKClcbiAgICB9IGVsc2UgaWYgKGVyKVxuICAgICAgdGhpc1tfb25lcnJvcl0oZXIpXG4gICAgZWxzZSB7XG4gICAgICB0aGlzW19mZF0gPSBmZFxuICAgICAgdGhpcy5lbWl0KCdvcGVuJywgZmQpXG4gICAgICB0aGlzW19mbHVzaF0oKVxuICAgIH1cbiAgfVxuXG4gIGVuZCAoYnVmLCBlbmMpIHtcbiAgICBpZiAoYnVmKVxuICAgICAgdGhpcy53cml0ZShidWYsIGVuYylcblxuICAgIHRoaXNbX2VuZGVkXSA9IHRydWVcblxuICAgIC8vIHN5bnRoZXRpYyBhZnRlci13cml0ZSBsb2dpYywgd2hlcmUgZHJhaW4vZmluaXNoIGxpdmVcbiAgICBpZiAoIXRoaXNbX3dyaXRpbmddICYmICF0aGlzW19xdWV1ZV0ubGVuZ3RoICYmXG4gICAgICAgIHR5cGVvZiB0aGlzW19mZF0gPT09ICdudW1iZXInKVxuICAgICAgdGhpc1tfb253cml0ZV0obnVsbCwgMClcbiAgfVxuXG4gIHdyaXRlIChidWYsIGVuYykge1xuICAgIGlmICh0eXBlb2YgYnVmID09PSAnc3RyaW5nJylcbiAgICAgIGJ1ZiA9IG5ldyBCdWZmZXIoYnVmLCBlbmMpXG5cbiAgICBpZiAodGhpc1tfZW5kZWRdKSB7XG4gICAgICB0aGlzLmVtaXQoJ2Vycm9yJywgbmV3IEVycm9yKCd3cml0ZSgpIGFmdGVyIGVuZCgpJykpXG4gICAgICByZXR1cm4gZmFsc2VcbiAgICB9XG5cbiAgICBpZiAodGhpc1tfZmRdID09PSBudWxsIHx8IHRoaXNbX3dyaXRpbmddIHx8IHRoaXNbX3F1ZXVlXS5sZW5ndGgpIHtcbiAgICAgIHRoaXNbX3F1ZXVlXS5wdXNoKGJ1ZilcbiAgICAgIHRoaXNbX25lZWREcmFpbl0gPSB0cnVlXG4gICAgICByZXR1cm4gZmFsc2VcbiAgICB9XG5cbiAgICB0aGlzW193cml0aW5nXSA9IHRydWVcbiAgICB0aGlzW193cml0ZV0oYnVmKVxuICAgIHJldHVybiB0cnVlXG4gIH1cblxuICBbX3dyaXRlXSAoYnVmKSB7XG4gICAgZnMud3JpdGUodGhpc1tfZmRdLCBidWYsIDAsIGJ1Zi5sZW5ndGgsIHRoaXNbX3Bvc10sIChlciwgYncpID0+XG4gICAgICB0aGlzW19vbndyaXRlXShlciwgYncpKVxuICB9XG5cbiAgW19vbndyaXRlXSAoZXIsIGJ3KSB7XG4gICAgaWYgKGVyKVxuICAgICAgdGhpc1tfb25lcnJvcl0oZXIpXG4gICAgZWxzZSB7XG4gICAgICBpZiAodGhpc1tfcG9zXSAhPT0gbnVsbClcbiAgICAgICAgdGhpc1tfcG9zXSArPSBid1xuICAgICAgaWYgKHRoaXNbX3F1ZXVlXS5sZW5ndGgpXG4gICAgICAgIHRoaXNbX2ZsdXNoXSgpXG4gICAgICBlbHNlIHtcbiAgICAgICAgdGhpc1tfd3JpdGluZ10gPSBmYWxzZVxuXG4gICAgICAgIGlmICh0aGlzW19lbmRlZF0gJiYgIXRoaXNbX2ZpbmlzaGVkXSkge1xuICAgICAgICAgIHRoaXNbX2ZpbmlzaGVkXSA9IHRydWVcbiAgICAgICAgICB0aGlzW19jbG9zZV0oKVxuICAgICAgICAgIHRoaXMuZW1pdCgnZmluaXNoJylcbiAgICAgICAgfSBlbHNlIGlmICh0aGlzW19uZWVkRHJhaW5dKSB7XG4gICAgICAgICAgdGhpc1tfbmVlZERyYWluXSA9IGZhbHNlXG4gICAgICAgICAgdGhpcy5lbWl0KCdkcmFpbicpXG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG4gIH1cblxuICBbX2ZsdXNoXSAoKSB7XG4gICAgaWYgKHRoaXNbX3F1ZXVlXS5sZW5ndGggPT09IDApIHtcbiAgICAgIGlmICh0aGlzW19lbmRlZF0pXG4gICAgICAgIHRoaXNbX29ud3JpdGVdKG51bGwsIDApXG4gICAgfSBlbHNlIGlmICh0aGlzW19xdWV1ZV0ubGVuZ3RoID09PSAxKVxuICAgICAgdGhpc1tfd3JpdGVdKHRoaXNbX3F1ZXVlXS5wb3AoKSlcbiAgICBlbHNlIHtcbiAgICAgIGNvbnN0IGlvdmVjID0gdGhpc1tfcXVldWVdXG4gICAgICB0aGlzW19xdWV1ZV0gPSBbXVxuICAgICAgd3JpdGV2KHRoaXNbX2ZkXSwgaW92ZWMsIHRoaXNbX3Bvc10sXG4gICAgICAgIChlciwgYncpID0+IHRoaXNbX29ud3JpdGVdKGVyLCBidykpXG4gICAgfVxuICB9XG5cbiAgW19jbG9zZV0gKCkge1xuICAgIGlmICh0aGlzW19hdXRvQ2xvc2VdICYmIHR5cGVvZiB0aGlzW19mZF0gPT09ICdudW1iZXInKSB7XG4gICAgICBmcy5jbG9zZSh0aGlzW19mZF0sIF8gPT4gdGhpcy5lbWl0KCdjbG9zZScpKVxuICAgICAgdGhpc1tfZmRdID0gbnVsbFxuICAgIH1cbiAgfVxufVxuXG5jbGFzcyBXcml0ZVN0cmVhbVN5bmMgZXh0ZW5kcyBXcml0ZVN0cmVhbSB7XG4gIFtfb3Blbl0gKCkge1xuICAgIGxldCBmZFxuICAgIHRyeSB7XG4gICAgICBmZCA9IGZzLm9wZW5TeW5jKHRoaXNbX3BhdGhdLCB0aGlzW19mbGFnc10sIHRoaXNbX21vZGVdKVxuICAgIH0gY2F0Y2ggKGVyKSB7XG4gICAgICBpZiAodGhpc1tfZGVmYXVsdEZsYWddICYmXG4gICAgICAgICAgdGhpc1tfZmxhZ3NdID09PSAncisnICYmXG4gICAgICAgICAgZXIgJiYgZXIuY29kZSA9PT0gJ0VOT0VOVCcpIHtcbiAgICAgICAgdGhpc1tfZmxhZ3NdID0gJ3cnXG4gICAgICAgIHJldHVybiB0aGlzW19vcGVuXSgpXG4gICAgICB9IGVsc2VcbiAgICAgICAgdGhyb3cgZXJcbiAgICB9XG4gICAgdGhpc1tfb25vcGVuXShudWxsLCBmZClcbiAgfVxuXG4gIFtfY2xvc2VdICgpIHtcbiAgICBpZiAodGhpc1tfYXV0b0Nsb3NlXSAmJiB0eXBlb2YgdGhpc1tfZmRdID09PSAnbnVtYmVyJykge1xuICAgICAgdHJ5IHtcbiAgICAgICAgZnMuY2xvc2VTeW5jKHRoaXNbX2ZkXSlcbiAgICAgIH0gY2F0Y2ggKGVyKSB7fVxuICAgICAgdGhpc1tfZmRdID0gbnVsbFxuICAgICAgdGhpcy5lbWl0KCdjbG9zZScpXG4gICAgfVxuICB9XG5cbiAgW193cml0ZV0gKGJ1Zikge1xuICAgIHRyeSB7XG4gICAgICB0aGlzW19vbndyaXRlXShudWxsLFxuICAgICAgICBmcy53cml0ZVN5bmModGhpc1tfZmRdLCBidWYsIDAsIGJ1Zi5sZW5ndGgsIHRoaXNbX3Bvc10pKVxuICAgIH0gY2F0Y2ggKGVyKSB7XG4gICAgICB0aGlzW19vbndyaXRlXShlciwgMClcbiAgICB9XG4gIH1cbn1cblxuY29uc3Qgd3JpdGV2ID0gKGZkLCBpb3ZlYywgcG9zLCBjYikgPT4ge1xuICBjb25zdCBkb25lID0gKGVyLCBidykgPT4gY2IoZXIsIGJ3LCBpb3ZlYylcbiAgY29uc3QgcmVxID0gbmV3IEZTUmVxV3JhcCgpXG4gIHJlcS5vbmNvbXBsZXRlID0gZG9uZVxuICBiaW5kaW5nLndyaXRlQnVmZmVycyhmZCwgaW92ZWMsIHBvcywgcmVxKVxufVxuXG5leHBvcnRzLlJlYWRTdHJlYW0gPSBSZWFkU3RyZWFtXG5leHBvcnRzLlJlYWRTdHJlYW1TeW5jID0gUmVhZFN0cmVhbVN5bmNcblxuZXhwb3J0cy5Xcml0ZVN0cmVhbSA9IFdyaXRlU3RyZWFtXG5leHBvcnRzLldyaXRlU3RyZWFtU3luYyA9IFdyaXRlU3RyZWFtU3luY1xuIl0sIm5hbWVzIjpbXSwiaWdub3JlTGlzdCI6WzBdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/swarm-js/node_modules/fs-minipass/index.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/swarm-js/node_modules/got/dist/source/as-promise/create-rejection.js":
/*!*******************************************************************************************!*\
  !*** ./node_modules/swarm-js/node_modules/got/dist/source/as-promise/create-rejection.js ***!
  \*******************************************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";
eval("\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nconst types_1 = __webpack_require__(/*! ./types */ \"(ssr)/./node_modules/swarm-js/node_modules/got/dist/source/as-promise/types.js\");\nfunction createRejection(error, ...beforeErrorGroups) {\n    const promise = (async () => {\n        if (error instanceof types_1.RequestError) {\n            try {\n                for (const hooks of beforeErrorGroups) {\n                    if (hooks) {\n                        for (const hook of hooks) {\n                            // eslint-disable-next-line no-await-in-loop\n                            error = await hook(error);\n                        }\n                    }\n                }\n            }\n            catch (error_) {\n                error = error_;\n            }\n        }\n        throw error;\n    })();\n    const returnPromise = () => promise;\n    promise.json = returnPromise;\n    promise.text = returnPromise;\n    promise.buffer = returnPromise;\n    promise.on = returnPromise;\n    return promise;\n}\nexports[\"default\"] = createRejection;\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvc3dhcm0tanMvbm9kZV9tb2R1bGVzL2dvdC9kaXN0L3NvdXJjZS9hcy1wcm9taXNlL2NyZWF0ZS1yZWplY3Rpb24uanMiLCJtYXBwaW5ncyI6IkFBQWE7QUFDYiw4Q0FBNkMsRUFBRSxhQUFhLEVBQUM7QUFDN0QsZ0JBQWdCLG1CQUFPLENBQUMsK0ZBQVM7QUFDakM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esa0JBQWUiLCJzb3VyY2VzIjpbIi9Vc2Vycy9wYW56YS9Eb2N1bWVudHMvUGVyc29uYWxQcm9qZWN0cy9wcmVkaWsvbm9kZV9tb2R1bGVzL3N3YXJtLWpzL25vZGVfbW9kdWxlcy9nb3QvZGlzdC9zb3VyY2UvYXMtcHJvbWlzZS9jcmVhdGUtcmVqZWN0aW9uLmpzIl0sInNvdXJjZXNDb250ZW50IjpbIlwidXNlIHN0cmljdFwiO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xuY29uc3QgdHlwZXNfMSA9IHJlcXVpcmUoXCIuL3R5cGVzXCIpO1xuZnVuY3Rpb24gY3JlYXRlUmVqZWN0aW9uKGVycm9yLCAuLi5iZWZvcmVFcnJvckdyb3Vwcykge1xuICAgIGNvbnN0IHByb21pc2UgPSAoYXN5bmMgKCkgPT4ge1xuICAgICAgICBpZiAoZXJyb3IgaW5zdGFuY2VvZiB0eXBlc18xLlJlcXVlc3RFcnJvcikge1xuICAgICAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgICAgICBmb3IgKGNvbnN0IGhvb2tzIG9mIGJlZm9yZUVycm9yR3JvdXBzKSB7XG4gICAgICAgICAgICAgICAgICAgIGlmIChob29rcykge1xuICAgICAgICAgICAgICAgICAgICAgICAgZm9yIChjb25zdCBob29rIG9mIGhvb2tzKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIG5vLWF3YWl0LWluLWxvb3BcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBlcnJvciA9IGF3YWl0IGhvb2soZXJyb3IpO1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgY2F0Y2ggKGVycm9yXykge1xuICAgICAgICAgICAgICAgIGVycm9yID0gZXJyb3JfO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHRocm93IGVycm9yO1xuICAgIH0pKCk7XG4gICAgY29uc3QgcmV0dXJuUHJvbWlzZSA9ICgpID0+IHByb21pc2U7XG4gICAgcHJvbWlzZS5qc29uID0gcmV0dXJuUHJvbWlzZTtcbiAgICBwcm9taXNlLnRleHQgPSByZXR1cm5Qcm9taXNlO1xuICAgIHByb21pc2UuYnVmZmVyID0gcmV0dXJuUHJvbWlzZTtcbiAgICBwcm9taXNlLm9uID0gcmV0dXJuUHJvbWlzZTtcbiAgICByZXR1cm4gcHJvbWlzZTtcbn1cbmV4cG9ydHMuZGVmYXVsdCA9IGNyZWF0ZVJlamVjdGlvbjtcbiJdLCJuYW1lcyI6W10sImlnbm9yZUxpc3QiOlswXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/swarm-js/node_modules/got/dist/source/as-promise/create-rejection.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/swarm-js/node_modules/got/dist/source/as-promise/index.js":
/*!********************************************************************************!*\
  !*** ./node_modules/swarm-js/node_modules/got/dist/source/as-promise/index.js ***!
  \********************************************************************************/
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

"use strict";
eval("\nvar __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {\n    if (k2 === undefined) k2 = k;\n    Object.defineProperty(o, k2, { enumerable: true, get: function() { return m[k]; } });\n}) : (function(o, m, k, k2) {\n    if (k2 === undefined) k2 = k;\n    o[k2] = m[k];\n}));\nvar __exportStar = (this && this.__exportStar) || function(m, exports) {\n    for (var p in m) if (p !== \"default\" && !Object.prototype.hasOwnProperty.call(exports, p)) __createBinding(exports, m, p);\n};\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nconst events_1 = __webpack_require__(/*! events */ \"events\");\nconst is_1 = __webpack_require__(/*! @sindresorhus/is */ \"(ssr)/./node_modules/@sindresorhus/is/dist/index.js\");\nconst PCancelable = __webpack_require__(/*! p-cancelable */ \"(ssr)/./node_modules/swarm-js/node_modules/p-cancelable/index.js\");\nconst types_1 = __webpack_require__(/*! ./types */ \"(ssr)/./node_modules/swarm-js/node_modules/got/dist/source/as-promise/types.js\");\nconst parse_body_1 = __webpack_require__(/*! ./parse-body */ \"(ssr)/./node_modules/swarm-js/node_modules/got/dist/source/as-promise/parse-body.js\");\nconst core_1 = __webpack_require__(/*! ../core */ \"(ssr)/./node_modules/swarm-js/node_modules/got/dist/source/core/index.js\");\nconst proxy_events_1 = __webpack_require__(/*! ../core/utils/proxy-events */ \"(ssr)/./node_modules/swarm-js/node_modules/got/dist/source/core/utils/proxy-events.js\");\nconst get_buffer_1 = __webpack_require__(/*! ../core/utils/get-buffer */ \"(ssr)/./node_modules/swarm-js/node_modules/got/dist/source/core/utils/get-buffer.js\");\nconst is_response_ok_1 = __webpack_require__(/*! ../core/utils/is-response-ok */ \"(ssr)/./node_modules/swarm-js/node_modules/got/dist/source/core/utils/is-response-ok.js\");\nconst proxiedRequestEvents = [\n    'request',\n    'response',\n    'redirect',\n    'uploadProgress',\n    'downloadProgress'\n];\nfunction asPromise(normalizedOptions) {\n    let globalRequest;\n    let globalResponse;\n    const emitter = new events_1.EventEmitter();\n    const promise = new PCancelable((resolve, reject, onCancel) => {\n        const makeRequest = (retryCount) => {\n            const request = new core_1.default(undefined, normalizedOptions);\n            request.retryCount = retryCount;\n            request._noPipe = true;\n            onCancel(() => request.destroy());\n            onCancel.shouldReject = false;\n            onCancel(() => reject(new types_1.CancelError(request)));\n            globalRequest = request;\n            request.once('response', async (response) => {\n                var _a;\n                response.retryCount = retryCount;\n                if (response.request.aborted) {\n                    // Canceled while downloading - will throw a `CancelError` or `TimeoutError` error\n                    return;\n                }\n                // Download body\n                let rawBody;\n                try {\n                    rawBody = await get_buffer_1.default(request);\n                    response.rawBody = rawBody;\n                }\n                catch (_b) {\n                    // The same error is caught below.\n                    // See request.once('error')\n                    return;\n                }\n                if (request._isAboutToError) {\n                    return;\n                }\n                // Parse body\n                const contentEncoding = ((_a = response.headers['content-encoding']) !== null && _a !== void 0 ? _a : '').toLowerCase();\n                const isCompressed = ['gzip', 'deflate', 'br'].includes(contentEncoding);\n                const { options } = request;\n                if (isCompressed && !options.decompress) {\n                    response.body = rawBody;\n                }\n                else {\n                    try {\n                        response.body = parse_body_1.default(response, options.responseType, options.parseJson, options.encoding);\n                    }\n                    catch (error) {\n                        // Fallback to `utf8`\n                        response.body = rawBody.toString();\n                        if (is_response_ok_1.isResponseOk(response)) {\n                            request._beforeError(error);\n                            return;\n                        }\n                    }\n                }\n                try {\n                    for (const [index, hook] of options.hooks.afterResponse.entries()) {\n                        // @ts-expect-error TS doesn't notice that CancelableRequest is a Promise\n                        // eslint-disable-next-line no-await-in-loop\n                        response = await hook(response, async (updatedOptions) => {\n                            const typedOptions = core_1.default.normalizeArguments(undefined, {\n                                ...updatedOptions,\n                                retry: {\n                                    calculateDelay: () => 0\n                                },\n                                throwHttpErrors: false,\n                                resolveBodyOnly: false\n                            }, options);\n                            // Remove any further hooks for that request, because we'll call them anyway.\n                            // The loop continues. We don't want duplicates (asPromise recursion).\n                            typedOptions.hooks.afterResponse = typedOptions.hooks.afterResponse.slice(0, index);\n                            for (const hook of typedOptions.hooks.beforeRetry) {\n                                // eslint-disable-next-line no-await-in-loop\n                                await hook(typedOptions);\n                            }\n                            const promise = asPromise(typedOptions);\n                            onCancel(() => {\n                                promise.catch(() => { });\n                                promise.cancel();\n                            });\n                            return promise;\n                        });\n                    }\n                }\n                catch (error) {\n                    request._beforeError(new types_1.RequestError(error.message, error, request));\n                    return;\n                }\n                globalResponse = response;\n                if (!is_response_ok_1.isResponseOk(response)) {\n                    request._beforeError(new types_1.HTTPError(response));\n                    return;\n                }\n                request.destroy();\n                resolve(request.options.resolveBodyOnly ? response.body : response);\n            });\n            const onError = (error) => {\n                if (promise.isCanceled) {\n                    return;\n                }\n                const { options } = request;\n                if (error instanceof types_1.HTTPError && !options.throwHttpErrors) {\n                    const { response } = error;\n                    resolve(request.options.resolveBodyOnly ? response.body : response);\n                    return;\n                }\n                reject(error);\n            };\n            request.once('error', onError);\n            const previousBody = request.options.body;\n            request.once('retry', (newRetryCount, error) => {\n                var _a, _b;\n                if (previousBody === ((_a = error.request) === null || _a === void 0 ? void 0 : _a.options.body) && is_1.default.nodeStream((_b = error.request) === null || _b === void 0 ? void 0 : _b.options.body)) {\n                    onError(error);\n                    return;\n                }\n                makeRequest(newRetryCount);\n            });\n            proxy_events_1.default(request, emitter, proxiedRequestEvents);\n        };\n        makeRequest(0);\n    });\n    promise.on = (event, fn) => {\n        emitter.on(event, fn);\n        return promise;\n    };\n    const shortcut = (responseType) => {\n        const newPromise = (async () => {\n            // Wait until downloading has ended\n            await promise;\n            const { options } = globalResponse.request;\n            return parse_body_1.default(globalResponse, responseType, options.parseJson, options.encoding);\n        })();\n        Object.defineProperties(newPromise, Object.getOwnPropertyDescriptors(promise));\n        return newPromise;\n    };\n    promise.json = () => {\n        const { headers } = globalRequest.options;\n        if (!globalRequest.writableFinished && headers.accept === undefined) {\n            headers.accept = 'application/json';\n        }\n        return shortcut('json');\n    };\n    promise.buffer = () => shortcut('buffer');\n    promise.text = () => shortcut('text');\n    return promise;\n}\nexports[\"default\"] = asPromise;\n__exportStar(__webpack_require__(/*! ./types */ \"(ssr)/./node_modules/swarm-js/node_modules/got/dist/source/as-promise/types.js\"), exports);\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvc3dhcm0tanMvbm9kZV9tb2R1bGVzL2dvdC9kaXN0L3NvdXJjZS9hcy1wcm9taXNlL2luZGV4LmpzIiwibWFwcGluZ3MiOiJBQUFhO0FBQ2I7QUFDQTtBQUNBLG1DQUFtQyxvQ0FBb0MsZ0JBQWdCO0FBQ3ZGLENBQUM7QUFDRDtBQUNBO0FBQ0EsQ0FBQztBQUNEO0FBQ0E7QUFDQTtBQUNBLDhDQUE2QyxFQUFFLGFBQWEsRUFBQztBQUM3RCxpQkFBaUIsbUJBQU8sQ0FBQyxzQkFBUTtBQUNqQyxhQUFhLG1CQUFPLENBQUMsNkVBQWtCO0FBQ3ZDLG9CQUFvQixtQkFBTyxDQUFDLHNGQUFjO0FBQzFDLGdCQUFnQixtQkFBTyxDQUFDLCtGQUFTO0FBQ2pDLHFCQUFxQixtQkFBTyxDQUFDLHlHQUFjO0FBQzNDLGVBQWUsbUJBQU8sQ0FBQyx5RkFBUztBQUNoQyx1QkFBdUIsbUJBQU8sQ0FBQyx5SEFBNEI7QUFDM0QscUJBQXFCLG1CQUFPLENBQUMscUhBQTBCO0FBQ3ZELHlCQUF5QixtQkFBTyxDQUFDLDZIQUE4QjtBQUMvRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esd0JBQXdCLFVBQVU7QUFDbEM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxpQ0FBaUM7QUFDakM7QUFDQTtBQUNBLDZCQUE2QjtBQUM3QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx1REFBdUQ7QUFDdkQ7QUFDQSw2QkFBNkI7QUFDN0I7QUFDQSx5QkFBeUI7QUFDekI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0E7QUFDQSx3QkFBd0IsVUFBVTtBQUNsQztBQUNBLDRCQUE0QixXQUFXO0FBQ3ZDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxvQkFBb0IsVUFBVTtBQUM5QjtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBLGdCQUFnQixVQUFVO0FBQzFCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGtCQUFlO0FBQ2YsYUFBYSxtQkFBTyxDQUFDLCtGQUFTIiwic291cmNlcyI6WyIvVXNlcnMvcGFuemEvRG9jdW1lbnRzL1BlcnNvbmFsUHJvamVjdHMvcHJlZGlrL25vZGVfbW9kdWxlcy9zd2FybS1qcy9ub2RlX21vZHVsZXMvZ290L2Rpc3Qvc291cmNlL2FzLXByb21pc2UvaW5kZXguanMiXSwic291cmNlc0NvbnRlbnQiOlsiXCJ1c2Ugc3RyaWN0XCI7XG52YXIgX19jcmVhdGVCaW5kaW5nID0gKHRoaXMgJiYgdGhpcy5fX2NyZWF0ZUJpbmRpbmcpIHx8IChPYmplY3QuY3JlYXRlID8gKGZ1bmN0aW9uKG8sIG0sIGssIGsyKSB7XG4gICAgaWYgKGsyID09PSB1bmRlZmluZWQpIGsyID0gaztcbiAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkobywgazIsIHsgZW51bWVyYWJsZTogdHJ1ZSwgZ2V0OiBmdW5jdGlvbigpIHsgcmV0dXJuIG1ba107IH0gfSk7XG59KSA6IChmdW5jdGlvbihvLCBtLCBrLCBrMikge1xuICAgIGlmIChrMiA9PT0gdW5kZWZpbmVkKSBrMiA9IGs7XG4gICAgb1trMl0gPSBtW2tdO1xufSkpO1xudmFyIF9fZXhwb3J0U3RhciA9ICh0aGlzICYmIHRoaXMuX19leHBvcnRTdGFyKSB8fCBmdW5jdGlvbihtLCBleHBvcnRzKSB7XG4gICAgZm9yICh2YXIgcCBpbiBtKSBpZiAocCAhPT0gXCJkZWZhdWx0XCIgJiYgIU9iamVjdC5wcm90b3R5cGUuaGFzT3duUHJvcGVydHkuY2FsbChleHBvcnRzLCBwKSkgX19jcmVhdGVCaW5kaW5nKGV4cG9ydHMsIG0sIHApO1xufTtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcbmNvbnN0IGV2ZW50c18xID0gcmVxdWlyZShcImV2ZW50c1wiKTtcbmNvbnN0IGlzXzEgPSByZXF1aXJlKFwiQHNpbmRyZXNvcmh1cy9pc1wiKTtcbmNvbnN0IFBDYW5jZWxhYmxlID0gcmVxdWlyZShcInAtY2FuY2VsYWJsZVwiKTtcbmNvbnN0IHR5cGVzXzEgPSByZXF1aXJlKFwiLi90eXBlc1wiKTtcbmNvbnN0IHBhcnNlX2JvZHlfMSA9IHJlcXVpcmUoXCIuL3BhcnNlLWJvZHlcIik7XG5jb25zdCBjb3JlXzEgPSByZXF1aXJlKFwiLi4vY29yZVwiKTtcbmNvbnN0IHByb3h5X2V2ZW50c18xID0gcmVxdWlyZShcIi4uL2NvcmUvdXRpbHMvcHJveHktZXZlbnRzXCIpO1xuY29uc3QgZ2V0X2J1ZmZlcl8xID0gcmVxdWlyZShcIi4uL2NvcmUvdXRpbHMvZ2V0LWJ1ZmZlclwiKTtcbmNvbnN0IGlzX3Jlc3BvbnNlX29rXzEgPSByZXF1aXJlKFwiLi4vY29yZS91dGlscy9pcy1yZXNwb25zZS1va1wiKTtcbmNvbnN0IHByb3hpZWRSZXF1ZXN0RXZlbnRzID0gW1xuICAgICdyZXF1ZXN0JyxcbiAgICAncmVzcG9uc2UnLFxuICAgICdyZWRpcmVjdCcsXG4gICAgJ3VwbG9hZFByb2dyZXNzJyxcbiAgICAnZG93bmxvYWRQcm9ncmVzcydcbl07XG5mdW5jdGlvbiBhc1Byb21pc2Uobm9ybWFsaXplZE9wdGlvbnMpIHtcbiAgICBsZXQgZ2xvYmFsUmVxdWVzdDtcbiAgICBsZXQgZ2xvYmFsUmVzcG9uc2U7XG4gICAgY29uc3QgZW1pdHRlciA9IG5ldyBldmVudHNfMS5FdmVudEVtaXR0ZXIoKTtcbiAgICBjb25zdCBwcm9taXNlID0gbmV3IFBDYW5jZWxhYmxlKChyZXNvbHZlLCByZWplY3QsIG9uQ2FuY2VsKSA9PiB7XG4gICAgICAgIGNvbnN0IG1ha2VSZXF1ZXN0ID0gKHJldHJ5Q291bnQpID0+IHtcbiAgICAgICAgICAgIGNvbnN0IHJlcXVlc3QgPSBuZXcgY29yZV8xLmRlZmF1bHQodW5kZWZpbmVkLCBub3JtYWxpemVkT3B0aW9ucyk7XG4gICAgICAgICAgICByZXF1ZXN0LnJldHJ5Q291bnQgPSByZXRyeUNvdW50O1xuICAgICAgICAgICAgcmVxdWVzdC5fbm9QaXBlID0gdHJ1ZTtcbiAgICAgICAgICAgIG9uQ2FuY2VsKCgpID0+IHJlcXVlc3QuZGVzdHJveSgpKTtcbiAgICAgICAgICAgIG9uQ2FuY2VsLnNob3VsZFJlamVjdCA9IGZhbHNlO1xuICAgICAgICAgICAgb25DYW5jZWwoKCkgPT4gcmVqZWN0KG5ldyB0eXBlc18xLkNhbmNlbEVycm9yKHJlcXVlc3QpKSk7XG4gICAgICAgICAgICBnbG9iYWxSZXF1ZXN0ID0gcmVxdWVzdDtcbiAgICAgICAgICAgIHJlcXVlc3Qub25jZSgncmVzcG9uc2UnLCBhc3luYyAocmVzcG9uc2UpID0+IHtcbiAgICAgICAgICAgICAgICB2YXIgX2E7XG4gICAgICAgICAgICAgICAgcmVzcG9uc2UucmV0cnlDb3VudCA9IHJldHJ5Q291bnQ7XG4gICAgICAgICAgICAgICAgaWYgKHJlc3BvbnNlLnJlcXVlc3QuYWJvcnRlZCkge1xuICAgICAgICAgICAgICAgICAgICAvLyBDYW5jZWxlZCB3aGlsZSBkb3dubG9hZGluZyAtIHdpbGwgdGhyb3cgYSBgQ2FuY2VsRXJyb3JgIG9yIGBUaW1lb3V0RXJyb3JgIGVycm9yXG4gICAgICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgLy8gRG93bmxvYWQgYm9keVxuICAgICAgICAgICAgICAgIGxldCByYXdCb2R5O1xuICAgICAgICAgICAgICAgIHRyeSB7XG4gICAgICAgICAgICAgICAgICAgIHJhd0JvZHkgPSBhd2FpdCBnZXRfYnVmZmVyXzEuZGVmYXVsdChyZXF1ZXN0KTtcbiAgICAgICAgICAgICAgICAgICAgcmVzcG9uc2UucmF3Qm9keSA9IHJhd0JvZHk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGNhdGNoIChfYikge1xuICAgICAgICAgICAgICAgICAgICAvLyBUaGUgc2FtZSBlcnJvciBpcyBjYXVnaHQgYmVsb3cuXG4gICAgICAgICAgICAgICAgICAgIC8vIFNlZSByZXF1ZXN0Lm9uY2UoJ2Vycm9yJylcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBpZiAocmVxdWVzdC5faXNBYm91dFRvRXJyb3IpIHtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAvLyBQYXJzZSBib2R5XG4gICAgICAgICAgICAgICAgY29uc3QgY29udGVudEVuY29kaW5nID0gKChfYSA9IHJlc3BvbnNlLmhlYWRlcnNbJ2NvbnRlbnQtZW5jb2RpbmcnXSkgIT09IG51bGwgJiYgX2EgIT09IHZvaWQgMCA/IF9hIDogJycpLnRvTG93ZXJDYXNlKCk7XG4gICAgICAgICAgICAgICAgY29uc3QgaXNDb21wcmVzc2VkID0gWydnemlwJywgJ2RlZmxhdGUnLCAnYnInXS5pbmNsdWRlcyhjb250ZW50RW5jb2RpbmcpO1xuICAgICAgICAgICAgICAgIGNvbnN0IHsgb3B0aW9ucyB9ID0gcmVxdWVzdDtcbiAgICAgICAgICAgICAgICBpZiAoaXNDb21wcmVzc2VkICYmICFvcHRpb25zLmRlY29tcHJlc3MpIHtcbiAgICAgICAgICAgICAgICAgICAgcmVzcG9uc2UuYm9keSA9IHJhd0JvZHk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICB0cnkge1xuICAgICAgICAgICAgICAgICAgICAgICAgcmVzcG9uc2UuYm9keSA9IHBhcnNlX2JvZHlfMS5kZWZhdWx0KHJlc3BvbnNlLCBvcHRpb25zLnJlc3BvbnNlVHlwZSwgb3B0aW9ucy5wYXJzZUpzb24sIG9wdGlvbnMuZW5jb2RpbmcpO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIGNhdGNoIChlcnJvcikge1xuICAgICAgICAgICAgICAgICAgICAgICAgLy8gRmFsbGJhY2sgdG8gYHV0ZjhgXG4gICAgICAgICAgICAgICAgICAgICAgICByZXNwb25zZS5ib2R5ID0gcmF3Qm9keS50b1N0cmluZygpO1xuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKGlzX3Jlc3BvbnNlX29rXzEuaXNSZXNwb25zZU9rKHJlc3BvbnNlKSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJlcXVlc3QuX2JlZm9yZUVycm9yKGVycm9yKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgICAgICAgICAgZm9yIChjb25zdCBbaW5kZXgsIGhvb2tdIG9mIG9wdGlvbnMuaG9va3MuYWZ0ZXJSZXNwb25zZS5lbnRyaWVzKCkpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIC8vIEB0cy1leHBlY3QtZXJyb3IgVFMgZG9lc24ndCBub3RpY2UgdGhhdCBDYW5jZWxhYmxlUmVxdWVzdCBpcyBhIFByb21pc2VcbiAgICAgICAgICAgICAgICAgICAgICAgIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBuby1hd2FpdC1pbi1sb29wXG4gICAgICAgICAgICAgICAgICAgICAgICByZXNwb25zZSA9IGF3YWl0IGhvb2socmVzcG9uc2UsIGFzeW5jICh1cGRhdGVkT3B0aW9ucykgPT4ge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNvbnN0IHR5cGVkT3B0aW9ucyA9IGNvcmVfMS5kZWZhdWx0Lm5vcm1hbGl6ZUFyZ3VtZW50cyh1bmRlZmluZWQsIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgLi4udXBkYXRlZE9wdGlvbnMsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJldHJ5OiB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBjYWxjdWxhdGVEZWxheTogKCkgPT4gMFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB9LFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB0aHJvd0h0dHBFcnJvcnM6IGZhbHNlLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXNvbHZlQm9keU9ubHk6IGZhbHNlXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfSwgb3B0aW9ucyk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgLy8gUmVtb3ZlIGFueSBmdXJ0aGVyIGhvb2tzIGZvciB0aGF0IHJlcXVlc3QsIGJlY2F1c2Ugd2UnbGwgY2FsbCB0aGVtIGFueXdheS5cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAvLyBUaGUgbG9vcCBjb250aW51ZXMuIFdlIGRvbid0IHdhbnQgZHVwbGljYXRlcyAoYXNQcm9taXNlIHJlY3Vyc2lvbikuXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgdHlwZWRPcHRpb25zLmhvb2tzLmFmdGVyUmVzcG9uc2UgPSB0eXBlZE9wdGlvbnMuaG9va3MuYWZ0ZXJSZXNwb25zZS5zbGljZSgwLCBpbmRleCk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgZm9yIChjb25zdCBob29rIG9mIHR5cGVkT3B0aW9ucy5ob29rcy5iZWZvcmVSZXRyeSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgbm8tYXdhaXQtaW4tbG9vcFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBhd2FpdCBob29rKHR5cGVkT3B0aW9ucyk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNvbnN0IHByb21pc2UgPSBhc1Byb21pc2UodHlwZWRPcHRpb25zKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBvbkNhbmNlbCgoKSA9PiB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHByb21pc2UuY2F0Y2goKCkgPT4geyB9KTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgcHJvbWlzZS5jYW5jZWwoKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gcHJvbWlzZTtcbiAgICAgICAgICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGNhdGNoIChlcnJvcikge1xuICAgICAgICAgICAgICAgICAgICByZXF1ZXN0Ll9iZWZvcmVFcnJvcihuZXcgdHlwZXNfMS5SZXF1ZXN0RXJyb3IoZXJyb3IubWVzc2FnZSwgZXJyb3IsIHJlcXVlc3QpKTtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBnbG9iYWxSZXNwb25zZSA9IHJlc3BvbnNlO1xuICAgICAgICAgICAgICAgIGlmICghaXNfcmVzcG9uc2Vfb2tfMS5pc1Jlc3BvbnNlT2socmVzcG9uc2UpKSB7XG4gICAgICAgICAgICAgICAgICAgIHJlcXVlc3QuX2JlZm9yZUVycm9yKG5ldyB0eXBlc18xLkhUVFBFcnJvcihyZXNwb25zZSkpO1xuICAgICAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIHJlcXVlc3QuZGVzdHJveSgpO1xuICAgICAgICAgICAgICAgIHJlc29sdmUocmVxdWVzdC5vcHRpb25zLnJlc29sdmVCb2R5T25seSA/IHJlc3BvbnNlLmJvZHkgOiByZXNwb25zZSk7XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIGNvbnN0IG9uRXJyb3IgPSAoZXJyb3IpID0+IHtcbiAgICAgICAgICAgICAgICBpZiAocHJvbWlzZS5pc0NhbmNlbGVkKSB7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgY29uc3QgeyBvcHRpb25zIH0gPSByZXF1ZXN0O1xuICAgICAgICAgICAgICAgIGlmIChlcnJvciBpbnN0YW5jZW9mIHR5cGVzXzEuSFRUUEVycm9yICYmICFvcHRpb25zLnRocm93SHR0cEVycm9ycykge1xuICAgICAgICAgICAgICAgICAgICBjb25zdCB7IHJlc3BvbnNlIH0gPSBlcnJvcjtcbiAgICAgICAgICAgICAgICAgICAgcmVzb2x2ZShyZXF1ZXN0Lm9wdGlvbnMucmVzb2x2ZUJvZHlPbmx5ID8gcmVzcG9uc2UuYm9keSA6IHJlc3BvbnNlKTtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICByZWplY3QoZXJyb3IpO1xuICAgICAgICAgICAgfTtcbiAgICAgICAgICAgIHJlcXVlc3Qub25jZSgnZXJyb3InLCBvbkVycm9yKTtcbiAgICAgICAgICAgIGNvbnN0IHByZXZpb3VzQm9keSA9IHJlcXVlc3Qub3B0aW9ucy5ib2R5O1xuICAgICAgICAgICAgcmVxdWVzdC5vbmNlKCdyZXRyeScsIChuZXdSZXRyeUNvdW50LCBlcnJvcikgPT4ge1xuICAgICAgICAgICAgICAgIHZhciBfYSwgX2I7XG4gICAgICAgICAgICAgICAgaWYgKHByZXZpb3VzQm9keSA9PT0gKChfYSA9IGVycm9yLnJlcXVlc3QpID09PSBudWxsIHx8IF9hID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfYS5vcHRpb25zLmJvZHkpICYmIGlzXzEuZGVmYXVsdC5ub2RlU3RyZWFtKChfYiA9IGVycm9yLnJlcXVlc3QpID09PSBudWxsIHx8IF9iID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfYi5vcHRpb25zLmJvZHkpKSB7XG4gICAgICAgICAgICAgICAgICAgIG9uRXJyb3IoZXJyb3IpO1xuICAgICAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIG1ha2VSZXF1ZXN0KG5ld1JldHJ5Q291bnQpO1xuICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICBwcm94eV9ldmVudHNfMS5kZWZhdWx0KHJlcXVlc3QsIGVtaXR0ZXIsIHByb3hpZWRSZXF1ZXN0RXZlbnRzKTtcbiAgICAgICAgfTtcbiAgICAgICAgbWFrZVJlcXVlc3QoMCk7XG4gICAgfSk7XG4gICAgcHJvbWlzZS5vbiA9IChldmVudCwgZm4pID0+IHtcbiAgICAgICAgZW1pdHRlci5vbihldmVudCwgZm4pO1xuICAgICAgICByZXR1cm4gcHJvbWlzZTtcbiAgICB9O1xuICAgIGNvbnN0IHNob3J0Y3V0ID0gKHJlc3BvbnNlVHlwZSkgPT4ge1xuICAgICAgICBjb25zdCBuZXdQcm9taXNlID0gKGFzeW5jICgpID0+IHtcbiAgICAgICAgICAgIC8vIFdhaXQgdW50aWwgZG93bmxvYWRpbmcgaGFzIGVuZGVkXG4gICAgICAgICAgICBhd2FpdCBwcm9taXNlO1xuICAgICAgICAgICAgY29uc3QgeyBvcHRpb25zIH0gPSBnbG9iYWxSZXNwb25zZS5yZXF1ZXN0O1xuICAgICAgICAgICAgcmV0dXJuIHBhcnNlX2JvZHlfMS5kZWZhdWx0KGdsb2JhbFJlc3BvbnNlLCByZXNwb25zZVR5cGUsIG9wdGlvbnMucGFyc2VKc29uLCBvcHRpb25zLmVuY29kaW5nKTtcbiAgICAgICAgfSkoKTtcbiAgICAgICAgT2JqZWN0LmRlZmluZVByb3BlcnRpZXMobmV3UHJvbWlzZSwgT2JqZWN0LmdldE93blByb3BlcnR5RGVzY3JpcHRvcnMocHJvbWlzZSkpO1xuICAgICAgICByZXR1cm4gbmV3UHJvbWlzZTtcbiAgICB9O1xuICAgIHByb21pc2UuanNvbiA9ICgpID0+IHtcbiAgICAgICAgY29uc3QgeyBoZWFkZXJzIH0gPSBnbG9iYWxSZXF1ZXN0Lm9wdGlvbnM7XG4gICAgICAgIGlmICghZ2xvYmFsUmVxdWVzdC53cml0YWJsZUZpbmlzaGVkICYmIGhlYWRlcnMuYWNjZXB0ID09PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgIGhlYWRlcnMuYWNjZXB0ID0gJ2FwcGxpY2F0aW9uL2pzb24nO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBzaG9ydGN1dCgnanNvbicpO1xuICAgIH07XG4gICAgcHJvbWlzZS5idWZmZXIgPSAoKSA9PiBzaG9ydGN1dCgnYnVmZmVyJyk7XG4gICAgcHJvbWlzZS50ZXh0ID0gKCkgPT4gc2hvcnRjdXQoJ3RleHQnKTtcbiAgICByZXR1cm4gcHJvbWlzZTtcbn1cbmV4cG9ydHMuZGVmYXVsdCA9IGFzUHJvbWlzZTtcbl9fZXhwb3J0U3RhcihyZXF1aXJlKFwiLi90eXBlc1wiKSwgZXhwb3J0cyk7XG4iXSwibmFtZXMiOltdLCJpZ25vcmVMaXN0IjpbMF0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/swarm-js/node_modules/got/dist/source/as-promise/index.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/swarm-js/node_modules/got/dist/source/as-promise/normalize-arguments.js":
/*!**********************************************************************************************!*\
  !*** ./node_modules/swarm-js/node_modules/got/dist/source/as-promise/normalize-arguments.js ***!
  \**********************************************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";
eval("\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nconst is_1 = __webpack_require__(/*! @sindresorhus/is */ \"(ssr)/./node_modules/@sindresorhus/is/dist/index.js\");\nconst normalizeArguments = (options, defaults) => {\n    if (is_1.default.null_(options.encoding)) {\n        throw new TypeError('To get a Buffer, set `options.responseType` to `buffer` instead');\n    }\n    is_1.assert.any([is_1.default.string, is_1.default.undefined], options.encoding);\n    is_1.assert.any([is_1.default.boolean, is_1.default.undefined], options.resolveBodyOnly);\n    is_1.assert.any([is_1.default.boolean, is_1.default.undefined], options.methodRewriting);\n    is_1.assert.any([is_1.default.boolean, is_1.default.undefined], options.isStream);\n    is_1.assert.any([is_1.default.string, is_1.default.undefined], options.responseType);\n    // `options.responseType`\n    if (options.responseType === undefined) {\n        options.responseType = 'text';\n    }\n    // `options.retry`\n    const { retry } = options;\n    if (defaults) {\n        options.retry = { ...defaults.retry };\n    }\n    else {\n        options.retry = {\n            calculateDelay: retryObject => retryObject.computedValue,\n            limit: 0,\n            methods: [],\n            statusCodes: [],\n            errorCodes: [],\n            maxRetryAfter: undefined\n        };\n    }\n    if (is_1.default.object(retry)) {\n        options.retry = {\n            ...options.retry,\n            ...retry\n        };\n        options.retry.methods = [...new Set(options.retry.methods.map(method => method.toUpperCase()))];\n        options.retry.statusCodes = [...new Set(options.retry.statusCodes)];\n        options.retry.errorCodes = [...new Set(options.retry.errorCodes)];\n    }\n    else if (is_1.default.number(retry)) {\n        options.retry.limit = retry;\n    }\n    if (is_1.default.undefined(options.retry.maxRetryAfter)) {\n        options.retry.maxRetryAfter = Math.min(\n        // TypeScript is not smart enough to handle `.filter(x => is.number(x))`.\n        // eslint-disable-next-line unicorn/no-fn-reference-in-iterator\n        ...[options.timeout.request, options.timeout.connect].filter(is_1.default.number));\n    }\n    // `options.pagination`\n    if (is_1.default.object(options.pagination)) {\n        if (defaults) {\n            options.pagination = {\n                ...defaults.pagination,\n                ...options.pagination\n            };\n        }\n        const { pagination } = options;\n        if (!is_1.default.function_(pagination.transform)) {\n            throw new Error('`options.pagination.transform` must be implemented');\n        }\n        if (!is_1.default.function_(pagination.shouldContinue)) {\n            throw new Error('`options.pagination.shouldContinue` must be implemented');\n        }\n        if (!is_1.default.function_(pagination.filter)) {\n            throw new TypeError('`options.pagination.filter` must be implemented');\n        }\n        if (!is_1.default.function_(pagination.paginate)) {\n            throw new Error('`options.pagination.paginate` must be implemented');\n        }\n    }\n    // JSON mode\n    if (options.responseType === 'json' && options.headers.accept === undefined) {\n        options.headers.accept = 'application/json';\n    }\n    return options;\n};\nexports[\"default\"] = normalizeArguments;\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvc3dhcm0tanMvbm9kZV9tb2R1bGVzL2dvdC9kaXN0L3NvdXJjZS9hcy1wcm9taXNlL25vcm1hbGl6ZS1hcmd1bWVudHMuanMiLCJtYXBwaW5ncyI6IkFBQWE7QUFDYiw4Q0FBNkMsRUFBRSxhQUFhLEVBQUM7QUFDN0QsYUFBYSxtQkFBTyxDQUFDLDZFQUFrQjtBQUN2QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsWUFBWSxRQUFRO0FBQ3BCO0FBQ0EsMEJBQTBCO0FBQzFCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZ0JBQWdCLGFBQWE7QUFDN0I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxrQkFBZSIsInNvdXJjZXMiOlsiL1VzZXJzL3BhbnphL0RvY3VtZW50cy9QZXJzb25hbFByb2plY3RzL3ByZWRpay9ub2RlX21vZHVsZXMvc3dhcm0tanMvbm9kZV9tb2R1bGVzL2dvdC9kaXN0L3NvdXJjZS9hcy1wcm9taXNlL25vcm1hbGl6ZS1hcmd1bWVudHMuanMiXSwic291cmNlc0NvbnRlbnQiOlsiXCJ1c2Ugc3RyaWN0XCI7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XG5jb25zdCBpc18xID0gcmVxdWlyZShcIkBzaW5kcmVzb3JodXMvaXNcIik7XG5jb25zdCBub3JtYWxpemVBcmd1bWVudHMgPSAob3B0aW9ucywgZGVmYXVsdHMpID0+IHtcbiAgICBpZiAoaXNfMS5kZWZhdWx0Lm51bGxfKG9wdGlvbnMuZW5jb2RpbmcpKSB7XG4gICAgICAgIHRocm93IG5ldyBUeXBlRXJyb3IoJ1RvIGdldCBhIEJ1ZmZlciwgc2V0IGBvcHRpb25zLnJlc3BvbnNlVHlwZWAgdG8gYGJ1ZmZlcmAgaW5zdGVhZCcpO1xuICAgIH1cbiAgICBpc18xLmFzc2VydC5hbnkoW2lzXzEuZGVmYXVsdC5zdHJpbmcsIGlzXzEuZGVmYXVsdC51bmRlZmluZWRdLCBvcHRpb25zLmVuY29kaW5nKTtcbiAgICBpc18xLmFzc2VydC5hbnkoW2lzXzEuZGVmYXVsdC5ib29sZWFuLCBpc18xLmRlZmF1bHQudW5kZWZpbmVkXSwgb3B0aW9ucy5yZXNvbHZlQm9keU9ubHkpO1xuICAgIGlzXzEuYXNzZXJ0LmFueShbaXNfMS5kZWZhdWx0LmJvb2xlYW4sIGlzXzEuZGVmYXVsdC51bmRlZmluZWRdLCBvcHRpb25zLm1ldGhvZFJld3JpdGluZyk7XG4gICAgaXNfMS5hc3NlcnQuYW55KFtpc18xLmRlZmF1bHQuYm9vbGVhbiwgaXNfMS5kZWZhdWx0LnVuZGVmaW5lZF0sIG9wdGlvbnMuaXNTdHJlYW0pO1xuICAgIGlzXzEuYXNzZXJ0LmFueShbaXNfMS5kZWZhdWx0LnN0cmluZywgaXNfMS5kZWZhdWx0LnVuZGVmaW5lZF0sIG9wdGlvbnMucmVzcG9uc2VUeXBlKTtcbiAgICAvLyBgb3B0aW9ucy5yZXNwb25zZVR5cGVgXG4gICAgaWYgKG9wdGlvbnMucmVzcG9uc2VUeXBlID09PSB1bmRlZmluZWQpIHtcbiAgICAgICAgb3B0aW9ucy5yZXNwb25zZVR5cGUgPSAndGV4dCc7XG4gICAgfVxuICAgIC8vIGBvcHRpb25zLnJldHJ5YFxuICAgIGNvbnN0IHsgcmV0cnkgfSA9IG9wdGlvbnM7XG4gICAgaWYgKGRlZmF1bHRzKSB7XG4gICAgICAgIG9wdGlvbnMucmV0cnkgPSB7IC4uLmRlZmF1bHRzLnJldHJ5IH07XG4gICAgfVxuICAgIGVsc2Uge1xuICAgICAgICBvcHRpb25zLnJldHJ5ID0ge1xuICAgICAgICAgICAgY2FsY3VsYXRlRGVsYXk6IHJldHJ5T2JqZWN0ID0+IHJldHJ5T2JqZWN0LmNvbXB1dGVkVmFsdWUsXG4gICAgICAgICAgICBsaW1pdDogMCxcbiAgICAgICAgICAgIG1ldGhvZHM6IFtdLFxuICAgICAgICAgICAgc3RhdHVzQ29kZXM6IFtdLFxuICAgICAgICAgICAgZXJyb3JDb2RlczogW10sXG4gICAgICAgICAgICBtYXhSZXRyeUFmdGVyOiB1bmRlZmluZWRcbiAgICAgICAgfTtcbiAgICB9XG4gICAgaWYgKGlzXzEuZGVmYXVsdC5vYmplY3QocmV0cnkpKSB7XG4gICAgICAgIG9wdGlvbnMucmV0cnkgPSB7XG4gICAgICAgICAgICAuLi5vcHRpb25zLnJldHJ5LFxuICAgICAgICAgICAgLi4ucmV0cnlcbiAgICAgICAgfTtcbiAgICAgICAgb3B0aW9ucy5yZXRyeS5tZXRob2RzID0gWy4uLm5ldyBTZXQob3B0aW9ucy5yZXRyeS5tZXRob2RzLm1hcChtZXRob2QgPT4gbWV0aG9kLnRvVXBwZXJDYXNlKCkpKV07XG4gICAgICAgIG9wdGlvbnMucmV0cnkuc3RhdHVzQ29kZXMgPSBbLi4ubmV3IFNldChvcHRpb25zLnJldHJ5LnN0YXR1c0NvZGVzKV07XG4gICAgICAgIG9wdGlvbnMucmV0cnkuZXJyb3JDb2RlcyA9IFsuLi5uZXcgU2V0KG9wdGlvbnMucmV0cnkuZXJyb3JDb2RlcyldO1xuICAgIH1cbiAgICBlbHNlIGlmIChpc18xLmRlZmF1bHQubnVtYmVyKHJldHJ5KSkge1xuICAgICAgICBvcHRpb25zLnJldHJ5LmxpbWl0ID0gcmV0cnk7XG4gICAgfVxuICAgIGlmIChpc18xLmRlZmF1bHQudW5kZWZpbmVkKG9wdGlvbnMucmV0cnkubWF4UmV0cnlBZnRlcikpIHtcbiAgICAgICAgb3B0aW9ucy5yZXRyeS5tYXhSZXRyeUFmdGVyID0gTWF0aC5taW4oXG4gICAgICAgIC8vIFR5cGVTY3JpcHQgaXMgbm90IHNtYXJ0IGVub3VnaCB0byBoYW5kbGUgYC5maWx0ZXIoeCA9PiBpcy5udW1iZXIoeCkpYC5cbiAgICAgICAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIHVuaWNvcm4vbm8tZm4tcmVmZXJlbmNlLWluLWl0ZXJhdG9yXG4gICAgICAgIC4uLltvcHRpb25zLnRpbWVvdXQucmVxdWVzdCwgb3B0aW9ucy50aW1lb3V0LmNvbm5lY3RdLmZpbHRlcihpc18xLmRlZmF1bHQubnVtYmVyKSk7XG4gICAgfVxuICAgIC8vIGBvcHRpb25zLnBhZ2luYXRpb25gXG4gICAgaWYgKGlzXzEuZGVmYXVsdC5vYmplY3Qob3B0aW9ucy5wYWdpbmF0aW9uKSkge1xuICAgICAgICBpZiAoZGVmYXVsdHMpIHtcbiAgICAgICAgICAgIG9wdGlvbnMucGFnaW5hdGlvbiA9IHtcbiAgICAgICAgICAgICAgICAuLi5kZWZhdWx0cy5wYWdpbmF0aW9uLFxuICAgICAgICAgICAgICAgIC4uLm9wdGlvbnMucGFnaW5hdGlvblxuICAgICAgICAgICAgfTtcbiAgICAgICAgfVxuICAgICAgICBjb25zdCB7IHBhZ2luYXRpb24gfSA9IG9wdGlvbnM7XG4gICAgICAgIGlmICghaXNfMS5kZWZhdWx0LmZ1bmN0aW9uXyhwYWdpbmF0aW9uLnRyYW5zZm9ybSkpIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcignYG9wdGlvbnMucGFnaW5hdGlvbi50cmFuc2Zvcm1gIG11c3QgYmUgaW1wbGVtZW50ZWQnKTtcbiAgICAgICAgfVxuICAgICAgICBpZiAoIWlzXzEuZGVmYXVsdC5mdW5jdGlvbl8ocGFnaW5hdGlvbi5zaG91bGRDb250aW51ZSkpIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcignYG9wdGlvbnMucGFnaW5hdGlvbi5zaG91bGRDb250aW51ZWAgbXVzdCBiZSBpbXBsZW1lbnRlZCcpO1xuICAgICAgICB9XG4gICAgICAgIGlmICghaXNfMS5kZWZhdWx0LmZ1bmN0aW9uXyhwYWdpbmF0aW9uLmZpbHRlcikpIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBUeXBlRXJyb3IoJ2BvcHRpb25zLnBhZ2luYXRpb24uZmlsdGVyYCBtdXN0IGJlIGltcGxlbWVudGVkJyk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKCFpc18xLmRlZmF1bHQuZnVuY3Rpb25fKHBhZ2luYXRpb24ucGFnaW5hdGUpKSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ2BvcHRpb25zLnBhZ2luYXRpb24ucGFnaW5hdGVgIG11c3QgYmUgaW1wbGVtZW50ZWQnKTtcbiAgICAgICAgfVxuICAgIH1cbiAgICAvLyBKU09OIG1vZGVcbiAgICBpZiAob3B0aW9ucy5yZXNwb25zZVR5cGUgPT09ICdqc29uJyAmJiBvcHRpb25zLmhlYWRlcnMuYWNjZXB0ID09PSB1bmRlZmluZWQpIHtcbiAgICAgICAgb3B0aW9ucy5oZWFkZXJzLmFjY2VwdCA9ICdhcHBsaWNhdGlvbi9qc29uJztcbiAgICB9XG4gICAgcmV0dXJuIG9wdGlvbnM7XG59O1xuZXhwb3J0cy5kZWZhdWx0ID0gbm9ybWFsaXplQXJndW1lbnRzO1xuIl0sIm5hbWVzIjpbXSwiaWdub3JlTGlzdCI6WzBdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/swarm-js/node_modules/got/dist/source/as-promise/normalize-arguments.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/swarm-js/node_modules/got/dist/source/as-promise/parse-body.js":
/*!*************************************************************************************!*\
  !*** ./node_modules/swarm-js/node_modules/got/dist/source/as-promise/parse-body.js ***!
  \*************************************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";
eval("\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nconst types_1 = __webpack_require__(/*! ./types */ \"(ssr)/./node_modules/swarm-js/node_modules/got/dist/source/as-promise/types.js\");\nconst parseBody = (response, responseType, parseJson, encoding) => {\n    const { rawBody } = response;\n    try {\n        if (responseType === 'text') {\n            return rawBody.toString(encoding);\n        }\n        if (responseType === 'json') {\n            return rawBody.length === 0 ? '' : parseJson(rawBody.toString());\n        }\n        if (responseType === 'buffer') {\n            return rawBody;\n        }\n        throw new types_1.ParseError({\n            message: `Unknown body type '${responseType}'`,\n            name: 'Error'\n        }, response);\n    }\n    catch (error) {\n        throw new types_1.ParseError(error, response);\n    }\n};\nexports[\"default\"] = parseBody;\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvc3dhcm0tanMvbm9kZV9tb2R1bGVzL2dvdC9kaXN0L3NvdXJjZS9hcy1wcm9taXNlL3BhcnNlLWJvZHkuanMiLCJtYXBwaW5ncyI6IkFBQWE7QUFDYiw4Q0FBNkMsRUFBRSxhQUFhLEVBQUM7QUFDN0QsZ0JBQWdCLG1CQUFPLENBQUMsK0ZBQVM7QUFDakM7QUFDQSxZQUFZLFVBQVU7QUFDdEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDJDQUEyQyxhQUFhO0FBQ3hEO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxrQkFBZSIsInNvdXJjZXMiOlsiL1VzZXJzL3BhbnphL0RvY3VtZW50cy9QZXJzb25hbFByb2plY3RzL3ByZWRpay9ub2RlX21vZHVsZXMvc3dhcm0tanMvbm9kZV9tb2R1bGVzL2dvdC9kaXN0L3NvdXJjZS9hcy1wcm9taXNlL3BhcnNlLWJvZHkuanMiXSwic291cmNlc0NvbnRlbnQiOlsiXCJ1c2Ugc3RyaWN0XCI7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XG5jb25zdCB0eXBlc18xID0gcmVxdWlyZShcIi4vdHlwZXNcIik7XG5jb25zdCBwYXJzZUJvZHkgPSAocmVzcG9uc2UsIHJlc3BvbnNlVHlwZSwgcGFyc2VKc29uLCBlbmNvZGluZykgPT4ge1xuICAgIGNvbnN0IHsgcmF3Qm9keSB9ID0gcmVzcG9uc2U7XG4gICAgdHJ5IHtcbiAgICAgICAgaWYgKHJlc3BvbnNlVHlwZSA9PT0gJ3RleHQnKSB7XG4gICAgICAgICAgICByZXR1cm4gcmF3Qm9keS50b1N0cmluZyhlbmNvZGluZyk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHJlc3BvbnNlVHlwZSA9PT0gJ2pzb24nKSB7XG4gICAgICAgICAgICByZXR1cm4gcmF3Qm9keS5sZW5ndGggPT09IDAgPyAnJyA6IHBhcnNlSnNvbihyYXdCb2R5LnRvU3RyaW5nKCkpO1xuICAgICAgICB9XG4gICAgICAgIGlmIChyZXNwb25zZVR5cGUgPT09ICdidWZmZXInKSB7XG4gICAgICAgICAgICByZXR1cm4gcmF3Qm9keTtcbiAgICAgICAgfVxuICAgICAgICB0aHJvdyBuZXcgdHlwZXNfMS5QYXJzZUVycm9yKHtcbiAgICAgICAgICAgIG1lc3NhZ2U6IGBVbmtub3duIGJvZHkgdHlwZSAnJHtyZXNwb25zZVR5cGV9J2AsXG4gICAgICAgICAgICBuYW1lOiAnRXJyb3InXG4gICAgICAgIH0sIHJlc3BvbnNlKTtcbiAgICB9XG4gICAgY2F0Y2ggKGVycm9yKSB7XG4gICAgICAgIHRocm93IG5ldyB0eXBlc18xLlBhcnNlRXJyb3IoZXJyb3IsIHJlc3BvbnNlKTtcbiAgICB9XG59O1xuZXhwb3J0cy5kZWZhdWx0ID0gcGFyc2VCb2R5O1xuIl0sIm5hbWVzIjpbXSwiaWdub3JlTGlzdCI6WzBdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/swarm-js/node_modules/got/dist/source/as-promise/parse-body.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/swarm-js/node_modules/got/dist/source/as-promise/types.js":
/*!********************************************************************************!*\
  !*** ./node_modules/swarm-js/node_modules/got/dist/source/as-promise/types.js ***!
  \********************************************************************************/
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

"use strict";
eval("\nvar __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {\n    if (k2 === undefined) k2 = k;\n    Object.defineProperty(o, k2, { enumerable: true, get: function() { return m[k]; } });\n}) : (function(o, m, k, k2) {\n    if (k2 === undefined) k2 = k;\n    o[k2] = m[k];\n}));\nvar __exportStar = (this && this.__exportStar) || function(m, exports) {\n    for (var p in m) if (p !== \"default\" && !Object.prototype.hasOwnProperty.call(exports, p)) __createBinding(exports, m, p);\n};\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nexports.CancelError = exports.ParseError = void 0;\nconst core_1 = __webpack_require__(/*! ../core */ \"(ssr)/./node_modules/swarm-js/node_modules/got/dist/source/core/index.js\");\n/**\nAn error to be thrown when server response code is 2xx, and parsing body fails.\nIncludes a `response` property.\n*/\nclass ParseError extends core_1.RequestError {\n    constructor(error, response) {\n        const { options } = response.request;\n        super(`${error.message} in \"${options.url.toString()}\"`, error, response.request);\n        this.name = 'ParseError';\n        this.code = this.code === 'ERR_GOT_REQUEST_ERROR' ? 'ERR_BODY_PARSE_FAILURE' : this.code;\n    }\n}\nexports.ParseError = ParseError;\n/**\nAn error to be thrown when the request is aborted with `.cancel()`.\n*/\nclass CancelError extends core_1.RequestError {\n    constructor(request) {\n        super('Promise was canceled', {}, request);\n        this.name = 'CancelError';\n        this.code = 'ERR_CANCELED';\n    }\n    get isCanceled() {\n        return true;\n    }\n}\nexports.CancelError = CancelError;\n__exportStar(__webpack_require__(/*! ../core */ \"(ssr)/./node_modules/swarm-js/node_modules/got/dist/source/core/index.js\"), exports);\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvc3dhcm0tanMvbm9kZV9tb2R1bGVzL2dvdC9kaXN0L3NvdXJjZS9hcy1wcm9taXNlL3R5cGVzLmpzIiwibWFwcGluZ3MiOiJBQUFhO0FBQ2I7QUFDQTtBQUNBLG1DQUFtQyxvQ0FBb0MsZ0JBQWdCO0FBQ3ZGLENBQUM7QUFDRDtBQUNBO0FBQ0EsQ0FBQztBQUNEO0FBQ0E7QUFDQTtBQUNBLDhDQUE2QyxFQUFFLGFBQWEsRUFBQztBQUM3RCxtQkFBbUIsR0FBRyxrQkFBa0I7QUFDeEMsZUFBZSxtQkFBTyxDQUFDLHlGQUFTO0FBQ2hDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGdCQUFnQixVQUFVO0FBQzFCLGlCQUFpQixlQUFlLE1BQU0sdUJBQXVCO0FBQzdEO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esa0JBQWtCO0FBQ2xCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx3Q0FBd0M7QUFDeEM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxtQkFBbUI7QUFDbkIsYUFBYSxtQkFBTyxDQUFDLHlGQUFTIiwic291cmNlcyI6WyIvVXNlcnMvcGFuemEvRG9jdW1lbnRzL1BlcnNvbmFsUHJvamVjdHMvcHJlZGlrL25vZGVfbW9kdWxlcy9zd2FybS1qcy9ub2RlX21vZHVsZXMvZ290L2Rpc3Qvc291cmNlL2FzLXByb21pc2UvdHlwZXMuanMiXSwic291cmNlc0NvbnRlbnQiOlsiXCJ1c2Ugc3RyaWN0XCI7XG52YXIgX19jcmVhdGVCaW5kaW5nID0gKHRoaXMgJiYgdGhpcy5fX2NyZWF0ZUJpbmRpbmcpIHx8IChPYmplY3QuY3JlYXRlID8gKGZ1bmN0aW9uKG8sIG0sIGssIGsyKSB7XG4gICAgaWYgKGsyID09PSB1bmRlZmluZWQpIGsyID0gaztcbiAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkobywgazIsIHsgZW51bWVyYWJsZTogdHJ1ZSwgZ2V0OiBmdW5jdGlvbigpIHsgcmV0dXJuIG1ba107IH0gfSk7XG59KSA6IChmdW5jdGlvbihvLCBtLCBrLCBrMikge1xuICAgIGlmIChrMiA9PT0gdW5kZWZpbmVkKSBrMiA9IGs7XG4gICAgb1trMl0gPSBtW2tdO1xufSkpO1xudmFyIF9fZXhwb3J0U3RhciA9ICh0aGlzICYmIHRoaXMuX19leHBvcnRTdGFyKSB8fCBmdW5jdGlvbihtLCBleHBvcnRzKSB7XG4gICAgZm9yICh2YXIgcCBpbiBtKSBpZiAocCAhPT0gXCJkZWZhdWx0XCIgJiYgIU9iamVjdC5wcm90b3R5cGUuaGFzT3duUHJvcGVydHkuY2FsbChleHBvcnRzLCBwKSkgX19jcmVhdGVCaW5kaW5nKGV4cG9ydHMsIG0sIHApO1xufTtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcbmV4cG9ydHMuQ2FuY2VsRXJyb3IgPSBleHBvcnRzLlBhcnNlRXJyb3IgPSB2b2lkIDA7XG5jb25zdCBjb3JlXzEgPSByZXF1aXJlKFwiLi4vY29yZVwiKTtcbi8qKlxuQW4gZXJyb3IgdG8gYmUgdGhyb3duIHdoZW4gc2VydmVyIHJlc3BvbnNlIGNvZGUgaXMgMnh4LCBhbmQgcGFyc2luZyBib2R5IGZhaWxzLlxuSW5jbHVkZXMgYSBgcmVzcG9uc2VgIHByb3BlcnR5LlxuKi9cbmNsYXNzIFBhcnNlRXJyb3IgZXh0ZW5kcyBjb3JlXzEuUmVxdWVzdEVycm9yIHtcbiAgICBjb25zdHJ1Y3RvcihlcnJvciwgcmVzcG9uc2UpIHtcbiAgICAgICAgY29uc3QgeyBvcHRpb25zIH0gPSByZXNwb25zZS5yZXF1ZXN0O1xuICAgICAgICBzdXBlcihgJHtlcnJvci5tZXNzYWdlfSBpbiBcIiR7b3B0aW9ucy51cmwudG9TdHJpbmcoKX1cImAsIGVycm9yLCByZXNwb25zZS5yZXF1ZXN0KTtcbiAgICAgICAgdGhpcy5uYW1lID0gJ1BhcnNlRXJyb3InO1xuICAgICAgICB0aGlzLmNvZGUgPSB0aGlzLmNvZGUgPT09ICdFUlJfR09UX1JFUVVFU1RfRVJST1InID8gJ0VSUl9CT0RZX1BBUlNFX0ZBSUxVUkUnIDogdGhpcy5jb2RlO1xuICAgIH1cbn1cbmV4cG9ydHMuUGFyc2VFcnJvciA9IFBhcnNlRXJyb3I7XG4vKipcbkFuIGVycm9yIHRvIGJlIHRocm93biB3aGVuIHRoZSByZXF1ZXN0IGlzIGFib3J0ZWQgd2l0aCBgLmNhbmNlbCgpYC5cbiovXG5jbGFzcyBDYW5jZWxFcnJvciBleHRlbmRzIGNvcmVfMS5SZXF1ZXN0RXJyb3Ige1xuICAgIGNvbnN0cnVjdG9yKHJlcXVlc3QpIHtcbiAgICAgICAgc3VwZXIoJ1Byb21pc2Ugd2FzIGNhbmNlbGVkJywge30sIHJlcXVlc3QpO1xuICAgICAgICB0aGlzLm5hbWUgPSAnQ2FuY2VsRXJyb3InO1xuICAgICAgICB0aGlzLmNvZGUgPSAnRVJSX0NBTkNFTEVEJztcbiAgICB9XG4gICAgZ2V0IGlzQ2FuY2VsZWQoKSB7XG4gICAgICAgIHJldHVybiB0cnVlO1xuICAgIH1cbn1cbmV4cG9ydHMuQ2FuY2VsRXJyb3IgPSBDYW5jZWxFcnJvcjtcbl9fZXhwb3J0U3RhcihyZXF1aXJlKFwiLi4vY29yZVwiKSwgZXhwb3J0cyk7XG4iXSwibmFtZXMiOltdLCJpZ25vcmVMaXN0IjpbMF0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/swarm-js/node_modules/got/dist/source/as-promise/types.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/swarm-js/node_modules/got/dist/source/core/calculate-retry-delay.js":
/*!******************************************************************************************!*\
  !*** ./node_modules/swarm-js/node_modules/got/dist/source/core/calculate-retry-delay.js ***!
  \******************************************************************************************/
/***/ ((__unused_webpack_module, exports) => {

"use strict";
eval("\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nexports.retryAfterStatusCodes = void 0;\nexports.retryAfterStatusCodes = new Set([413, 429, 503]);\nconst calculateRetryDelay = ({ attemptCount, retryOptions, error, retryAfter }) => {\n    if (attemptCount > retryOptions.limit) {\n        return 0;\n    }\n    const hasMethod = retryOptions.methods.includes(error.options.method);\n    const hasErrorCode = retryOptions.errorCodes.includes(error.code);\n    const hasStatusCode = error.response && retryOptions.statusCodes.includes(error.response.statusCode);\n    if (!hasMethod || (!hasErrorCode && !hasStatusCode)) {\n        return 0;\n    }\n    if (error.response) {\n        if (retryAfter) {\n            if (retryOptions.maxRetryAfter === undefined || retryAfter > retryOptions.maxRetryAfter) {\n                return 0;\n            }\n            return retryAfter;\n        }\n        if (error.response.statusCode === 413) {\n            return 0;\n        }\n    }\n    const noise = Math.random() * 100;\n    return ((2 ** (attemptCount - 1)) * 1000) + noise;\n};\nexports[\"default\"] = calculateRetryDelay;\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvc3dhcm0tanMvbm9kZV9tb2R1bGVzL2dvdC9kaXN0L3NvdXJjZS9jb3JlL2NhbGN1bGF0ZS1yZXRyeS1kZWxheS5qcyIsIm1hcHBpbmdzIjoiQUFBYTtBQUNiLDhDQUE2QyxFQUFFLGFBQWEsRUFBQztBQUM3RCw2QkFBNkI7QUFDN0IsNkJBQTZCO0FBQzdCLCtCQUErQiwrQ0FBK0M7QUFDOUU7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGtCQUFlIiwic291cmNlcyI6WyIvVXNlcnMvcGFuemEvRG9jdW1lbnRzL1BlcnNvbmFsUHJvamVjdHMvcHJlZGlrL25vZGVfbW9kdWxlcy9zd2FybS1qcy9ub2RlX21vZHVsZXMvZ290L2Rpc3Qvc291cmNlL2NvcmUvY2FsY3VsYXRlLXJldHJ5LWRlbGF5LmpzIl0sInNvdXJjZXNDb250ZW50IjpbIlwidXNlIHN0cmljdFwiO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xuZXhwb3J0cy5yZXRyeUFmdGVyU3RhdHVzQ29kZXMgPSB2b2lkIDA7XG5leHBvcnRzLnJldHJ5QWZ0ZXJTdGF0dXNDb2RlcyA9IG5ldyBTZXQoWzQxMywgNDI5LCA1MDNdKTtcbmNvbnN0IGNhbGN1bGF0ZVJldHJ5RGVsYXkgPSAoeyBhdHRlbXB0Q291bnQsIHJldHJ5T3B0aW9ucywgZXJyb3IsIHJldHJ5QWZ0ZXIgfSkgPT4ge1xuICAgIGlmIChhdHRlbXB0Q291bnQgPiByZXRyeU9wdGlvbnMubGltaXQpIHtcbiAgICAgICAgcmV0dXJuIDA7XG4gICAgfVxuICAgIGNvbnN0IGhhc01ldGhvZCA9IHJldHJ5T3B0aW9ucy5tZXRob2RzLmluY2x1ZGVzKGVycm9yLm9wdGlvbnMubWV0aG9kKTtcbiAgICBjb25zdCBoYXNFcnJvckNvZGUgPSByZXRyeU9wdGlvbnMuZXJyb3JDb2Rlcy5pbmNsdWRlcyhlcnJvci5jb2RlKTtcbiAgICBjb25zdCBoYXNTdGF0dXNDb2RlID0gZXJyb3IucmVzcG9uc2UgJiYgcmV0cnlPcHRpb25zLnN0YXR1c0NvZGVzLmluY2x1ZGVzKGVycm9yLnJlc3BvbnNlLnN0YXR1c0NvZGUpO1xuICAgIGlmICghaGFzTWV0aG9kIHx8ICghaGFzRXJyb3JDb2RlICYmICFoYXNTdGF0dXNDb2RlKSkge1xuICAgICAgICByZXR1cm4gMDtcbiAgICB9XG4gICAgaWYgKGVycm9yLnJlc3BvbnNlKSB7XG4gICAgICAgIGlmIChyZXRyeUFmdGVyKSB7XG4gICAgICAgICAgICBpZiAocmV0cnlPcHRpb25zLm1heFJldHJ5QWZ0ZXIgPT09IHVuZGVmaW5lZCB8fCByZXRyeUFmdGVyID4gcmV0cnlPcHRpb25zLm1heFJldHJ5QWZ0ZXIpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gMDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiByZXRyeUFmdGVyO1xuICAgICAgICB9XG4gICAgICAgIGlmIChlcnJvci5yZXNwb25zZS5zdGF0dXNDb2RlID09PSA0MTMpIHtcbiAgICAgICAgICAgIHJldHVybiAwO1xuICAgICAgICB9XG4gICAgfVxuICAgIGNvbnN0IG5vaXNlID0gTWF0aC5yYW5kb20oKSAqIDEwMDtcbiAgICByZXR1cm4gKCgyICoqIChhdHRlbXB0Q291bnQgLSAxKSkgKiAxMDAwKSArIG5vaXNlO1xufTtcbmV4cG9ydHMuZGVmYXVsdCA9IGNhbGN1bGF0ZVJldHJ5RGVsYXk7XG4iXSwibmFtZXMiOltdLCJpZ25vcmVMaXN0IjpbMF0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/swarm-js/node_modules/got/dist/source/core/calculate-retry-delay.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/swarm-js/node_modules/got/dist/source/core/index.js":
/*!**************************************************************************!*\
  !*** ./node_modules/swarm-js/node_modules/got/dist/source/core/index.js ***!
  \**************************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";
eval("\nObject.defineProperty(exports, \"__esModule\", ({\n    value: true\n}));\nexports.UnsupportedProtocolError = exports.ReadError = exports.TimeoutError = exports.UploadError = exports.CacheError = exports.HTTPError = exports.MaxRedirectsError = exports.RequestError = exports.setNonEnumerableProperties = exports.knownHookEvents = exports.withoutBody = exports.kIsNormalizedAlready = void 0;\nconst util_1 = __webpack_require__(/*! util */ \"util\");\nconst stream_1 = __webpack_require__(/*! stream */ \"stream\");\nconst fs_1 = __webpack_require__(/*! fs */ \"fs\");\nconst url_1 = __webpack_require__(/*! url */ \"url\");\nconst http = __webpack_require__(/*! http */ \"http\");\nconst http_1 = __webpack_require__(/*! http */ \"http\");\nconst https = __webpack_require__(/*! https */ \"https\");\nconst http_timer_1 = __webpack_require__(/*! @szmarczak/http-timer */ \"(ssr)/./node_modules/swarm-js/node_modules/@szmarczak/http-timer/dist/source/index.js\");\nconst cacheable_lookup_1 = __webpack_require__(/*! cacheable-lookup */ \"(ssr)/./node_modules/swarm-js/node_modules/cacheable-lookup/source/index.js\");\nconst CacheableRequest = __webpack_require__(/*! cacheable-request */ \"(ssr)/./node_modules/cacheable-request/src/index.js\");\nconst decompressResponse = __webpack_require__(/*! decompress-response */ \"(ssr)/./node_modules/decompress-response/index.js\");\n// @ts-expect-error Missing types\nconst http2wrapper = __webpack_require__(/*! http2-wrapper */ \"(ssr)/./node_modules/swarm-js/node_modules/http2-wrapper/source/index.js\");\nconst lowercaseKeys = __webpack_require__(/*! lowercase-keys */ \"(ssr)/./node_modules/swarm-js/node_modules/lowercase-keys/index.js\");\nconst is_1 = __webpack_require__(/*! @sindresorhus/is */ \"(ssr)/./node_modules/@sindresorhus/is/dist/index.js\");\nconst get_body_size_1 = __webpack_require__(/*! ./utils/get-body-size */ \"(ssr)/./node_modules/swarm-js/node_modules/got/dist/source/core/utils/get-body-size.js\");\nconst is_form_data_1 = __webpack_require__(/*! ./utils/is-form-data */ \"(ssr)/./node_modules/swarm-js/node_modules/got/dist/source/core/utils/is-form-data.js\");\nconst proxy_events_1 = __webpack_require__(/*! ./utils/proxy-events */ \"(ssr)/./node_modules/swarm-js/node_modules/got/dist/source/core/utils/proxy-events.js\");\nconst timed_out_1 = __webpack_require__(/*! ./utils/timed-out */ \"(ssr)/./node_modules/swarm-js/node_modules/got/dist/source/core/utils/timed-out.js\");\nconst url_to_options_1 = __webpack_require__(/*! ./utils/url-to-options */ \"(ssr)/./node_modules/swarm-js/node_modules/got/dist/source/core/utils/url-to-options.js\");\nconst options_to_url_1 = __webpack_require__(/*! ./utils/options-to-url */ \"(ssr)/./node_modules/swarm-js/node_modules/got/dist/source/core/utils/options-to-url.js\");\nconst weakable_map_1 = __webpack_require__(/*! ./utils/weakable-map */ \"(ssr)/./node_modules/swarm-js/node_modules/got/dist/source/core/utils/weakable-map.js\");\nconst get_buffer_1 = __webpack_require__(/*! ./utils/get-buffer */ \"(ssr)/./node_modules/swarm-js/node_modules/got/dist/source/core/utils/get-buffer.js\");\nconst dns_ip_version_1 = __webpack_require__(/*! ./utils/dns-ip-version */ \"(ssr)/./node_modules/swarm-js/node_modules/got/dist/source/core/utils/dns-ip-version.js\");\nconst is_response_ok_1 = __webpack_require__(/*! ./utils/is-response-ok */ \"(ssr)/./node_modules/swarm-js/node_modules/got/dist/source/core/utils/is-response-ok.js\");\nconst deprecation_warning_1 = __webpack_require__(/*! ../utils/deprecation-warning */ \"(ssr)/./node_modules/swarm-js/node_modules/got/dist/source/utils/deprecation-warning.js\");\nconst normalize_arguments_1 = __webpack_require__(/*! ../as-promise/normalize-arguments */ \"(ssr)/./node_modules/swarm-js/node_modules/got/dist/source/as-promise/normalize-arguments.js\");\nconst calculate_retry_delay_1 = __webpack_require__(/*! ./calculate-retry-delay */ \"(ssr)/./node_modules/swarm-js/node_modules/got/dist/source/core/calculate-retry-delay.js\");\nlet globalDnsCache;\nconst kRequest = Symbol('request');\nconst kResponse = Symbol('response');\nconst kResponseSize = Symbol('responseSize');\nconst kDownloadedSize = Symbol('downloadedSize');\nconst kBodySize = Symbol('bodySize');\nconst kUploadedSize = Symbol('uploadedSize');\nconst kServerResponsesPiped = Symbol('serverResponsesPiped');\nconst kUnproxyEvents = Symbol('unproxyEvents');\nconst kIsFromCache = Symbol('isFromCache');\nconst kCancelTimeouts = Symbol('cancelTimeouts');\nconst kStartedReading = Symbol('startedReading');\nconst kStopReading = Symbol('stopReading');\nconst kTriggerRead = Symbol('triggerRead');\nconst kBody = Symbol('body');\nconst kJobs = Symbol('jobs');\nconst kOriginalResponse = Symbol('originalResponse');\nconst kRetryTimeout = Symbol('retryTimeout');\nexports.kIsNormalizedAlready = Symbol('isNormalizedAlready');\nconst supportsBrotli = is_1.default.string(process.versions.brotli);\nexports.withoutBody = new Set([\n    'GET',\n    'HEAD'\n]);\nexports.knownHookEvents = [\n    'init',\n    'beforeRequest',\n    'beforeRedirect',\n    'beforeError',\n    'beforeRetry',\n    // Promise-Only\n    'afterResponse'\n];\nfunction validateSearchParameters(searchParameters) {\n    // eslint-disable-next-line guard-for-in\n    for(const key in searchParameters){\n        const value = searchParameters[key];\n        if (!is_1.default.string(value) && !is_1.default.number(value) && !is_1.default.boolean(value) && !is_1.default.null_(value) && !is_1.default.undefined(value)) {\n            throw new TypeError(`The \\`searchParams\\` value '${String(value)}' must be a string, number, boolean or null`);\n        }\n    }\n}\nfunction isClientRequest(clientRequest) {\n    return is_1.default.object(clientRequest) && !('statusCode' in clientRequest);\n}\nconst cacheableStore = new weakable_map_1.default();\nconst waitForOpenFile = async (file)=>new Promise((resolve, reject)=>{\n        const onError = (error)=>{\n            reject(error);\n        };\n        // Node.js 12 has incomplete types\n        if (!file.pending) {\n            resolve();\n        }\n        file.once('error', onError);\n        file.once('ready', ()=>{\n            file.off('error', onError);\n            resolve();\n        });\n    });\nconst redirectCodes = new Set([\n    300,\n    301,\n    302,\n    303,\n    304,\n    307,\n    308\n]);\nconst nonEnumerableProperties = [\n    'context',\n    'body',\n    'json',\n    'form'\n];\nexports.setNonEnumerableProperties = (sources, to)=>{\n    // Non enumerable properties shall not be merged\n    const properties = {};\n    for (const source of sources){\n        if (!source) {\n            continue;\n        }\n        for (const name of nonEnumerableProperties){\n            if (!(name in source)) {\n                continue;\n            }\n            properties[name] = {\n                writable: true,\n                configurable: true,\n                enumerable: false,\n                // @ts-expect-error TS doesn't see the check above\n                value: source[name]\n            };\n        }\n    }\n    Object.defineProperties(to, properties);\n};\n/**\nAn error to be thrown when a request fails.\nContains a `code` property with error class code, like `ECONNREFUSED`.\n*/ class RequestError extends Error {\n    constructor(message, error, self){\n        var _a, _b;\n        super(message);\n        Error.captureStackTrace(this, this.constructor);\n        this.name = 'RequestError';\n        this.code = (_a = error.code) !== null && _a !== void 0 ? _a : 'ERR_GOT_REQUEST_ERROR';\n        if (self instanceof Request) {\n            Object.defineProperty(this, 'request', {\n                enumerable: false,\n                value: self\n            });\n            Object.defineProperty(this, 'response', {\n                enumerable: false,\n                value: self[kResponse]\n            });\n            Object.defineProperty(this, 'options', {\n                // This fails because of TS 3.7.2 useDefineForClassFields\n                // Ref: https://github.com/microsoft/TypeScript/issues/34972\n                enumerable: false,\n                value: self.options\n            });\n        } else {\n            Object.defineProperty(this, 'options', {\n                // This fails because of TS 3.7.2 useDefineForClassFields\n                // Ref: https://github.com/microsoft/TypeScript/issues/34972\n                enumerable: false,\n                value: self\n            });\n        }\n        this.timings = (_b = this.request) === null || _b === void 0 ? void 0 : _b.timings;\n        // Recover the original stacktrace\n        if (is_1.default.string(error.stack) && is_1.default.string(this.stack)) {\n            const indexOfMessage = this.stack.indexOf(this.message) + this.message.length;\n            const thisStackTrace = this.stack.slice(indexOfMessage).split('\\n').reverse();\n            const errorStackTrace = error.stack.slice(error.stack.indexOf(error.message) + error.message.length).split('\\n').reverse();\n            // Remove duplicated traces\n            while(errorStackTrace.length !== 0 && errorStackTrace[0] === thisStackTrace[0]){\n                thisStackTrace.shift();\n            }\n            this.stack = `${this.stack.slice(0, indexOfMessage)}${thisStackTrace.reverse().join('\\n')}${errorStackTrace.reverse().join('\\n')}`;\n        }\n    }\n}\nexports.RequestError = RequestError;\n/**\nAn error to be thrown when the server redirects you more than ten times.\nIncludes a `response` property.\n*/ class MaxRedirectsError extends RequestError {\n    constructor(request){\n        super(`Redirected ${request.options.maxRedirects} times. Aborting.`, {}, request);\n        this.name = 'MaxRedirectsError';\n        this.code = 'ERR_TOO_MANY_REDIRECTS';\n    }\n}\nexports.MaxRedirectsError = MaxRedirectsError;\n/**\nAn error to be thrown when the server response code is not 2xx nor 3xx if `options.followRedirect` is `true`, but always except for 304.\nIncludes a `response` property.\n*/ class HTTPError extends RequestError {\n    constructor(response){\n        super(`Response code ${response.statusCode} (${response.statusMessage})`, {}, response.request);\n        this.name = 'HTTPError';\n        this.code = 'ERR_NON_2XX_3XX_RESPONSE';\n    }\n}\nexports.HTTPError = HTTPError;\n/**\nAn error to be thrown when a cache method fails.\nFor example, if the database goes down or there's a filesystem error.\n*/ class CacheError extends RequestError {\n    constructor(error, request){\n        super(error.message, error, request);\n        this.name = 'CacheError';\n        this.code = this.code === 'ERR_GOT_REQUEST_ERROR' ? 'ERR_CACHE_ACCESS' : this.code;\n    }\n}\nexports.CacheError = CacheError;\n/**\nAn error to be thrown when the request body is a stream and an error occurs while reading from that stream.\n*/ class UploadError extends RequestError {\n    constructor(error, request){\n        super(error.message, error, request);\n        this.name = 'UploadError';\n        this.code = this.code === 'ERR_GOT_REQUEST_ERROR' ? 'ERR_UPLOAD' : this.code;\n    }\n}\nexports.UploadError = UploadError;\n/**\nAn error to be thrown when the request is aborted due to a timeout.\nIncludes an `event` and `timings` property.\n*/ class TimeoutError extends RequestError {\n    constructor(error, timings, request){\n        super(error.message, error, request);\n        this.name = 'TimeoutError';\n        this.event = error.event;\n        this.timings = timings;\n    }\n}\nexports.TimeoutError = TimeoutError;\n/**\nAn error to be thrown when reading from response stream fails.\n*/ class ReadError extends RequestError {\n    constructor(error, request){\n        super(error.message, error, request);\n        this.name = 'ReadError';\n        this.code = this.code === 'ERR_GOT_REQUEST_ERROR' ? 'ERR_READING_RESPONSE_STREAM' : this.code;\n    }\n}\nexports.ReadError = ReadError;\n/**\nAn error to be thrown when given an unsupported protocol.\n*/ class UnsupportedProtocolError extends RequestError {\n    constructor(options){\n        super(`Unsupported protocol \"${options.url.protocol}\"`, {}, options);\n        this.name = 'UnsupportedProtocolError';\n        this.code = 'ERR_UNSUPPORTED_PROTOCOL';\n    }\n}\nexports.UnsupportedProtocolError = UnsupportedProtocolError;\nconst proxiedRequestEvents = [\n    'socket',\n    'connect',\n    'continue',\n    'information',\n    'upgrade',\n    'timeout'\n];\nclass Request extends stream_1.Duplex {\n    constructor(url, options = {}, defaults){\n        super({\n            // This must be false, to enable throwing after destroy\n            // It is used for retry logic in Promise API\n            autoDestroy: false,\n            // It needs to be zero because we're just proxying the data to another stream\n            highWaterMark: 0\n        });\n        this[kDownloadedSize] = 0;\n        this[kUploadedSize] = 0;\n        this.requestInitialized = false;\n        this[kServerResponsesPiped] = new Set();\n        this.redirects = [];\n        this[kStopReading] = false;\n        this[kTriggerRead] = false;\n        this[kJobs] = [];\n        this.retryCount = 0;\n        // TODO: Remove this when targeting Node.js >= 12\n        this._progressCallbacks = [];\n        const unlockWrite = ()=>this._unlockWrite();\n        const lockWrite = ()=>this._lockWrite();\n        this.on('pipe', (source)=>{\n            source.prependListener('data', unlockWrite);\n            source.on('data', lockWrite);\n            source.prependListener('end', unlockWrite);\n            source.on('end', lockWrite);\n        });\n        this.on('unpipe', (source)=>{\n            source.off('data', unlockWrite);\n            source.off('data', lockWrite);\n            source.off('end', unlockWrite);\n            source.off('end', lockWrite);\n        });\n        this.on('pipe', (source)=>{\n            if (source instanceof http_1.IncomingMessage) {\n                this.options.headers = {\n                    ...source.headers,\n                    ...this.options.headers\n                };\n            }\n        });\n        const { json, body, form } = options;\n        if (json || body || form) {\n            this._lockWrite();\n        }\n        if (exports.kIsNormalizedAlready in options) {\n            this.options = options;\n        } else {\n            try {\n                // @ts-expect-error Common TypeScript bug saying that `this.constructor` is not accessible\n                this.options = this.constructor.normalizeArguments(url, options, defaults);\n            } catch (error) {\n                // TODO: Move this to `_destroy()`\n                if (is_1.default.nodeStream(options.body)) {\n                    options.body.destroy();\n                }\n                this.destroy(error);\n                return;\n            }\n        }\n        (async ()=>{\n            var _a;\n            try {\n                if (this.options.body instanceof fs_1.ReadStream) {\n                    await waitForOpenFile(this.options.body);\n                }\n                const { url: normalizedURL } = this.options;\n                if (!normalizedURL) {\n                    throw new TypeError('Missing `url` property');\n                }\n                this.requestUrl = normalizedURL.toString();\n                decodeURI(this.requestUrl);\n                await this._finalizeBody();\n                await this._makeRequest();\n                if (this.destroyed) {\n                    (_a = this[kRequest]) === null || _a === void 0 ? void 0 : _a.destroy();\n                    return;\n                }\n                // Queued writes etc.\n                for (const job of this[kJobs]){\n                    job();\n                }\n                // Prevent memory leak\n                this[kJobs].length = 0;\n                this.requestInitialized = true;\n            } catch (error) {\n                if (error instanceof RequestError) {\n                    this._beforeError(error);\n                    return;\n                }\n                // This is a workaround for https://github.com/nodejs/node/issues/33335\n                if (!this.destroyed) {\n                    this.destroy(error);\n                }\n            }\n        })();\n    }\n    static normalizeArguments(url, options, defaults) {\n        var _a, _b, _c, _d, _e;\n        const rawOptions = options;\n        if (is_1.default.object(url) && !is_1.default.urlInstance(url)) {\n            options = {\n                ...defaults,\n                ...url,\n                ...options\n            };\n        } else {\n            if (url && options && options.url !== undefined) {\n                throw new TypeError('The `url` option is mutually exclusive with the `input` argument');\n            }\n            options = {\n                ...defaults,\n                ...options\n            };\n            if (url !== undefined) {\n                options.url = url;\n            }\n            if (is_1.default.urlInstance(options.url)) {\n                options.url = new url_1.URL(options.url.toString());\n            }\n        }\n        // TODO: Deprecate URL options in Got 12.\n        // Support extend-specific options\n        if (options.cache === false) {\n            options.cache = undefined;\n        }\n        if (options.dnsCache === false) {\n            options.dnsCache = undefined;\n        }\n        // Nice type assertions\n        is_1.assert.any([\n            is_1.default.string,\n            is_1.default.undefined\n        ], options.method);\n        is_1.assert.any([\n            is_1.default.object,\n            is_1.default.undefined\n        ], options.headers);\n        is_1.assert.any([\n            is_1.default.string,\n            is_1.default.urlInstance,\n            is_1.default.undefined\n        ], options.prefixUrl);\n        is_1.assert.any([\n            is_1.default.object,\n            is_1.default.undefined\n        ], options.cookieJar);\n        is_1.assert.any([\n            is_1.default.object,\n            is_1.default.string,\n            is_1.default.undefined\n        ], options.searchParams);\n        is_1.assert.any([\n            is_1.default.object,\n            is_1.default.string,\n            is_1.default.undefined\n        ], options.cache);\n        is_1.assert.any([\n            is_1.default.object,\n            is_1.default.number,\n            is_1.default.undefined\n        ], options.timeout);\n        is_1.assert.any([\n            is_1.default.object,\n            is_1.default.undefined\n        ], options.context);\n        is_1.assert.any([\n            is_1.default.object,\n            is_1.default.undefined\n        ], options.hooks);\n        is_1.assert.any([\n            is_1.default.boolean,\n            is_1.default.undefined\n        ], options.decompress);\n        is_1.assert.any([\n            is_1.default.boolean,\n            is_1.default.undefined\n        ], options.ignoreInvalidCookies);\n        is_1.assert.any([\n            is_1.default.boolean,\n            is_1.default.undefined\n        ], options.followRedirect);\n        is_1.assert.any([\n            is_1.default.number,\n            is_1.default.undefined\n        ], options.maxRedirects);\n        is_1.assert.any([\n            is_1.default.boolean,\n            is_1.default.undefined\n        ], options.throwHttpErrors);\n        is_1.assert.any([\n            is_1.default.boolean,\n            is_1.default.undefined\n        ], options.http2);\n        is_1.assert.any([\n            is_1.default.boolean,\n            is_1.default.undefined\n        ], options.allowGetBody);\n        is_1.assert.any([\n            is_1.default.string,\n            is_1.default.undefined\n        ], options.localAddress);\n        is_1.assert.any([\n            dns_ip_version_1.isDnsLookupIpVersion,\n            is_1.default.undefined\n        ], options.dnsLookupIpVersion);\n        is_1.assert.any([\n            is_1.default.object,\n            is_1.default.undefined\n        ], options.https);\n        is_1.assert.any([\n            is_1.default.boolean,\n            is_1.default.undefined\n        ], options.rejectUnauthorized);\n        if (options.https) {\n            is_1.assert.any([\n                is_1.default.boolean,\n                is_1.default.undefined\n            ], options.https.rejectUnauthorized);\n            is_1.assert.any([\n                is_1.default.function_,\n                is_1.default.undefined\n            ], options.https.checkServerIdentity);\n            is_1.assert.any([\n                is_1.default.string,\n                is_1.default.object,\n                is_1.default.array,\n                is_1.default.undefined\n            ], options.https.certificateAuthority);\n            is_1.assert.any([\n                is_1.default.string,\n                is_1.default.object,\n                is_1.default.array,\n                is_1.default.undefined\n            ], options.https.key);\n            is_1.assert.any([\n                is_1.default.string,\n                is_1.default.object,\n                is_1.default.array,\n                is_1.default.undefined\n            ], options.https.certificate);\n            is_1.assert.any([\n                is_1.default.string,\n                is_1.default.undefined\n            ], options.https.passphrase);\n            is_1.assert.any([\n                is_1.default.string,\n                is_1.default.buffer,\n                is_1.default.array,\n                is_1.default.undefined\n            ], options.https.pfx);\n        }\n        is_1.assert.any([\n            is_1.default.object,\n            is_1.default.undefined\n        ], options.cacheOptions);\n        // `options.method`\n        if (is_1.default.string(options.method)) {\n            options.method = options.method.toUpperCase();\n        } else {\n            options.method = 'GET';\n        }\n        // `options.headers`\n        if (options.headers === (defaults === null || defaults === void 0 ? void 0 : defaults.headers)) {\n            options.headers = {\n                ...options.headers\n            };\n        } else {\n            options.headers = lowercaseKeys({\n                ...defaults === null || defaults === void 0 ? void 0 : defaults.headers,\n                ...options.headers\n            });\n        }\n        // Disallow legacy `url.Url`\n        if ('slashes' in options) {\n            throw new TypeError('The legacy `url.Url` has been deprecated. Use `URL` instead.');\n        }\n        // `options.auth`\n        if ('auth' in options) {\n            throw new TypeError('Parameter `auth` is deprecated. Use `username` / `password` instead.');\n        }\n        // `options.searchParams`\n        if ('searchParams' in options) {\n            if (options.searchParams && options.searchParams !== (defaults === null || defaults === void 0 ? void 0 : defaults.searchParams)) {\n                let searchParameters;\n                if (is_1.default.string(options.searchParams) || options.searchParams instanceof url_1.URLSearchParams) {\n                    searchParameters = new url_1.URLSearchParams(options.searchParams);\n                } else {\n                    validateSearchParameters(options.searchParams);\n                    searchParameters = new url_1.URLSearchParams();\n                    // eslint-disable-next-line guard-for-in\n                    for(const key in options.searchParams){\n                        const value = options.searchParams[key];\n                        if (value === null) {\n                            searchParameters.append(key, '');\n                        } else if (value !== undefined) {\n                            searchParameters.append(key, value);\n                        }\n                    }\n                }\n                // `normalizeArguments()` is also used to merge options\n                (_a = defaults === null || defaults === void 0 ? void 0 : defaults.searchParams) === null || _a === void 0 ? void 0 : _a.forEach((value, key)=>{\n                    // Only use default if one isn't already defined\n                    if (!searchParameters.has(key)) {\n                        searchParameters.append(key, value);\n                    }\n                });\n                options.searchParams = searchParameters;\n            }\n        }\n        // `options.username` & `options.password`\n        options.username = (_b = options.username) !== null && _b !== void 0 ? _b : '';\n        options.password = (_c = options.password) !== null && _c !== void 0 ? _c : '';\n        // `options.prefixUrl` & `options.url`\n        if (is_1.default.undefined(options.prefixUrl)) {\n            options.prefixUrl = (_d = defaults === null || defaults === void 0 ? void 0 : defaults.prefixUrl) !== null && _d !== void 0 ? _d : '';\n        } else {\n            options.prefixUrl = options.prefixUrl.toString();\n            if (options.prefixUrl !== '' && !options.prefixUrl.endsWith('/')) {\n                options.prefixUrl += '/';\n            }\n        }\n        if (is_1.default.string(options.url)) {\n            if (options.url.startsWith('/')) {\n                throw new Error('`input` must not start with a slash when using `prefixUrl`');\n            }\n            options.url = options_to_url_1.default(options.prefixUrl + options.url, options);\n        } else if (is_1.default.undefined(options.url) && options.prefixUrl !== '' || options.protocol) {\n            options.url = options_to_url_1.default(options.prefixUrl, options);\n        }\n        if (options.url) {\n            if ('port' in options) {\n                delete options.port;\n            }\n            // Make it possible to change `options.prefixUrl`\n            let { prefixUrl } = options;\n            Object.defineProperty(options, 'prefixUrl', {\n                set: (value)=>{\n                    const url = options.url;\n                    if (!url.href.startsWith(value)) {\n                        throw new Error(`Cannot change \\`prefixUrl\\` from ${prefixUrl} to ${value}: ${url.href}`);\n                    }\n                    options.url = new url_1.URL(value + url.href.slice(prefixUrl.length));\n                    prefixUrl = value;\n                },\n                get: ()=>prefixUrl\n            });\n            // Support UNIX sockets\n            let { protocol } = options.url;\n            if (protocol === 'unix:') {\n                protocol = 'http:';\n                options.url = new url_1.URL(`http://unix${options.url.pathname}${options.url.search}`);\n            }\n            // Set search params\n            if (options.searchParams) {\n                // eslint-disable-next-line @typescript-eslint/no-base-to-string\n                options.url.search = options.searchParams.toString();\n            }\n            // Protocol check\n            if (protocol !== 'http:' && protocol !== 'https:') {\n                throw new UnsupportedProtocolError(options);\n            }\n            // Update `username`\n            if (options.username === '') {\n                options.username = options.url.username;\n            } else {\n                options.url.username = options.username;\n            }\n            // Update `password`\n            if (options.password === '') {\n                options.password = options.url.password;\n            } else {\n                options.url.password = options.password;\n            }\n        }\n        // `options.cookieJar`\n        const { cookieJar } = options;\n        if (cookieJar) {\n            let { setCookie, getCookieString } = cookieJar;\n            is_1.assert.function_(setCookie);\n            is_1.assert.function_(getCookieString);\n            /* istanbul ignore next: Horrible `tough-cookie` v3 check */ if (setCookie.length === 4 && getCookieString.length === 0) {\n                setCookie = util_1.promisify(setCookie.bind(options.cookieJar));\n                getCookieString = util_1.promisify(getCookieString.bind(options.cookieJar));\n                options.cookieJar = {\n                    setCookie,\n                    getCookieString: getCookieString\n                };\n            }\n        }\n        // `options.cache`\n        const { cache } = options;\n        if (cache) {\n            if (!cacheableStore.has(cache)) {\n                cacheableStore.set(cache, new CacheableRequest((requestOptions, handler)=>{\n                    const result = requestOptions[kRequest](requestOptions, handler);\n                    // TODO: remove this when `cacheable-request` supports async request functions.\n                    if (is_1.default.promise(result)) {\n                        // @ts-expect-error\n                        // We only need to implement the error handler in order to support HTTP2 caching.\n                        // The result will be a promise anyway.\n                        result.once = (event, handler)=>{\n                            if (event === 'error') {\n                                result.catch(handler);\n                            } else if (event === 'abort') {\n                                // The empty catch is needed here in case when\n                                // it rejects before it's `await`ed in `_makeRequest`.\n                                (async ()=>{\n                                    try {\n                                        const request = await result;\n                                        request.once('abort', handler);\n                                    } catch (_a) {}\n                                })();\n                            } else {\n                                /* istanbul ignore next: safety check */ throw new Error(`Unknown HTTP2 promise event: ${event}`);\n                            }\n                            return result;\n                        };\n                    }\n                    return result;\n                }, cache));\n            }\n        }\n        // `options.cacheOptions`\n        options.cacheOptions = {\n            ...options.cacheOptions\n        };\n        // `options.dnsCache`\n        if (options.dnsCache === true) {\n            if (!globalDnsCache) {\n                globalDnsCache = new cacheable_lookup_1.default();\n            }\n            options.dnsCache = globalDnsCache;\n        } else if (!is_1.default.undefined(options.dnsCache) && !options.dnsCache.lookup) {\n            throw new TypeError(`Parameter \\`dnsCache\\` must be a CacheableLookup instance or a boolean, got ${is_1.default(options.dnsCache)}`);\n        }\n        // `options.timeout`\n        if (is_1.default.number(options.timeout)) {\n            options.timeout = {\n                request: options.timeout\n            };\n        } else if (defaults && options.timeout !== defaults.timeout) {\n            options.timeout = {\n                ...defaults.timeout,\n                ...options.timeout\n            };\n        } else {\n            options.timeout = {\n                ...options.timeout\n            };\n        }\n        // `options.context`\n        if (!options.context) {\n            options.context = {};\n        }\n        // `options.hooks`\n        const areHooksDefault = options.hooks === (defaults === null || defaults === void 0 ? void 0 : defaults.hooks);\n        options.hooks = {\n            ...options.hooks\n        };\n        for (const event of exports.knownHookEvents){\n            if (event in options.hooks) {\n                if (is_1.default.array(options.hooks[event])) {\n                    // See https://github.com/microsoft/TypeScript/issues/31445#issuecomment-576929044\n                    options.hooks[event] = [\n                        ...options.hooks[event]\n                    ];\n                } else {\n                    throw new TypeError(`Parameter \\`${event}\\` must be an Array, got ${is_1.default(options.hooks[event])}`);\n                }\n            } else {\n                options.hooks[event] = [];\n            }\n        }\n        if (defaults && !areHooksDefault) {\n            for (const event of exports.knownHookEvents){\n                const defaultHooks = defaults.hooks[event];\n                if (defaultHooks.length > 0) {\n                    // See https://github.com/microsoft/TypeScript/issues/31445#issuecomment-576929044\n                    options.hooks[event] = [\n                        ...defaults.hooks[event],\n                        ...options.hooks[event]\n                    ];\n                }\n            }\n        }\n        // DNS options\n        if ('family' in options) {\n            deprecation_warning_1.default('\"options.family\" was never documented, please use \"options.dnsLookupIpVersion\"');\n        }\n        // HTTPS options\n        if (defaults === null || defaults === void 0 ? void 0 : defaults.https) {\n            options.https = {\n                ...defaults.https,\n                ...options.https\n            };\n        }\n        if ('rejectUnauthorized' in options) {\n            deprecation_warning_1.default('\"options.rejectUnauthorized\" is now deprecated, please use \"options.https.rejectUnauthorized\"');\n        }\n        if ('checkServerIdentity' in options) {\n            deprecation_warning_1.default('\"options.checkServerIdentity\" was never documented, please use \"options.https.checkServerIdentity\"');\n        }\n        if ('ca' in options) {\n            deprecation_warning_1.default('\"options.ca\" was never documented, please use \"options.https.certificateAuthority\"');\n        }\n        if ('key' in options) {\n            deprecation_warning_1.default('\"options.key\" was never documented, please use \"options.https.key\"');\n        }\n        if ('cert' in options) {\n            deprecation_warning_1.default('\"options.cert\" was never documented, please use \"options.https.certificate\"');\n        }\n        if ('passphrase' in options) {\n            deprecation_warning_1.default('\"options.passphrase\" was never documented, please use \"options.https.passphrase\"');\n        }\n        if ('pfx' in options) {\n            deprecation_warning_1.default('\"options.pfx\" was never documented, please use \"options.https.pfx\"');\n        }\n        // Other options\n        if ('followRedirects' in options) {\n            throw new TypeError('The `followRedirects` option does not exist. Use `followRedirect` instead.');\n        }\n        if (options.agent) {\n            for(const key in options.agent){\n                if (key !== 'http' && key !== 'https' && key !== 'http2') {\n                    throw new TypeError(`Expected the \\`options.agent\\` properties to be \\`http\\`, \\`https\\` or \\`http2\\`, got \\`${key}\\``);\n                }\n            }\n        }\n        options.maxRedirects = (_e = options.maxRedirects) !== null && _e !== void 0 ? _e : 0;\n        // Set non-enumerable properties\n        exports.setNonEnumerableProperties([\n            defaults,\n            rawOptions\n        ], options);\n        return normalize_arguments_1.default(options, defaults);\n    }\n    _lockWrite() {\n        const onLockedWrite = ()=>{\n            throw new TypeError('The payload has been already provided');\n        };\n        this.write = onLockedWrite;\n        this.end = onLockedWrite;\n    }\n    _unlockWrite() {\n        this.write = super.write;\n        this.end = super.end;\n    }\n    async _finalizeBody() {\n        const { options } = this;\n        const { headers } = options;\n        const isForm = !is_1.default.undefined(options.form);\n        const isJSON = !is_1.default.undefined(options.json);\n        const isBody = !is_1.default.undefined(options.body);\n        const hasPayload = isForm || isJSON || isBody;\n        const cannotHaveBody = exports.withoutBody.has(options.method) && !(options.method === 'GET' && options.allowGetBody);\n        this._cannotHaveBody = cannotHaveBody;\n        if (hasPayload) {\n            if (cannotHaveBody) {\n                throw new TypeError(`The \\`${options.method}\\` method cannot be used with a body`);\n            }\n            if ([\n                isBody,\n                isForm,\n                isJSON\n            ].filter((isTrue)=>isTrue).length > 1) {\n                throw new TypeError('The `body`, `json` and `form` options are mutually exclusive');\n            }\n            if (isBody && !(options.body instanceof stream_1.Readable) && !is_1.default.string(options.body) && !is_1.default.buffer(options.body) && !is_form_data_1.default(options.body)) {\n                throw new TypeError('The `body` option must be a stream.Readable, string or Buffer');\n            }\n            if (isForm && !is_1.default.object(options.form)) {\n                throw new TypeError('The `form` option must be an Object');\n            }\n            {\n                // Serialize body\n                const noContentType = !is_1.default.string(headers['content-type']);\n                if (isBody) {\n                    // Special case for https://github.com/form-data/form-data\n                    if (is_form_data_1.default(options.body) && noContentType) {\n                        headers['content-type'] = `multipart/form-data; boundary=${options.body.getBoundary()}`;\n                    }\n                    this[kBody] = options.body;\n                } else if (isForm) {\n                    if (noContentType) {\n                        headers['content-type'] = 'application/x-www-form-urlencoded';\n                    }\n                    this[kBody] = new url_1.URLSearchParams(options.form).toString();\n                } else {\n                    if (noContentType) {\n                        headers['content-type'] = 'application/json';\n                    }\n                    this[kBody] = options.stringifyJson(options.json);\n                }\n                const uploadBodySize = await get_body_size_1.default(this[kBody], options.headers);\n                // See https://tools.ietf.org/html/rfc7230#section-3.3.2\n                // A user agent SHOULD send a Content-Length in a request message when\n                // no Transfer-Encoding is sent and the request method defines a meaning\n                // for an enclosed payload body.  For example, a Content-Length header\n                // field is normally sent in a POST request even when the value is 0\n                // (indicating an empty payload body).  A user agent SHOULD NOT send a\n                // Content-Length header field when the request message does not contain\n                // a payload body and the method semantics do not anticipate such a\n                // body.\n                if (is_1.default.undefined(headers['content-length']) && is_1.default.undefined(headers['transfer-encoding'])) {\n                    if (!cannotHaveBody && !is_1.default.undefined(uploadBodySize)) {\n                        headers['content-length'] = String(uploadBodySize);\n                    }\n                }\n            }\n        } else if (cannotHaveBody) {\n            this._lockWrite();\n        } else {\n            this._unlockWrite();\n        }\n        this[kBodySize] = Number(headers['content-length']) || undefined;\n    }\n    async _onResponseBase(response) {\n        const { options } = this;\n        const { url } = options;\n        this[kOriginalResponse] = response;\n        if (options.decompress) {\n            response = decompressResponse(response);\n        }\n        const statusCode = response.statusCode;\n        const typedResponse = response;\n        typedResponse.statusMessage = typedResponse.statusMessage ? typedResponse.statusMessage : http.STATUS_CODES[statusCode];\n        typedResponse.url = options.url.toString();\n        typedResponse.requestUrl = this.requestUrl;\n        typedResponse.redirectUrls = this.redirects;\n        typedResponse.request = this;\n        typedResponse.isFromCache = response.fromCache || false;\n        typedResponse.ip = this.ip;\n        typedResponse.retryCount = this.retryCount;\n        this[kIsFromCache] = typedResponse.isFromCache;\n        this[kResponseSize] = Number(response.headers['content-length']) || undefined;\n        this[kResponse] = response;\n        response.once('end', ()=>{\n            this[kResponseSize] = this[kDownloadedSize];\n            this.emit('downloadProgress', this.downloadProgress);\n        });\n        response.once('error', (error)=>{\n            // Force clean-up, because some packages don't do this.\n            // TODO: Fix decompress-response\n            response.destroy();\n            this._beforeError(new ReadError(error, this));\n        });\n        response.once('aborted', ()=>{\n            this._beforeError(new ReadError({\n                name: 'Error',\n                message: 'The server aborted pending request',\n                code: 'ECONNRESET'\n            }, this));\n        });\n        this.emit('downloadProgress', this.downloadProgress);\n        const rawCookies = response.headers['set-cookie'];\n        if (is_1.default.object(options.cookieJar) && rawCookies) {\n            let promises = rawCookies.map(async (rawCookie)=>options.cookieJar.setCookie(rawCookie, url.toString()));\n            if (options.ignoreInvalidCookies) {\n                promises = promises.map(async (p)=>p.catch(()=>{}));\n            }\n            try {\n                await Promise.all(promises);\n            } catch (error) {\n                this._beforeError(error);\n                return;\n            }\n        }\n        if (options.followRedirect && response.headers.location && redirectCodes.has(statusCode)) {\n            // We're being redirected, we don't care about the response.\n            // It'd be best to abort the request, but we can't because\n            // we would have to sacrifice the TCP connection. We don't want that.\n            response.resume();\n            if (this[kRequest]) {\n                this[kCancelTimeouts]();\n                // eslint-disable-next-line @typescript-eslint/no-dynamic-delete\n                delete this[kRequest];\n                this[kUnproxyEvents]();\n            }\n            const shouldBeGet = statusCode === 303 && options.method !== 'GET' && options.method !== 'HEAD';\n            if (shouldBeGet || !options.methodRewriting) {\n                // Server responded with \"see other\", indicating that the resource exists at another location,\n                // and the client should request it from that location via GET or HEAD.\n                options.method = 'GET';\n                if ('body' in options) {\n                    delete options.body;\n                }\n                if ('json' in options) {\n                    delete options.json;\n                }\n                if ('form' in options) {\n                    delete options.form;\n                }\n                this[kBody] = undefined;\n                delete options.headers['content-length'];\n            }\n            if (this.redirects.length >= options.maxRedirects) {\n                this._beforeError(new MaxRedirectsError(this));\n                return;\n            }\n            try {\n                // Do not remove. See https://github.com/sindresorhus/got/pull/214\n                const redirectBuffer = Buffer.from(response.headers.location, 'binary').toString();\n                // Handles invalid URLs. See https://github.com/sindresorhus/got/issues/604\n                const redirectUrl = new url_1.URL(redirectBuffer, url);\n                const redirectString = redirectUrl.toString();\n                decodeURI(redirectString);\n                // eslint-disable-next-line no-inner-declarations\n                function isUnixSocketURL(url) {\n                    return url.protocol === 'unix:' || url.hostname === 'unix';\n                }\n                if (!isUnixSocketURL(url) && isUnixSocketURL(redirectUrl)) {\n                    this._beforeError(new RequestError('Cannot redirect to UNIX socket', {}, this));\n                    return;\n                }\n                // Redirecting to a different site, clear sensitive data.\n                if (redirectUrl.hostname !== url.hostname || redirectUrl.port !== url.port) {\n                    if ('host' in options.headers) {\n                        delete options.headers.host;\n                    }\n                    if ('cookie' in options.headers) {\n                        delete options.headers.cookie;\n                    }\n                    if ('authorization' in options.headers) {\n                        delete options.headers.authorization;\n                    }\n                    if (options.username || options.password) {\n                        options.username = '';\n                        options.password = '';\n                    }\n                } else {\n                    redirectUrl.username = options.username;\n                    redirectUrl.password = options.password;\n                }\n                this.redirects.push(redirectString);\n                options.url = redirectUrl;\n                for (const hook of options.hooks.beforeRedirect){\n                    // eslint-disable-next-line no-await-in-loop\n                    await hook(options, typedResponse);\n                }\n                this.emit('redirect', typedResponse, options);\n                await this._makeRequest();\n            } catch (error) {\n                this._beforeError(error);\n                return;\n            }\n            return;\n        }\n        if (options.isStream && options.throwHttpErrors && !is_response_ok_1.isResponseOk(typedResponse)) {\n            this._beforeError(new HTTPError(typedResponse));\n            return;\n        }\n        response.on('readable', ()=>{\n            if (this[kTriggerRead]) {\n                this._read();\n            }\n        });\n        this.on('resume', ()=>{\n            response.resume();\n        });\n        this.on('pause', ()=>{\n            response.pause();\n        });\n        response.once('end', ()=>{\n            this.push(null);\n        });\n        this.emit('response', response);\n        for (const destination of this[kServerResponsesPiped]){\n            if (destination.headersSent) {\n                continue;\n            }\n            // eslint-disable-next-line guard-for-in\n            for(const key in response.headers){\n                const isAllowed = options.decompress ? key !== 'content-encoding' : true;\n                const value = response.headers[key];\n                if (isAllowed) {\n                    destination.setHeader(key, value);\n                }\n            }\n            destination.statusCode = statusCode;\n        }\n    }\n    async _onResponse(response) {\n        try {\n            await this._onResponseBase(response);\n        } catch (error) {\n            /* istanbul ignore next: better safe than sorry */ this._beforeError(error);\n        }\n    }\n    _onRequest(request) {\n        const { options } = this;\n        const { timeout, url } = options;\n        http_timer_1.default(request);\n        this[kCancelTimeouts] = timed_out_1.default(request, timeout, url);\n        const responseEventName = options.cache ? 'cacheableResponse' : 'response';\n        request.once(responseEventName, (response)=>{\n            void this._onResponse(response);\n        });\n        request.once('error', (error)=>{\n            var _a;\n            // Force clean-up, because some packages (e.g. nock) don't do this.\n            request.destroy();\n            // Node.js <= 12.18.2 mistakenly emits the response `end` first.\n            (_a = request.res) === null || _a === void 0 ? void 0 : _a.removeAllListeners('end');\n            error = error instanceof timed_out_1.TimeoutError ? new TimeoutError(error, this.timings, this) : new RequestError(error.message, error, this);\n            this._beforeError(error);\n        });\n        this[kUnproxyEvents] = proxy_events_1.default(request, this, proxiedRequestEvents);\n        this[kRequest] = request;\n        this.emit('uploadProgress', this.uploadProgress);\n        // Send body\n        const body = this[kBody];\n        const currentRequest = this.redirects.length === 0 ? this : request;\n        if (is_1.default.nodeStream(body)) {\n            body.pipe(currentRequest);\n            body.once('error', (error)=>{\n                this._beforeError(new UploadError(error, this));\n            });\n        } else {\n            this._unlockWrite();\n            if (!is_1.default.undefined(body)) {\n                this._writeRequest(body, undefined, ()=>{});\n                currentRequest.end();\n                this._lockWrite();\n            } else if (this._cannotHaveBody || this._noPipe) {\n                currentRequest.end();\n                this._lockWrite();\n            }\n        }\n        this.emit('request', request);\n    }\n    async _createCacheableRequest(url, options) {\n        return new Promise((resolve, reject)=>{\n            // TODO: Remove `utils/url-to-options.ts` when `cacheable-request` is fixed\n            Object.assign(options, url_to_options_1.default(url));\n            // `http-cache-semantics` checks this\n            // TODO: Fix this ignore.\n            // @ts-expect-error\n            delete options.url;\n            let request;\n            // This is ugly\n            const cacheRequest = cacheableStore.get(options.cache)(options, async (response)=>{\n                // TODO: Fix `cacheable-response`\n                response._readableState.autoDestroy = false;\n                if (request) {\n                    (await request).emit('cacheableResponse', response);\n                }\n                resolve(response);\n            });\n            // Restore options\n            options.url = url;\n            cacheRequest.once('error', reject);\n            cacheRequest.once('request', async (requestOrPromise)=>{\n                request = requestOrPromise;\n                resolve(request);\n            });\n        });\n    }\n    async _makeRequest() {\n        var _a, _b, _c, _d, _e;\n        const { options } = this;\n        const { headers } = options;\n        for(const key in headers){\n            if (is_1.default.undefined(headers[key])) {\n                // eslint-disable-next-line @typescript-eslint/no-dynamic-delete\n                delete headers[key];\n            } else if (is_1.default.null_(headers[key])) {\n                throw new TypeError(`Use \\`undefined\\` instead of \\`null\\` to delete the \\`${key}\\` header`);\n            }\n        }\n        if (options.decompress && is_1.default.undefined(headers['accept-encoding'])) {\n            headers['accept-encoding'] = supportsBrotli ? 'gzip, deflate, br' : 'gzip, deflate';\n        }\n        // Set cookies\n        if (options.cookieJar) {\n            const cookieString = await options.cookieJar.getCookieString(options.url.toString());\n            if (is_1.default.nonEmptyString(cookieString)) {\n                options.headers.cookie = cookieString;\n            }\n        }\n        for (const hook of options.hooks.beforeRequest){\n            // eslint-disable-next-line no-await-in-loop\n            const result = await hook(options);\n            if (!is_1.default.undefined(result)) {\n                // @ts-expect-error Skip the type mismatch to support abstract responses\n                options.request = ()=>result;\n                break;\n            }\n        }\n        if (options.body && this[kBody] !== options.body) {\n            this[kBody] = options.body;\n        }\n        const { agent, request, timeout, url } = options;\n        if (options.dnsCache && !('lookup' in options)) {\n            options.lookup = options.dnsCache.lookup;\n        }\n        // UNIX sockets\n        if (url.hostname === 'unix') {\n            const matches = /(?<socketPath>.+?):(?<path>.+)/.exec(`${url.pathname}${url.search}`);\n            if (matches === null || matches === void 0 ? void 0 : matches.groups) {\n                const { socketPath, path } = matches.groups;\n                Object.assign(options, {\n                    socketPath,\n                    path,\n                    host: ''\n                });\n            }\n        }\n        const isHttps = url.protocol === 'https:';\n        // Fallback function\n        let fallbackFn;\n        if (options.http2) {\n            fallbackFn = http2wrapper.auto;\n        } else {\n            fallbackFn = isHttps ? https.request : http.request;\n        }\n        const realFn = (_a = options.request) !== null && _a !== void 0 ? _a : fallbackFn;\n        // Cache support\n        const fn = options.cache ? this._createCacheableRequest : realFn;\n        // Pass an agent directly when HTTP2 is disabled\n        if (agent && !options.http2) {\n            options.agent = agent[isHttps ? 'https' : 'http'];\n        }\n        // Prepare plain HTTP request options\n        options[kRequest] = realFn;\n        delete options.request;\n        // TODO: Fix this ignore.\n        // @ts-expect-error\n        delete options.timeout;\n        const requestOptions = options;\n        requestOptions.shared = (_b = options.cacheOptions) === null || _b === void 0 ? void 0 : _b.shared;\n        requestOptions.cacheHeuristic = (_c = options.cacheOptions) === null || _c === void 0 ? void 0 : _c.cacheHeuristic;\n        requestOptions.immutableMinTimeToLive = (_d = options.cacheOptions) === null || _d === void 0 ? void 0 : _d.immutableMinTimeToLive;\n        requestOptions.ignoreCargoCult = (_e = options.cacheOptions) === null || _e === void 0 ? void 0 : _e.ignoreCargoCult;\n        // If `dnsLookupIpVersion` is not present do not override `family`\n        if (options.dnsLookupIpVersion !== undefined) {\n            try {\n                requestOptions.family = dns_ip_version_1.dnsLookupIpVersionToFamily(options.dnsLookupIpVersion);\n            } catch (_f) {\n                throw new Error('Invalid `dnsLookupIpVersion` option value');\n            }\n        }\n        // HTTPS options remapping\n        if (options.https) {\n            if ('rejectUnauthorized' in options.https) {\n                requestOptions.rejectUnauthorized = options.https.rejectUnauthorized;\n            }\n            if (options.https.checkServerIdentity) {\n                requestOptions.checkServerIdentity = options.https.checkServerIdentity;\n            }\n            if (options.https.certificateAuthority) {\n                requestOptions.ca = options.https.certificateAuthority;\n            }\n            if (options.https.certificate) {\n                requestOptions.cert = options.https.certificate;\n            }\n            if (options.https.key) {\n                requestOptions.key = options.https.key;\n            }\n            if (options.https.passphrase) {\n                requestOptions.passphrase = options.https.passphrase;\n            }\n            if (options.https.pfx) {\n                requestOptions.pfx = options.https.pfx;\n            }\n        }\n        try {\n            let requestOrResponse = await fn(url, requestOptions);\n            if (is_1.default.undefined(requestOrResponse)) {\n                requestOrResponse = fallbackFn(url, requestOptions);\n            }\n            // Restore options\n            options.request = request;\n            options.timeout = timeout;\n            options.agent = agent;\n            // HTTPS options restore\n            if (options.https) {\n                if ('rejectUnauthorized' in options.https) {\n                    delete requestOptions.rejectUnauthorized;\n                }\n                if (options.https.checkServerIdentity) {\n                    // @ts-expect-error - This one will be removed when we remove the alias.\n                    delete requestOptions.checkServerIdentity;\n                }\n                if (options.https.certificateAuthority) {\n                    delete requestOptions.ca;\n                }\n                if (options.https.certificate) {\n                    delete requestOptions.cert;\n                }\n                if (options.https.key) {\n                    delete requestOptions.key;\n                }\n                if (options.https.passphrase) {\n                    delete requestOptions.passphrase;\n                }\n                if (options.https.pfx) {\n                    delete requestOptions.pfx;\n                }\n            }\n            if (isClientRequest(requestOrResponse)) {\n                this._onRequest(requestOrResponse);\n            // Emit the response after the stream has been ended\n            } else if (this.writable) {\n                this.once('finish', ()=>{\n                    void this._onResponse(requestOrResponse);\n                });\n                this._unlockWrite();\n                this.end();\n                this._lockWrite();\n            } else {\n                void this._onResponse(requestOrResponse);\n            }\n        } catch (error) {\n            if (error instanceof CacheableRequest.CacheError) {\n                throw new CacheError(error, this);\n            }\n            throw new RequestError(error.message, error, this);\n        }\n    }\n    async _error(error) {\n        try {\n            for (const hook of this.options.hooks.beforeError){\n                // eslint-disable-next-line no-await-in-loop\n                error = await hook(error);\n            }\n        } catch (error_) {\n            error = new RequestError(error_.message, error_, this);\n        }\n        this.destroy(error);\n    }\n    _beforeError(error) {\n        if (this[kStopReading]) {\n            return;\n        }\n        const { options } = this;\n        const retryCount = this.retryCount + 1;\n        this[kStopReading] = true;\n        if (!(error instanceof RequestError)) {\n            error = new RequestError(error.message, error, this);\n        }\n        const typedError = error;\n        const { response } = typedError;\n        void (async ()=>{\n            if (response && !response.body) {\n                response.setEncoding(this._readableState.encoding);\n                try {\n                    response.rawBody = await get_buffer_1.default(response);\n                    response.body = response.rawBody.toString();\n                } catch (_a) {}\n            }\n            if (this.listenerCount('retry') !== 0) {\n                let backoff;\n                try {\n                    let retryAfter;\n                    if (response && 'retry-after' in response.headers) {\n                        retryAfter = Number(response.headers['retry-after']);\n                        if (Number.isNaN(retryAfter)) {\n                            retryAfter = Date.parse(response.headers['retry-after']) - Date.now();\n                            if (retryAfter <= 0) {\n                                retryAfter = 1;\n                            }\n                        } else {\n                            retryAfter *= 1000;\n                        }\n                    }\n                    backoff = await options.retry.calculateDelay({\n                        attemptCount: retryCount,\n                        retryOptions: options.retry,\n                        error: typedError,\n                        retryAfter,\n                        computedValue: calculate_retry_delay_1.default({\n                            attemptCount: retryCount,\n                            retryOptions: options.retry,\n                            error: typedError,\n                            retryAfter,\n                            computedValue: 0\n                        })\n                    });\n                } catch (error_) {\n                    void this._error(new RequestError(error_.message, error_, this));\n                    return;\n                }\n                if (backoff) {\n                    const retry = async ()=>{\n                        try {\n                            for (const hook of this.options.hooks.beforeRetry){\n                                // eslint-disable-next-line no-await-in-loop\n                                await hook(this.options, typedError, retryCount);\n                            }\n                        } catch (error_) {\n                            void this._error(new RequestError(error_.message, error, this));\n                            return;\n                        }\n                        // Something forced us to abort the retry\n                        if (this.destroyed) {\n                            return;\n                        }\n                        this.destroy();\n                        this.emit('retry', retryCount, error);\n                    };\n                    this[kRetryTimeout] = setTimeout(retry, backoff);\n                    return;\n                }\n            }\n            void this._error(typedError);\n        })();\n    }\n    _read() {\n        this[kTriggerRead] = true;\n        const response = this[kResponse];\n        if (response && !this[kStopReading]) {\n            // We cannot put this in the `if` above\n            // because `.read()` also triggers the `end` event\n            if (response.readableLength) {\n                this[kTriggerRead] = false;\n            }\n            let data;\n            while((data = response.read()) !== null){\n                this[kDownloadedSize] += data.length;\n                this[kStartedReading] = true;\n                const progress = this.downloadProgress;\n                if (progress.percent < 1) {\n                    this.emit('downloadProgress', progress);\n                }\n                this.push(data);\n            }\n        }\n    }\n    // Node.js 12 has incorrect types, so the encoding must be a string\n    _write(chunk, encoding, callback) {\n        const write = ()=>{\n            this._writeRequest(chunk, encoding, callback);\n        };\n        if (this.requestInitialized) {\n            write();\n        } else {\n            this[kJobs].push(write);\n        }\n    }\n    _writeRequest(chunk, encoding, callback) {\n        if (this[kRequest].destroyed) {\n            // Probably the `ClientRequest` instance will throw\n            return;\n        }\n        this._progressCallbacks.push(()=>{\n            this[kUploadedSize] += Buffer.byteLength(chunk, encoding);\n            const progress = this.uploadProgress;\n            if (progress.percent < 1) {\n                this.emit('uploadProgress', progress);\n            }\n        });\n        // TODO: What happens if it's from cache? Then this[kRequest] won't be defined.\n        this[kRequest].write(chunk, encoding, (error)=>{\n            if (!error && this._progressCallbacks.length > 0) {\n                this._progressCallbacks.shift()();\n            }\n            callback(error);\n        });\n    }\n    _final(callback) {\n        const endRequest = ()=>{\n            // FIX: Node.js 10 calls the write callback AFTER the end callback!\n            while(this._progressCallbacks.length !== 0){\n                this._progressCallbacks.shift()();\n            }\n            // We need to check if `this[kRequest]` is present,\n            // because it isn't when we use cache.\n            if (!(kRequest in this)) {\n                callback();\n                return;\n            }\n            if (this[kRequest].destroyed) {\n                callback();\n                return;\n            }\n            this[kRequest].end((error)=>{\n                if (!error) {\n                    this[kBodySize] = this[kUploadedSize];\n                    this.emit('uploadProgress', this.uploadProgress);\n                    this[kRequest].emit('upload-complete');\n                }\n                callback(error);\n            });\n        };\n        if (this.requestInitialized) {\n            endRequest();\n        } else {\n            this[kJobs].push(endRequest);\n        }\n    }\n    _destroy(error, callback) {\n        var _a;\n        this[kStopReading] = true;\n        // Prevent further retries\n        clearTimeout(this[kRetryTimeout]);\n        if (kRequest in this) {\n            this[kCancelTimeouts]();\n            // TODO: Remove the next `if` when these get fixed:\n            // - https://github.com/nodejs/node/issues/32851\n            if (!((_a = this[kResponse]) === null || _a === void 0 ? void 0 : _a.complete)) {\n                this[kRequest].destroy();\n            }\n        }\n        if (error !== null && !is_1.default.undefined(error) && !(error instanceof RequestError)) {\n            error = new RequestError(error.message, error, this);\n        }\n        callback(error);\n    }\n    get _isAboutToError() {\n        return this[kStopReading];\n    }\n    /**\n    The remote IP address.\n    */ get ip() {\n        var _a;\n        return (_a = this.socket) === null || _a === void 0 ? void 0 : _a.remoteAddress;\n    }\n    /**\n    Indicates whether the request has been aborted or not.\n    */ get aborted() {\n        var _a, _b, _c;\n        return ((_b = (_a = this[kRequest]) === null || _a === void 0 ? void 0 : _a.destroyed) !== null && _b !== void 0 ? _b : this.destroyed) && !((_c = this[kOriginalResponse]) === null || _c === void 0 ? void 0 : _c.complete);\n    }\n    get socket() {\n        var _a, _b;\n        return (_b = (_a = this[kRequest]) === null || _a === void 0 ? void 0 : _a.socket) !== null && _b !== void 0 ? _b : undefined;\n    }\n    /**\n    Progress event for downloading (receiving a response).\n    */ get downloadProgress() {\n        let percent;\n        if (this[kResponseSize]) {\n            percent = this[kDownloadedSize] / this[kResponseSize];\n        } else if (this[kResponseSize] === this[kDownloadedSize]) {\n            percent = 1;\n        } else {\n            percent = 0;\n        }\n        return {\n            percent,\n            transferred: this[kDownloadedSize],\n            total: this[kResponseSize]\n        };\n    }\n    /**\n    Progress event for uploading (sending a request).\n    */ get uploadProgress() {\n        let percent;\n        if (this[kBodySize]) {\n            percent = this[kUploadedSize] / this[kBodySize];\n        } else if (this[kBodySize] === this[kUploadedSize]) {\n            percent = 1;\n        } else {\n            percent = 0;\n        }\n        return {\n            percent,\n            transferred: this[kUploadedSize],\n            total: this[kBodySize]\n        };\n    }\n    /**\n    The object contains the following properties:\n\n    - `start` - Time when the request started.\n    - `socket` - Time when a socket was assigned to the request.\n    - `lookup` - Time when the DNS lookup finished.\n    - `connect` - Time when the socket successfully connected.\n    - `secureConnect` - Time when the socket securely connected.\n    - `upload` - Time when the request finished uploading.\n    - `response` - Time when the request fired `response` event.\n    - `end` - Time when the response fired `end` event.\n    - `error` - Time when the request fired `error` event.\n    - `abort` - Time when the request fired `abort` event.\n    - `phases`\n        - `wait` - `timings.socket - timings.start`\n        - `dns` - `timings.lookup - timings.socket`\n        - `tcp` - `timings.connect - timings.lookup`\n        - `tls` - `timings.secureConnect - timings.connect`\n        - `request` - `timings.upload - (timings.secureConnect || timings.connect)`\n        - `firstByte` - `timings.response - timings.upload`\n        - `download` - `timings.end - timings.response`\n        - `total` - `(timings.end || timings.error || timings.abort) - timings.start`\n\n    If something has not been measured yet, it will be `undefined`.\n\n    __Note__: The time is a `number` representing the milliseconds elapsed since the UNIX epoch.\n    */ get timings() {\n        var _a;\n        return (_a = this[kRequest]) === null || _a === void 0 ? void 0 : _a.timings;\n    }\n    /**\n    Whether the response was retrieved from the cache.\n    */ get isFromCache() {\n        return this[kIsFromCache];\n    }\n    pipe(destination, options) {\n        if (this[kStartedReading]) {\n            throw new Error('Failed to pipe. The response has been emitted already.');\n        }\n        if (destination instanceof http_1.ServerResponse) {\n            this[kServerResponsesPiped].add(destination);\n        }\n        return super.pipe(destination, options);\n    }\n    unpipe(destination) {\n        if (destination instanceof http_1.ServerResponse) {\n            this[kServerResponsesPiped].delete(destination);\n        }\n        super.unpipe(destination);\n        return this;\n    }\n}\nexports[\"default\"] = Request;\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvc3dhcm0tanMvbm9kZV9tb2R1bGVzL2dvdC9kaXN0L3NvdXJjZS9jb3JlL2luZGV4LmpzIiwibWFwcGluZ3MiOiJBQUFhO0FBQ2JBLDhDQUE2QztJQUFFRyxPQUFPO0FBQUssQ0FBQyxFQUFDO0FBQzdERCxnQ0FBZ0MsR0FBR0EsaUJBQWlCLEdBQUdBLG9CQUFvQixHQUFHQSxtQkFBbUIsR0FBR0Esa0JBQWtCLEdBQUdBLGlCQUFpQixHQUFHQSx5QkFBeUIsR0FBR0Esb0JBQW9CLEdBQUdBLGtDQUFrQyxHQUFHQSx1QkFBdUIsR0FBR0EsbUJBQW1CLEdBQUdBLDRCQUE0QixHQUFHLEtBQUs7QUFDelQsTUFBTWMsU0FBU0MsbUJBQU9BLENBQUMsa0JBQU07QUFDN0IsTUFBTUMsV0FBV0QsbUJBQU9BLENBQUMsc0JBQVE7QUFDakMsTUFBTUUsT0FBT0YsbUJBQU9BLENBQUMsY0FBSTtBQUN6QixNQUFNRyxRQUFRSCxtQkFBT0EsQ0FBQyxnQkFBSztBQUMzQixNQUFNSSxPQUFPSixtQkFBT0EsQ0FBQyxrQkFBTTtBQUMzQixNQUFNSyxTQUFTTCxtQkFBT0EsQ0FBQyxrQkFBTTtBQUM3QixNQUFNTSxRQUFRTixtQkFBT0EsQ0FBQyxvQkFBTztBQUM3QixNQUFNTyxlQUFlUCxtQkFBT0EsQ0FBQyxvSEFBdUI7QUFDcEQsTUFBTVEscUJBQXFCUixtQkFBT0EsQ0FBQyxxR0FBa0I7QUFDckQsTUFBTVMsbUJBQW1CVCxtQkFBT0EsQ0FBQyw4RUFBbUI7QUFDcEQsTUFBTVUscUJBQXFCVixtQkFBT0EsQ0FBQyw4RUFBcUI7QUFDeEQsaUNBQWlDO0FBQ2pDLE1BQU1XLGVBQWVYLG1CQUFPQSxDQUFDLCtGQUFlO0FBQzVDLE1BQU1ZLGdCQUFnQlosbUJBQU9BLENBQUMsMEZBQWdCO0FBQzlDLE1BQU1hLE9BQU9iLG1CQUFPQSxDQUFDLDZFQUFrQjtBQUN2QyxNQUFNYyxrQkFBa0JkLG1CQUFPQSxDQUFDLHFIQUF1QjtBQUN2RCxNQUFNZSxp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RUFBRTNLLE9BQU8sRUFBRTtRQUN2QixJQUFJLElBQUksQ0FBQ3hELGdCQUFnQixFQUFFO1lBQ3ZCLE1BQU0sSUFBSWdELE1BQU07UUFDcEI7UUFDQSxJQUFJbUwsdUJBQXVCclEsT0FBT3dWLGNBQWMsRUFBRTtZQUM5QyxJQUFJLENBQUMxVCxzQkFBc0IsQ0FBQzJULEdBQUcsQ0FBQ3BGO1FBQ3BDO1FBQ0EsT0FBTyxLQUFLLENBQUNXLEtBQUtYLGFBQWEzSztJQUNuQztJQUNBZ1EsT0FBT3JGLFdBQVcsRUFBRTtRQUNoQixJQUFJQSx1QkFBdUJyUSxPQUFPd1YsY0FBYyxFQUFFO1lBQzlDLElBQUksQ0FBQzFULHNCQUFzQixDQUFDNlQsTUFBTSxDQUFDdEY7UUFDdkM7UUFDQSxLQUFLLENBQUNxRixPQUFPckY7UUFDYixPQUFPLElBQUk7SUFDZjtBQUNKO0FBQ0F6UixrQkFBZSxHQUFHNkciLCJzb3VyY2VzIjpbIi9Vc2Vycy9wYW56YS9Eb2N1bWVudHMvUGVyc29uYWxQcm9qZWN0cy9wcmVkaWsvbm9kZV9tb2R1bGVzL3N3YXJtLWpzL25vZGVfbW9kdWxlcy9nb3QvZGlzdC9zb3VyY2UvY29yZS9pbmRleC5qcyJdLCJzb3VyY2VzQ29udGVudCI6WyJcInVzZSBzdHJpY3RcIjtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcbmV4cG9ydHMuVW5zdXBwb3J0ZWRQcm90b2NvbEVycm9yID0gZXhwb3J0cy5SZWFkRXJyb3IgPSBleHBvcnRzLlRpbWVvdXRFcnJvciA9IGV4cG9ydHMuVXBsb2FkRXJyb3IgPSBleHBvcnRzLkNhY2hlRXJyb3IgPSBleHBvcnRzLkhUVFBFcnJvciA9IGV4cG9ydHMuTWF4UmVkaXJlY3RzRXJyb3IgPSBleHBvcnRzLlJlcXVlc3RFcnJvciA9IGV4cG9ydHMuc2V0Tm9uRW51bWVyYWJsZVByb3BlcnRpZXMgPSBleHBvcnRzLmtub3duSG9va0V2ZW50cyA9IGV4cG9ydHMud2l0aG91dEJvZHkgPSBleHBvcnRzLmtJc05vcm1hbGl6ZWRBbHJlYWR5ID0gdm9pZCAwO1xuY29uc3QgdXRpbF8xID0gcmVxdWlyZShcInV0aWxcIik7XG5jb25zdCBzdHJlYW1fMSA9IHJlcXVpcmUoXCJzdHJlYW1cIik7XG5jb25zdCBmc18xID0gcmVxdWlyZShcImZzXCIpO1xuY29uc3QgdXJsXzEgPSByZXF1aXJlKFwidXJsXCIpO1xuY29uc3QgaHR0cCA9IHJlcXVpcmUoXCJodHRwXCIpO1xuY29uc3QgaHR0cF8xID0gcmVxdWlyZShcImh0dHBcIik7XG5jb25zdCBodHRwcyA9IHJlcXVpcmUoXCJodHRwc1wiKTtcbmNvbnN0IGh0dHBfdGltZXJfMSA9IHJlcXVpcmUoXCJAc3ptYXJjemFrL2h0dHAtdGltZXJcIik7XG5jb25zdCBjYWNoZWFibGVfbG9va3VwXzEgPSByZXF1aXJlKFwiY2FjaGVhYmxlLWxvb2t1cFwiKTtcbmNvbnN0IENhY2hlYWJsZVJlcXVlc3QgPSByZXF1aXJlKFwiY2FjaGVhYmxlLXJlcXVlc3RcIik7XG5jb25zdCBkZWNvbXByZXNzUmVzcG9uc2UgPSByZXF1aXJlKFwiZGVjb21wcmVzcy1yZXNwb25zZVwiKTtcbi8vIEB0cy1leHBlY3QtZXJyb3IgTWlzc2luZyB0eXBlc1xuY29uc3QgaHR0cDJ3cmFwcGVyID0gcmVxdWlyZShcImh0dHAyLXdyYXBwZXJcIik7XG5jb25zdCBsb3dlcmNhc2VLZXlzID0gcmVxdWlyZShcImxvd2VyY2FzZS1rZXlzXCIpO1xuY29uc3QgaXNfMSA9IHJlcXVpcmUoXCJAc2luZHJlc29yaHVzL2lzXCIpO1xuY29uc3QgZ2V0X2JvZHlfc2l6ZV8xID0gcmVxdWlyZShcIi4vdXRpbHMvZ2V0LWJvZHktc2l6ZVwiKTtcbmNvbnN0IGlzX2Zvcm1fZGF0YV8xID0gcmVxdWlyZShcIi4vdXRpbHMvaXMtZm9ybS1kYXRhXCIpO1xuY29uc3QgcHJveHlfZXZlbnRzXzEgPSByZXF1aXJlKFwiLi91dGlscy9wcm94eS1ldmVudHNcIik7XG5jb25zdCB0aW1lZF9vdXRfMSA9IHJlcXVpcmUoXCIuL3V0aWxzL3RpbWVkLW91dFwiKTtcbmNvbnN0IHVybF90b19vcHRpb25zXzEgPSByZXF1aXJlKFwiLi91dGlscy91cmwtdG8tb3B0aW9uc1wiKTtcbmNvbnN0IG9wdGlvbnNfdG9fdXJsXzEgPSByZXF1aXJlKFwiLi91dGlscy9vcHRpb25zLXRvLXVybFwiKTtcbmNvbnN0IHdlYWthYmxlX21hcF8xID0gcmVxdWlyZShcIi4vdXRpbHMvd2Vha2FibGUtbWFwXCIpO1xuY29uc3QgZ2V0X2J1ZmZlcl8xID0gcmVxdWlyZShcIi4vdXRpbHMvZ2V0LWJ1ZmZlclwiKTtcbmNvbnN0IGRuc19pcF92ZXJzaW9uXzEgPSByZXF1aXJlKFwiLi91dGlscy9kbnMtaXAtdmVyc2lvblwiKTtcbmNvbnN0IGlzX3Jlc3BvbnNlX29rXzEgPSByZXF1aXJlKFwiLi91dGlscy9pcy1yZXNwb25zZS1va1wiKTtcbmNvbnN0IGRlcHJlY2F0aW9uX3dhcm5pbmdfMSA9IHJlcXVpcmUoXCIuLi91dGlscy9kZXByZWNhdGlvbi13YXJuaW5nXCIpO1xuY29uc3Qgbm9ybWFsaXplX2FyZ3VtZW50c18xID0gcmVxdWlyZShcIi4uL2FzLXByb21pc2Uvbm9ybWFsaXplLWFyZ3VtZW50c1wiKTtcbmNvbnN0IGNhbGN1bGF0ZV9yZXRyeV9kZWxheV8xID0gcmVxdWlyZShcIi4vY2FsY3VsYXRlLXJldHJ5LWRlbGF5XCIpO1xubGV0IGdsb2JhbERuc0NhY2hlO1xuY29uc3Qga1JlcXVlc3QgPSBTeW1ib2woJ3JlcXVlc3QnKTtcbmNvbnN0IGtSZXNwb25zZSA9IFN5bWJvbCgncmVzcG9uc2UnKTtcbmNvbnN0IGtSZXNwb25zZVNpemUgPSBTeW1ib2woJ3Jlc3BvbnNlU2l6ZScpO1xuY29uc3Qga0Rvd25sb2FkZWRTaXplID0gU3ltYm9sKCdkb3dubG9hZGVkU2l6ZScpO1xuY29uc3Qga0JvZHlTaXplID0gU3ltYm9sKCdib2R5U2l6ZScpO1xuY29uc3Qga1VwbG9hZGVkU2l6ZSA9IFN5bWJvbCgndXBsb2FkZWRTaXplJyk7XG5jb25zdCBrU2VydmVyUmVzcG9uc2VzUGlwZWQgPSBTeW1ib2woJ3NlcnZlclJlc3BvbnNlc1BpcGVkJyk7XG5jb25zdCBrVW5wcm94eUV2ZW50cyA9IFN5bWJvbCgndW5wcm94eUV2ZW50cycpO1xuY29uc3Qga0lzRnJvbUNhY2hlID0gU3ltYm9sKCdpc0Zyb21DYWNoZScpO1xuY29uc3Qga0NhbmNlbFRpbWVvdXRzID0gU3ltYm9sKCdjYW5jZWxUaW1lb3V0cycpO1xuY29uc3Qga1N0YXJ0ZWRSZWFkaW5nID0gU3ltYm9sKCdzdGFydGVkUmVhZGluZycpO1xuY29uc3Qga1N0b3BSZWFkaW5nID0gU3ltYm9sKCdzdG9wUmVhZGluZycpO1xuY29uc3Qga1RyaWdnZXJSZWFkID0gU3ltYm9sKCd0cmlnZ2VyUmVhZCcpO1xuY29uc3Qga0JvZHkgPSBTeW1ib2woJ2JvZHknKTtcbmNvbnN0IGtKb2JzID0gU3ltYm9sKCdqb2JzJyk7XG5jb25zdCBrT3JpZ2luYWxSZXNwb25zZSA9IFN5bWJvbCgnb3JpZ2luYWxSZXNwb25zZScpO1xuY29uc3Qga1JldHJ5VGltZW91dCA9IFN5bWJvbCgncmV0cnlUaW1lb3V0Jyk7XG5leHBvcnRzLmtJc05vcm1hbGl6ZWRBbHJlYWR5ID0gU3ltYm9sKCdpc05vcm1hbGl6ZWRBbHJlYWR5Jyk7XG5jb25zdCBzdXBwb3J0c0Jyb3RsaSA9IGlzXzEuZGVmYXVsdC5zdHJpbmcocHJvY2Vzcy52ZXJzaW9ucy5icm90bGkpO1xuZXhwb3J0cy53aXRob3V0Qm9keSA9IG5ldyBTZXQoWydHRVQnLCAnSEVBRCddKTtcbmV4cG9ydHMua25vd25Ib29rRXZlbnRzID0gW1xuICAgICdpbml0JyxcbiAgICAnYmVmb3JlUmVxdWVzdCcsXG4gICAgJ2JlZm9yZVJlZGlyZWN0JyxcbiAgICAnYmVmb3JlRXJyb3InLFxuICAgICdiZWZvcmVSZXRyeScsXG4gICAgLy8gUHJvbWlzZS1Pbmx5XG4gICAgJ2FmdGVyUmVzcG9uc2UnXG5dO1xuZnVuY3Rpb24gdmFsaWRhdGVTZWFyY2hQYXJhbWV0ZXJzKHNlYXJjaFBhcmFtZXRlcnMpIHtcbiAgICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgZ3VhcmQtZm9yLWluXG4gICAgZm9yIChjb25zdCBrZXkgaW4gc2VhcmNoUGFyYW1ldGVycykge1xuICAgICAgICBjb25zdCB2YWx1ZSA9IHNlYXJjaFBhcmFtZXRlcnNba2V5XTtcbiAgICAgICAgaWYgKCFpc18xLmRlZmF1bHQuc3RyaW5nKHZhbHVlKSAmJiAhaXNfMS5kZWZhdWx0Lm51bWJlcih2YWx1ZSkgJiYgIWlzXzEuZGVmYXVsdC5ib29sZWFuKHZhbHVlKSAmJiAhaXNfMS5kZWZhdWx0Lm51bGxfKHZhbHVlKSAmJiAhaXNfMS5kZWZhdWx0LnVuZGVmaW5lZCh2YWx1ZSkpIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBUeXBlRXJyb3IoYFRoZSBcXGBzZWFyY2hQYXJhbXNcXGAgdmFsdWUgJyR7U3RyaW5nKHZhbHVlKX0nIG11c3QgYmUgYSBzdHJpbmcsIG51bWJlciwgYm9vbGVhbiBvciBudWxsYCk7XG4gICAgICAgIH1cbiAgICB9XG59XG5mdW5jdGlvbiBpc0NsaWVudFJlcXVlc3QoY2xpZW50UmVxdWVzdCkge1xuICAgIHJldHVybiBpc18xLmRlZmF1bHQub2JqZWN0KGNsaWVudFJlcXVlc3QpICYmICEoJ3N0YXR1c0NvZGUnIGluIGNsaWVudFJlcXVlc3QpO1xufVxuY29uc3QgY2FjaGVhYmxlU3RvcmUgPSBuZXcgd2Vha2FibGVfbWFwXzEuZGVmYXVsdCgpO1xuY29uc3Qgd2FpdEZvck9wZW5GaWxlID0gYXN5bmMgKGZpbGUpID0+IG5ldyBQcm9taXNlKChyZXNvbHZlLCByZWplY3QpID0+IHtcbiAgICBjb25zdCBvbkVycm9yID0gKGVycm9yKSA9PiB7XG4gICAgICAgIHJlamVjdChlcnJvcik7XG4gICAgfTtcbiAgICAvLyBOb2RlLmpzIDEyIGhhcyBpbmNvbXBsZXRlIHR5cGVzXG4gICAgaWYgKCFmaWxlLnBlbmRpbmcpIHtcbiAgICAgICAgcmVzb2x2ZSgpO1xuICAgIH1cbiAgICBmaWxlLm9uY2UoJ2Vycm9yJywgb25FcnJvcik7XG4gICAgZmlsZS5vbmNlKCdyZWFkeScsICgpID0+IHtcbiAgICAgICAgZmlsZS5vZmYoJ2Vycm9yJywgb25FcnJvcik7XG4gICAgICAgIHJlc29sdmUoKTtcbiAgICB9KTtcbn0pO1xuY29uc3QgcmVkaXJlY3RDb2RlcyA9IG5ldyBTZXQoWzMwMCwgMzAxLCAzMDIsIDMwMywgMzA0LCAzMDcsIDMwOF0pO1xuY29uc3Qgbm9uRW51bWVyYWJsZVByb3BlcnRpZXMgPSBbXG4gICAgJ2NvbnRleHQnLFxuICAgICdib2R5JyxcbiAgICAnanNvbicsXG4gICAgJ2Zvcm0nXG5dO1xuZXhwb3J0cy5zZXROb25FbnVtZXJhYmxlUHJvcGVydGllcyA9IChzb3VyY2VzLCB0bykgPT4ge1xuICAgIC8vIE5vbiBlbnVtZXJhYmxlIHByb3BlcnRpZXMgc2hhbGwgbm90IGJlIG1lcmdlZFxuICAgIGNvbnN0IHByb3BlcnRpZXMgPSB7fTtcbiAgICBmb3IgKGNvbnN0IHNvdXJjZSBvZiBzb3VyY2VzKSB7XG4gICAgICAgIGlmICghc291cmNlKSB7XG4gICAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgfVxuICAgICAgICBmb3IgKGNvbnN0IG5hbWUgb2Ygbm9uRW51bWVyYWJsZVByb3BlcnRpZXMpIHtcbiAgICAgICAgICAgIGlmICghKG5hbWUgaW4gc291cmNlKSkge1xuICAgICAgICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcHJvcGVydGllc1tuYW1lXSA9IHtcbiAgICAgICAgICAgICAgICB3cml0YWJsZTogdHJ1ZSxcbiAgICAgICAgICAgICAgICBjb25maWd1cmFibGU6IHRydWUsXG4gICAgICAgICAgICAgICAgZW51bWVyYWJsZTogZmFsc2UsXG4gICAgICAgICAgICAgICAgLy8gQHRzLWV4cGVjdC1lcnJvciBUUyBkb2Vzbid0IHNlZSB0aGUgY2hlY2sgYWJvdmVcbiAgICAgICAgICAgICAgICB2YWx1ZTogc291cmNlW25hbWVdXG4gICAgICAgICAgICB9O1xuICAgICAgICB9XG4gICAgfVxuICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0aWVzKHRvLCBwcm9wZXJ0aWVzKTtcbn07XG4vKipcbkFuIGVycm9yIHRvIGJlIHRocm93biB3aGVuIGEgcmVxdWVzdCBmYWlscy5cbkNvbnRhaW5zIGEgYGNvZGVgIHByb3BlcnR5IHdpdGggZXJyb3IgY2xhc3MgY29kZSwgbGlrZSBgRUNPTk5SRUZVU0VEYC5cbiovXG5jbGFzcyBSZXF1ZXN0RXJyb3IgZXh0ZW5kcyBFcnJvciB7XG4gICAgY29uc3RydWN0b3IobWVzc2FnZSwgZXJyb3IsIHNlbGYpIHtcbiAgICAgICAgdmFyIF9hLCBfYjtcbiAgICAgICAgc3VwZXIobWVzc2FnZSk7XG4gICAgICAgIEVycm9yLmNhcHR1cmVTdGFja1RyYWNlKHRoaXMsIHRoaXMuY29uc3RydWN0b3IpO1xuICAgICAgICB0aGlzLm5hbWUgPSAnUmVxdWVzdEVycm9yJztcbiAgICAgICAgdGhpcy5jb2RlID0gKF9hID0gZXJyb3IuY29kZSkgIT09IG51bGwgJiYgX2EgIT09IHZvaWQgMCA/IF9hIDogJ0VSUl9HT1RfUkVRVUVTVF9FUlJPUic7XG4gICAgICAgIGlmIChzZWxmIGluc3RhbmNlb2YgUmVxdWVzdCkge1xuICAgICAgICAgICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KHRoaXMsICdyZXF1ZXN0Jywge1xuICAgICAgICAgICAgICAgIGVudW1lcmFibGU6IGZhbHNlLFxuICAgICAgICAgICAgICAgIHZhbHVlOiBzZWxmXG4gICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eSh0aGlzLCAncmVzcG9uc2UnLCB7XG4gICAgICAgICAgICAgICAgZW51bWVyYWJsZTogZmFsc2UsXG4gICAgICAgICAgICAgICAgdmFsdWU6IHNlbGZba1Jlc3BvbnNlXVxuICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkodGhpcywgJ29wdGlvbnMnLCB7XG4gICAgICAgICAgICAgICAgLy8gVGhpcyBmYWlscyBiZWNhdXNlIG9mIFRTIDMuNy4yIHVzZURlZmluZUZvckNsYXNzRmllbGRzXG4gICAgICAgICAgICAgICAgLy8gUmVmOiBodHRwczovL2dpdGh1Yi5jb20vbWljcm9zb2Z0L1R5cGVTY3JpcHQvaXNzdWVzLzM0OTcyXG4gICAgICAgICAgICAgICAgZW51bWVyYWJsZTogZmFsc2UsXG4gICAgICAgICAgICAgICAgdmFsdWU6IHNlbGYub3B0aW9uc1xuICAgICAgICAgICAgfSk7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkodGhpcywgJ29wdGlvbnMnLCB7XG4gICAgICAgICAgICAgICAgLy8gVGhpcyBmYWlscyBiZWNhdXNlIG9mIFRTIDMuNy4yIHVzZURlZmluZUZvckNsYXNzRmllbGRzXG4gICAgICAgICAgICAgICAgLy8gUmVmOiBodHRwczovL2dpdGh1Yi5jb20vbWljcm9zb2Z0L1R5cGVTY3JpcHQvaXNzdWVzLzM0OTcyXG4gICAgICAgICAgICAgICAgZW51bWVyYWJsZTogZmFsc2UsXG4gICAgICAgICAgICAgICAgdmFsdWU6IHNlbGZcbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9XG4gICAgICAgIHRoaXMudGltaW5ncyA9IChfYiA9IHRoaXMucmVxdWVzdCkgPT09IG51bGwgfHwgX2IgPT09IHZvaWQgMCA/IHZvaWQgMCA6IF9iLnRpbWluZ3M7XG4gICAgICAgIC8vIFJlY292ZXIgdGhlIG9yaWdpbmFsIHN0YWNrdHJhY2VcbiAgICAgICAgaWYgKGlzXzEuZGVmYXVsdC5zdHJpbmcoZXJyb3Iuc3RhY2spICYmIGlzXzEuZGVmYXVsdC5zdHJpbmcodGhpcy5zdGFjaykpIHtcbiAgICAgICAgICAgIGNvbnN0IGluZGV4T2ZNZXNzYWdlID0gdGhpcy5zdGFjay5pbmRleE9mKHRoaXMubWVzc2FnZSkgKyB0aGlzLm1lc3NhZ2UubGVuZ3RoO1xuICAgICAgICAgICAgY29uc3QgdGhpc1N0YWNrVHJhY2UgPSB0aGlzLnN0YWNrLnNsaWNlKGluZGV4T2ZNZXNzYWdlKS5zcGxpdCgnXFxuJykucmV2ZXJzZSgpO1xuICAgICAgICAgICAgY29uc3QgZXJyb3JTdGFja1RyYWNlID0gZXJyb3Iuc3RhY2suc2xpY2UoZXJyb3Iuc3RhY2suaW5kZXhPZihlcnJvci5tZXNzYWdlKSArIGVycm9yLm1lc3NhZ2UubGVuZ3RoKS5zcGxpdCgnXFxuJykucmV2ZXJzZSgpO1xuICAgICAgICAgICAgLy8gUmVtb3ZlIGR1cGxpY2F0ZWQgdHJhY2VzXG4gICAgICAgICAgICB3aGlsZSAoZXJyb3JTdGFja1RyYWNlLmxlbmd0aCAhPT0gMCAmJiBlcnJvclN0YWNrVHJhY2VbMF0gPT09IHRoaXNTdGFja1RyYWNlWzBdKSB7XG4gICAgICAgICAgICAgICAgdGhpc1N0YWNrVHJhY2Uuc2hpZnQoKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHRoaXMuc3RhY2sgPSBgJHt0aGlzLnN0YWNrLnNsaWNlKDAsIGluZGV4T2ZNZXNzYWdlKX0ke3RoaXNTdGFja1RyYWNlLnJldmVyc2UoKS5qb2luKCdcXG4nKX0ke2Vycm9yU3RhY2tUcmFjZS5yZXZlcnNlKCkuam9pbignXFxuJyl9YDtcbiAgICAgICAgfVxuICAgIH1cbn1cbmV4cG9ydHMuUmVxdWVzdEVycm9yID0gUmVxdWVzdEVycm9yO1xuLyoqXG5BbiBlcnJvciB0byBiZSB0aHJvd24gd2hlbiB0aGUgc2VydmVyIHJlZGlyZWN0cyB5b3UgbW9yZSB0aGFuIHRlbiB0aW1lcy5cbkluY2x1ZGVzIGEgYHJlc3BvbnNlYCBwcm9wZXJ0eS5cbiovXG5jbGFzcyBNYXhSZWRpcmVjdHNFcnJvciBleHRlbmRzIFJlcXVlc3RFcnJvciB7XG4gICAgY29uc3RydWN0b3IocmVxdWVzdCkge1xuICAgICAgICBzdXBlcihgUmVkaXJlY3RlZCAke3JlcXVlc3Qub3B0aW9ucy5tYXhSZWRpcmVjdHN9IHRpbWVzLiBBYm9ydGluZy5gLCB7fSwgcmVxdWVzdCk7XG4gICAgICAgIHRoaXMubmFtZSA9ICdNYXhSZWRpcmVjdHNFcnJvcic7XG4gICAgICAgIHRoaXMuY29kZSA9ICdFUlJfVE9PX01BTllfUkVESVJFQ1RTJztcbiAgICB9XG59XG5leHBvcnRzLk1heFJlZGlyZWN0c0Vycm9yID0gTWF4UmVkaXJlY3RzRXJyb3I7XG4vKipcbkFuIGVycm9yIHRvIGJlIHRocm93biB3aGVuIHRoZSBzZXJ2ZXIgcmVzcG9uc2UgY29kZSBpcyBub3QgMnh4IG5vciAzeHggaWYgYG9wdGlvbnMuZm9sbG93UmVkaXJlY3RgIGlzIGB0cnVlYCwgYnV0IGFsd2F5cyBleGNlcHQgZm9yIDMwNC5cbkluY2x1ZGVzIGEgYHJlc3BvbnNlYCBwcm9wZXJ0eS5cbiovXG5jbGFzcyBIVFRQRXJyb3IgZXh0ZW5kcyBSZXF1ZXN0RXJyb3Ige1xuICAgIGNvbnN0cnVjdG9yKHJlc3BvbnNlKSB7XG4gICAgICAgIHN1cGVyKGBSZXNwb25zZSBjb2RlICR7cmVzcG9uc2Uuc3RhdHVzQ29kZX0gKCR7cmVzcG9uc2Uuc3RhdHVzTWVzc2FnZX0pYCwge30sIHJlc3BvbnNlLnJlcXVlc3QpO1xuICAgICAgICB0aGlzLm5hbWUgPSAnSFRUUEVycm9yJztcbiAgICAgICAgdGhpcy5jb2RlID0gJ0VSUl9OT05fMlhYXzNYWF9SRVNQT05TRSc7XG4gICAgfVxufVxuZXhwb3J0cy5IVFRQRXJyb3IgPSBIVFRQRXJyb3I7XG4vKipcbkFuIGVycm9yIHRvIGJlIHRocm93biB3aGVuIGEgY2FjaGUgbWV0aG9kIGZhaWxzLlxuRm9yIGV4YW1wbGUsIGlmIHRoZSBkYXRhYmFzZSBnb2VzIGRvd24gb3IgdGhlcmUncyBhIGZpbGVzeXN0ZW0gZXJyb3IuXG4qL1xuY2xhc3MgQ2FjaGVFcnJvciBleHRlbmRzIFJlcXVlc3RFcnJvciB7XG4gICAgY29uc3RydWN0b3IoZXJyb3IsIHJlcXVlc3QpIHtcbiAgICAgICAgc3VwZXIoZXJyb3IubWVzc2FnZSwgZXJyb3IsIHJlcXVlc3QpO1xuICAgICAgICB0aGlzLm5hbWUgPSAnQ2FjaGVFcnJvcic7XG4gICAgICAgIHRoaXMuY29kZSA9IHRoaXMuY29kZSA9PT0gJ0VSUl9HT1RfUkVRVUVTVF9FUlJPUicgPyAnRVJSX0NBQ0hFX0FDQ0VTUycgOiB0aGlzLmNvZGU7XG4gICAgfVxufVxuZXhwb3J0cy5DYWNoZUVycm9yID0gQ2FjaGVFcnJvcjtcbi8qKlxuQW4gZXJyb3IgdG8gYmUgdGhyb3duIHdoZW4gdGhlIHJlcXVlc3QgYm9keSBpcyBhIHN0cmVhbSBhbmQgYW4gZXJyb3Igb2NjdXJzIHdoaWxlIHJlYWRpbmcgZnJvbSB0aGF0IHN0cmVhbS5cbiovXG5jbGFzcyBVcGxvYWRFcnJvciBleHRlbmRzIFJlcXVlc3RFcnJvciB7XG4gICAgY29uc3RydWN0b3IoZXJyb3IsIHJlcXVlc3QpIHtcbiAgICAgICAgc3VwZXIoZXJyb3IubWVzc2FnZSwgZXJyb3IsIHJlcXVlc3QpO1xuICAgICAgICB0aGlzLm5hbWUgPSAnVXBsb2FkRXJyb3InO1xuICAgICAgICB0aGlzLmNvZGUgPSB0aGlzLmNvZGUgPT09ICdFUlJfR09UX1JFUVVFU1RfRVJST1InID8gJ0VSUl9VUExPQUQnIDogdGhpcy5jb2RlO1xuICAgIH1cbn1cbmV4cG9ydHMuVXBsb2FkRXJyb3IgPSBVcGxvYWRFcnJvcjtcbi8qKlxuQW4gZXJyb3IgdG8gYmUgdGhyb3duIHdoZW4gdGhlIHJlcXVlc3QgaXMgYWJvcnRlZCBkdWUgdG8gYSB0aW1lb3V0LlxuSW5jbHVkZXMgYW4gYGV2ZW50YCBhbmQgYHRpbWluZ3NgIHByb3BlcnR5LlxuKi9cbmNsYXNzIFRpbWVvdXRFcnJvciBleHRlbmRzIFJlcXVlc3RFcnJvciB7XG4gICAgY29uc3RydWN0b3IoZXJyb3IsIHRpbWluZ3MsIHJlcXVlc3QpIHtcbiAgICAgICAgc3VwZXIoZXJyb3IubWVzc2FnZSwgZXJyb3IsIHJlcXVlc3QpO1xuICAgICAgICB0aGlzLm5hbWUgPSAnVGltZW91dEVycm9yJztcbiAgICAgICAgdGhpcy5ldmVudCA9IGVycm9yLmV2ZW50O1xuICAgICAgICB0aGlzLnRpbWluZ3MgPSB0aW1pbmdzO1xuICAgIH1cbn1cbmV4cG9ydHMuVGltZW91dEVycm9yID0gVGltZW91dEVycm9yO1xuLyoqXG5BbiBlcnJvciB0byBiZSB0aHJvd24gd2hlbiByZWFkaW5nIGZyb20gcmVzcG9uc2Ugc3RyZWFtIGZhaWxzLlxuKi9cbmNsYXNzIFJlYWRFcnJvciBleHRlbmRzIFJlcXVlc3RFcnJvciB7XG4gICAgY29uc3RydWN0b3IoZXJyb3IsIHJlcXVlc3QpIHtcbiAgICAgICAgc3VwZXIoZXJyb3IubWVzc2FnZSwgZXJyb3IsIHJlcXVlc3QpO1xuICAgICAgICB0aGlzLm5hbWUgPSAnUmVhZEVycm9yJztcbiAgICAgICAgdGhpcy5jb2RlID0gdGhpcy5jb2RlID09PSAnRVJSX0dPVF9SRVFVRVNUX0VSUk9SJyA/ICdFUlJfUkVBRElOR19SRVNQT05TRV9TVFJFQU0nIDogdGhpcy5jb2RlO1xuICAgIH1cbn1cbmV4cG9ydHMuUmVhZEVycm9yID0gUmVhZEVycm9yO1xuLyoqXG5BbiBlcnJvciB0byBiZSB0aHJvd24gd2hlbiBnaXZlbiBhbiB1bnN1cHBvcnRlZCBwcm90b2NvbC5cbiovXG5jbGFzcyBVbnN1cHBvcnRlZFByb3RvY29sRXJyb3IgZXh0ZW5kcyBSZXF1ZXN0RXJyb3Ige1xuICAgIGNvbnN0cnVjdG9yKG9wdGlvbnMpIHtcbiAgICAgICAgc3VwZXIoYFVuc3VwcG9ydGVkIHByb3RvY29sIFwiJHtvcHRpb25zLnVybC5wcm90b2NvbH1cImAsIHt9LCBvcHRpb25zKTtcbiAgICAgICAgdGhpcy5uYW1lID0gJ1Vuc3VwcG9ydGVkUHJvdG9jb2xFcnJvcic7XG4gICAgICAgIHRoaXMuY29kZSA9ICdFUlJfVU5TVVBQT1JURURfUFJPVE9DT0wnO1xuICAgIH1cbn1cbmV4cG9ydHMuVW5zdXBwb3J0ZWRQcm90b2NvbEVycm9yID0gVW5zdXBwb3J0ZWRQcm90b2NvbEVycm9yO1xuY29uc3QgcHJveGllZFJlcXVlc3RFdmVudHMgPSBbXG4gICAgJ3NvY2tldCcsXG4gICAgJ2Nvbm5lY3QnLFxuICAgICdjb250aW51ZScsXG4gICAgJ2luZm9ybWF0aW9uJyxcbiAgICAndXBncmFkZScsXG4gICAgJ3RpbWVvdXQnXG5dO1xuY2xhc3MgUmVxdWVzdCBleHRlbmRzIHN0cmVhbV8xLkR1cGxleCB7XG4gICAgY29uc3RydWN0b3IodXJsLCBvcHRpb25zID0ge30sIGRlZmF1bHRzKSB7XG4gICAgICAgIHN1cGVyKHtcbiAgICAgICAgICAgIC8vIFRoaXMgbXVzdCBiZSBmYWxzZSwgdG8gZW5hYmxlIHRocm93aW5nIGFmdGVyIGRlc3Ryb3lcbiAgICAgICAgICAgIC8vIEl0IGlzIHVzZWQgZm9yIHJldHJ5IGxvZ2ljIGluIFByb21pc2UgQVBJXG4gICAgICAgICAgICBhdXRvRGVzdHJveTogZmFsc2UsXG4gICAgICAgICAgICAvLyBJdCBuZWVkcyB0byBiZSB6ZXJvIGJlY2F1c2Ugd2UncmUganVzdCBwcm94eWluZyB0aGUgZGF0YSB0byBhbm90aGVyIHN0cmVhbVxuICAgICAgICAgICAgaGlnaFdhdGVyTWFyazogMFxuICAgICAgICB9KTtcbiAgICAgICAgdGhpc1trRG93bmxvYWRlZFNpemVdID0gMDtcbiAgICAgICAgdGhpc1trVXBsb2FkZWRTaXplXSA9IDA7XG4gICAgICAgIHRoaXMucmVxdWVzdEluaXRpYWxpemVkID0gZmFsc2U7XG4gICAgICAgIHRoaXNba1NlcnZlclJlc3BvbnNlc1BpcGVkXSA9IG5ldyBTZXQoKTtcbiAgICAgICAgdGhpcy5yZWRpcmVjdHMgPSBbXTtcbiAgICAgICAgdGhpc1trU3RvcFJlYWRpbmddID0gZmFsc2U7XG4gICAgICAgIHRoaXNba1RyaWdnZXJSZWFkXSA9IGZhbHNlO1xuICAgICAgICB0aGlzW2tKb2JzXSA9IFtdO1xuICAgICAgICB0aGlzLnJldHJ5Q291bnQgPSAwO1xuICAgICAgICAvLyBUT0RPOiBSZW1vdmUgdGhpcyB3aGVuIHRhcmdldGluZyBOb2RlLmpzID49IDEyXG4gICAgICAgIHRoaXMuX3Byb2dyZXNzQ2FsbGJhY2tzID0gW107XG4gICAgICAgIGNvbnN0IHVubG9ja1dyaXRlID0gKCkgPT4gdGhpcy5fdW5sb2NrV3JpdGUoKTtcbiAgICAgICAgY29uc3QgbG9ja1dyaXRlID0gKCkgPT4gdGhpcy5fbG9ja1dyaXRlKCk7XG4gICAgICAgIHRoaXMub24oJ3BpcGUnLCAoc291cmNlKSA9PiB7XG4gICAgICAgICAgICBzb3VyY2UucHJlcGVuZExpc3RlbmVyKCdkYXRhJywgdW5sb2NrV3JpdGUpO1xuICAgICAgICAgICAgc291cmNlLm9uKCdkYXRhJywgbG9ja1dyaXRlKTtcbiAgICAgICAgICAgIHNvdXJjZS5wcmVwZW5kTGlzdGVuZXIoJ2VuZCcsIHVubG9ja1dyaXRlKTtcbiAgICAgICAgICAgIHNvdXJjZS5vbignZW5kJywgbG9ja1dyaXRlKTtcbiAgICAgICAgfSk7XG4gICAgICAgIHRoaXMub24oJ3VucGlwZScsIChzb3VyY2UpID0+IHtcbiAgICAgICAgICAgIHNvdXJjZS5vZmYoJ2RhdGEnLCB1bmxvY2tXcml0ZSk7XG4gICAgICAgICAgICBzb3VyY2Uub2ZmKCdkYXRhJywgbG9ja1dyaXRlKTtcbiAgICAgICAgICAgIHNvdXJjZS5vZmYoJ2VuZCcsIHVubG9ja1dyaXRlKTtcbiAgICAgICAgICAgIHNvdXJjZS5vZmYoJ2VuZCcsIGxvY2tXcml0ZSk7XG4gICAgICAgIH0pO1xuICAgICAgICB0aGlzLm9uKCdwaXBlJywgc291cmNlID0+IHtcbiAgICAgICAgICAgIGlmIChzb3VyY2UgaW5zdGFuY2VvZiBodHRwXzEuSW5jb21pbmdNZXNzYWdlKSB7XG4gICAgICAgICAgICAgICAgdGhpcy5vcHRpb25zLmhlYWRlcnMgPSB7XG4gICAgICAgICAgICAgICAgICAgIC4uLnNvdXJjZS5oZWFkZXJzLFxuICAgICAgICAgICAgICAgICAgICAuLi50aGlzLm9wdGlvbnMuaGVhZGVyc1xuICAgICAgICAgICAgICAgIH07XG4gICAgICAgICAgICB9XG4gICAgICAgIH0pO1xuICAgICAgICBjb25zdCB7IGpzb24sIGJvZHksIGZvcm0gfSA9IG9wdGlvbnM7XG4gICAgICAgIGlmIChqc29uIHx8IGJvZHkgfHwgZm9ybSkge1xuICAgICAgICAgICAgdGhpcy5fbG9ja1dyaXRlKCk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKGV4cG9ydHMua0lzTm9ybWFsaXplZEFscmVhZHkgaW4gb3B0aW9ucykge1xuICAgICAgICAgICAgdGhpcy5vcHRpb25zID0gb3B0aW9ucztcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIHRyeSB7XG4gICAgICAgICAgICAgICAgLy8gQHRzLWV4cGVjdC1lcnJvciBDb21tb24gVHlwZVNjcmlwdCBidWcgc2F5aW5nIHRoYXQgYHRoaXMuY29uc3RydWN0b3JgIGlzIG5vdCBhY2Nlc3NpYmxlXG4gICAgICAgICAgICAgICAgdGhpcy5vcHRpb25zID0gdGhpcy5jb25zdHJ1Y3Rvci5ub3JtYWxpemVBcmd1bWVudHModXJsLCBvcHRpb25zLCBkZWZhdWx0cyk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBjYXRjaCAoZXJyb3IpIHtcbiAgICAgICAgICAgICAgICAvLyBUT0RPOiBNb3ZlIHRoaXMgdG8gYF9kZXN0cm95KClgXG4gICAgICAgICAgICAgICAgaWYgKGlzXzEuZGVmYXVsdC5ub2RlU3RyZWFtKG9wdGlvbnMuYm9keSkpIHtcbiAgICAgICAgICAgICAgICAgICAgb3B0aW9ucy5ib2R5LmRlc3Ryb3koKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgdGhpcy5kZXN0cm95KGVycm9yKTtcbiAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgKGFzeW5jICgpID0+IHtcbiAgICAgICAgICAgIHZhciBfYTtcbiAgICAgICAgICAgIHRyeSB7XG4gICAgICAgICAgICAgICAgaWYgKHRoaXMub3B0aW9ucy5ib2R5IGluc3RhbmNlb2YgZnNfMS5SZWFkU3RyZWFtKSB7XG4gICAgICAgICAgICAgICAgICAgIGF3YWl0IHdhaXRGb3JPcGVuRmlsZSh0aGlzLm9wdGlvbnMuYm9keSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGNvbnN0IHsgdXJsOiBub3JtYWxpemVkVVJMIH0gPSB0aGlzLm9wdGlvbnM7XG4gICAgICAgICAgICAgICAgaWYgKCFub3JtYWxpemVkVVJMKSB7XG4gICAgICAgICAgICAgICAgICAgIHRocm93IG5ldyBUeXBlRXJyb3IoJ01pc3NpbmcgYHVybGAgcHJvcGVydHknKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgdGhpcy5yZXF1ZXN0VXJsID0gbm9ybWFsaXplZFVSTC50b1N0cmluZygpO1xuICAgICAgICAgICAgICAgIGRlY29kZVVSSSh0aGlzLnJlcXVlc3RVcmwpO1xuICAgICAgICAgICAgICAgIGF3YWl0IHRoaXMuX2ZpbmFsaXplQm9keSgpO1xuICAgICAgICAgICAgICAgIGF3YWl0IHRoaXMuX21ha2VSZXF1ZXN0KCk7XG4gICAgICAgICAgICAgICAgaWYgKHRoaXMuZGVzdHJveWVkKSB7XG4gICAgICAgICAgICAgICAgICAgIChfYSA9IHRoaXNba1JlcXVlc3RdKSA9PT0gbnVsbCB8fCBfYSA9PT0gdm9pZCAwID8gdm9pZCAwIDogX2EuZGVzdHJveSgpO1xuICAgICAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIC8vIFF1ZXVlZCB3cml0ZXMgZXRjLlxuICAgICAgICAgICAgICAgIGZvciAoY29uc3Qgam9iIG9mIHRoaXNba0pvYnNdKSB7XG4gICAgICAgICAgICAgICAgICAgIGpvYigpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAvLyBQcmV2ZW50IG1lbW9yeSBsZWFrXG4gICAgICAgICAgICAgICAgdGhpc1trSm9ic10ubGVuZ3RoID0gMDtcbiAgICAgICAgICAgICAgICB0aGlzLnJlcXVlc3RJbml0aWFsaXplZCA9IHRydWU7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBjYXRjaCAoZXJyb3IpIHtcbiAgICAgICAgICAgICAgICBpZiAoZXJyb3IgaW5zdGFuY2VvZiBSZXF1ZXN0RXJyb3IpIHtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5fYmVmb3JlRXJyb3IoZXJyb3IpO1xuICAgICAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIC8vIFRoaXMgaXMgYSB3b3JrYXJvdW5kIGZvciBodHRwczovL2dpdGh1Yi5jb20vbm9kZWpzL25vZGUvaXNzdWVzLzMzMzM1XG4gICAgICAgICAgICAgICAgaWYgKCF0aGlzLmRlc3Ryb3llZCkge1xuICAgICAgICAgICAgICAgICAgICB0aGlzLmRlc3Ryb3koZXJyb3IpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgfSkoKTtcbiAgICB9XG4gICAgc3RhdGljIG5vcm1hbGl6ZUFyZ3VtZW50cyh1cmwsIG9wdGlvbnMsIGRlZmF1bHRzKSB7XG4gICAgICAgIHZhciBfYSwgX2IsIF9jLCBfZCwgX2U7XG4gICAgICAgIGNvbnN0IHJhd09wdGlvbnMgPSBvcHRpb25zO1xuICAgICAgICBpZiAoaXNfMS5kZWZhdWx0Lm9iamVjdCh1cmwpICYmICFpc18xLmRlZmF1bHQudXJsSW5zdGFuY2UodXJsKSkge1xuICAgICAgICAgICAgb3B0aW9ucyA9IHsgLi4uZGVmYXVsdHMsIC4uLnVybCwgLi4ub3B0aW9ucyB9O1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgaWYgKHVybCAmJiBvcHRpb25zICYmIG9wdGlvbnMudXJsICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgICAgICB0aHJvdyBuZXcgVHlwZUVycm9yKCdUaGUgYHVybGAgb3B0aW9uIGlzIG11dHVhbGx5IGV4Y2x1c2l2ZSB3aXRoIHRoZSBgaW5wdXRgIGFyZ3VtZW50Jyk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBvcHRpb25zID0geyAuLi5kZWZhdWx0cywgLi4ub3B0aW9ucyB9O1xuICAgICAgICAgICAgaWYgKHVybCAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICAgICAgb3B0aW9ucy51cmwgPSB1cmw7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAoaXNfMS5kZWZhdWx0LnVybEluc3RhbmNlKG9wdGlvbnMudXJsKSkge1xuICAgICAgICAgICAgICAgIG9wdGlvbnMudXJsID0gbmV3IHVybF8xLlVSTChvcHRpb25zLnVybC50b1N0cmluZygpKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICAvLyBUT0RPOiBEZXByZWNhdGUgVVJMIG9wdGlvbnMgaW4gR290IDEyLlxuICAgICAgICAvLyBTdXBwb3J0IGV4dGVuZC1zcGVjaWZpYyBvcHRpb25zXG4gICAgICAgIGlmIChvcHRpb25zLmNhY2hlID09PSBmYWxzZSkge1xuICAgICAgICAgICAgb3B0aW9ucy5jYWNoZSA9IHVuZGVmaW5lZDtcbiAgICAgICAgfVxuICAgICAgICBpZiAob3B0aW9ucy5kbnNDYWNoZSA9PT0gZmFsc2UpIHtcbiAgICAgICAgICAgIG9wdGlvbnMuZG5zQ2FjaGUgPSB1bmRlZmluZWQ7XG4gICAgICAgIH1cbiAgICAgICAgLy8gTmljZSB0eXBlIGFzc2VydGlvbnNcbiAgICAgICAgaXNfMS5hc3NlcnQuYW55KFtpc18xLmRlZmF1bHQuc3RyaW5nLCBpc18xLmRlZmF1bHQudW5kZWZpbmVkXSwgb3B0aW9ucy5tZXRob2QpO1xuICAgICAgICBpc18xLmFzc2VydC5hbnkoW2lzXzEuZGVmYXVsdC5vYmplY3QsIGlzXzEuZGVmYXVsdC51bmRlZmluZWRdLCBvcHRpb25zLmhlYWRlcnMpO1xuICAgICAgICBpc18xLmFzc2VydC5hbnkoW2lzXzEuZGVmYXVsdC5zdHJpbmcsIGlzXzEuZGVmYXVsdC51cmxJbnN0YW5jZSwgaXNfMS5kZWZhdWx0LnVuZGVmaW5lZF0sIG9wdGlvbnMucHJlZml4VXJsKTtcbiAgICAgICAgaXNfMS5hc3NlcnQuYW55KFtpc18xLmRlZmF1bHQub2JqZWN0LCBpc18xLmRlZmF1bHQudW5kZWZpbmVkXSwgb3B0aW9ucy5jb29raWVKYXIpO1xuICAgICAgICBpc18xLmFzc2VydC5hbnkoW2lzXzEuZGVmYXVsdC5vYmplY3QsIGlzXzEuZGVmYXVsdC5zdHJpbmcsIGlzXzEuZGVmYXVsdC51bmRlZmluZWRdLCBvcHRpb25zLnNlYXJjaFBhcmFtcyk7XG4gICAgICAgIGlzXzEuYXNzZXJ0LmFueShbaXNfMS5kZWZhdWx0Lm9iamVjdCwgaXNfMS5kZWZhdWx0LnN0cmluZywgaXNfMS5kZWZhdWx0LnVuZGVmaW5lZF0sIG9wdGlvbnMuY2FjaGUpO1xuICAgICAgICBpc18xLmFzc2VydC5hbnkoW2lzXzEuZGVmYXVsdC5vYmplY3QsIGlzXzEuZGVmYXVsdC5udW1iZXIsIGlzXzEuZGVmYXVsdC51bmRlZmluZWRdLCBvcHRpb25zLnRpbWVvdXQpO1xuICAgICAgICBpc18xLmFzc2VydC5hbnkoW2lzXzEuZGVmYXVsdC5vYmplY3QsIGlzXzEuZGVmYXVsdC51bmRlZmluZWRdLCBvcHRpb25zLmNvbnRleHQpO1xuICAgICAgICBpc18xLmFzc2VydC5hbnkoW2lzXzEuZGVmYXVsdC5vYmplY3QsIGlzXzEuZGVmYXVsdC51bmRlZmluZWRdLCBvcHRpb25zLmhvb2tzKTtcbiAgICAgICAgaXNfMS5hc3NlcnQuYW55KFtpc18xLmRlZmF1bHQuYm9vbGVhbiwgaXNfMS5kZWZhdWx0LnVuZGVmaW5lZF0sIG9wdGlvbnMuZGVjb21wcmVzcyk7XG4gICAgICAgIGlzXzEuYXNzZXJ0LmFueShbaXNfMS5kZWZhdWx0LmJvb2xlYW4sIGlzXzEuZGVmYXVsdC51bmRlZmluZWRdLCBvcHRpb25zLmlnbm9yZUludmFsaWRDb29raWVzKTtcbiAgICAgICAgaXNfMS5hc3NlcnQuYW55KFtpc18xLmRlZmF1bHQuYm9vbGVhbiwgaXNfMS5kZWZhdWx0LnVuZGVmaW5lZF0sIG9wdGlvbnMuZm9sbG93UmVkaXJlY3QpO1xuICAgICAgICBpc18xLmFzc2VydC5hbnkoW2lzXzEuZGVmYXVsdC5udW1iZXIsIGlzXzEuZGVmYXVsdC51bmRlZmluZWRdLCBvcHRpb25zLm1heFJlZGlyZWN0cyk7XG4gICAgICAgIGlzXzEuYXNzZXJ0LmFueShbaXNfMS5kZWZhdWx0LmJvb2xlYW4sIGlzXzEuZGVmYXVsdC51bmRlZmluZWRdLCBvcHRpb25zLnRocm93SHR0cEVycm9ycyk7XG4gICAgICAgIGlzXzEuYXNzZXJ0LmFueShbaXNfMS5kZWZhdWx0LmJvb2xlYW4sIGlzXzEuZGVmYXVsdC51bmRlZmluZWRdLCBvcHRpb25zLmh0dHAyKTtcbiAgICAgICAgaXNfMS5hc3NlcnQuYW55KFtpc18xLmRlZmF1bHQuYm9vbGVhbiwgaXNfMS5kZWZhdWx0LnVuZGVmaW5lZF0sIG9wdGlvbnMuYWxsb3dHZXRCb2R5KTtcbiAgICAgICAgaXNfMS5hc3NlcnQuYW55KFtpc18xLmRlZmF1bHQuc3RyaW5nLCBpc18xLmRlZmF1bHQudW5kZWZpbmVkXSwgb3B0aW9ucy5sb2NhbEFkZHJlc3MpO1xuICAgICAgICBpc18xLmFzc2VydC5hbnkoW2Ruc19pcF92ZXJzaW9uXzEuaXNEbnNMb29rdXBJcFZlcnNpb24sIGlzXzEuZGVmYXVsdC51bmRlZmluZWRdLCBvcHRpb25zLmRuc0xvb2t1cElwVmVyc2lvbik7XG4gICAgICAgIGlzXzEuYXNzZXJ0LmFueShbaXNfMS5kZWZhdWx0Lm9iamVjdCwgaXNfMS5kZWZhdWx0LnVuZGVmaW5lZF0sIG9wdGlvbnMuaHR0cHMpO1xuICAgICAgICBpc18xLmFzc2VydC5hbnkoW2lzXzEuZGVmYXVsdC5ib29sZWFuLCBpc18xLmRlZmF1bHQudW5kZWZpbmVkXSwgb3B0aW9ucy5yZWplY3RVbmF1dGhvcml6ZWQpO1xuICAgICAgICBpZiAob3B0aW9ucy5odHRwcykge1xuICAgICAgICAgICAgaXNfMS5hc3NlcnQuYW55KFtpc18xLmRlZmF1bHQuYm9vbGVhbiwgaXNfMS5kZWZhdWx0LnVuZGVmaW5lZF0sIG9wdGlvbnMuaHR0cHMucmVqZWN0VW5hdXRob3JpemVkKTtcbiAgICAgICAgICAgIGlzXzEuYXNzZXJ0LmFueShbaXNfMS5kZWZhdWx0LmZ1bmN0aW9uXywgaXNfMS5kZWZhdWx0LnVuZGVmaW5lZF0sIG9wdGlvbnMuaHR0cHMuY2hlY2tTZXJ2ZXJJZGVudGl0eSk7XG4gICAgICAgICAgICBpc18xLmFzc2VydC5hbnkoW2lzXzEuZGVmYXVsdC5zdHJpbmcsIGlzXzEuZGVmYXVsdC5vYmplY3QsIGlzXzEuZGVmYXVsdC5hcnJheSwgaXNfMS5kZWZhdWx0LnVuZGVmaW5lZF0sIG9wdGlvbnMuaHR0cHMuY2VydGlmaWNhdGVBdXRob3JpdHkpO1xuICAgICAgICAgICAgaXNfMS5hc3NlcnQuYW55KFtpc18xLmRlZmF1bHQuc3RyaW5nLCBpc18xLmRlZmF1bHQub2JqZWN0LCBpc18xLmRlZmF1bHQuYXJyYXksIGlzXzEuZGVmYXVsdC51bmRlZmluZWRdLCBvcHRpb25zLmh0dHBzLmtleSk7XG4gICAgICAgICAgICBpc18xLmFzc2VydC5hbnkoW2lzXzEuZGVmYXVsdC5zdHJpbmcsIGlzXzEuZGVmYXVsdC5vYmplY3QsIGlzXzEuZGVmYXVsdC5hcnJheSwgaXNfMS5kZWZhdWx0LnVuZGVmaW5lZF0sIG9wdGlvbnMuaHR0cHMuY2VydGlmaWNhdGUpO1xuICAgICAgICAgICAgaXNfMS5hc3NlcnQuYW55KFtpc18xLmRlZmF1bHQuc3RyaW5nLCBpc18xLmRlZmF1bHQudW5kZWZpbmVkXSwgb3B0aW9ucy5odHRwcy5wYXNzcGhyYXNlKTtcbiAgICAgICAgICAgIGlzXzEuYXNzZXJ0LmFueShbaXNfMS5kZWZhdWx0LnN0cmluZywgaXNfMS5kZWZhdWx0LmJ1ZmZlciwgaXNfMS5kZWZhdWx0LmFycmF5LCBpc18xLmRlZmF1bHQudW5kZWZpbmVkXSwgb3B0aW9ucy5odHRwcy5wZngpO1xuICAgICAgICB9XG4gICAgICAgIGlzXzEuYXNzZXJ0LmFueShbaXNfMS5kZWZhdWx0Lm9iamVjdCwgaXNfMS5kZWZhdWx0LnVuZGVmaW5lZF0sIG9wdGlvbnMuY2FjaGVPcHRpb25zKTtcbiAgICAgICAgLy8gYG9wdGlvbnMubWV0aG9kYFxuICAgICAgICBpZiAoaXNfMS5kZWZhdWx0LnN0cmluZyhvcHRpb25zLm1ldGhvZCkpIHtcbiAgICAgICAgICAgIG9wdGlvbnMubWV0aG9kID0gb3B0aW9ucy5tZXRob2QudG9VcHBlckNhc2UoKTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIG9wdGlvbnMubWV0aG9kID0gJ0dFVCc7XG4gICAgICAgIH1cbiAgICAgICAgLy8gYG9wdGlvbnMuaGVhZGVyc2BcbiAgICAgICAgaWYgKG9wdGlvbnMuaGVhZGVycyA9PT0gKGRlZmF1bHRzID09PSBudWxsIHx8IGRlZmF1bHRzID09PSB2b2lkIDAgPyB2b2lkIDAgOiBkZWZhdWx0cy5oZWFkZXJzKSkge1xuICAgICAgICAgICAgb3B0aW9ucy5oZWFkZXJzID0geyAuLi5vcHRpb25zLmhlYWRlcnMgfTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIG9wdGlvbnMuaGVhZGVycyA9IGxvd2VyY2FzZUtleXMoeyAuLi4oZGVmYXVsdHMgPT09IG51bGwgfHwgZGVmYXVsdHMgPT09IHZvaWQgMCA/IHZvaWQgMCA6IGRlZmF1bHRzLmhlYWRlcnMpLCAuLi5vcHRpb25zLmhlYWRlcnMgfSk7XG4gICAgICAgIH1cbiAgICAgICAgLy8gRGlzYWxsb3cgbGVnYWN5IGB1cmwuVXJsYFxuICAgICAgICBpZiAoJ3NsYXNoZXMnIGluIG9wdGlvbnMpIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBUeXBlRXJyb3IoJ1RoZSBsZWdhY3kgYHVybC5VcmxgIGhhcyBiZWVuIGRlcHJlY2F0ZWQuIFVzZSBgVVJMYCBpbnN0ZWFkLicpO1xuICAgICAgICB9XG4gICAgICAgIC8vIGBvcHRpb25zLmF1dGhgXG4gICAgICAgIGlmICgnYXV0aCcgaW4gb3B0aW9ucykge1xuICAgICAgICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvcignUGFyYW1ldGVyIGBhdXRoYCBpcyBkZXByZWNhdGVkLiBVc2UgYHVzZXJuYW1lYCAvIGBwYXNzd29yZGAgaW5zdGVhZC4nKTtcbiAgICAgICAgfVxuICAgICAgICAvLyBgb3B0aW9ucy5zZWFyY2hQYXJhbXNgXG4gICAgICAgIGlmICgnc2VhcmNoUGFyYW1zJyBpbiBvcHRpb25zKSB7XG4gICAgICAgICAgICBpZiAob3B0aW9ucy5zZWFyY2hQYXJhbXMgJiYgb3B0aW9ucy5zZWFyY2hQYXJhbXMgIT09IChkZWZhdWx0cyA9PT0gbnVsbCB8fCBkZWZhdWx0cyA9PT0gdm9pZCAwID8gdm9pZCAwIDogZGVmYXVsdHMuc2VhcmNoUGFyYW1zKSkge1xuICAgICAgICAgICAgICAgIGxldCBzZWFyY2hQYXJhbWV0ZXJzO1xuICAgICAgICAgICAgICAgIGlmIChpc18xLmRlZmF1bHQuc3RyaW5nKG9wdGlvbnMuc2VhcmNoUGFyYW1zKSB8fCAob3B0aW9ucy5zZWFyY2hQYXJhbXMgaW5zdGFuY2VvZiB1cmxfMS5VUkxTZWFyY2hQYXJhbXMpKSB7XG4gICAgICAgICAgICAgICAgICAgIHNlYXJjaFBhcmFtZXRlcnMgPSBuZXcgdXJsXzEuVVJMU2VhcmNoUGFyYW1zKG9wdGlvbnMuc2VhcmNoUGFyYW1zKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgIHZhbGlkYXRlU2VhcmNoUGFyYW1ldGVycyhvcHRpb25zLnNlYXJjaFBhcmFtcyk7XG4gICAgICAgICAgICAgICAgICAgIHNlYXJjaFBhcmFtZXRlcnMgPSBuZXcgdXJsXzEuVVJMU2VhcmNoUGFyYW1zKCk7XG4gICAgICAgICAgICAgICAgICAgIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBndWFyZC1mb3ItaW5cbiAgICAgICAgICAgICAgICAgICAgZm9yIChjb25zdCBrZXkgaW4gb3B0aW9ucy5zZWFyY2hQYXJhbXMpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGNvbnN0IHZhbHVlID0gb3B0aW9ucy5zZWFyY2hQYXJhbXNba2V5XTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmICh2YWx1ZSA9PT0gbnVsbCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHNlYXJjaFBhcmFtZXRlcnMuYXBwZW5kKGtleSwgJycpO1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgZWxzZSBpZiAodmFsdWUgIT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHNlYXJjaFBhcmFtZXRlcnMuYXBwZW5kKGtleSwgdmFsdWUpO1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIC8vIGBub3JtYWxpemVBcmd1bWVudHMoKWAgaXMgYWxzbyB1c2VkIHRvIG1lcmdlIG9wdGlvbnNcbiAgICAgICAgICAgICAgICAoX2EgPSBkZWZhdWx0cyA9PT0gbnVsbCB8fCBkZWZhdWx0cyA9PT0gdm9pZCAwID8gdm9pZCAwIDogZGVmYXVsdHMuc2VhcmNoUGFyYW1zKSA9PT0gbnVsbCB8fCBfYSA9PT0gdm9pZCAwID8gdm9pZCAwIDogX2EuZm9yRWFjaCgodmFsdWUsIGtleSkgPT4ge1xuICAgICAgICAgICAgICAgICAgICAvLyBPbmx5IHVzZSBkZWZhdWx0IGlmIG9uZSBpc24ndCBhbHJlYWR5IGRlZmluZWRcbiAgICAgICAgICAgICAgICAgICAgaWYgKCFzZWFyY2hQYXJhbWV0ZXJzLmhhcyhrZXkpKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBzZWFyY2hQYXJhbWV0ZXJzLmFwcGVuZChrZXksIHZhbHVlKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgIG9wdGlvbnMuc2VhcmNoUGFyYW1zID0gc2VhcmNoUGFyYW1ldGVycztcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICAvLyBgb3B0aW9ucy51c2VybmFtZWAgJiBgb3B0aW9ucy5wYXNzd29yZGBcbiAgICAgICAgb3B0aW9ucy51c2VybmFtZSA9IChfYiA9IG9wdGlvbnMudXNlcm5hbWUpICE9PSBudWxsICYmIF9iICE9PSB2b2lkIDAgPyBfYiA6ICcnO1xuICAgICAgICBvcHRpb25zLnBhc3N3b3JkID0gKF9jID0gb3B0aW9ucy5wYXNzd29yZCkgIT09IG51bGwgJiYgX2MgIT09IHZvaWQgMCA/IF9jIDogJyc7XG4gICAgICAgIC8vIGBvcHRpb25zLnByZWZpeFVybGAgJiBgb3B0aW9ucy51cmxgXG4gICAgICAgIGlmIChpc18xLmRlZmF1bHQudW5kZWZpbmVkKG9wdGlvbnMucHJlZml4VXJsKSkge1xuICAgICAgICAgICAgb3B0aW9ucy5wcmVmaXhVcmwgPSAoX2QgPSBkZWZhdWx0cyA9PT0gbnVsbCB8fCBkZWZhdWx0cyA9PT0gdm9pZCAwID8gdm9pZCAwIDogZGVmYXVsdHMucHJlZml4VXJsKSAhPT0gbnVsbCAmJiBfZCAhPT0gdm9pZCAwID8gX2QgOiAnJztcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIG9wdGlvbnMucHJlZml4VXJsID0gb3B0aW9ucy5wcmVmaXhVcmwudG9TdHJpbmcoKTtcbiAgICAgICAgICAgIGlmIChvcHRpb25zLnByZWZpeFVybCAhPT0gJycgJiYgIW9wdGlvbnMucHJlZml4VXJsLmVuZHNXaXRoKCcvJykpIHtcbiAgICAgICAgICAgICAgICBvcHRpb25zLnByZWZpeFVybCArPSAnLyc7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgaWYgKGlzXzEuZGVmYXVsdC5zdHJpbmcob3B0aW9ucy51cmwpKSB7XG4gICAgICAgICAgICBpZiAob3B0aW9ucy51cmwuc3RhcnRzV2l0aCgnLycpKSB7XG4gICAgICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdgaW5wdXRgIG11c3Qgbm90IHN0YXJ0IHdpdGggYSBzbGFzaCB3aGVuIHVzaW5nIGBwcmVmaXhVcmxgJyk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBvcHRpb25zLnVybCA9IG9wdGlvbnNfdG9fdXJsXzEuZGVmYXVsdChvcHRpb25zLnByZWZpeFVybCArIG9wdGlvbnMudXJsLCBvcHRpb25zKTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIGlmICgoaXNfMS5kZWZhdWx0LnVuZGVmaW5lZChvcHRpb25zLnVybCkgJiYgb3B0aW9ucy5wcmVmaXhVcmwgIT09ICcnKSB8fCBvcHRpb25zLnByb3RvY29sKSB7XG4gICAgICAgICAgICBvcHRpb25zLnVybCA9IG9wdGlvbnNfdG9fdXJsXzEuZGVmYXVsdChvcHRpb25zLnByZWZpeFVybCwgb3B0aW9ucyk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKG9wdGlvbnMudXJsKSB7XG4gICAgICAgICAgICBpZiAoJ3BvcnQnIGluIG9wdGlvbnMpIHtcbiAgICAgICAgICAgICAgICBkZWxldGUgb3B0aW9ucy5wb3J0O1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgLy8gTWFrZSBpdCBwb3NzaWJsZSB0byBjaGFuZ2UgYG9wdGlvbnMucHJlZml4VXJsYFxuICAgICAgICAgICAgbGV0IHsgcHJlZml4VXJsIH0gPSBvcHRpb25zO1xuICAgICAgICAgICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KG9wdGlvbnMsICdwcmVmaXhVcmwnLCB7XG4gICAgICAgICAgICAgICAgc2V0OiAodmFsdWUpID0+IHtcbiAgICAgICAgICAgICAgICAgICAgY29uc3QgdXJsID0gb3B0aW9ucy51cmw7XG4gICAgICAgICAgICAgICAgICAgIGlmICghdXJsLmhyZWYuc3RhcnRzV2l0aCh2YWx1ZSkpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihgQ2Fubm90IGNoYW5nZSBcXGBwcmVmaXhVcmxcXGAgZnJvbSAke3ByZWZpeFVybH0gdG8gJHt2YWx1ZX06ICR7dXJsLmhyZWZ9YCk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgb3B0aW9ucy51cmwgPSBuZXcgdXJsXzEuVVJMKHZhbHVlICsgdXJsLmhyZWYuc2xpY2UocHJlZml4VXJsLmxlbmd0aCkpO1xuICAgICAgICAgICAgICAgICAgICBwcmVmaXhVcmwgPSB2YWx1ZTtcbiAgICAgICAgICAgICAgICB9LFxuICAgICAgICAgICAgICAgIGdldDogKCkgPT4gcHJlZml4VXJsXG4gICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIC8vIFN1cHBvcnQgVU5JWCBzb2NrZXRzXG4gICAgICAgICAgICBsZXQgeyBwcm90b2NvbCB9ID0gb3B0aW9ucy51cmw7XG4gICAgICAgICAgICBpZiAocHJvdG9jb2wgPT09ICd1bml4OicpIHtcbiAgICAgICAgICAgICAgICBwcm90b2NvbCA9ICdodHRwOic7XG4gICAgICAgICAgICAgICAgb3B0aW9ucy51cmwgPSBuZXcgdXJsXzEuVVJMKGBodHRwOi8vdW5peCR7b3B0aW9ucy51cmwucGF0aG5hbWV9JHtvcHRpb25zLnVybC5zZWFyY2h9YCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICAvLyBTZXQgc2VhcmNoIHBhcmFtc1xuICAgICAgICAgICAgaWYgKG9wdGlvbnMuc2VhcmNoUGFyYW1zKSB7XG4gICAgICAgICAgICAgICAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIEB0eXBlc2NyaXB0LWVzbGludC9uby1iYXNlLXRvLXN0cmluZ1xuICAgICAgICAgICAgICAgIG9wdGlvbnMudXJsLnNlYXJjaCA9IG9wdGlvbnMuc2VhcmNoUGFyYW1zLnRvU3RyaW5nKCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICAvLyBQcm90b2NvbCBjaGVja1xuICAgICAgICAgICAgaWYgKHByb3RvY29sICE9PSAnaHR0cDonICYmIHByb3RvY29sICE9PSAnaHR0cHM6Jykge1xuICAgICAgICAgICAgICAgIHRocm93IG5ldyBVbnN1cHBvcnRlZFByb3RvY29sRXJyb3Iob3B0aW9ucyk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICAvLyBVcGRhdGUgYHVzZXJuYW1lYFxuICAgICAgICAgICAgaWYgKG9wdGlvbnMudXNlcm5hbWUgPT09ICcnKSB7XG4gICAgICAgICAgICAgICAgb3B0aW9ucy51c2VybmFtZSA9IG9wdGlvbnMudXJsLnVzZXJuYW1lO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgb3B0aW9ucy51cmwudXNlcm5hbWUgPSBvcHRpb25zLnVzZXJuYW1lO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgLy8gVXBkYXRlIGBwYXNzd29yZGBcbiAgICAgICAgICAgIGlmIChvcHRpb25zLnBhc3N3b3JkID09PSAnJykge1xuICAgICAgICAgICAgICAgIG9wdGlvbnMucGFzc3dvcmQgPSBvcHRpb25zLnVybC5wYXNzd29yZDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgIG9wdGlvbnMudXJsLnBhc3N3b3JkID0gb3B0aW9ucy5wYXNzd29yZDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICAvLyBgb3B0aW9ucy5jb29raWVKYXJgXG4gICAgICAgIGNvbnN0IHsgY29va2llSmFyIH0gPSBvcHRpb25zO1xuICAgICAgICBpZiAoY29va2llSmFyKSB7XG4gICAgICAgICAgICBsZXQgeyBzZXRDb29raWUsIGdldENvb2tpZVN0cmluZyB9ID0gY29va2llSmFyO1xuICAgICAgICAgICAgaXNfMS5hc3NlcnQuZnVuY3Rpb25fKHNldENvb2tpZSk7XG4gICAgICAgICAgICBpc18xLmFzc2VydC5mdW5jdGlvbl8oZ2V0Q29va2llU3RyaW5nKTtcbiAgICAgICAgICAgIC8qIGlzdGFuYnVsIGlnbm9yZSBuZXh0OiBIb3JyaWJsZSBgdG91Z2gtY29va2llYCB2MyBjaGVjayAqL1xuICAgICAgICAgICAgaWYgKHNldENvb2tpZS5sZW5ndGggPT09IDQgJiYgZ2V0Q29va2llU3RyaW5nLmxlbmd0aCA9PT0gMCkge1xuICAgICAgICAgICAgICAgIHNldENvb2tpZSA9IHV0aWxfMS5wcm9taXNpZnkoc2V0Q29va2llLmJpbmQob3B0aW9ucy5jb29raWVKYXIpKTtcbiAgICAgICAgICAgICAgICBnZXRDb29raWVTdHJpbmcgPSB1dGlsXzEucHJvbWlzaWZ5KGdldENvb2tpZVN0cmluZy5iaW5kKG9wdGlvbnMuY29va2llSmFyKSk7XG4gICAgICAgICAgICAgICAgb3B0aW9ucy5jb29raWVKYXIgPSB7XG4gICAgICAgICAgICAgICAgICAgIHNldENvb2tpZSxcbiAgICAgICAgICAgICAgICAgICAgZ2V0Q29va2llU3RyaW5nOiBnZXRDb29raWVTdHJpbmdcbiAgICAgICAgICAgICAgICB9O1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIC8vIGBvcHRpb25zLmNhY2hlYFxuICAgICAgICBjb25zdCB7IGNhY2hlIH0gPSBvcHRpb25zO1xuICAgICAgICBpZiAoY2FjaGUpIHtcbiAgICAgICAgICAgIGlmICghY2FjaGVhYmxlU3RvcmUuaGFzKGNhY2hlKSkge1xuICAgICAgICAgICAgICAgIGNhY2hlYWJsZVN0b3JlLnNldChjYWNoZSwgbmV3IENhY2hlYWJsZVJlcXVlc3QoKChyZXF1ZXN0T3B0aW9ucywgaGFuZGxlcikgPT4ge1xuICAgICAgICAgICAgICAgICAgICBjb25zdCByZXN1bHQgPSByZXF1ZXN0T3B0aW9uc1trUmVxdWVzdF0ocmVxdWVzdE9wdGlvbnMsIGhhbmRsZXIpO1xuICAgICAgICAgICAgICAgICAgICAvLyBUT0RPOiByZW1vdmUgdGhpcyB3aGVuIGBjYWNoZWFibGUtcmVxdWVzdGAgc3VwcG9ydHMgYXN5bmMgcmVxdWVzdCBmdW5jdGlvbnMuXG4gICAgICAgICAgICAgICAgICAgIGlmIChpc18xLmRlZmF1bHQucHJvbWlzZShyZXN1bHQpKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAvLyBAdHMtZXhwZWN0LWVycm9yXG4gICAgICAgICAgICAgICAgICAgICAgICAvLyBXZSBvbmx5IG5lZWQgdG8gaW1wbGVtZW50IHRoZSBlcnJvciBoYW5kbGVyIGluIG9yZGVyIHRvIHN1cHBvcnQgSFRUUDIgY2FjaGluZy5cbiAgICAgICAgICAgICAgICAgICAgICAgIC8vIFRoZSByZXN1bHQgd2lsbCBiZSBhIHByb21pc2UgYW55d2F5LlxuICAgICAgICAgICAgICAgICAgICAgICAgcmVzdWx0Lm9uY2UgPSAoZXZlbnQsIGhhbmRsZXIpID0+IHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAoZXZlbnQgPT09ICdlcnJvcicpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgcmVzdWx0LmNhdGNoKGhhbmRsZXIpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBlbHNlIGlmIChldmVudCA9PT0gJ2Fib3J0Jykge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAvLyBUaGUgZW1wdHkgY2F0Y2ggaXMgbmVlZGVkIGhlcmUgaW4gY2FzZSB3aGVuXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vIGl0IHJlamVjdHMgYmVmb3JlIGl0J3MgYGF3YWl0YGVkIGluIGBfbWFrZVJlcXVlc3RgLlxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAoYXN5bmMgKCkgPT4ge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBjb25zdCByZXF1ZXN0ID0gKGF3YWl0IHJlc3VsdCk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgcmVxdWVzdC5vbmNlKCdhYm9ydCcsIGhhbmRsZXIpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgY2F0Y2ggKF9hKSB7IH1cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfSkoKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8qIGlzdGFuYnVsIGlnbm9yZSBuZXh0OiBzYWZldHkgY2hlY2sgKi9cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKGBVbmtub3duIEhUVFAyIHByb21pc2UgZXZlbnQ6ICR7ZXZlbnR9YCk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiByZXN1bHQ7XG4gICAgICAgICAgICAgICAgICAgICAgICB9O1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiByZXN1bHQ7XG4gICAgICAgICAgICAgICAgfSksIGNhY2hlKSk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgLy8gYG9wdGlvbnMuY2FjaGVPcHRpb25zYFxuICAgICAgICBvcHRpb25zLmNhY2hlT3B0aW9ucyA9IHsgLi4ub3B0aW9ucy5jYWNoZU9wdGlvbnMgfTtcbiAgICAgICAgLy8gYG9wdGlvbnMuZG5zQ2FjaGVgXG4gICAgICAgIGlmIChvcHRpb25zLmRuc0NhY2hlID09PSB0cnVlKSB7XG4gICAgICAgICAgICBpZiAoIWdsb2JhbERuc0NhY2hlKSB7XG4gICAgICAgICAgICAgICAgZ2xvYmFsRG5zQ2FjaGUgPSBuZXcgY2FjaGVhYmxlX2xvb2t1cF8xLmRlZmF1bHQoKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIG9wdGlvbnMuZG5zQ2FjaGUgPSBnbG9iYWxEbnNDYWNoZTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIGlmICghaXNfMS5kZWZhdWx0LnVuZGVmaW5lZChvcHRpb25zLmRuc0NhY2hlKSAmJiAhb3B0aW9ucy5kbnNDYWNoZS5sb29rdXApIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBUeXBlRXJyb3IoYFBhcmFtZXRlciBcXGBkbnNDYWNoZVxcYCBtdXN0IGJlIGEgQ2FjaGVhYmxlTG9va3VwIGluc3RhbmNlIG9yIGEgYm9vbGVhbiwgZ290ICR7aXNfMS5kZWZhdWx0KG9wdGlvbnMuZG5zQ2FjaGUpfWApO1xuICAgICAgICB9XG4gICAgICAgIC8vIGBvcHRpb25zLnRpbWVvdXRgXG4gICAgICAgIGlmIChpc18xLmRlZmF1bHQubnVtYmVyKG9wdGlvbnMudGltZW91dCkpIHtcbiAgICAgICAgICAgIG9wdGlvbnMudGltZW91dCA9IHsgcmVxdWVzdDogb3B0aW9ucy50aW1lb3V0IH07XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSBpZiAoZGVmYXVsdHMgJiYgb3B0aW9ucy50aW1lb3V0ICE9PSBkZWZhdWx0cy50aW1lb3V0KSB7XG4gICAgICAgICAgICBvcHRpb25zLnRpbWVvdXQgPSB7XG4gICAgICAgICAgICAgICAgLi4uZGVmYXVsdHMudGltZW91dCxcbiAgICAgICAgICAgICAgICAuLi5vcHRpb25zLnRpbWVvdXRcbiAgICAgICAgICAgIH07XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICBvcHRpb25zLnRpbWVvdXQgPSB7IC4uLm9wdGlvbnMudGltZW91dCB9O1xuICAgICAgICB9XG4gICAgICAgIC8vIGBvcHRpb25zLmNvbnRleHRgXG4gICAgICAgIGlmICghb3B0aW9ucy5jb250ZXh0KSB7XG4gICAgICAgICAgICBvcHRpb25zLmNvbnRleHQgPSB7fTtcbiAgICAgICAgfVxuICAgICAgICAvLyBgb3B0aW9ucy5ob29rc2BcbiAgICAgICAgY29uc3QgYXJlSG9va3NEZWZhdWx0ID0gb3B0aW9ucy5ob29rcyA9PT0gKGRlZmF1bHRzID09PSBudWxsIHx8IGRlZmF1bHRzID09PSB2b2lkIDAgPyB2b2lkIDAgOiBkZWZhdWx0cy5ob29rcyk7XG4gICAgICAgIG9wdGlvbnMuaG9va3MgPSB7IC4uLm9wdGlvbnMuaG9va3MgfTtcbiAgICAgICAgZm9yIChjb25zdCBldmVudCBvZiBleHBvcnRzLmtub3duSG9va0V2ZW50cykge1xuICAgICAgICAgICAgaWYgKGV2ZW50IGluIG9wdGlvbnMuaG9va3MpIHtcbiAgICAgICAgICAgICAgICBpZiAoaXNfMS5kZWZhdWx0LmFycmF5KG9wdGlvbnMuaG9va3NbZXZlbnRdKSkge1xuICAgICAgICAgICAgICAgICAgICAvLyBTZWUgaHR0cHM6Ly9naXRodWIuY29tL21pY3Jvc29mdC9UeXBlU2NyaXB0L2lzc3Vlcy8zMTQ0NSNpc3N1ZWNvbW1lbnQtNTc2OTI5MDQ0XG4gICAgICAgICAgICAgICAgICAgIG9wdGlvbnMuaG9va3NbZXZlbnRdID0gWy4uLm9wdGlvbnMuaG9va3NbZXZlbnRdXTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgIHRocm93IG5ldyBUeXBlRXJyb3IoYFBhcmFtZXRlciBcXGAke2V2ZW50fVxcYCBtdXN0IGJlIGFuIEFycmF5LCBnb3QgJHtpc18xLmRlZmF1bHQob3B0aW9ucy5ob29rc1tldmVudF0pfWApO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgIG9wdGlvbnMuaG9va3NbZXZlbnRdID0gW107XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgaWYgKGRlZmF1bHRzICYmICFhcmVIb29rc0RlZmF1bHQpIHtcbiAgICAgICAgICAgIGZvciAoY29uc3QgZXZlbnQgb2YgZXhwb3J0cy5rbm93bkhvb2tFdmVudHMpIHtcbiAgICAgICAgICAgICAgICBjb25zdCBkZWZhdWx0SG9va3MgPSBkZWZhdWx0cy5ob29rc1tldmVudF07XG4gICAgICAgICAgICAgICAgaWYgKGRlZmF1bHRIb29rcy5sZW5ndGggPiAwKSB7XG4gICAgICAgICAgICAgICAgICAgIC8vIFNlZSBodHRwczovL2dpdGh1Yi5jb20vbWljcm9zb2Z0L1R5cGVTY3JpcHQvaXNzdWVzLzMxNDQ1I2lzc3VlY29tbWVudC01NzY5MjkwNDRcbiAgICAgICAgICAgICAgICAgICAgb3B0aW9ucy5ob29rc1tldmVudF0gPSBbXG4gICAgICAgICAgICAgICAgICAgICAgICAuLi5kZWZhdWx0cy5ob29rc1tldmVudF0sXG4gICAgICAgICAgICAgICAgICAgICAgICAuLi5vcHRpb25zLmhvb2tzW2V2ZW50XVxuICAgICAgICAgICAgICAgICAgICBdO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICAvLyBETlMgb3B0aW9uc1xuICAgICAgICBpZiAoJ2ZhbWlseScgaW4gb3B0aW9ucykge1xuICAgICAgICAgICAgZGVwcmVjYXRpb25fd2FybmluZ18xLmRlZmF1bHQoJ1wib3B0aW9ucy5mYW1pbHlcIiB3YXMgbmV2ZXIgZG9jdW1lbnRlZCwgcGxlYXNlIHVzZSBcIm9wdGlvbnMuZG5zTG9va3VwSXBWZXJzaW9uXCInKTtcbiAgICAgICAgfVxuICAgICAgICAvLyBIVFRQUyBvcHRpb25zXG4gICAgICAgIGlmIChkZWZhdWx0cyA9PT0gbnVsbCB8fCBkZWZhdWx0cyA9PT0gdm9pZCAwID8gdm9pZCAwIDogZGVmYXVsdHMuaHR0cHMpIHtcbiAgICAgICAgICAgIG9wdGlvbnMuaHR0cHMgPSB7IC4uLmRlZmF1bHRzLmh0dHBzLCAuLi5vcHRpb25zLmh0dHBzIH07XG4gICAgICAgIH1cbiAgICAgICAgaWYgKCdyZWplY3RVbmF1dGhvcml6ZWQnIGluIG9wdGlvbnMpIHtcbiAgICAgICAgICAgIGRlcHJlY2F0aW9uX3dhcm5pbmdfMS5kZWZhdWx0KCdcIm9wdGlvbnMucmVqZWN0VW5hdXRob3JpemVkXCIgaXMgbm93IGRlcHJlY2F0ZWQsIHBsZWFzZSB1c2UgXCJvcHRpb25zLmh0dHBzLnJlamVjdFVuYXV0aG9yaXplZFwiJyk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKCdjaGVja1NlcnZlcklkZW50aXR5JyBpbiBvcHRpb25zKSB7XG4gICAgICAgICAgICBkZXByZWNhdGlvbl93YXJuaW5nXzEuZGVmYXVsdCgnXCJvcHRpb25zLmNoZWNrU2VydmVySWRlbnRpdHlcIiB3YXMgbmV2ZXIgZG9jdW1lbnRlZCwgcGxlYXNlIHVzZSBcIm9wdGlvbnMuaHR0cHMuY2hlY2tTZXJ2ZXJJZGVudGl0eVwiJyk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKCdjYScgaW4gb3B0aW9ucykge1xuICAgICAgICAgICAgZGVwcmVjYXRpb25fd2FybmluZ18xLmRlZmF1bHQoJ1wib3B0aW9ucy5jYVwiIHdhcyBuZXZlciBkb2N1bWVudGVkLCBwbGVhc2UgdXNlIFwib3B0aW9ucy5odHRwcy5jZXJ0aWZpY2F0ZUF1dGhvcml0eVwiJyk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKCdrZXknIGluIG9wdGlvbnMpIHtcbiAgICAgICAgICAgIGRlcHJlY2F0aW9uX3dhcm5pbmdfMS5kZWZhdWx0KCdcIm9wdGlvbnMua2V5XCIgd2FzIG5ldmVyIGRvY3VtZW50ZWQsIHBsZWFzZSB1c2UgXCJvcHRpb25zLmh0dHBzLmtleVwiJyk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKCdjZXJ0JyBpbiBvcHRpb25zKSB7XG4gICAgICAgICAgICBkZXByZWNhdGlvbl93YXJuaW5nXzEuZGVmYXVsdCgnXCJvcHRpb25zLmNlcnRcIiB3YXMgbmV2ZXIgZG9jdW1lbnRlZCwgcGxlYXNlIHVzZSBcIm9wdGlvbnMuaHR0cHMuY2VydGlmaWNhdGVcIicpO1xuICAgICAgICB9XG4gICAgICAgIGlmICgncGFzc3BocmFzZScgaW4gb3B0aW9ucykge1xuICAgICAgICAgICAgZGVwcmVjYXRpb25fd2FybmluZ18xLmRlZmF1bHQoJ1wib3B0aW9ucy5wYXNzcGhyYXNlXCIgd2FzIG5ldmVyIGRvY3VtZW50ZWQsIHBsZWFzZSB1c2UgXCJvcHRpb25zLmh0dHBzLnBhc3NwaHJhc2VcIicpO1xuICAgICAgICB9XG4gICAgICAgIGlmICgncGZ4JyBpbiBvcHRpb25zKSB7XG4gICAgICAgICAgICBkZXByZWNhdGlvbl93YXJuaW5nXzEuZGVmYXVsdCgnXCJvcHRpb25zLnBmeFwiIHdhcyBuZXZlciBkb2N1bWVudGVkLCBwbGVhc2UgdXNlIFwib3B0aW9ucy5odHRwcy5wZnhcIicpO1xuICAgICAgICB9XG4gICAgICAgIC8vIE90aGVyIG9wdGlvbnNcbiAgICAgICAgaWYgKCdmb2xsb3dSZWRpcmVjdHMnIGluIG9wdGlvbnMpIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBUeXBlRXJyb3IoJ1RoZSBgZm9sbG93UmVkaXJlY3RzYCBvcHRpb24gZG9lcyBub3QgZXhpc3QuIFVzZSBgZm9sbG93UmVkaXJlY3RgIGluc3RlYWQuJyk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKG9wdGlvbnMuYWdlbnQpIHtcbiAgICAgICAgICAgIGZvciAoY29uc3Qga2V5IGluIG9wdGlvbnMuYWdlbnQpIHtcbiAgICAgICAgICAgICAgICBpZiAoa2V5ICE9PSAnaHR0cCcgJiYga2V5ICE9PSAnaHR0cHMnICYmIGtleSAhPT0gJ2h0dHAyJykge1xuICAgICAgICAgICAgICAgICAgICB0aHJvdyBuZXcgVHlwZUVycm9yKGBFeHBlY3RlZCB0aGUgXFxgb3B0aW9ucy5hZ2VudFxcYCBwcm9wZXJ0aWVzIHRvIGJlIFxcYGh0dHBcXGAsIFxcYGh0dHBzXFxgIG9yIFxcYGh0dHAyXFxgLCBnb3QgXFxgJHtrZXl9XFxgYCk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIG9wdGlvbnMubWF4UmVkaXJlY3RzID0gKF9lID0gb3B0aW9ucy5tYXhSZWRpcmVjdHMpICE9PSBudWxsICYmIF9lICE9PSB2b2lkIDAgPyBfZSA6IDA7XG4gICAgICAgIC8vIFNldCBub24tZW51bWVyYWJsZSBwcm9wZXJ0aWVzXG4gICAgICAgIGV4cG9ydHMuc2V0Tm9uRW51bWVyYWJsZVByb3BlcnRpZXMoW2RlZmF1bHRzLCByYXdPcHRpb25zXSwgb3B0aW9ucyk7XG4gICAgICAgIHJldHVybiBub3JtYWxpemVfYXJndW1lbnRzXzEuZGVmYXVsdChvcHRpb25zLCBkZWZhdWx0cyk7XG4gICAgfVxuICAgIF9sb2NrV3JpdGUoKSB7XG4gICAgICAgIGNvbnN0IG9uTG9ja2VkV3JpdGUgPSAoKSA9PiB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgVHlwZUVycm9yKCdUaGUgcGF5bG9hZCBoYXMgYmVlbiBhbHJlYWR5IHByb3ZpZGVkJyk7XG4gICAgICAgIH07XG4gICAgICAgIHRoaXMud3JpdGUgPSBvbkxvY2tlZFdyaXRlO1xuICAgICAgICB0aGlzLmVuZCA9IG9uTG9ja2VkV3JpdGU7XG4gICAgfVxuICAgIF91bmxvY2tXcml0ZSgpIHtcbiAgICAgICAgdGhpcy53cml0ZSA9IHN1cGVyLndyaXRlO1xuICAgICAgICB0aGlzLmVuZCA9IHN1cGVyLmVuZDtcbiAgICB9XG4gICAgYXN5bmMgX2ZpbmFsaXplQm9keSgpIHtcbiAgICAgICAgY29uc3QgeyBvcHRpb25zIH0gPSB0aGlzO1xuICAgICAgICBjb25zdCB7IGhlYWRlcnMgfSA9IG9wdGlvbnM7XG4gICAgICAgIGNvbnN0IGlzRm9ybSA9ICFpc18xLmRlZmF1bHQudW5kZWZpbmVkKG9wdGlvbnMuZm9ybSk7XG4gICAgICAgIGNvbnN0IGlzSlNPTiA9ICFpc18xLmRlZmF1bHQudW5kZWZpbmVkKG9wdGlvbnMuanNvbik7XG4gICAgICAgIGNvbnN0IGlzQm9keSA9ICFpc18xLmRlZmF1bHQudW5kZWZpbmVkKG9wdGlvbnMuYm9keSk7XG4gICAgICAgIGNvbnN0IGhhc1BheWxvYWQgPSBpc0Zvcm0gfHwgaXNKU09OIHx8IGlzQm9keTtcbiAgICAgICAgY29uc3QgY2Fubm90SGF2ZUJvZHkgPSBleHBvcnRzLndpdGhvdXRCb2R5LmhhcyhvcHRpb25zLm1ldGhvZCkgJiYgIShvcHRpb25zLm1ldGhvZCA9PT0gJ0dFVCcgJiYgb3B0aW9ucy5hbGxvd0dldEJvZHkpO1xuICAgICAgICB0aGlzLl9jYW5ub3RIYXZlQm9keSA9IGNhbm5vdEhhdmVCb2R5O1xuICAgICAgICBpZiAoaGFzUGF5bG9hZCkge1xuICAgICAgICAgICAgaWYgKGNhbm5vdEhhdmVCb2R5KSB7XG4gICAgICAgICAgICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvcihgVGhlIFxcYCR7b3B0aW9ucy5tZXRob2R9XFxgIG1ldGhvZCBjYW5ub3QgYmUgdXNlZCB3aXRoIGEgYm9keWApO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKFtpc0JvZHksIGlzRm9ybSwgaXNKU09OXS5maWx0ZXIoaXNUcnVlID0+IGlzVHJ1ZSkubGVuZ3RoID4gMSkge1xuICAgICAgICAgICAgICAgIHRocm93IG5ldyBUeXBlRXJyb3IoJ1RoZSBgYm9keWAsIGBqc29uYCBhbmQgYGZvcm1gIG9wdGlvbnMgYXJlIG11dHVhbGx5IGV4Y2x1c2l2ZScpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKGlzQm9keSAmJlxuICAgICAgICAgICAgICAgICEob3B0aW9ucy5ib2R5IGluc3RhbmNlb2Ygc3RyZWFtXzEuUmVhZGFibGUpICYmXG4gICAgICAgICAgICAgICAgIWlzXzEuZGVmYXVsdC5zdHJpbmcob3B0aW9ucy5ib2R5KSAmJlxuICAgICAgICAgICAgICAgICFpc18xLmRlZmF1bHQuYnVmZmVyKG9wdGlvbnMuYm9keSkgJiZcbiAgICAgICAgICAgICAgICAhaXNfZm9ybV9kYXRhXzEuZGVmYXVsdChvcHRpb25zLmJvZHkpKSB7XG4gICAgICAgICAgICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvcignVGhlIGBib2R5YCBvcHRpb24gbXVzdCBiZSBhIHN0cmVhbS5SZWFkYWJsZSwgc3RyaW5nIG9yIEJ1ZmZlcicpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKGlzRm9ybSAmJiAhaXNfMS5kZWZhdWx0Lm9iamVjdChvcHRpb25zLmZvcm0pKSB7XG4gICAgICAgICAgICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvcignVGhlIGBmb3JtYCBvcHRpb24gbXVzdCBiZSBhbiBPYmplY3QnKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHtcbiAgICAgICAgICAgICAgICAvLyBTZXJpYWxpemUgYm9keVxuICAgICAgICAgICAgICAgIGNvbnN0IG5vQ29udGVudFR5cGUgPSAhaXNfMS5kZWZhdWx0LnN0cmluZyhoZWFkZXJzWydjb250ZW50LXR5cGUnXSk7XG4gICAgICAgICAgICAgICAgaWYgKGlzQm9keSkge1xuICAgICAgICAgICAgICAgICAgICAvLyBTcGVjaWFsIGNhc2UgZm9yIGh0dHBzOi8vZ2l0aHViLmNvbS9mb3JtLWRhdGEvZm9ybS1kYXRhXG4gICAgICAgICAgICAgICAgICAgIGlmIChpc19mb3JtX2RhdGFfMS5kZWZhdWx0KG9wdGlvbnMuYm9keSkgJiYgbm9Db250ZW50VHlwZSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgaGVhZGVyc1snY29udGVudC10eXBlJ10gPSBgbXVsdGlwYXJ0L2Zvcm0tZGF0YTsgYm91bmRhcnk9JHtvcHRpb25zLmJvZHkuZ2V0Qm91bmRhcnkoKX1gO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIHRoaXNba0JvZHldID0gb3B0aW9ucy5ib2R5O1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBlbHNlIGlmIChpc0Zvcm0pIHtcbiAgICAgICAgICAgICAgICAgICAgaWYgKG5vQ29udGVudFR5cGUpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGhlYWRlcnNbJ2NvbnRlbnQtdHlwZSddID0gJ2FwcGxpY2F0aW9uL3gtd3d3LWZvcm0tdXJsZW5jb2RlZCc7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgdGhpc1trQm9keV0gPSAobmV3IHVybF8xLlVSTFNlYXJjaFBhcmFtcyhvcHRpb25zLmZvcm0pKS50b1N0cmluZygpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgaWYgKG5vQ29udGVudFR5cGUpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGhlYWRlcnNbJ2NvbnRlbnQtdHlwZSddID0gJ2FwcGxpY2F0aW9uL2pzb24nO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIHRoaXNba0JvZHldID0gb3B0aW9ucy5zdHJpbmdpZnlKc29uKG9wdGlvbnMuanNvbik7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGNvbnN0IHVwbG9hZEJvZHlTaXplID0gYXdhaXQgZ2V0X2JvZHlfc2l6ZV8xLmRlZmF1bHQodGhpc1trQm9keV0sIG9wdGlvbnMuaGVhZGVycyk7XG4gICAgICAgICAgICAgICAgLy8gU2VlIGh0dHBzOi8vdG9vbHMuaWV0Zi5vcmcvaHRtbC9yZmM3MjMwI3NlY3Rpb24tMy4zLjJcbiAgICAgICAgICAgICAgICAvLyBBIHVzZXIgYWdlbnQgU0hPVUxEIHNlbmQgYSBDb250ZW50LUxlbmd0aCBpbiBhIHJlcXVlc3QgbWVzc2FnZSB3aGVuXG4gICAgICAgICAgICAgICAgLy8gbm8gVHJhbnNmZXItRW5jb2RpbmcgaXMgc2VudCBhbmQgdGhlIHJlcXVlc3QgbWV0aG9kIGRlZmluZXMgYSBtZWFuaW5nXG4gICAgICAgICAgICAgICAgLy8gZm9yIGFuIGVuY2xvc2VkIHBheWxvYWQgYm9keS4gIEZvciBleGFtcGxlLCBhIENvbnRlbnQtTGVuZ3RoIGhlYWRlclxuICAgICAgICAgICAgICAgIC8vIGZpZWxkIGlzIG5vcm1hbGx5IHNlbnQgaW4gYSBQT1NUIHJlcXVlc3QgZXZlbiB3aGVuIHRoZSB2YWx1ZSBpcyAwXG4gICAgICAgICAgICAgICAgLy8gKGluZGljYXRpbmcgYW4gZW1wdHkgcGF5bG9hZCBib2R5KS4gIEEgdXNlciBhZ2VudCBTSE9VTEQgTk9UIHNlbmQgYVxuICAgICAgICAgICAgICAgIC8vIENvbnRlbnQtTGVuZ3RoIGhlYWRlciBmaWVsZCB3aGVuIHRoZSByZXF1ZXN0IG1lc3NhZ2UgZG9lcyBub3QgY29udGFpblxuICAgICAgICAgICAgICAgIC8vIGEgcGF5bG9hZCBib2R5IGFuZCB0aGUgbWV0aG9kIHNlbWFudGljcyBkbyBub3QgYW50aWNpcGF0ZSBzdWNoIGFcbiAgICAgICAgICAgICAgICAvLyBib2R5LlxuICAgICAgICAgICAgICAgIGlmIChpc18xLmRlZmF1bHQudW5kZWZpbmVkKGhlYWRlcnNbJ2NvbnRlbnQtbGVuZ3RoJ10pICYmIGlzXzEuZGVmYXVsdC51bmRlZmluZWQoaGVhZGVyc1sndHJhbnNmZXItZW5jb2RpbmcnXSkpIHtcbiAgICAgICAgICAgICAgICAgICAgaWYgKCFjYW5ub3RIYXZlQm9keSAmJiAhaXNfMS5kZWZhdWx0LnVuZGVmaW5lZCh1cGxvYWRCb2R5U2l6ZSkpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGhlYWRlcnNbJ2NvbnRlbnQtbGVuZ3RoJ10gPSBTdHJpbmcodXBsb2FkQm9keVNpemUpO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGVsc2UgaWYgKGNhbm5vdEhhdmVCb2R5KSB7XG4gICAgICAgICAgICB0aGlzLl9sb2NrV3JpdGUoKTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIHRoaXMuX3VubG9ja1dyaXRlKCk7XG4gICAgICAgIH1cbiAgICAgICAgdGhpc1trQm9keVNpemVdID0gTnVtYmVyKGhlYWRlcnNbJ2NvbnRlbnQtbGVuZ3RoJ10pIHx8IHVuZGVmaW5lZDtcbiAgICB9XG4gICAgYXN5bmMgX29uUmVzcG9uc2VCYXNlKHJlc3BvbnNlKSB7XG4gICAgICAgIGNvbnN0IHsgb3B0aW9ucyB9ID0gdGhpcztcbiAgICAgICAgY29uc3QgeyB1cmwgfSA9IG9wdGlvbnM7XG4gICAgICAgIHRoaXNba09yaWdpbmFsUmVzcG9uc2VdID0gcmVzcG9uc2U7XG4gICAgICAgIGlmIChvcHRpb25zLmRlY29tcHJlc3MpIHtcbiAgICAgICAgICAgIHJlc3BvbnNlID0gZGVjb21wcmVzc1Jlc3BvbnNlKHJlc3BvbnNlKTtcbiAgICAgICAgfVxuICAgICAgICBjb25zdCBzdGF0dXNDb2RlID0gcmVzcG9uc2Uuc3RhdHVzQ29kZTtcbiAgICAgICAgY29uc3QgdHlwZWRSZXNwb25zZSA9IHJlc3BvbnNlO1xuICAgICAgICB0eXBlZFJlc3BvbnNlLnN0YXR1c01lc3NhZ2UgPSB0eXBlZFJlc3BvbnNlLnN0YXR1c01lc3NhZ2UgPyB0eXBlZFJlc3BvbnNlLnN0YXR1c01lc3NhZ2UgOiBodHRwLlNUQVRVU19DT0RFU1tzdGF0dXNDb2RlXTtcbiAgICAgICAgdHlwZWRSZXNwb25zZS51cmwgPSBvcHRpb25zLnVybC50b1N0cmluZygpO1xuICAgICAgICB0eXBlZFJlc3BvbnNlLnJlcXVlc3RVcmwgPSB0aGlzLnJlcXVlc3RVcmw7XG4gICAgICAgIHR5cGVkUmVzcG9uc2UucmVkaXJlY3RVcmxzID0gdGhpcy5yZWRpcmVjdHM7XG4gICAgICAgIHR5cGVkUmVzcG9uc2UucmVxdWVzdCA9IHRoaXM7XG4gICAgICAgIHR5cGVkUmVzcG9uc2UuaXNGcm9tQ2FjaGUgPSByZXNwb25zZS5mcm9tQ2FjaGUgfHwgZmFsc2U7XG4gICAgICAgIHR5cGVkUmVzcG9uc2UuaXAgPSB0aGlzLmlwO1xuICAgICAgICB0eXBlZFJlc3BvbnNlLnJldHJ5Q291bnQgPSB0aGlzLnJldHJ5Q291bnQ7XG4gICAgICAgIHRoaXNba0lzRnJvbUNhY2hlXSA9IHR5cGVkUmVzcG9uc2UuaXNGcm9tQ2FjaGU7XG4gICAgICAgIHRoaXNba1Jlc3BvbnNlU2l6ZV0gPSBOdW1iZXIocmVzcG9uc2UuaGVhZGVyc1snY29udGVudC1sZW5ndGgnXSkgfHwgdW5kZWZpbmVkO1xuICAgICAgICB0aGlzW2tSZXNwb25zZV0gPSByZXNwb25zZTtcbiAgICAgICAgcmVzcG9uc2Uub25jZSgnZW5kJywgKCkgPT4ge1xuICAgICAgICAgICAgdGhpc1trUmVzcG9uc2VTaXplXSA9IHRoaXNba0Rvd25sb2FkZWRTaXplXTtcbiAgICAgICAgICAgIHRoaXMuZW1pdCgnZG93bmxvYWRQcm9ncmVzcycsIHRoaXMuZG93bmxvYWRQcm9ncmVzcyk7XG4gICAgICAgIH0pO1xuICAgICAgICByZXNwb25zZS5vbmNlKCdlcnJvcicsIChlcnJvcikgPT4ge1xuICAgICAgICAgICAgLy8gRm9yY2UgY2xlYW4tdXAsIGJlY2F1c2Ugc29tZSBwYWNrYWdlcyBkb24ndCBkbyB0aGlzLlxuICAgICAgICAgICAgLy8gVE9ETzogRml4IGRlY29tcHJlc3MtcmVzcG9uc2VcbiAgICAgICAgICAgIHJlc3BvbnNlLmRlc3Ryb3koKTtcbiAgICAgICAgICAgIHRoaXMuX2JlZm9yZUVycm9yKG5ldyBSZWFkRXJyb3IoZXJyb3IsIHRoaXMpKTtcbiAgICAgICAgfSk7XG4gICAgICAgIHJlc3BvbnNlLm9uY2UoJ2Fib3J0ZWQnLCAoKSA9PiB7XG4gICAgICAgICAgICB0aGlzLl9iZWZvcmVFcnJvcihuZXcgUmVhZEVycm9yKHtcbiAgICAgICAgICAgICAgICBuYW1lOiAnRXJyb3InLFxuICAgICAgICAgICAgICAgIG1lc3NhZ2U6ICdUaGUgc2VydmVyIGFib3J0ZWQgcGVuZGluZyByZXF1ZXN0JyxcbiAgICAgICAgICAgICAgICBjb2RlOiAnRUNPTk5SRVNFVCdcbiAgICAgICAgICAgIH0sIHRoaXMpKTtcbiAgICAgICAgfSk7XG4gICAgICAgIHRoaXMuZW1pdCgnZG93bmxvYWRQcm9ncmVzcycsIHRoaXMuZG93bmxvYWRQcm9ncmVzcyk7XG4gICAgICAgIGNvbnN0IHJhd0Nvb2tpZXMgPSByZXNwb25zZS5oZWFkZXJzWydzZXQtY29va2llJ107XG4gICAgICAgIGlmIChpc18xLmRlZmF1bHQub2JqZWN0KG9wdGlvbnMuY29va2llSmFyKSAmJiByYXdDb29raWVzKSB7XG4gICAgICAgICAgICBsZXQgcHJvbWlzZXMgPSByYXdDb29raWVzLm1hcChhc3luYyAocmF3Q29va2llKSA9PiBvcHRpb25zLmNvb2tpZUphci5zZXRDb29raWUocmF3Q29va2llLCB1cmwudG9TdHJpbmcoKSkpO1xuICAgICAgICAgICAgaWYgKG9wdGlvbnMuaWdub3JlSW52YWxpZENvb2tpZXMpIHtcbiAgICAgICAgICAgICAgICBwcm9taXNlcyA9IHByb21pc2VzLm1hcChhc3luYyAocCkgPT4gcC5jYXRjaCgoKSA9PiB7IH0pKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHRyeSB7XG4gICAgICAgICAgICAgICAgYXdhaXQgUHJvbWlzZS5hbGwocHJvbWlzZXMpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgY2F0Y2ggKGVycm9yKSB7XG4gICAgICAgICAgICAgICAgdGhpcy5fYmVmb3JlRXJyb3IoZXJyb3IpO1xuICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBpZiAob3B0aW9ucy5mb2xsb3dSZWRpcmVjdCAmJiByZXNwb25zZS5oZWFkZXJzLmxvY2F0aW9uICYmIHJlZGlyZWN0Q29kZXMuaGFzKHN0YXR1c0NvZGUpKSB7XG4gICAgICAgICAgICAvLyBXZSdyZSBiZWluZyByZWRpcmVjdGVkLCB3ZSBkb24ndCBjYXJlIGFib3V0IHRoZSByZXNwb25zZS5cbiAgICAgICAgICAgIC8vIEl0J2QgYmUgYmVzdCB0byBhYm9ydCB0aGUgcmVxdWVzdCwgYnV0IHdlIGNhbid0IGJlY2F1c2VcbiAgICAgICAgICAgIC8vIHdlIHdvdWxkIGhhdmUgdG8gc2FjcmlmaWNlIHRoZSBUQ1AgY29ubmVjdGlvbi4gV2UgZG9uJ3Qgd2FudCB0aGF0LlxuICAgICAgICAgICAgcmVzcG9uc2UucmVzdW1lKCk7XG4gICAgICAgICAgICBpZiAodGhpc1trUmVxdWVzdF0pIHtcbiAgICAgICAgICAgICAgICB0aGlzW2tDYW5jZWxUaW1lb3V0c10oKTtcbiAgICAgICAgICAgICAgICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgQHR5cGVzY3JpcHQtZXNsaW50L25vLWR5bmFtaWMtZGVsZXRlXG4gICAgICAgICAgICAgICAgZGVsZXRlIHRoaXNba1JlcXVlc3RdO1xuICAgICAgICAgICAgICAgIHRoaXNba1VucHJveHlFdmVudHNdKCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBjb25zdCBzaG91bGRCZUdldCA9IHN0YXR1c0NvZGUgPT09IDMwMyAmJiBvcHRpb25zLm1ldGhvZCAhPT0gJ0dFVCcgJiYgb3B0aW9ucy5tZXRob2QgIT09ICdIRUFEJztcbiAgICAgICAgICAgIGlmIChzaG91bGRCZUdldCB8fCAhb3B0aW9ucy5tZXRob2RSZXdyaXRpbmcpIHtcbiAgICAgICAgICAgICAgICAvLyBTZXJ2ZXIgcmVzcG9uZGVkIHdpdGggXCJzZWUgb3RoZXJcIiwgaW5kaWNhdGluZyB0aGF0IHRoZSByZXNvdXJjZSBleGlzdHMgYXQgYW5vdGhlciBsb2NhdGlvbixcbiAgICAgICAgICAgICAgICAvLyBhbmQgdGhlIGNsaWVudCBzaG91bGQgcmVxdWVzdCBpdCBmcm9tIHRoYXQgbG9jYXRpb24gdmlhIEdFVCBvciBIRUFELlxuICAgICAgICAgICAgICAgIG9wdGlvbnMubWV0aG9kID0gJ0dFVCc7XG4gICAgICAgICAgICAgICAgaWYgKCdib2R5JyBpbiBvcHRpb25zKSB7XG4gICAgICAgICAgICAgICAgICAgIGRlbGV0ZSBvcHRpb25zLmJvZHk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGlmICgnanNvbicgaW4gb3B0aW9ucykge1xuICAgICAgICAgICAgICAgICAgICBkZWxldGUgb3B0aW9ucy5qc29uO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBpZiAoJ2Zvcm0nIGluIG9wdGlvbnMpIHtcbiAgICAgICAgICAgICAgICAgICAgZGVsZXRlIG9wdGlvbnMuZm9ybTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgdGhpc1trQm9keV0gPSB1bmRlZmluZWQ7XG4gICAgICAgICAgICAgICAgZGVsZXRlIG9wdGlvbnMuaGVhZGVyc1snY29udGVudC1sZW5ndGgnXTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmICh0aGlzLnJlZGlyZWN0cy5sZW5ndGggPj0gb3B0aW9ucy5tYXhSZWRpcmVjdHMpIHtcbiAgICAgICAgICAgICAgICB0aGlzLl9iZWZvcmVFcnJvcihuZXcgTWF4UmVkaXJlY3RzRXJyb3IodGhpcykpO1xuICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHRyeSB7XG4gICAgICAgICAgICAgICAgLy8gRG8gbm90IHJlbW92ZS4gU2VlIGh0dHBzOi8vZ2l0aHViLmNvbS9zaW5kcmVzb3JodXMvZ290L3B1bGwvMjE0XG4gICAgICAgICAgICAgICAgY29uc3QgcmVkaXJlY3RCdWZmZXIgPSBCdWZmZXIuZnJvbShyZXNwb25zZS5oZWFkZXJzLmxvY2F0aW9uLCAnYmluYXJ5JykudG9TdHJpbmcoKTtcbiAgICAgICAgICAgICAgICAvLyBIYW5kbGVzIGludmFsaWQgVVJMcy4gU2VlIGh0dHBzOi8vZ2l0aHViLmNvbS9zaW5kcmVzb3JodXMvZ290L2lzc3Vlcy82MDRcbiAgICAgICAgICAgICAgICBjb25zdCByZWRpcmVjdFVybCA9IG5ldyB1cmxfMS5VUkwocmVkaXJlY3RCdWZmZXIsIHVybCk7XG4gICAgICAgICAgICAgICAgY29uc3QgcmVkaXJlY3RTdHJpbmcgPSByZWRpcmVjdFVybC50b1N0cmluZygpO1xuICAgICAgICAgICAgICAgIGRlY29kZVVSSShyZWRpcmVjdFN0cmluZyk7XG4gICAgICAgICAgICAgICAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIG5vLWlubmVyLWRlY2xhcmF0aW9uc1xuICAgICAgICAgICAgICAgIGZ1bmN0aW9uIGlzVW5peFNvY2tldFVSTCh1cmwpIHtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHVybC5wcm90b2NvbCA9PT0gJ3VuaXg6JyB8fCB1cmwuaG9zdG5hbWUgPT09ICd1bml4JztcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgaWYgKCFpc1VuaXhTb2NrZXRVUkwodXJsKSAmJiBpc1VuaXhTb2NrZXRVUkwocmVkaXJlY3RVcmwpKSB7XG4gICAgICAgICAgICAgICAgICAgIHRoaXMuX2JlZm9yZUVycm9yKG5ldyBSZXF1ZXN0RXJyb3IoJ0Nhbm5vdCByZWRpcmVjdCB0byBVTklYIHNvY2tldCcsIHt9LCB0aGlzKSk7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgLy8gUmVkaXJlY3RpbmcgdG8gYSBkaWZmZXJlbnQgc2l0ZSwgY2xlYXIgc2Vuc2l0aXZlIGRhdGEuXG4gICAgICAgICAgICAgICAgaWYgKHJlZGlyZWN0VXJsLmhvc3RuYW1lICE9PSB1cmwuaG9zdG5hbWUgfHwgcmVkaXJlY3RVcmwucG9ydCAhPT0gdXJsLnBvcnQpIHtcbiAgICAgICAgICAgICAgICAgICAgaWYgKCdob3N0JyBpbiBvcHRpb25zLmhlYWRlcnMpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGRlbGV0ZSBvcHRpb25zLmhlYWRlcnMuaG9zdDtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICBpZiAoJ2Nvb2tpZScgaW4gb3B0aW9ucy5oZWFkZXJzKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBkZWxldGUgb3B0aW9ucy5oZWFkZXJzLmNvb2tpZTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICBpZiAoJ2F1dGhvcml6YXRpb24nIGluIG9wdGlvbnMuaGVhZGVycykge1xuICAgICAgICAgICAgICAgICAgICAgICAgZGVsZXRlIG9wdGlvbnMuaGVhZGVycy5hdXRob3JpemF0aW9uO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIGlmIChvcHRpb25zLnVzZXJuYW1lIHx8IG9wdGlvbnMucGFzc3dvcmQpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIG9wdGlvbnMudXNlcm5hbWUgPSAnJztcbiAgICAgICAgICAgICAgICAgICAgICAgIG9wdGlvbnMucGFzc3dvcmQgPSAnJztcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgcmVkaXJlY3RVcmwudXNlcm5hbWUgPSBvcHRpb25zLnVzZXJuYW1lO1xuICAgICAgICAgICAgICAgICAgICByZWRpcmVjdFVybC5wYXNzd29yZCA9IG9wdGlvbnMucGFzc3dvcmQ7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIHRoaXMucmVkaXJlY3RzLnB1c2gocmVkaXJlY3RTdHJpbmcpO1xuICAgICAgICAgICAgICAgIG9wdGlvbnMudXJsID0gcmVkaXJlY3RVcmw7XG4gICAgICAgICAgICAgICAgZm9yIChjb25zdCBob29rIG9mIG9wdGlvbnMuaG9va3MuYmVmb3JlUmVkaXJlY3QpIHtcbiAgICAgICAgICAgICAgICAgICAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIG5vLWF3YWl0LWluLWxvb3BcbiAgICAgICAgICAgICAgICAgICAgYXdhaXQgaG9vayhvcHRpb25zLCB0eXBlZFJlc3BvbnNlKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgdGhpcy5lbWl0KCdyZWRpcmVjdCcsIHR5cGVkUmVzcG9uc2UsIG9wdGlvbnMpO1xuICAgICAgICAgICAgICAgIGF3YWl0IHRoaXMuX21ha2VSZXF1ZXN0KCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBjYXRjaCAoZXJyb3IpIHtcbiAgICAgICAgICAgICAgICB0aGlzLl9iZWZvcmVFcnJvcihlcnJvcik7XG4gICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICAgIGlmIChvcHRpb25zLmlzU3RyZWFtICYmIG9wdGlvbnMudGhyb3dIdHRwRXJyb3JzICYmICFpc19yZXNwb25zZV9va18xLmlzUmVzcG9uc2VPayh0eXBlZFJlc3BvbnNlKSkge1xuICAgICAgICAgICAgdGhpcy5fYmVmb3JlRXJyb3IobmV3IEhUVFBFcnJvcih0eXBlZFJlc3BvbnNlKSk7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgICAgcmVzcG9uc2Uub24oJ3JlYWRhYmxlJywgKCkgPT4ge1xuICAgICAgICAgICAgaWYgKHRoaXNba1RyaWdnZXJSZWFkXSkge1xuICAgICAgICAgICAgICAgIHRoaXMuX3JlYWQoKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSk7XG4gICAgICAgIHRoaXMub24oJ3Jlc3VtZScsICgpID0+IHtcbiAgICAgICAgICAgIHJlc3BvbnNlLnJlc3VtZSgpO1xuICAgICAgICB9KTtcbiAgICAgICAgdGhpcy5vbigncGF1c2UnLCAoKSA9PiB7XG4gICAgICAgICAgICByZXNwb25zZS5wYXVzZSgpO1xuICAgICAgICB9KTtcbiAgICAgICAgcmVzcG9uc2Uub25jZSgnZW5kJywgKCkgPT4ge1xuICAgICAgICAgICAgdGhpcy5wdXNoKG51bGwpO1xuICAgICAgICB9KTtcbiAgICAgICAgdGhpcy5lbWl0KCdyZXNwb25zZScsIHJlc3BvbnNlKTtcbiAgICAgICAgZm9yIChjb25zdCBkZXN0aW5hdGlvbiBvZiB0aGlzW2tTZXJ2ZXJSZXNwb25zZXNQaXBlZF0pIHtcbiAgICAgICAgICAgIGlmIChkZXN0aW5hdGlvbi5oZWFkZXJzU2VudCkge1xuICAgICAgICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIGd1YXJkLWZvci1pblxuICAgICAgICAgICAgZm9yIChjb25zdCBrZXkgaW4gcmVzcG9uc2UuaGVhZGVycykge1xuICAgICAgICAgICAgICAgIGNvbnN0IGlzQWxsb3dlZCA9IG9wdGlvbnMuZGVjb21wcmVzcyA/IGtleSAhPT0gJ2NvbnRlbnQtZW5jb2RpbmcnIDogdHJ1ZTtcbiAgICAgICAgICAgICAgICBjb25zdCB2YWx1ZSA9IHJlc3BvbnNlLmhlYWRlcnNba2V5XTtcbiAgICAgICAgICAgICAgICBpZiAoaXNBbGxvd2VkKSB7XG4gICAgICAgICAgICAgICAgICAgIGRlc3RpbmF0aW9uLnNldEhlYWRlcihrZXksIHZhbHVlKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBkZXN0aW5hdGlvbi5zdGF0dXNDb2RlID0gc3RhdHVzQ29kZTtcbiAgICAgICAgfVxuICAgIH1cbiAgICBhc3luYyBfb25SZXNwb25zZShyZXNwb25zZSkge1xuICAgICAgICB0cnkge1xuICAgICAgICAgICAgYXdhaXQgdGhpcy5fb25SZXNwb25zZUJhc2UocmVzcG9uc2UpO1xuICAgICAgICB9XG4gICAgICAgIGNhdGNoIChlcnJvcikge1xuICAgICAgICAgICAgLyogaXN0YW5idWwgaWdub3JlIG5leHQ6IGJldHRlciBzYWZlIHRoYW4gc29ycnkgKi9cbiAgICAgICAgICAgIHRoaXMuX2JlZm9yZUVycm9yKGVycm9yKTtcbiAgICAgICAgfVxuICAgIH1cbiAgICBfb25SZXF1ZXN0KHJlcXVlc3QpIHtcbiAgICAgICAgY29uc3QgeyBvcHRpb25zIH0gPSB0aGlzO1xuICAgICAgICBjb25zdCB7IHRpbWVvdXQsIHVybCB9ID0gb3B0aW9ucztcbiAgICAgICAgaHR0cF90aW1lcl8xLmRlZmF1bHQocmVxdWVzdCk7XG4gICAgICAgIHRoaXNba0NhbmNlbFRpbWVvdXRzXSA9IHRpbWVkX291dF8xLmRlZmF1bHQocmVxdWVzdCwgdGltZW91dCwgdXJsKTtcbiAgICAgICAgY29uc3QgcmVzcG9uc2VFdmVudE5hbWUgPSBvcHRpb25zLmNhY2hlID8gJ2NhY2hlYWJsZVJlc3BvbnNlJyA6ICdyZXNwb25zZSc7XG4gICAgICAgIHJlcXVlc3Qub25jZShyZXNwb25zZUV2ZW50TmFtZSwgKHJlc3BvbnNlKSA9PiB7XG4gICAgICAgICAgICB2b2lkIHRoaXMuX29uUmVzcG9uc2UocmVzcG9uc2UpO1xuICAgICAgICB9KTtcbiAgICAgICAgcmVxdWVzdC5vbmNlKCdlcnJvcicsIChlcnJvcikgPT4ge1xuICAgICAgICAgICAgdmFyIF9hO1xuICAgICAgICAgICAgLy8gRm9yY2UgY2xlYW4tdXAsIGJlY2F1c2Ugc29tZSBwYWNrYWdlcyAoZS5nLiBub2NrKSBkb24ndCBkbyB0aGlzLlxuICAgICAgICAgICAgcmVxdWVzdC5kZXN0cm95KCk7XG4gICAgICAgICAgICAvLyBOb2RlLmpzIDw9IDEyLjE4LjIgbWlzdGFrZW5seSBlbWl0cyB0aGUgcmVzcG9uc2UgYGVuZGAgZmlyc3QuXG4gICAgICAgICAgICAoX2EgPSByZXF1ZXN0LnJlcykgPT09IG51bGwgfHwgX2EgPT09IHZvaWQgMCA/IHZvaWQgMCA6IF9hLnJlbW92ZUFsbExpc3RlbmVycygnZW5kJyk7XG4gICAgICAgICAgICBlcnJvciA9IGVycm9yIGluc3RhbmNlb2YgdGltZWRfb3V0XzEuVGltZW91dEVycm9yID8gbmV3IFRpbWVvdXRFcnJvcihlcnJvciwgdGhpcy50aW1pbmdzLCB0aGlzKSA6IG5ldyBSZXF1ZXN0RXJyb3IoZXJyb3IubWVzc2FnZSwgZXJyb3IsIHRoaXMpO1xuICAgICAgICAgICAgdGhpcy5fYmVmb3JlRXJyb3IoZXJyb3IpO1xuICAgICAgICB9KTtcbiAgICAgICAgdGhpc1trVW5wcm94eUV2ZW50c10gPSBwcm94eV9ldmVudHNfMS5kZWZhdWx0KHJlcXVlc3QsIHRoaXMsIHByb3hpZWRSZXF1ZXN0RXZlbnRzKTtcbiAgICAgICAgdGhpc1trUmVxdWVzdF0gPSByZXF1ZXN0O1xuICAgICAgICB0aGlzLmVtaXQoJ3VwbG9hZFByb2dyZXNzJywgdGhpcy51cGxvYWRQcm9ncmVzcyk7XG4gICAgICAgIC8vIFNlbmQgYm9keVxuICAgICAgICBjb25zdCBib2R5ID0gdGhpc1trQm9keV07XG4gICAgICAgIGNvbnN0IGN1cnJlbnRSZXF1ZXN0ID0gdGhpcy5yZWRpcmVjdHMubGVuZ3RoID09PSAwID8gdGhpcyA6IHJlcXVlc3Q7XG4gICAgICAgIGlmIChpc18xLmRlZmF1bHQubm9kZVN0cmVhbShib2R5KSkge1xuICAgICAgICAgICAgYm9keS5waXBlKGN1cnJlbnRSZXF1ZXN0KTtcbiAgICAgICAgICAgIGJvZHkub25jZSgnZXJyb3InLCAoZXJyb3IpID0+IHtcbiAgICAgICAgICAgICAgICB0aGlzLl9iZWZvcmVFcnJvcihuZXcgVXBsb2FkRXJyb3IoZXJyb3IsIHRoaXMpKTtcbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgdGhpcy5fdW5sb2NrV3JpdGUoKTtcbiAgICAgICAgICAgIGlmICghaXNfMS5kZWZhdWx0LnVuZGVmaW5lZChib2R5KSkge1xuICAgICAgICAgICAgICAgIHRoaXMuX3dyaXRlUmVxdWVzdChib2R5LCB1bmRlZmluZWQsICgpID0+IHsgfSk7XG4gICAgICAgICAgICAgICAgY3VycmVudFJlcXVlc3QuZW5kKCk7XG4gICAgICAgICAgICAgICAgdGhpcy5fbG9ja1dyaXRlKCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIGlmICh0aGlzLl9jYW5ub3RIYXZlQm9keSB8fCB0aGlzLl9ub1BpcGUpIHtcbiAgICAgICAgICAgICAgICBjdXJyZW50UmVxdWVzdC5lbmQoKTtcbiAgICAgICAgICAgICAgICB0aGlzLl9sb2NrV3JpdGUoKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICB0aGlzLmVtaXQoJ3JlcXVlc3QnLCByZXF1ZXN0KTtcbiAgICB9XG4gICAgYXN5bmMgX2NyZWF0ZUNhY2hlYWJsZVJlcXVlc3QodXJsLCBvcHRpb25zKSB7XG4gICAgICAgIHJldHVybiBuZXcgUHJvbWlzZSgocmVzb2x2ZSwgcmVqZWN0KSA9PiB7XG4gICAgICAgICAgICAvLyBUT0RPOiBSZW1vdmUgYHV0aWxzL3VybC10by1vcHRpb25zLnRzYCB3aGVuIGBjYWNoZWFibGUtcmVxdWVzdGAgaXMgZml4ZWRcbiAgICAgICAgICAgIE9iamVjdC5hc3NpZ24ob3B0aW9ucywgdXJsX3RvX29wdGlvbnNfMS5kZWZhdWx0KHVybCkpO1xuICAgICAgICAgICAgLy8gYGh0dHAtY2FjaGUtc2VtYW50aWNzYCBjaGVja3MgdGhpc1xuICAgICAgICAgICAgLy8gVE9ETzogRml4IHRoaXMgaWdub3JlLlxuICAgICAgICAgICAgLy8gQHRzLWV4cGVjdC1lcnJvclxuICAgICAgICAgICAgZGVsZXRlIG9wdGlvbnMudXJsO1xuICAgICAgICAgICAgbGV0IHJlcXVlc3Q7XG4gICAgICAgICAgICAvLyBUaGlzIGlzIHVnbHlcbiAgICAgICAgICAgIGNvbnN0IGNhY2hlUmVxdWVzdCA9IGNhY2hlYWJsZVN0b3JlLmdldChvcHRpb25zLmNhY2hlKShvcHRpb25zLCBhc3luYyAocmVzcG9uc2UpID0+IHtcbiAgICAgICAgICAgICAgICAvLyBUT0RPOiBGaXggYGNhY2hlYWJsZS1yZXNwb25zZWBcbiAgICAgICAgICAgICAgICByZXNwb25zZS5fcmVhZGFibGVTdGF0ZS5hdXRvRGVzdHJveSA9IGZhbHNlO1xuICAgICAgICAgICAgICAgIGlmIChyZXF1ZXN0KSB7XG4gICAgICAgICAgICAgICAgICAgIChhd2FpdCByZXF1ZXN0KS5lbWl0KCdjYWNoZWFibGVSZXNwb25zZScsIHJlc3BvbnNlKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgcmVzb2x2ZShyZXNwb25zZSk7XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIC8vIFJlc3RvcmUgb3B0aW9uc1xuICAgICAgICAgICAgb3B0aW9ucy51cmwgPSB1cmw7XG4gICAgICAgICAgICBjYWNoZVJlcXVlc3Qub25jZSgnZXJyb3InLCByZWplY3QpO1xuICAgICAgICAgICAgY2FjaGVSZXF1ZXN0Lm9uY2UoJ3JlcXVlc3QnLCBhc3luYyAocmVxdWVzdE9yUHJvbWlzZSkgPT4ge1xuICAgICAgICAgICAgICAgIHJlcXVlc3QgPSByZXF1ZXN0T3JQcm9taXNlO1xuICAgICAgICAgICAgICAgIHJlc29sdmUocmVxdWVzdCk7XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfSk7XG4gICAgfVxuICAgIGFzeW5jIF9tYWtlUmVxdWVzdCgpIHtcbiAgICAgICAgdmFyIF9hLCBfYiwgX2MsIF9kLCBfZTtcbiAgICAgICAgY29uc3QgeyBvcHRpb25zIH0gPSB0aGlzO1xuICAgICAgICBjb25zdCB7IGhlYWRlcnMgfSA9IG9wdGlvbnM7XG4gICAgICAgIGZvciAoY29uc3Qga2V5IGluIGhlYWRlcnMpIHtcbiAgICAgICAgICAgIGlmIChpc18xLmRlZmF1bHQudW5kZWZpbmVkKGhlYWRlcnNba2V5XSkpIHtcbiAgICAgICAgICAgICAgICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgQHR5cGVzY3JpcHQtZXNsaW50L25vLWR5bmFtaWMtZGVsZXRlXG4gICAgICAgICAgICAgICAgZGVsZXRlIGhlYWRlcnNba2V5XTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2UgaWYgKGlzXzEuZGVmYXVsdC5udWxsXyhoZWFkZXJzW2tleV0pKSB7XG4gICAgICAgICAgICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvcihgVXNlIFxcYHVuZGVmaW5lZFxcYCBpbnN0ZWFkIG9mIFxcYG51bGxcXGAgdG8gZGVsZXRlIHRoZSBcXGAke2tleX1cXGAgaGVhZGVyYCk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgaWYgKG9wdGlvbnMuZGVjb21wcmVzcyAmJiBpc18xLmRlZmF1bHQudW5kZWZpbmVkKGhlYWRlcnNbJ2FjY2VwdC1lbmNvZGluZyddKSkge1xuICAgICAgICAgICAgaGVhZGVyc1snYWNjZXB0LWVuY29kaW5nJ10gPSBzdXBwb3J0c0Jyb3RsaSA/ICdnemlwLCBkZWZsYXRlLCBicicgOiAnZ3ppcCwgZGVmbGF0ZSc7XG4gICAgICAgIH1cbiAgICAgICAgLy8gU2V0IGNvb2tpZXNcbiAgICAgICAgaWYgKG9wdGlvbnMuY29va2llSmFyKSB7XG4gICAgICAgICAgICBjb25zdCBjb29raWVTdHJpbmcgPSBhd2FpdCBvcHRpb25zLmNvb2tpZUphci5nZXRDb29raWVTdHJpbmcob3B0aW9ucy51cmwudG9TdHJpbmcoKSk7XG4gICAgICAgICAgICBpZiAoaXNfMS5kZWZhdWx0Lm5vbkVtcHR5U3RyaW5nKGNvb2tpZVN0cmluZykpIHtcbiAgICAgICAgICAgICAgICBvcHRpb25zLmhlYWRlcnMuY29va2llID0gY29va2llU3RyaW5nO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGZvciAoY29uc3QgaG9vayBvZiBvcHRpb25zLmhvb2tzLmJlZm9yZVJlcXVlc3QpIHtcbiAgICAgICAgICAgIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBuby1hd2FpdC1pbi1sb29wXG4gICAgICAgICAgICBjb25zdCByZXN1bHQgPSBhd2FpdCBob29rKG9wdGlvbnMpO1xuICAgICAgICAgICAgaWYgKCFpc18xLmRlZmF1bHQudW5kZWZpbmVkKHJlc3VsdCkpIHtcbiAgICAgICAgICAgICAgICAvLyBAdHMtZXhwZWN0LWVycm9yIFNraXAgdGhlIHR5cGUgbWlzbWF0Y2ggdG8gc3VwcG9ydCBhYnN0cmFjdCByZXNwb25zZXNcbiAgICAgICAgICAgICAgICBvcHRpb25zLnJlcXVlc3QgPSAoKSA9PiByZXN1bHQ7XG4gICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgaWYgKG9wdGlvbnMuYm9keSAmJiB0aGlzW2tCb2R5XSAhPT0gb3B0aW9ucy5ib2R5KSB7XG4gICAgICAgICAgICB0aGlzW2tCb2R5XSA9IG9wdGlvbnMuYm9keTtcbiAgICAgICAgfVxuICAgICAgICBjb25zdCB7IGFnZW50LCByZXF1ZXN0LCB0aW1lb3V0LCB1cmwgfSA9IG9wdGlvbnM7XG4gICAgICAgIGlmIChvcHRpb25zLmRuc0NhY2hlICYmICEoJ2xvb2t1cCcgaW4gb3B0aW9ucykpIHtcbiAgICAgICAgICAgIG9wdGlvbnMubG9va3VwID0gb3B0aW9ucy5kbnNDYWNoZS5sb29rdXA7XG4gICAgICAgIH1cbiAgICAgICAgLy8gVU5JWCBzb2NrZXRzXG4gICAgICAgIGlmICh1cmwuaG9zdG5hbWUgPT09ICd1bml4Jykge1xuICAgICAgICAgICAgY29uc3QgbWF0Y2hlcyA9IC8oPzxzb2NrZXRQYXRoPi4rPyk6KD88cGF0aD4uKykvLmV4ZWMoYCR7dXJsLnBhdGhuYW1lfSR7dXJsLnNlYXJjaH1gKTtcbiAgICAgICAgICAgIGlmIChtYXRjaGVzID09PSBudWxsIHx8IG1hdGNoZXMgPT09IHZvaWQgMCA/IHZvaWQgMCA6IG1hdGNoZXMuZ3JvdXBzKSB7XG4gICAgICAgICAgICAgICAgY29uc3QgeyBzb2NrZXRQYXRoLCBwYXRoIH0gPSBtYXRjaGVzLmdyb3VwcztcbiAgICAgICAgICAgICAgICBPYmplY3QuYXNzaWduKG9wdGlvbnMsIHtcbiAgICAgICAgICAgICAgICAgICAgc29ja2V0UGF0aCxcbiAgICAgICAgICAgICAgICAgICAgcGF0aCxcbiAgICAgICAgICAgICAgICAgICAgaG9zdDogJydcbiAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBjb25zdCBpc0h0dHBzID0gdXJsLnByb3RvY29sID09PSAnaHR0cHM6JztcbiAgICAgICAgLy8gRmFsbGJhY2sgZnVuY3Rpb25cbiAgICAgICAgbGV0IGZhbGxiYWNrRm47XG4gICAgICAgIGlmIChvcHRpb25zLmh0dHAyKSB7XG4gICAgICAgICAgICBmYWxsYmFja0ZuID0gaHR0cDJ3cmFwcGVyLmF1dG87XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICBmYWxsYmFja0ZuID0gaXNIdHRwcyA/IGh0dHBzLnJlcXVlc3QgOiBodHRwLnJlcXVlc3Q7XG4gICAgICAgIH1cbiAgICAgICAgY29uc3QgcmVhbEZuID0gKF9hID0gb3B0aW9ucy5yZXF1ZXN0KSAhPT0gbnVsbCAmJiBfYSAhPT0gdm9pZCAwID8gX2EgOiBmYWxsYmFja0ZuO1xuICAgICAgICAvLyBDYWNoZSBzdXBwb3J0XG4gICAgICAgIGNvbnN0IGZuID0gb3B0aW9ucy5jYWNoZSA/IHRoaXMuX2NyZWF0ZUNhY2hlYWJsZVJlcXVlc3QgOiByZWFsRm47XG4gICAgICAgIC8vIFBhc3MgYW4gYWdlbnQgZGlyZWN0bHkgd2hlbiBIVFRQMiBpcyBkaXNhYmxlZFxuICAgICAgICBpZiAoYWdlbnQgJiYgIW9wdGlvbnMuaHR0cDIpIHtcbiAgICAgICAgICAgIG9wdGlvbnMuYWdlbnQgPSBhZ2VudFtpc0h0dHBzID8gJ2h0dHBzJyA6ICdodHRwJ107XG4gICAgICAgIH1cbiAgICAgICAgLy8gUHJlcGFyZSBwbGFpbiBIVFRQIHJlcXVlc3Qgb3B0aW9uc1xuICAgICAgICBvcHRpb25zW2tSZXF1ZXN0XSA9IHJlYWxGbjtcbiAgICAgICAgZGVsZXRlIG9wdGlvbnMucmVxdWVzdDtcbiAgICAgICAgLy8gVE9ETzogRml4IHRoaXMgaWdub3JlLlxuICAgICAgICAvLyBAdHMtZXhwZWN0LWVycm9yXG4gICAgICAgIGRlbGV0ZSBvcHRpb25zLnRpbWVvdXQ7XG4gICAgICAgIGNvbnN0IHJlcXVlc3RPcHRpb25zID0gb3B0aW9ucztcbiAgICAgICAgcmVxdWVzdE9wdGlvbnMuc2hhcmVkID0gKF9iID0gb3B0aW9ucy5jYWNoZU9wdGlvbnMpID09PSBudWxsIHx8IF9iID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfYi5zaGFyZWQ7XG4gICAgICAgIHJlcXVlc3RPcHRpb25zLmNhY2hlSGV1cmlzdGljID0gKF9jID0gb3B0aW9ucy5jYWNoZU9wdGlvbnMpID09PSBudWxsIHx8IF9jID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfYy5jYWNoZUhldXJpc3RpYztcbiAgICAgICAgcmVxdWVzdE9wdGlvbnMuaW1tdXRhYmxlTWluVGltZVRvTGl2ZSA9IChfZCA9IG9wdGlvbnMuY2FjaGVPcHRpb25zKSA9PT0gbnVsbCB8fCBfZCA9PT0gdm9pZCAwID8gdm9pZCAwIDogX2QuaW1tdXRhYmxlTWluVGltZVRvTGl2ZTtcbiAgICAgICAgcmVxdWVzdE9wdGlvbnMuaWdub3JlQ2FyZ29DdWx0ID0gKF9lID0gb3B0aW9ucy5jYWNoZU9wdGlvbnMpID09PSBudWxsIHx8IF9lID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfZS5pZ25vcmVDYXJnb0N1bHQ7XG4gICAgICAgIC8vIElmIGBkbnNMb29rdXBJcFZlcnNpb25gIGlzIG5vdCBwcmVzZW50IGRvIG5vdCBvdmVycmlkZSBgZmFtaWx5YFxuICAgICAgICBpZiAob3B0aW9ucy5kbnNMb29rdXBJcFZlcnNpb24gIT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgICAgICByZXF1ZXN0T3B0aW9ucy5mYW1pbHkgPSBkbnNfaXBfdmVyc2lvbl8xLmRuc0xvb2t1cElwVmVyc2lvblRvRmFtaWx5KG9wdGlvbnMuZG5zTG9va3VwSXBWZXJzaW9uKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGNhdGNoIChfZikge1xuICAgICAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcignSW52YWxpZCBgZG5zTG9va3VwSXBWZXJzaW9uYCBvcHRpb24gdmFsdWUnKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICAvLyBIVFRQUyBvcHRpb25zIHJlbWFwcGluZ1xuICAgICAgICBpZiAob3B0aW9ucy5odHRwcykge1xuICAgICAgICAgICAgaWYgKCdyZWplY3RVbmF1dGhvcml6ZWQnIGluIG9wdGlvbnMuaHR0cHMpIHtcbiAgICAgICAgICAgICAgICByZXF1ZXN0T3B0aW9ucy5yZWplY3RVbmF1dGhvcml6ZWQgPSBvcHRpb25zLmh0dHBzLnJlamVjdFVuYXV0aG9yaXplZDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmIChvcHRpb25zLmh0dHBzLmNoZWNrU2VydmVySWRlbnRpdHkpIHtcbiAgICAgICAgICAgICAgICByZXF1ZXN0T3B0aW9ucy5jaGVja1NlcnZlcklkZW50aXR5ID0gb3B0aW9ucy5odHRwcy5jaGVja1NlcnZlcklkZW50aXR5O1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKG9wdGlvbnMuaHR0cHMuY2VydGlmaWNhdGVBdXRob3JpdHkpIHtcbiAgICAgICAgICAgICAgICByZXF1ZXN0T3B0aW9ucy5jYSA9IG9wdGlvbnMuaHR0cHMuY2VydGlmaWNhdGVBdXRob3JpdHk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAob3B0aW9ucy5odHRwcy5jZXJ0aWZpY2F0ZSkge1xuICAgICAgICAgICAgICAgIHJlcXVlc3RPcHRpb25zLmNlcnQgPSBvcHRpb25zLmh0dHBzLmNlcnRpZmljYXRlO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKG9wdGlvbnMuaHR0cHMua2V5KSB7XG4gICAgICAgICAgICAgICAgcmVxdWVzdE9wdGlvbnMua2V5ID0gb3B0aW9ucy5odHRwcy5rZXk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAob3B0aW9ucy5odHRwcy5wYXNzcGhyYXNlKSB7XG4gICAgICAgICAgICAgICAgcmVxdWVzdE9wdGlvbnMucGFzc3BocmFzZSA9IG9wdGlvbnMuaHR0cHMucGFzc3BocmFzZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmIChvcHRpb25zLmh0dHBzLnBmeCkge1xuICAgICAgICAgICAgICAgIHJlcXVlc3RPcHRpb25zLnBmeCA9IG9wdGlvbnMuaHR0cHMucGZ4O1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHRyeSB7XG4gICAgICAgICAgICBsZXQgcmVxdWVzdE9yUmVzcG9uc2UgPSBhd2FpdCBmbih1cmwsIHJlcXVlc3RPcHRpb25zKTtcbiAgICAgICAgICAgIGlmIChpc18xLmRlZmF1bHQudW5kZWZpbmVkKHJlcXVlc3RPclJlc3BvbnNlKSkge1xuICAgICAgICAgICAgICAgIHJlcXVlc3RPclJlc3BvbnNlID0gZmFsbGJhY2tGbih1cmwsIHJlcXVlc3RPcHRpb25zKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIC8vIFJlc3RvcmUgb3B0aW9uc1xuICAgICAgICAgICAgb3B0aW9ucy5yZXF1ZXN0ID0gcmVxdWVzdDtcbiAgICAgICAgICAgIG9wdGlvbnMudGltZW91dCA9IHRpbWVvdXQ7XG4gICAgICAgICAgICBvcHRpb25zLmFnZW50ID0gYWdlbnQ7XG4gICAgICAgICAgICAvLyBIVFRQUyBvcHRpb25zIHJlc3RvcmVcbiAgICAgICAgICAgIGlmIChvcHRpb25zLmh0dHBzKSB7XG4gICAgICAgICAgICAgICAgaWYgKCdyZWplY3RVbmF1dGhvcml6ZWQnIGluIG9wdGlvbnMuaHR0cHMpIHtcbiAgICAgICAgICAgICAgICAgICAgZGVsZXRlIHJlcXVlc3RPcHRpb25zLnJlamVjdFVuYXV0aG9yaXplZDtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgaWYgKG9wdGlvbnMuaHR0cHMuY2hlY2tTZXJ2ZXJJZGVudGl0eSkge1xuICAgICAgICAgICAgICAgICAgICAvLyBAdHMtZXhwZWN0LWVycm9yIC0gVGhpcyBvbmUgd2lsbCBiZSByZW1vdmVkIHdoZW4gd2UgcmVtb3ZlIHRoZSBhbGlhcy5cbiAgICAgICAgICAgICAgICAgICAgZGVsZXRlIHJlcXVlc3RPcHRpb25zLmNoZWNrU2VydmVySWRlbnRpdHk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGlmIChvcHRpb25zLmh0dHBzLmNlcnRpZmljYXRlQXV0aG9yaXR5KSB7XG4gICAgICAgICAgICAgICAgICAgIGRlbGV0ZSByZXF1ZXN0T3B0aW9ucy5jYTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgaWYgKG9wdGlvbnMuaHR0cHMuY2VydGlmaWNhdGUpIHtcbiAgICAgICAgICAgICAgICAgICAgZGVsZXRlIHJlcXVlc3RPcHRpb25zLmNlcnQ7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGlmIChvcHRpb25zLmh0dHBzLmtleSkge1xuICAgICAgICAgICAgICAgICAgICBkZWxldGUgcmVxdWVzdE9wdGlvbnMua2V5O1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBpZiAob3B0aW9ucy5odHRwcy5wYXNzcGhyYXNlKSB7XG4gICAgICAgICAgICAgICAgICAgIGRlbGV0ZSByZXF1ZXN0T3B0aW9ucy5wYXNzcGhyYXNlO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBpZiAob3B0aW9ucy5odHRwcy5wZngpIHtcbiAgICAgICAgICAgICAgICAgICAgZGVsZXRlIHJlcXVlc3RPcHRpb25zLnBmeDtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAoaXNDbGllbnRSZXF1ZXN0KHJlcXVlc3RPclJlc3BvbnNlKSkge1xuICAgICAgICAgICAgICAgIHRoaXMuX29uUmVxdWVzdChyZXF1ZXN0T3JSZXNwb25zZSk7XG4gICAgICAgICAgICAgICAgLy8gRW1pdCB0aGUgcmVzcG9uc2UgYWZ0ZXIgdGhlIHN0cmVhbSBoYXMgYmVlbiBlbmRlZFxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSBpZiAodGhpcy53cml0YWJsZSkge1xuICAgICAgICAgICAgICAgIHRoaXMub25jZSgnZmluaXNoJywgKCkgPT4ge1xuICAgICAgICAgICAgICAgICAgICB2b2lkIHRoaXMuX29uUmVzcG9uc2UocmVxdWVzdE9yUmVzcG9uc2UpO1xuICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgIHRoaXMuX3VubG9ja1dyaXRlKCk7XG4gICAgICAgICAgICAgICAgdGhpcy5lbmQoKTtcbiAgICAgICAgICAgICAgICB0aGlzLl9sb2NrV3JpdGUoKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgIHZvaWQgdGhpcy5fb25SZXNwb25zZShyZXF1ZXN0T3JSZXNwb25zZSk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgY2F0Y2ggKGVycm9yKSB7XG4gICAgICAgICAgICBpZiAoZXJyb3IgaW5zdGFuY2VvZiBDYWNoZWFibGVSZXF1ZXN0LkNhY2hlRXJyb3IpIHtcbiAgICAgICAgICAgICAgICB0aHJvdyBuZXcgQ2FjaGVFcnJvcihlcnJvciwgdGhpcyk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICB0aHJvdyBuZXcgUmVxdWVzdEVycm9yKGVycm9yLm1lc3NhZ2UsIGVycm9yLCB0aGlzKTtcbiAgICAgICAgfVxuICAgIH1cbiAgICBhc3luYyBfZXJyb3IoZXJyb3IpIHtcbiAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgIGZvciAoY29uc3QgaG9vayBvZiB0aGlzLm9wdGlvbnMuaG9va3MuYmVmb3JlRXJyb3IpIHtcbiAgICAgICAgICAgICAgICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgbm8tYXdhaXQtaW4tbG9vcFxuICAgICAgICAgICAgICAgIGVycm9yID0gYXdhaXQgaG9vayhlcnJvcik7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgY2F0Y2ggKGVycm9yXykge1xuICAgICAgICAgICAgZXJyb3IgPSBuZXcgUmVxdWVzdEVycm9yKGVycm9yXy5tZXNzYWdlLCBlcnJvcl8sIHRoaXMpO1xuICAgICAgICB9XG4gICAgICAgIHRoaXMuZGVzdHJveShlcnJvcik7XG4gICAgfVxuICAgIF9iZWZvcmVFcnJvcihlcnJvcikge1xuICAgICAgICBpZiAodGhpc1trU3RvcFJlYWRpbmddKSB7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgICAgY29uc3QgeyBvcHRpb25zIH0gPSB0aGlzO1xuICAgICAgICBjb25zdCByZXRyeUNvdW50ID0gdGhpcy5yZXRyeUNvdW50ICsgMTtcbiAgICAgICAgdGhpc1trU3RvcFJlYWRpbmddID0gdHJ1ZTtcbiAgICAgICAgaWYgKCEoZXJyb3IgaW5zdGFuY2VvZiBSZXF1ZXN0RXJyb3IpKSB7XG4gICAgICAgICAgICBlcnJvciA9IG5ldyBSZXF1ZXN0RXJyb3IoZXJyb3IubWVzc2FnZSwgZXJyb3IsIHRoaXMpO1xuICAgICAgICB9XG4gICAgICAgIGNvbnN0IHR5cGVkRXJyb3IgPSBlcnJvcjtcbiAgICAgICAgY29uc3QgeyByZXNwb25zZSB9ID0gdHlwZWRFcnJvcjtcbiAgICAgICAgdm9pZCAoYXN5bmMgKCkgPT4ge1xuICAgICAgICAgICAgaWYgKHJlc3BvbnNlICYmICFyZXNwb25zZS5ib2R5KSB7XG4gICAgICAgICAgICAgICAgcmVzcG9uc2Uuc2V0RW5jb2RpbmcodGhpcy5fcmVhZGFibGVTdGF0ZS5lbmNvZGluZyk7XG4gICAgICAgICAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgICAgICAgICAgcmVzcG9uc2UucmF3Qm9keSA9IGF3YWl0IGdldF9idWZmZXJfMS5kZWZhdWx0KHJlc3BvbnNlKTtcbiAgICAgICAgICAgICAgICAgICAgcmVzcG9uc2UuYm9keSA9IHJlc3BvbnNlLnJhd0JvZHkudG9TdHJpbmcoKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgY2F0Y2ggKF9hKSB7IH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmICh0aGlzLmxpc3RlbmVyQ291bnQoJ3JldHJ5JykgIT09IDApIHtcbiAgICAgICAgICAgICAgICBsZXQgYmFja29mZjtcbiAgICAgICAgICAgICAgICB0cnkge1xuICAgICAgICAgICAgICAgICAgICBsZXQgcmV0cnlBZnRlcjtcbiAgICAgICAgICAgICAgICAgICAgaWYgKHJlc3BvbnNlICYmICdyZXRyeS1hZnRlcicgaW4gcmVzcG9uc2UuaGVhZGVycykge1xuICAgICAgICAgICAgICAgICAgICAgICAgcmV0cnlBZnRlciA9IE51bWJlcihyZXNwb25zZS5oZWFkZXJzWydyZXRyeS1hZnRlciddKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmIChOdW1iZXIuaXNOYU4ocmV0cnlBZnRlcikpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXRyeUFmdGVyID0gRGF0ZS5wYXJzZShyZXNwb25zZS5oZWFkZXJzWydyZXRyeS1hZnRlciddKSAtIERhdGUubm93KCk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKHJldHJ5QWZ0ZXIgPD0gMCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXRyeUFmdGVyID0gMTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXRyeUFmdGVyICo9IDEwMDA7XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgYmFja29mZiA9IGF3YWl0IG9wdGlvbnMucmV0cnkuY2FsY3VsYXRlRGVsYXkoe1xuICAgICAgICAgICAgICAgICAgICAgICAgYXR0ZW1wdENvdW50OiByZXRyeUNvdW50LFxuICAgICAgICAgICAgICAgICAgICAgICAgcmV0cnlPcHRpb25zOiBvcHRpb25zLnJldHJ5LFxuICAgICAgICAgICAgICAgICAgICAgICAgZXJyb3I6IHR5cGVkRXJyb3IsXG4gICAgICAgICAgICAgICAgICAgICAgICByZXRyeUFmdGVyLFxuICAgICAgICAgICAgICAgICAgICAgICAgY29tcHV0ZWRWYWx1ZTogY2FsY3VsYXRlX3JldHJ5X2RlbGF5XzEuZGVmYXVsdCh7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgYXR0ZW1wdENvdW50OiByZXRyeUNvdW50LFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJldHJ5T3B0aW9uczogb3B0aW9ucy5yZXRyeSxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBlcnJvcjogdHlwZWRFcnJvcixcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXRyeUFmdGVyLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNvbXB1dGVkVmFsdWU6IDBcbiAgICAgICAgICAgICAgICAgICAgICAgIH0pXG4gICAgICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBjYXRjaCAoZXJyb3JfKSB7XG4gICAgICAgICAgICAgICAgICAgIHZvaWQgdGhpcy5fZXJyb3IobmV3IFJlcXVlc3RFcnJvcihlcnJvcl8ubWVzc2FnZSwgZXJyb3JfLCB0aGlzKSk7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgaWYgKGJhY2tvZmYpIHtcbiAgICAgICAgICAgICAgICAgICAgY29uc3QgcmV0cnkgPSBhc3luYyAoKSA9PiB7XG4gICAgICAgICAgICAgICAgICAgICAgICB0cnkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGZvciAoY29uc3QgaG9vayBvZiB0aGlzLm9wdGlvbnMuaG9va3MuYmVmb3JlUmV0cnkpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIG5vLWF3YWl0LWluLWxvb3BcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgYXdhaXQgaG9vayh0aGlzLm9wdGlvbnMsIHR5cGVkRXJyb3IsIHJldHJ5Q291bnQpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgIGNhdGNoIChlcnJvcl8pIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB2b2lkIHRoaXMuX2Vycm9yKG5ldyBSZXF1ZXN0RXJyb3IoZXJyb3JfLm1lc3NhZ2UsIGVycm9yLCB0aGlzKSk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgLy8gU29tZXRoaW5nIGZvcmNlZCB1cyB0byBhYm9ydCB0aGUgcmV0cnlcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmICh0aGlzLmRlc3Ryb3llZCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMuZGVzdHJveSgpO1xuICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy5lbWl0KCdyZXRyeScsIHJldHJ5Q291bnQsIGVycm9yKTtcbiAgICAgICAgICAgICAgICAgICAgfTtcbiAgICAgICAgICAgICAgICAgICAgdGhpc1trUmV0cnlUaW1lb3V0XSA9IHNldFRpbWVvdXQocmV0cnksIGJhY2tvZmYpO1xuICAgICAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgdm9pZCB0aGlzLl9lcnJvcih0eXBlZEVycm9yKTtcbiAgICAgICAgfSkoKTtcbiAgICB9XG4gICAgX3JlYWQoKSB7XG4gICAgICAgIHRoaXNba1RyaWdnZXJSZWFkXSA9IHRydWU7XG4gICAgICAgIGNvbnN0IHJlc3BvbnNlID0gdGhpc1trUmVzcG9uc2VdO1xuICAgICAgICBpZiAocmVzcG9uc2UgJiYgIXRoaXNba1N0b3BSZWFkaW5nXSkge1xuICAgICAgICAgICAgLy8gV2UgY2Fubm90IHB1dCB0aGlzIGluIHRoZSBgaWZgIGFib3ZlXG4gICAgICAgICAgICAvLyBiZWNhdXNlIGAucmVhZCgpYCBhbHNvIHRyaWdnZXJzIHRoZSBgZW5kYCBldmVudFxuICAgICAgICAgICAgaWYgKHJlc3BvbnNlLnJlYWRhYmxlTGVuZ3RoKSB7XG4gICAgICAgICAgICAgICAgdGhpc1trVHJpZ2dlclJlYWRdID0gZmFsc2U7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBsZXQgZGF0YTtcbiAgICAgICAgICAgIHdoaWxlICgoZGF0YSA9IHJlc3BvbnNlLnJlYWQoKSkgIT09IG51bGwpIHtcbiAgICAgICAgICAgICAgICB0aGlzW2tEb3dubG9hZGVkU2l6ZV0gKz0gZGF0YS5sZW5ndGg7XG4gICAgICAgICAgICAgICAgdGhpc1trU3RhcnRlZFJlYWRpbmddID0gdHJ1ZTtcbiAgICAgICAgICAgICAgICBjb25zdCBwcm9ncmVzcyA9IHRoaXMuZG93bmxvYWRQcm9ncmVzcztcbiAgICAgICAgICAgICAgICBpZiAocHJvZ3Jlc3MucGVyY2VudCA8IDEpIHtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5lbWl0KCdkb3dubG9hZFByb2dyZXNzJywgcHJvZ3Jlc3MpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB0aGlzLnB1c2goZGF0YSk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9XG4gICAgLy8gTm9kZS5qcyAxMiBoYXMgaW5jb3JyZWN0IHR5cGVzLCBzbyB0aGUgZW5jb2RpbmcgbXVzdCBiZSBhIHN0cmluZ1xuICAgIF93cml0ZShjaHVuaywgZW5jb2RpbmcsIGNhbGxiYWNrKSB7XG4gICAgICAgIGNvbnN0IHdyaXRlID0gKCkgPT4ge1xuICAgICAgICAgICAgdGhpcy5fd3JpdGVSZXF1ZXN0KGNodW5rLCBlbmNvZGluZywgY2FsbGJhY2spO1xuICAgICAgICB9O1xuICAgICAgICBpZiAodGhpcy5yZXF1ZXN0SW5pdGlhbGl6ZWQpIHtcbiAgICAgICAgICAgIHdyaXRlKCk7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICB0aGlzW2tKb2JzXS5wdXNoKHdyaXRlKTtcbiAgICAgICAgfVxuICAgIH1cbiAgICBfd3JpdGVSZXF1ZXN0KGNodW5rLCBlbmNvZGluZywgY2FsbGJhY2spIHtcbiAgICAgICAgaWYgKHRoaXNba1JlcXVlc3RdLmRlc3Ryb3llZCkge1xuICAgICAgICAgICAgLy8gUHJvYmFibHkgdGhlIGBDbGllbnRSZXF1ZXN0YCBpbnN0YW5jZSB3aWxsIHRocm93XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy5fcHJvZ3Jlc3NDYWxsYmFja3MucHVzaCgoKSA9PiB7XG4gICAgICAgICAgICB0aGlzW2tVcGxvYWRlZFNpemVdICs9IEJ1ZmZlci5ieXRlTGVuZ3RoKGNodW5rLCBlbmNvZGluZyk7XG4gICAgICAgICAgICBjb25zdCBwcm9ncmVzcyA9IHRoaXMudXBsb2FkUHJvZ3Jlc3M7XG4gICAgICAgICAgICBpZiAocHJvZ3Jlc3MucGVyY2VudCA8IDEpIHtcbiAgICAgICAgICAgICAgICB0aGlzLmVtaXQoJ3VwbG9hZFByb2dyZXNzJywgcHJvZ3Jlc3MpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9KTtcbiAgICAgICAgLy8gVE9ETzogV2hhdCBoYXBwZW5zIGlmIGl0J3MgZnJvbSBjYWNoZT8gVGhlbiB0aGlzW2tSZXF1ZXN0XSB3b24ndCBiZSBkZWZpbmVkLlxuICAgICAgICB0aGlzW2tSZXF1ZXN0XS53cml0ZShjaHVuaywgZW5jb2RpbmcsIChlcnJvcikgPT4ge1xuICAgICAgICAgICAgaWYgKCFlcnJvciAmJiB0aGlzLl9wcm9ncmVzc0NhbGxiYWNrcy5sZW5ndGggPiAwKSB7XG4gICAgICAgICAgICAgICAgdGhpcy5fcHJvZ3Jlc3NDYWxsYmFja3Muc2hpZnQoKSgpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgY2FsbGJhY2soZXJyb3IpO1xuICAgICAgICB9KTtcbiAgICB9XG4gICAgX2ZpbmFsKGNhbGxiYWNrKSB7XG4gICAgICAgIGNvbnN0IGVuZFJlcXVlc3QgPSAoKSA9PiB7XG4gICAgICAgICAgICAvLyBGSVg6IE5vZGUuanMgMTAgY2FsbHMgdGhlIHdyaXRlIGNhbGxiYWNrIEFGVEVSIHRoZSBlbmQgY2FsbGJhY2shXG4gICAgICAgICAgICB3aGlsZSAodGhpcy5fcHJvZ3Jlc3NDYWxsYmFja3MubGVuZ3RoICE9PSAwKSB7XG4gICAgICAgICAgICAgICAgdGhpcy5fcHJvZ3Jlc3NDYWxsYmFja3Muc2hpZnQoKSgpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgLy8gV2UgbmVlZCB0byBjaGVjayBpZiBgdGhpc1trUmVxdWVzdF1gIGlzIHByZXNlbnQsXG4gICAgICAgICAgICAvLyBiZWNhdXNlIGl0IGlzbid0IHdoZW4gd2UgdXNlIGNhY2hlLlxuICAgICAgICAgICAgaWYgKCEoa1JlcXVlc3QgaW4gdGhpcykpIHtcbiAgICAgICAgICAgICAgICBjYWxsYmFjaygpO1xuICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmICh0aGlzW2tSZXF1ZXN0XS5kZXN0cm95ZWQpIHtcbiAgICAgICAgICAgICAgICBjYWxsYmFjaygpO1xuICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHRoaXNba1JlcXVlc3RdLmVuZCgoZXJyb3IpID0+IHtcbiAgICAgICAgICAgICAgICBpZiAoIWVycm9yKSB7XG4gICAgICAgICAgICAgICAgICAgIHRoaXNba0JvZHlTaXplXSA9IHRoaXNba1VwbG9hZGVkU2l6ZV07XG4gICAgICAgICAgICAgICAgICAgIHRoaXMuZW1pdCgndXBsb2FkUHJvZ3Jlc3MnLCB0aGlzLnVwbG9hZFByb2dyZXNzKTtcbiAgICAgICAgICAgICAgICAgICAgdGhpc1trUmVxdWVzdF0uZW1pdCgndXBsb2FkLWNvbXBsZXRlJyk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGNhbGxiYWNrKGVycm9yKTtcbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9O1xuICAgICAgICBpZiAodGhpcy5yZXF1ZXN0SW5pdGlhbGl6ZWQpIHtcbiAgICAgICAgICAgIGVuZFJlcXVlc3QoKTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIHRoaXNba0pvYnNdLnB1c2goZW5kUmVxdWVzdCk7XG4gICAgICAgIH1cbiAgICB9XG4gICAgX2Rlc3Ryb3koZXJyb3IsIGNhbGxiYWNrKSB7XG4gICAgICAgIHZhciBfYTtcbiAgICAgICAgdGhpc1trU3RvcFJlYWRpbmddID0gdHJ1ZTtcbiAgICAgICAgLy8gUHJldmVudCBmdXJ0aGVyIHJldHJpZXNcbiAgICAgICAgY2xlYXJUaW1lb3V0KHRoaXNba1JldHJ5VGltZW91dF0pO1xuICAgICAgICBpZiAoa1JlcXVlc3QgaW4gdGhpcykge1xuICAgICAgICAgICAgdGhpc1trQ2FuY2VsVGltZW91dHNdKCk7XG4gICAgICAgICAgICAvLyBUT0RPOiBSZW1vdmUgdGhlIG5leHQgYGlmYCB3aGVuIHRoZXNlIGdldCBmaXhlZDpcbiAgICAgICAgICAgIC8vIC0gaHR0cHM6Ly9naXRodWIuY29tL25vZGVqcy9ub2RlL2lzc3Vlcy8zMjg1MVxuICAgICAgICAgICAgaWYgKCEoKF9hID0gdGhpc1trUmVzcG9uc2VdKSA9PT0gbnVsbCB8fCBfYSA9PT0gdm9pZCAwID8gdm9pZCAwIDogX2EuY29tcGxldGUpKSB7XG4gICAgICAgICAgICAgICAgdGhpc1trUmVxdWVzdF0uZGVzdHJveSgpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGlmIChlcnJvciAhPT0gbnVsbCAmJiAhaXNfMS5kZWZhdWx0LnVuZGVmaW5lZChlcnJvcikgJiYgIShlcnJvciBpbnN0YW5jZW9mIFJlcXVlc3RFcnJvcikpIHtcbiAgICAgICAgICAgIGVycm9yID0gbmV3IFJlcXVlc3RFcnJvcihlcnJvci5tZXNzYWdlLCBlcnJvciwgdGhpcyk7XG4gICAgICAgIH1cbiAgICAgICAgY2FsbGJhY2soZXJyb3IpO1xuICAgIH1cbiAgICBnZXQgX2lzQWJvdXRUb0Vycm9yKCkge1xuICAgICAgICByZXR1cm4gdGhpc1trU3RvcFJlYWRpbmddO1xuICAgIH1cbiAgICAvKipcbiAgICBUaGUgcmVtb3RlIElQIGFkZHJlc3MuXG4gICAgKi9cbiAgICBnZXQgaXAoKSB7XG4gICAgICAgIHZhciBfYTtcbiAgICAgICAgcmV0dXJuIChfYSA9IHRoaXMuc29ja2V0KSA9PT0gbnVsbCB8fCBfYSA9PT0gdm9pZCAwID8gdm9pZCAwIDogX2EucmVtb3RlQWRkcmVzcztcbiAgICB9XG4gICAgLyoqXG4gICAgSW5kaWNhdGVzIHdoZXRoZXIgdGhlIHJlcXVlc3QgaGFzIGJlZW4gYWJvcnRlZCBvciBub3QuXG4gICAgKi9cbiAgICBnZXQgYWJvcnRlZCgpIHtcbiAgICAgICAgdmFyIF9hLCBfYiwgX2M7XG4gICAgICAgIHJldHVybiAoKF9iID0gKF9hID0gdGhpc1trUmVxdWVzdF0pID09PSBudWxsIHx8IF9hID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfYS5kZXN0cm95ZWQpICE9PSBudWxsICYmIF9iICE9PSB2b2lkIDAgPyBfYiA6IHRoaXMuZGVzdHJveWVkKSAmJiAhKChfYyA9IHRoaXNba09yaWdpbmFsUmVzcG9uc2VdKSA9PT0gbnVsbCB8fCBfYyA9PT0gdm9pZCAwID8gdm9pZCAwIDogX2MuY29tcGxldGUpO1xuICAgIH1cbiAgICBnZXQgc29ja2V0KCkge1xuICAgICAgICB2YXIgX2EsIF9iO1xuICAgICAgICByZXR1cm4gKF9iID0gKF9hID0gdGhpc1trUmVxdWVzdF0pID09PSBudWxsIHx8IF9hID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfYS5zb2NrZXQpICE9PSBudWxsICYmIF9iICE9PSB2b2lkIDAgPyBfYiA6IHVuZGVmaW5lZDtcbiAgICB9XG4gICAgLyoqXG4gICAgUHJvZ3Jlc3MgZXZlbnQgZm9yIGRvd25sb2FkaW5nIChyZWNlaXZpbmcgYSByZXNwb25zZSkuXG4gICAgKi9cbiAgICBnZXQgZG93bmxvYWRQcm9ncmVzcygpIHtcbiAgICAgICAgbGV0IHBlcmNlbnQ7XG4gICAgICAgIGlmICh0aGlzW2tSZXNwb25zZVNpemVdKSB7XG4gICAgICAgICAgICBwZXJjZW50ID0gdGhpc1trRG93bmxvYWRlZFNpemVdIC8gdGhpc1trUmVzcG9uc2VTaXplXTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIGlmICh0aGlzW2tSZXNwb25zZVNpemVdID09PSB0aGlzW2tEb3dubG9hZGVkU2l6ZV0pIHtcbiAgICAgICAgICAgIHBlcmNlbnQgPSAxO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgcGVyY2VudCA9IDA7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgIHBlcmNlbnQsXG4gICAgICAgICAgICB0cmFuc2ZlcnJlZDogdGhpc1trRG93bmxvYWRlZFNpemVdLFxuICAgICAgICAgICAgdG90YWw6IHRoaXNba1Jlc3BvbnNlU2l6ZV1cbiAgICAgICAgfTtcbiAgICB9XG4gICAgLyoqXG4gICAgUHJvZ3Jlc3MgZXZlbnQgZm9yIHVwbG9hZGluZyAoc2VuZGluZyBhIHJlcXVlc3QpLlxuICAgICovXG4gICAgZ2V0IHVwbG9hZFByb2dyZXNzKCkge1xuICAgICAgICBsZXQgcGVyY2VudDtcbiAgICAgICAgaWYgKHRoaXNba0JvZHlTaXplXSkge1xuICAgICAgICAgICAgcGVyY2VudCA9IHRoaXNba1VwbG9hZGVkU2l6ZV0gLyB0aGlzW2tCb2R5U2l6ZV07XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSBpZiAodGhpc1trQm9keVNpemVdID09PSB0aGlzW2tVcGxvYWRlZFNpemVdKSB7XG4gICAgICAgICAgICBwZXJjZW50ID0gMTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIHBlcmNlbnQgPSAwO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICBwZXJjZW50LFxuICAgICAgICAgICAgdHJhbnNmZXJyZWQ6IHRoaXNba1VwbG9hZGVkU2l6ZV0sXG4gICAgICAgICAgICB0b3RhbDogdGhpc1trQm9keVNpemVdXG4gICAgICAgIH07XG4gICAgfVxuICAgIC8qKlxuICAgIFRoZSBvYmplY3QgY29udGFpbnMgdGhlIGZvbGxvd2luZyBwcm9wZXJ0aWVzOlxuXG4gICAgLSBgc3RhcnRgIC0gVGltZSB3aGVuIHRoZSByZXF1ZXN0IHN0YXJ0ZWQuXG4gICAgLSBgc29ja2V0YCAtIFRpbWUgd2hlbiBhIHNvY2tldCB3YXMgYXNzaWduZWQgdG8gdGhlIHJlcXVlc3QuXG4gICAgLSBgbG9va3VwYCAtIFRpbWUgd2hlbiB0aGUgRE5TIGxvb2t1cCBmaW5pc2hlZC5cbiAgICAtIGBjb25uZWN0YCAtIFRpbWUgd2hlbiB0aGUgc29ja2V0IHN1Y2Nlc3NmdWxseSBjb25uZWN0ZWQuXG4gICAgLSBgc2VjdXJlQ29ubmVjdGAgLSBUaW1lIHdoZW4gdGhlIHNvY2tldCBzZWN1cmVseSBjb25uZWN0ZWQuXG4gICAgLSBgdXBsb2FkYCAtIFRpbWUgd2hlbiB0aGUgcmVxdWVzdCBmaW5pc2hlZCB1cGxvYWRpbmcuXG4gICAgLSBgcmVzcG9uc2VgIC0gVGltZSB3aGVuIHRoZSByZXF1ZXN0IGZpcmVkIGByZXNwb25zZWAgZXZlbnQuXG4gICAgLSBgZW5kYCAtIFRpbWUgd2hlbiB0aGUgcmVzcG9uc2UgZmlyZWQgYGVuZGAgZXZlbnQuXG4gICAgLSBgZXJyb3JgIC0gVGltZSB3aGVuIHRoZSByZXF1ZXN0IGZpcmVkIGBlcnJvcmAgZXZlbnQuXG4gICAgLSBgYWJvcnRgIC0gVGltZSB3aGVuIHRoZSByZXF1ZXN0IGZpcmVkIGBhYm9ydGAgZXZlbnQuXG4gICAgLSBgcGhhc2VzYFxuICAgICAgICAtIGB3YWl0YCAtIGB0aW1pbmdzLnNvY2tldCAtIHRpbWluZ3Muc3RhcnRgXG4gICAgICAgIC0gYGRuc2AgLSBgdGltaW5ncy5sb29rdXAgLSB0aW1pbmdzLnNvY2tldGBcbiAgICAgICAgLSBgdGNwYCAtIGB0aW1pbmdzLmNvbm5lY3QgLSB0aW1pbmdzLmxvb2t1cGBcbiAgICAgICAgLSBgdGxzYCAtIGB0aW1pbmdzLnNlY3VyZUNvbm5lY3QgLSB0aW1pbmdzLmNvbm5lY3RgXG4gICAgICAgIC0gYHJlcXVlc3RgIC0gYHRpbWluZ3MudXBsb2FkIC0gKHRpbWluZ3Muc2VjdXJlQ29ubmVjdCB8fCB0aW1pbmdzLmNvbm5lY3QpYFxuICAgICAgICAtIGBmaXJzdEJ5dGVgIC0gYHRpbWluZ3MucmVzcG9uc2UgLSB0aW1pbmdzLnVwbG9hZGBcbiAgICAgICAgLSBgZG93bmxvYWRgIC0gYHRpbWluZ3MuZW5kIC0gdGltaW5ncy5yZXNwb25zZWBcbiAgICAgICAgLSBgdG90YWxgIC0gYCh0aW1pbmdzLmVuZCB8fCB0aW1pbmdzLmVycm9yIHx8IHRpbWluZ3MuYWJvcnQpIC0gdGltaW5ncy5zdGFydGBcblxuICAgIElmIHNvbWV0aGluZyBoYXMgbm90IGJlZW4gbWVhc3VyZWQgeWV0LCBpdCB3aWxsIGJlIGB1bmRlZmluZWRgLlxuXG4gICAgX19Ob3RlX186IFRoZSB0aW1lIGlzIGEgYG51bWJlcmAgcmVwcmVzZW50aW5nIHRoZSBtaWxsaXNlY29uZHMgZWxhcHNlZCBzaW5jZSB0aGUgVU5JWCBlcG9jaC5cbiAgICAqL1xuICAgIGdldCB0aW1pbmdzKCkge1xuICAgICAgICB2YXIgX2E7XG4gICAgICAgIHJldHVybiAoX2EgPSB0aGlzW2tSZXF1ZXN0XSkgPT09IG51bGwgfHwgX2EgPT09IHZvaWQgMCA/IHZvaWQgMCA6IF9hLnRpbWluZ3M7XG4gICAgfVxuICAgIC8qKlxuICAgIFdoZXRoZXIgdGhlIHJlc3BvbnNlIHdhcyByZXRyaWV2ZWQgZnJvbSB0aGUgY2FjaGUuXG4gICAgKi9cbiAgICBnZXQgaXNGcm9tQ2FjaGUoKSB7XG4gICAgICAgIHJldHVybiB0aGlzW2tJc0Zyb21DYWNoZV07XG4gICAgfVxuICAgIHBpcGUoZGVzdGluYXRpb24sIG9wdGlvbnMpIHtcbiAgICAgICAgaWYgKHRoaXNba1N0YXJ0ZWRSZWFkaW5nXSkge1xuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdGYWlsZWQgdG8gcGlwZS4gVGhlIHJlc3BvbnNlIGhhcyBiZWVuIGVtaXR0ZWQgYWxyZWFkeS4nKTtcbiAgICAgICAgfVxuICAgICAgICBpZiAoZGVzdGluYXRpb24gaW5zdGFuY2VvZiBodHRwXzEuU2VydmVyUmVzcG9uc2UpIHtcbiAgICAgICAgICAgIHRoaXNba1NlcnZlclJlc3BvbnNlc1BpcGVkXS5hZGQoZGVzdGluYXRpb24pO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBzdXBlci5waXBlKGRlc3RpbmF0aW9uLCBvcHRpb25zKTtcbiAgICB9XG4gICAgdW5waXBlKGRlc3RpbmF0aW9uKSB7XG4gICAgICAgIGlmIChkZXN0aW5hdGlvbiBpbnN0YW5jZW9mIGh0dHBfMS5TZXJ2ZXJSZXNwb25zZSkge1xuICAgICAgICAgICAgdGhpc1trU2VydmVyUmVzcG9uc2VzUGlwZWRdLmRlbGV0ZShkZXN0aW5hdGlvbik7XG4gICAgICAgIH1cbiAgICAgICAgc3VwZXIudW5waXBlKGRlc3RpbmF0aW9uKTtcbiAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfVxufVxuZXhwb3J0cy5kZWZhdWx0ID0gUmVxdWVzdDtcbiJdLCJuYW1lcyI6WyJPYmplY3QiLCJkZWZpbmVQcm9wZXJ0eSIsImV4cG9ydHMiLCJ2YWx1ZSIsIlVuc3VwcG9ydGVkUHJvdG9jb2xFcnJvciIsIlJlYWRFcnJvciIsIlRpbWVvdXRFcnJvciIsIlVwbG9hZEVycm9yIiwiQ2FjaGVFcnJvciIsIkhUVFBFcnJvciIsIk1heFJlZGlyZWN0c0Vycm9yIiwiUmVxdWVzdEVycm9yIiwic2V0Tm9uRW51bWVyYWJsZVByb3BlcnRpZXMiLCJrbm93bkhvb2tFdmVudHMiLCJ3aXRob3V0Qm9keSIsImtJc05vcm1hbGl6ZWRBbHJlYWR5IiwidXRpbF8xIiwicmVxdWlyZSIsInN0cmVhbV8xIiwiZnNfMSIsInVybF8xIiwiaHR0cCIsImh0dHBfMSIsImh0dHBzIiwiaHR0cF90aW1lcl8xIiwiY2FjaGVhYmxlX2xvb2t1cF8xIiwiQ2FjaGVhYmxlUmVxdWVzdCIsImRlY29tcHJlc3NSZXNwb25zZSIsImh0dHAyd3JhcHBlciIsImxvd2VyY2FzZUtleXMiLCJpc18xIiwiZ2V0X2JvZHlfc2l6ZV8xIiwiaXNfZm9ybV9kYXRhXzEiLCJwcm94eV9ldmVudHNfMSIsInRpbWVkX291dF8xIiwidXJsX3RvX29wdGlvbnNfMSIsIm9wdGlvbnNfdG9fdXJsXzEiLCJ3ZWFrYWJsZV9tYXBfMSIsImdldF9idWZmZXJfMSIsImRuc19pcF92ZXJzaW9uXzEiLCJpc19yZXNwb25zZV9va18xIiwiZGVwcmVjYXRpb25fd2FybmluZ18xIiwibm9ybWFsaXplX2FyZ3VtZW50c18xIiwiY2FsY3VsYXRlX3JldHJ5X2RlbGF5XzEiLCJnbG9iYWxEbnNDYWNoZSIsImtSZXF1ZXN0IiwiU3ltYm9sIiwia1Jlc3BvbnNlIiwia1Jlc3BvbnNlU2l6ZSIsImtEb3dubG9hZGVkU2l6ZSIsImtCb2R5U2l6ZSIsImtVcGxvYWRlZFNpemUiLCJrU2VydmVyUmVzcG9uc2VzUGlwZWQiLCJrVW5wcm94eUV2ZW50cyIsImtJc0Zyb21DYWNoZSIsImtDYW5jZWxUaW1lb3V0cyIsImtTdGFydGVkUmVhZGluZyIsImtTdG9wUmVhZGluZyIsImtUcmlnZ2VyUmVhZCIsImtCb2R5Iiwia0pvYnMiLCJrT3JpZ2luYWxSZXNwb25zZSIsImtSZXRyeVRpbWVvdXQiLCJzdXBwb3J0c0Jyb3RsaSIsImRlZmF1bHQiLCJzdHJpbmciLCJwcm9jZXNzIiwidmVyc2lvbnMiLCJicm90bGkiLCJTZXQiLCJ2YWxpZGF0ZVNlYXJjaFBhcmFtZXRlcnMiLCJzZWFyY2hQYXJhbWV0ZXJzIiwia2V5IiwibnVtYmVyIiwiYm9vbGVhbiIsIm51bGxfIiwidW5kZWZpbmVkIiwiVHlwZUVycm9yIiwiU3RyaW5nIiwiaXNDbGllbnRSZXF1ZXN0IiwiY2xpZW50UmVxdWVzdCIsIm9iamVjdCIsImNhY2hlYWJsZVN0b3JlIiwid2FpdEZvck9wZW5GaWxlIiwiZmlsZSIsIlByb21pc2UiLCJyZXNvbHZlIiwicmVqZWN0Iiwib25FcnJvciIsImVycm9yIiwicGVuZGluZyIsIm9uY2UiLCJvZmYiLCJyZWRpcmVjdENvZGVzIiwibm9uRW51bWVyYWJsZVByb3BlcnRpZXMiLCJzb3VyY2VzIiwidG8iLCJwcm9wZXJ0aWVzIiwic291cmNlIiwibmFtZSIsIndyaXRhYmxlIiwiY29uZmlndXJhYmxlIiwiZW51bWVyYWJsZSIsImRlZmluZVByb3BlcnRpZXMiLCJFcnJvciIsIm1lc3NhZ2UiLCJzZWxmIiwiX2EiLCJfYiIsImNhcHR1cmVTdGFja1RyYWNlIiwiY29kZSIsIlJlcXVlc3QiLCJvcHRpb25zIiwidGltaW5ncyIsInJlcXVlc3QiLCJzdGFjayIsImluZGV4T2ZNZXNzYWdlIiwiaW5kZXhPZiIsImxlbmd0aCIsInRoaXNTdGFja1RyYWNlIiwic2xpY2UiLCJzcGxpdCIsInJldmVyc2UiLCJlcnJvclN0YWNrVHJhY2UiLCJzaGlmdCIsImpvaW4iLCJtYXhSZWRpcmVjdHMiLCJyZXNwb25zZSIsInN0YXR1c0NvZGUiLCJzdGF0dXNNZXNzYWdlIiwiZXZlbnQiLCJ1cmwiLCJwcm90b2NvbCIsInByb3hpZWRSZXF1ZXN0RXZlbnRzIiwiRHVwbGV4IiwiZGVmYXVsdHMiLCJhdXRvRGVzdHJveSIsImhpZ2hXYXRlck1hcmsiLCJyZXF1ZXN0SW5pdGlhbGl6ZWQiLCJyZWRpcmVjdHMiLCJyZXRyeUNvdW50IiwiX3Byb2dyZXNzQ2FsbGJhY2tzIiwidW5sb2NrV3JpdGUiLCJfdW5sb2NrV3JpdGUiLCJsb2NrV3JpdGUiLCJfbG9ja1dyaXRlIiwib24iLCJwcmVwZW5kTGlzdGVuZXIiLCJJbmNvbWluZ01lc3NhZ2UiLCJoZWFkZXJzIiwianNvbiIsImJvZHkiLCJmb3JtIiwibm9ybWFsaXplQXJndW1lbnRzIiwibm9kZVN0cmVhbSIsImRlc3Ryb3kiLCJSZWFkU3RyZWFtIiwibm9ybWFsaXplZFVSTCIsInJlcXVlc3RVcmwiLCJ0b1N0cmluZyIsImRlY29kZVVSSSIsIl9maW5hbGl6ZUJvZHkiLCJfbWFrZVJlcXVlc3QiLCJkZXN0cm95ZWQiLCJqb2IiLCJfYmVmb3JlRXJyb3IiLCJfYyIsIl9kIiwiX2UiLCJyYXdPcHRpb25zIiwidXJsSW5zdGFuY2UiLCJVUkwiLCJjYWNoZSIsImRuc0NhY2hlIiwiYXNzZXJ0IiwiYW55IiwibWV0aG9kIiwicHJlZml4VXJsIiwiY29va2llSmFyIiwic2VhcmNoUGFyYW1zIiwidGltZW91dCIsImNvbnRleHQiLCJob29rcyIsImRlY29tcHJlc3MiLCJpZ25vcmVJbnZhbGlkQ29va2llcyIsImZvbGxvd1JlZGlyZWN0IiwidGhyb3dIdHRwRXJyb3JzIiwiaHR0cDIiLCJhbGxvd0dldEJvZHkiLCJsb2NhbEFkZHJlc3MiLCJpc0Ruc0xvb2t1cElwVmVyc2lvbiIsImRuc0xvb2t1cElwVmVyc2lvbiIsInJlamVjdFVuYXV0aG9yaXplZCIsImZ1bmN0aW9uXyIsImNoZWNrU2VydmVySWRlbnRpdHkiLCJhcnJheSIsImNlcnRpZmljYXRlQXV0aG9yaXR5IiwiY2VydGlmaWNhdGUiLCJwYXNzcGhyYXNlIiwiYnVmZmVyIiwicGZ4IiwiY2FjaGVPcHRpb25zIiwidG9VcHBlckNhc2UiLCJVUkxTZWFyY2hQYXJhbXMiLCJhcHBlbmQiLCJmb3JFYWNoIiwiaGFzIiwidXNlcm5hbWUiLCJwYXNzd29yZCIsImVuZHNXaXRoIiwic3RhcnRzV2l0aCIsInBvcnQiLCJzZXQiLCJocmVmIiwiZ2V0IiwicGF0aG5hbWUiLCJzZWFyY2giLCJzZXRDb29raWUiLCJnZXRDb29raWVTdHJpbmciLCJwcm9taXNpZnkiLCJiaW5kIiwicmVxdWVzdE9wdGlvbnMiLCJoYW5kbGVyIiwicmVzdWx0IiwicHJvbWlzZSIsImNhdGNoIiwibG9va3VwIiwiYXJlSG9va3NEZWZhdWx0IiwiZGVmYXVsdEhvb2tzIiwiYWdlbnQiLCJvbkxvY2tlZFdyaXRlIiwid3JpdGUiLCJlbmQiLCJpc0Zvcm0iLCJpc0pTT04iLCJpc0JvZHkiLCJoYXNQYXlsb2FkIiwiY2Fubm90SGF2ZUJvZHkiLCJfY2Fubm90SGF2ZUJvZHkiLCJmaWx0ZXIiLCJpc1RydWUiLCJSZWFkYWJsZSIsIm5vQ29udGVudFR5cGUiLCJnZXRCb3VuZGFyeSIsInN0cmluZ2lmeUpzb24iLCJ1cGxvYWRCb2R5U2l6ZSIsIk51bWJlciIsIl9vblJlc3BvbnNlQmFzZSIsInR5cGVkUmVzcG9uc2UiLCJTVEFUVVNfQ09ERVMiLCJyZWRpcmVjdFVybHMiLCJpc0Zyb21DYWNoZSIsImZyb21DYWNoZSIsImlwIiwiZW1pdCIsImRvd25sb2FkUHJvZ3Jlc3MiLCJyYXdDb29raWVzIiwicHJvbWlzZXMiLCJtYXAiLCJyYXdDb29raWUiLCJwIiwiYWxsIiwibG9jYXRpb24iLCJyZXN1bWUiLCJzaG91bGRCZUdldCIsIm1ldGhvZFJld3JpdGluZyIsInJlZGlyZWN0QnVmZmVyIiwiQnVmZmVyIiwiZnJvbSIsInJlZGlyZWN0VXJsIiwicmVkaXJlY3RTdHJpbmciLCJpc1VuaXhTb2NrZXRVUkwiLCJob3N0bmFtZSIsImhvc3QiLCJjb29raWUiLCJhdXRob3JpemF0aW9uIiwicHVzaCIsImhvb2siLCJiZWZvcmVSZWRpcmVjdCIsImlzU3RyZWFtIiwiaXNSZXNwb25zZU9rIiwiX3JlYWQiLCJwYXVzZSIsImRlc3RpbmF0aW9uIiwiaGVhZGVyc1NlbnQiLCJpc0FsbG93ZWQiLCJzZXRIZWFkZXIiLCJfb25SZXNwb25zZSIsIl9vblJlcXVlc3QiLCJyZXNwb25zZUV2ZW50TmFtZSIsInJlcyIsInJlbW92ZUFsbExpc3RlbmVycyIsInVwbG9hZFByb2dyZXNzIiwiY3VycmVudFJlcXVlc3QiLCJwaXBlIiwiX3dyaXRlUmVxdWVzdCIsIl9ub1BpcGUiLCJfY3JlYXRlQ2FjaGVhYmxlUmVxdWVzdCIsImFzc2lnbiIsImNhY2hlUmVxdWVzdCIsIl9yZWFkYWJsZVN0YXRlIiwicmVxdWVzdE9yUHJvbWlzZSIsImNvb2tpZVN0cmluZyIsIm5vbkVtcHR5U3RyaW5nIiwiYmVmb3JlUmVxdWVzdCIsIm1hdGNoZXMiLCJleGVjIiwiZ3JvdXBzIiwic29ja2V0UGF0aCIsInBhdGgiLCJpc0h0dHBzIiwiZmFsbGJhY2tGbiIsImF1dG8iLCJyZWFsRm4iLCJmbiIsInNoYXJlZCIsImNhY2hlSGV1cmlzdGljIiwiaW1tdXRhYmxlTWluVGltZVRvTGl2ZSIsImlnbm9yZUNhcmdvQ3VsdCIsImZhbWlseSIsImRuc0xvb2t1cElwVmVyc2lvblRvRmFtaWx5IiwiX2YiLCJjYSIsImNlcnQiLCJyZXF1ZXN0T3JSZXNwb25zZSIsIl9lcnJvciIsImJlZm9yZUVycm9yIiwiZXJyb3JfIiwidHlwZWRFcnJvciIsInNldEVuY29kaW5nIiwiZW5jb2RpbmciLCJyYXdCb2R5IiwibGlzdGVuZXJDb3VudCIsImJhY2tvZmYiLCJyZXRyeUFmdGVyIiwiaXNOYU4iLCJEYXRlIiwicGFyc2UiLCJub3ciLCJyZXRyeSIsImNhbGN1bGF0ZURlbGF5IiwiYXR0ZW1wdENvdW50IiwicmV0cnlPcHRpb25zIiwiY29tcHV0ZWRWYWx1ZSIsImJlZm9yZVJldHJ5Iiwic2V0VGltZW91dCIsInJlYWRhYmxlTGVuZ3RoIiwiZGF0YSIsInJlYWQiLCJwcm9ncmVzcyIsInBlcmNlbnQiLCJfd3JpdGUiLCJjaHVuayIsImNhbGxiYWNrIiwiYnl0ZUxlbmd0aCIsIl9maW5hbCIsImVuZFJlcXVlc3QiLCJfZGVzdHJveSIsImNsZWFyVGltZW91dCIsImNvbXBsZXRlIiwiX2lzQWJvdXRUb0Vycm9yIiwic29ja2V0IiwicmVtb3RlQWRkcmVzcyIsImFib3J0ZWQiLCJ0cmFuc2ZlcnJlZCIsInRvdGFsIiwiU2VydmVyUmVzcG9uc2UiLCJhZGQiLCJ1bnBpcGUiLCJkZWxldGUiXSwiaWdub3JlTGlzdCI6WzBdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/swarm-js/node_modules/got/dist/source/core/index.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/swarm-js/node_modules/got/dist/source/core/utils/dns-ip-version.js":
/*!*****************************************************************************************!*\
  !*** ./node_modules/swarm-js/node_modules/got/dist/source/core/utils/dns-ip-version.js ***!
  \*****************************************************************************************/
/***/ ((__unused_webpack_module, exports) => {

"use strict";
eval("\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nexports.dnsLookupIpVersionToFamily = exports.isDnsLookupIpVersion = void 0;\nconst conversionTable = {\n    auto: 0,\n    ipv4: 4,\n    ipv6: 6\n};\nexports.isDnsLookupIpVersion = (value) => {\n    return value in conversionTable;\n};\nexports.dnsLookupIpVersionToFamily = (dnsLookupIpVersion) => {\n    if (exports.isDnsLookupIpVersion(dnsLookupIpVersion)) {\n        return conversionTable[dnsLookupIpVersion];\n    }\n    throw new Error('Invalid DNS lookup IP version');\n};\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvc3dhcm0tanMvbm9kZV9tb2R1bGVzL2dvdC9kaXN0L3NvdXJjZS9jb3JlL3V0aWxzL2Rucy1pcC12ZXJzaW9uLmpzIiwibWFwcGluZ3MiOiJBQUFhO0FBQ2IsOENBQTZDLEVBQUUsYUFBYSxFQUFDO0FBQzdELGtDQUFrQyxHQUFHLDRCQUE0QjtBQUNqRTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsNEJBQTRCO0FBQzVCO0FBQ0E7QUFDQSxrQ0FBa0M7QUFDbEM7QUFDQTtBQUNBO0FBQ0E7QUFDQSIsInNvdXJjZXMiOlsiL1VzZXJzL3BhbnphL0RvY3VtZW50cy9QZXJzb25hbFByb2plY3RzL3ByZWRpay9ub2RlX21vZHVsZXMvc3dhcm0tanMvbm9kZV9tb2R1bGVzL2dvdC9kaXN0L3NvdXJjZS9jb3JlL3V0aWxzL2Rucy1pcC12ZXJzaW9uLmpzIl0sInNvdXJjZXNDb250ZW50IjpbIlwidXNlIHN0cmljdFwiO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xuZXhwb3J0cy5kbnNMb29rdXBJcFZlcnNpb25Ub0ZhbWlseSA9IGV4cG9ydHMuaXNEbnNMb29rdXBJcFZlcnNpb24gPSB2b2lkIDA7XG5jb25zdCBjb252ZXJzaW9uVGFibGUgPSB7XG4gICAgYXV0bzogMCxcbiAgICBpcHY0OiA0LFxuICAgIGlwdjY6IDZcbn07XG5leHBvcnRzLmlzRG5zTG9va3VwSXBWZXJzaW9uID0gKHZhbHVlKSA9PiB7XG4gICAgcmV0dXJuIHZhbHVlIGluIGNvbnZlcnNpb25UYWJsZTtcbn07XG5leHBvcnRzLmRuc0xvb2t1cElwVmVyc2lvblRvRmFtaWx5ID0gKGRuc0xvb2t1cElwVmVyc2lvbikgPT4ge1xuICAgIGlmIChleHBvcnRzLmlzRG5zTG9va3VwSXBWZXJzaW9uKGRuc0xvb2t1cElwVmVyc2lvbikpIHtcbiAgICAgICAgcmV0dXJuIGNvbnZlcnNpb25UYWJsZVtkbnNMb29rdXBJcFZlcnNpb25dO1xuICAgIH1cbiAgICB0aHJvdyBuZXcgRXJyb3IoJ0ludmFsaWQgRE5TIGxvb2t1cCBJUCB2ZXJzaW9uJyk7XG59O1xuIl0sIm5hbWVzIjpbXSwiaWdub3JlTGlzdCI6WzBdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/swarm-js/node_modules/got/dist/source/core/utils/dns-ip-version.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/swarm-js/node_modules/got/dist/source/core/utils/get-body-size.js":
/*!****************************************************************************************!*\
  !*** ./node_modules/swarm-js/node_modules/got/dist/source/core/utils/get-body-size.js ***!
  \****************************************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";
eval("\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nconst fs_1 = __webpack_require__(/*! fs */ \"fs\");\nconst util_1 = __webpack_require__(/*! util */ \"util\");\nconst is_1 = __webpack_require__(/*! @sindresorhus/is */ \"(ssr)/./node_modules/@sindresorhus/is/dist/index.js\");\nconst is_form_data_1 = __webpack_require__(/*! ./is-form-data */ \"(ssr)/./node_modules/swarm-js/node_modules/got/dist/source/core/utils/is-form-data.js\");\nconst statAsync = util_1.promisify(fs_1.stat);\nexports[\"default\"] = async (body, headers) => {\n    if (headers && 'content-length' in headers) {\n        return Number(headers['content-length']);\n    }\n    if (!body) {\n        return 0;\n    }\n    if (is_1.default.string(body)) {\n        return Buffer.byteLength(body);\n    }\n    if (is_1.default.buffer(body)) {\n        return body.length;\n    }\n    if (is_form_data_1.default(body)) {\n        return util_1.promisify(body.getLength.bind(body))();\n    }\n    if (body instanceof fs_1.ReadStream) {\n        const { size } = await statAsync(body.path);\n        if (size === 0) {\n            return undefined;\n        }\n        return size;\n    }\n    return undefined;\n};\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvc3dhcm0tanMvbm9kZV9tb2R1bGVzL2dvdC9kaXN0L3NvdXJjZS9jb3JlL3V0aWxzL2dldC1ib2R5LXNpemUuanMiLCJtYXBwaW5ncyI6IkFBQWE7QUFDYiw4Q0FBNkMsRUFBRSxhQUFhLEVBQUM7QUFDN0QsYUFBYSxtQkFBTyxDQUFDLGNBQUk7QUFDekIsZUFBZSxtQkFBTyxDQUFDLGtCQUFNO0FBQzdCLGFBQWEsbUJBQU8sQ0FBQyw2RUFBa0I7QUFDdkMsdUJBQXVCLG1CQUFPLENBQUMsNkdBQWdCO0FBQy9DO0FBQ0Esa0JBQWU7QUFDZjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGdCQUFnQixPQUFPO0FBQ3ZCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBIiwic291cmNlcyI6WyIvVXNlcnMvcGFuemEvRG9jdW1lbnRzL1BlcnNvbmFsUHJvamVjdHMvcHJlZGlrL25vZGVfbW9kdWxlcy9zd2FybS1qcy9ub2RlX21vZHVsZXMvZ290L2Rpc3Qvc291cmNlL2NvcmUvdXRpbHMvZ2V0LWJvZHktc2l6ZS5qcyJdLCJzb3VyY2VzQ29udGVudCI6WyJcInVzZSBzdHJpY3RcIjtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcbmNvbnN0IGZzXzEgPSByZXF1aXJlKFwiZnNcIik7XG5jb25zdCB1dGlsXzEgPSByZXF1aXJlKFwidXRpbFwiKTtcbmNvbnN0IGlzXzEgPSByZXF1aXJlKFwiQHNpbmRyZXNvcmh1cy9pc1wiKTtcbmNvbnN0IGlzX2Zvcm1fZGF0YV8xID0gcmVxdWlyZShcIi4vaXMtZm9ybS1kYXRhXCIpO1xuY29uc3Qgc3RhdEFzeW5jID0gdXRpbF8xLnByb21pc2lmeShmc18xLnN0YXQpO1xuZXhwb3J0cy5kZWZhdWx0ID0gYXN5bmMgKGJvZHksIGhlYWRlcnMpID0+IHtcbiAgICBpZiAoaGVhZGVycyAmJiAnY29udGVudC1sZW5ndGgnIGluIGhlYWRlcnMpIHtcbiAgICAgICAgcmV0dXJuIE51bWJlcihoZWFkZXJzWydjb250ZW50LWxlbmd0aCddKTtcbiAgICB9XG4gICAgaWYgKCFib2R5KSB7XG4gICAgICAgIHJldHVybiAwO1xuICAgIH1cbiAgICBpZiAoaXNfMS5kZWZhdWx0LnN0cmluZyhib2R5KSkge1xuICAgICAgICByZXR1cm4gQnVmZmVyLmJ5dGVMZW5ndGgoYm9keSk7XG4gICAgfVxuICAgIGlmIChpc18xLmRlZmF1bHQuYnVmZmVyKGJvZHkpKSB7XG4gICAgICAgIHJldHVybiBib2R5Lmxlbmd0aDtcbiAgICB9XG4gICAgaWYgKGlzX2Zvcm1fZGF0YV8xLmRlZmF1bHQoYm9keSkpIHtcbiAgICAgICAgcmV0dXJuIHV0aWxfMS5wcm9taXNpZnkoYm9keS5nZXRMZW5ndGguYmluZChib2R5KSkoKTtcbiAgICB9XG4gICAgaWYgKGJvZHkgaW5zdGFuY2VvZiBmc18xLlJlYWRTdHJlYW0pIHtcbiAgICAgICAgY29uc3QgeyBzaXplIH0gPSBhd2FpdCBzdGF0QXN5bmMoYm9keS5wYXRoKTtcbiAgICAgICAgaWYgKHNpemUgPT09IDApIHtcbiAgICAgICAgICAgIHJldHVybiB1bmRlZmluZWQ7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHNpemU7XG4gICAgfVxuICAgIHJldHVybiB1bmRlZmluZWQ7XG59O1xuIl0sIm5hbWVzIjpbXSwiaWdub3JlTGlzdCI6WzBdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/swarm-js/node_modules/got/dist/source/core/utils/get-body-size.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/swarm-js/node_modules/got/dist/source/core/utils/get-buffer.js":
/*!*************************************************************************************!*\
  !*** ./node_modules/swarm-js/node_modules/got/dist/source/core/utils/get-buffer.js ***!
  \*************************************************************************************/
/***/ ((__unused_webpack_module, exports) => {

"use strict";
eval("\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\n// TODO: Update https://github.com/sindresorhus/get-stream\nconst getBuffer = async (stream) => {\n    const chunks = [];\n    let length = 0;\n    for await (const chunk of stream) {\n        chunks.push(chunk);\n        length += Buffer.byteLength(chunk);\n    }\n    if (Buffer.isBuffer(chunks[0])) {\n        return Buffer.concat(chunks, length);\n    }\n    return Buffer.from(chunks.join(''));\n};\nexports[\"default\"] = getBuffer;\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvc3dhcm0tanMvbm9kZV9tb2R1bGVzL2dvdC9kaXN0L3NvdXJjZS9jb3JlL3V0aWxzL2dldC1idWZmZXIuanMiLCJtYXBwaW5ncyI6IkFBQWE7QUFDYiw4Q0FBNkMsRUFBRSxhQUFhLEVBQUM7QUFDN0Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxrQkFBZSIsInNvdXJjZXMiOlsiL1VzZXJzL3BhbnphL0RvY3VtZW50cy9QZXJzb25hbFByb2plY3RzL3ByZWRpay9ub2RlX21vZHVsZXMvc3dhcm0tanMvbm9kZV9tb2R1bGVzL2dvdC9kaXN0L3NvdXJjZS9jb3JlL3V0aWxzL2dldC1idWZmZXIuanMiXSwic291cmNlc0NvbnRlbnQiOlsiXCJ1c2Ugc3RyaWN0XCI7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XG4vLyBUT0RPOiBVcGRhdGUgaHR0cHM6Ly9naXRodWIuY29tL3NpbmRyZXNvcmh1cy9nZXQtc3RyZWFtXG5jb25zdCBnZXRCdWZmZXIgPSBhc3luYyAoc3RyZWFtKSA9PiB7XG4gICAgY29uc3QgY2h1bmtzID0gW107XG4gICAgbGV0IGxlbmd0aCA9IDA7XG4gICAgZm9yIGF3YWl0IChjb25zdCBjaHVuayBvZiBzdHJlYW0pIHtcbiAgICAgICAgY2h1bmtzLnB1c2goY2h1bmspO1xuICAgICAgICBsZW5ndGggKz0gQnVmZmVyLmJ5dGVMZW5ndGgoY2h1bmspO1xuICAgIH1cbiAgICBpZiAoQnVmZmVyLmlzQnVmZmVyKGNodW5rc1swXSkpIHtcbiAgICAgICAgcmV0dXJuIEJ1ZmZlci5jb25jYXQoY2h1bmtzLCBsZW5ndGgpO1xuICAgIH1cbiAgICByZXR1cm4gQnVmZmVyLmZyb20oY2h1bmtzLmpvaW4oJycpKTtcbn07XG5leHBvcnRzLmRlZmF1bHQgPSBnZXRCdWZmZXI7XG4iXSwibmFtZXMiOltdLCJpZ25vcmVMaXN0IjpbMF0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/swarm-js/node_modules/got/dist/source/core/utils/get-buffer.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/swarm-js/node_modules/got/dist/source/core/utils/is-form-data.js":
/*!***************************************************************************************!*\
  !*** ./node_modules/swarm-js/node_modules/got/dist/source/core/utils/is-form-data.js ***!
  \***************************************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";
eval("\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nconst is_1 = __webpack_require__(/*! @sindresorhus/is */ \"(ssr)/./node_modules/@sindresorhus/is/dist/index.js\");\nexports[\"default\"] = (body) => is_1.default.nodeStream(body) && is_1.default.function_(body.getBoundary);\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvc3dhcm0tanMvbm9kZV9tb2R1bGVzL2dvdC9kaXN0L3NvdXJjZS9jb3JlL3V0aWxzL2lzLWZvcm0tZGF0YS5qcyIsIm1hcHBpbmdzIjoiQUFBYTtBQUNiLDhDQUE2QyxFQUFFLGFBQWEsRUFBQztBQUM3RCxhQUFhLG1CQUFPLENBQUMsNkVBQWtCO0FBQ3ZDLGtCQUFlIiwic291cmNlcyI6WyIvVXNlcnMvcGFuemEvRG9jdW1lbnRzL1BlcnNvbmFsUHJvamVjdHMvcHJlZGlrL25vZGVfbW9kdWxlcy9zd2FybS1qcy9ub2RlX21vZHVsZXMvZ290L2Rpc3Qvc291cmNlL2NvcmUvdXRpbHMvaXMtZm9ybS1kYXRhLmpzIl0sInNvdXJjZXNDb250ZW50IjpbIlwidXNlIHN0cmljdFwiO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xuY29uc3QgaXNfMSA9IHJlcXVpcmUoXCJAc2luZHJlc29yaHVzL2lzXCIpO1xuZXhwb3J0cy5kZWZhdWx0ID0gKGJvZHkpID0+IGlzXzEuZGVmYXVsdC5ub2RlU3RyZWFtKGJvZHkpICYmIGlzXzEuZGVmYXVsdC5mdW5jdGlvbl8oYm9keS5nZXRCb3VuZGFyeSk7XG4iXSwibmFtZXMiOltdLCJpZ25vcmVMaXN0IjpbMF0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/swarm-js/node_modules/got/dist/source/core/utils/is-form-data.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/swarm-js/node_modules/got/dist/source/core/utils/is-response-ok.js":
/*!*****************************************************************************************!*\
  !*** ./node_modules/swarm-js/node_modules/got/dist/source/core/utils/is-response-ok.js ***!
  \*****************************************************************************************/
/***/ ((__unused_webpack_module, exports) => {

"use strict";
eval("\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nexports.isResponseOk = void 0;\nexports.isResponseOk = (response) => {\n    const { statusCode } = response;\n    const limitStatusCode = response.request.options.followRedirect ? 299 : 399;\n    return (statusCode >= 200 && statusCode <= limitStatusCode) || statusCode === 304;\n};\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvc3dhcm0tanMvbm9kZV9tb2R1bGVzL2dvdC9kaXN0L3NvdXJjZS9jb3JlL3V0aWxzL2lzLXJlc3BvbnNlLW9rLmpzIiwibWFwcGluZ3MiOiJBQUFhO0FBQ2IsOENBQTZDLEVBQUUsYUFBYSxFQUFDO0FBQzdELG9CQUFvQjtBQUNwQixvQkFBb0I7QUFDcEIsWUFBWSxhQUFhO0FBQ3pCO0FBQ0E7QUFDQSIsInNvdXJjZXMiOlsiL1VzZXJzL3BhbnphL0RvY3VtZW50cy9QZXJzb25hbFByb2plY3RzL3ByZWRpay9ub2RlX21vZHVsZXMvc3dhcm0tanMvbm9kZV9tb2R1bGVzL2dvdC9kaXN0L3NvdXJjZS9jb3JlL3V0aWxzL2lzLXJlc3BvbnNlLW9rLmpzIl0sInNvdXJjZXNDb250ZW50IjpbIlwidXNlIHN0cmljdFwiO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xuZXhwb3J0cy5pc1Jlc3BvbnNlT2sgPSB2b2lkIDA7XG5leHBvcnRzLmlzUmVzcG9uc2VPayA9IChyZXNwb25zZSkgPT4ge1xuICAgIGNvbnN0IHsgc3RhdHVzQ29kZSB9ID0gcmVzcG9uc2U7XG4gICAgY29uc3QgbGltaXRTdGF0dXNDb2RlID0gcmVzcG9uc2UucmVxdWVzdC5vcHRpb25zLmZvbGxvd1JlZGlyZWN0ID8gMjk5IDogMzk5O1xuICAgIHJldHVybiAoc3RhdHVzQ29kZSA+PSAyMDAgJiYgc3RhdHVzQ29kZSA8PSBsaW1pdFN0YXR1c0NvZGUpIHx8IHN0YXR1c0NvZGUgPT09IDMwNDtcbn07XG4iXSwibmFtZXMiOltdLCJpZ25vcmVMaXN0IjpbMF0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/swarm-js/node_modules/got/dist/source/core/utils/is-response-ok.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/swarm-js/node_modules/got/dist/source/core/utils/options-to-url.js":
/*!*****************************************************************************************!*\
  !*** ./node_modules/swarm-js/node_modules/got/dist/source/core/utils/options-to-url.js ***!
  \*****************************************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";
eval("\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\n/* istanbul ignore file: deprecated */\nconst url_1 = __webpack_require__(/*! url */ \"url\");\nconst keys = [\n    'protocol',\n    'host',\n    'hostname',\n    'port',\n    'pathname',\n    'search'\n];\nexports[\"default\"] = (origin, options) => {\n    var _a, _b;\n    if (options.path) {\n        if (options.pathname) {\n            throw new TypeError('Parameters `path` and `pathname` are mutually exclusive.');\n        }\n        if (options.search) {\n            throw new TypeError('Parameters `path` and `search` are mutually exclusive.');\n        }\n        if (options.searchParams) {\n            throw new TypeError('Parameters `path` and `searchParams` are mutually exclusive.');\n        }\n    }\n    if (options.search && options.searchParams) {\n        throw new TypeError('Parameters `search` and `searchParams` are mutually exclusive.');\n    }\n    if (!origin) {\n        if (!options.protocol) {\n            throw new TypeError('No URL protocol specified');\n        }\n        origin = `${options.protocol}//${(_b = (_a = options.hostname) !== null && _a !== void 0 ? _a : options.host) !== null && _b !== void 0 ? _b : ''}`;\n    }\n    const url = new url_1.URL(origin);\n    if (options.path) {\n        const searchIndex = options.path.indexOf('?');\n        if (searchIndex === -1) {\n            options.pathname = options.path;\n        }\n        else {\n            options.pathname = options.path.slice(0, searchIndex);\n            options.search = options.path.slice(searchIndex + 1);\n        }\n        delete options.path;\n    }\n    for (const key of keys) {\n        if (options[key]) {\n            url[key] = options[key].toString();\n        }\n    }\n    return url;\n};\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvc3dhcm0tanMvbm9kZV9tb2R1bGVzL2dvdC9kaXN0L3NvdXJjZS9jb3JlL3V0aWxzL29wdGlvbnMtdG8tdXJsLmpzIiwibWFwcGluZ3MiOiJBQUFhO0FBQ2IsOENBQTZDLEVBQUUsYUFBYSxFQUFDO0FBQzdEO0FBQ0EsY0FBYyxtQkFBTyxDQUFDLGdCQUFLO0FBQzNCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxrQkFBZTtBQUNmO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esb0JBQW9CLGlCQUFpQixJQUFJLGlIQUFpSDtBQUMxSjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBIiwic291cmNlcyI6WyIvVXNlcnMvcGFuemEvRG9jdW1lbnRzL1BlcnNvbmFsUHJvamVjdHMvcHJlZGlrL25vZGVfbW9kdWxlcy9zd2FybS1qcy9ub2RlX21vZHVsZXMvZ290L2Rpc3Qvc291cmNlL2NvcmUvdXRpbHMvb3B0aW9ucy10by11cmwuanMiXSwic291cmNlc0NvbnRlbnQiOlsiXCJ1c2Ugc3RyaWN0XCI7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XG4vKiBpc3RhbmJ1bCBpZ25vcmUgZmlsZTogZGVwcmVjYXRlZCAqL1xuY29uc3QgdXJsXzEgPSByZXF1aXJlKFwidXJsXCIpO1xuY29uc3Qga2V5cyA9IFtcbiAgICAncHJvdG9jb2wnLFxuICAgICdob3N0JyxcbiAgICAnaG9zdG5hbWUnLFxuICAgICdwb3J0JyxcbiAgICAncGF0aG5hbWUnLFxuICAgICdzZWFyY2gnXG5dO1xuZXhwb3J0cy5kZWZhdWx0ID0gKG9yaWdpbiwgb3B0aW9ucykgPT4ge1xuICAgIHZhciBfYSwgX2I7XG4gICAgaWYgKG9wdGlvbnMucGF0aCkge1xuICAgICAgICBpZiAob3B0aW9ucy5wYXRobmFtZSkge1xuICAgICAgICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvcignUGFyYW1ldGVycyBgcGF0aGAgYW5kIGBwYXRobmFtZWAgYXJlIG11dHVhbGx5IGV4Y2x1c2l2ZS4nKTtcbiAgICAgICAgfVxuICAgICAgICBpZiAob3B0aW9ucy5zZWFyY2gpIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBUeXBlRXJyb3IoJ1BhcmFtZXRlcnMgYHBhdGhgIGFuZCBgc2VhcmNoYCBhcmUgbXV0dWFsbHkgZXhjbHVzaXZlLicpO1xuICAgICAgICB9XG4gICAgICAgIGlmIChvcHRpb25zLnNlYXJjaFBhcmFtcykge1xuICAgICAgICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvcignUGFyYW1ldGVycyBgcGF0aGAgYW5kIGBzZWFyY2hQYXJhbXNgIGFyZSBtdXR1YWxseSBleGNsdXNpdmUuJyk7XG4gICAgICAgIH1cbiAgICB9XG4gICAgaWYgKG9wdGlvbnMuc2VhcmNoICYmIG9wdGlvbnMuc2VhcmNoUGFyYW1zKSB7XG4gICAgICAgIHRocm93IG5ldyBUeXBlRXJyb3IoJ1BhcmFtZXRlcnMgYHNlYXJjaGAgYW5kIGBzZWFyY2hQYXJhbXNgIGFyZSBtdXR1YWxseSBleGNsdXNpdmUuJyk7XG4gICAgfVxuICAgIGlmICghb3JpZ2luKSB7XG4gICAgICAgIGlmICghb3B0aW9ucy5wcm90b2NvbCkge1xuICAgICAgICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvcignTm8gVVJMIHByb3RvY29sIHNwZWNpZmllZCcpO1xuICAgICAgICB9XG4gICAgICAgIG9yaWdpbiA9IGAke29wdGlvbnMucHJvdG9jb2x9Ly8keyhfYiA9IChfYSA9IG9wdGlvbnMuaG9zdG5hbWUpICE9PSBudWxsICYmIF9hICE9PSB2b2lkIDAgPyBfYSA6IG9wdGlvbnMuaG9zdCkgIT09IG51bGwgJiYgX2IgIT09IHZvaWQgMCA/IF9iIDogJyd9YDtcbiAgICB9XG4gICAgY29uc3QgdXJsID0gbmV3IHVybF8xLlVSTChvcmlnaW4pO1xuICAgIGlmIChvcHRpb25zLnBhdGgpIHtcbiAgICAgICAgY29uc3Qgc2VhcmNoSW5kZXggPSBvcHRpb25zLnBhdGguaW5kZXhPZignPycpO1xuICAgICAgICBpZiAoc2VhcmNoSW5kZXggPT09IC0xKSB7XG4gICAgICAgICAgICBvcHRpb25zLnBhdGhuYW1lID0gb3B0aW9ucy5wYXRoO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgb3B0aW9ucy5wYXRobmFtZSA9IG9wdGlvbnMucGF0aC5zbGljZSgwLCBzZWFyY2hJbmRleCk7XG4gICAgICAgICAgICBvcHRpb25zLnNlYXJjaCA9IG9wdGlvbnMucGF0aC5zbGljZShzZWFyY2hJbmRleCArIDEpO1xuICAgICAgICB9XG4gICAgICAgIGRlbGV0ZSBvcHRpb25zLnBhdGg7XG4gICAgfVxuICAgIGZvciAoY29uc3Qga2V5IG9mIGtleXMpIHtcbiAgICAgICAgaWYgKG9wdGlvbnNba2V5XSkge1xuICAgICAgICAgICAgdXJsW2tleV0gPSBvcHRpb25zW2tleV0udG9TdHJpbmcoKTtcbiAgICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gdXJsO1xufTtcbiJdLCJuYW1lcyI6W10sImlnbm9yZUxpc3QiOlswXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/swarm-js/node_modules/got/dist/source/core/utils/options-to-url.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/swarm-js/node_modules/got/dist/source/core/utils/proxy-events.js":
/*!***************************************************************************************!*\
  !*** ./node_modules/swarm-js/node_modules/got/dist/source/core/utils/proxy-events.js ***!
  \***************************************************************************************/
/***/ ((__unused_webpack_module, exports) => {

"use strict";
eval("\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nfunction default_1(from, to, events) {\n    const fns = {};\n    for (const event of events) {\n        fns[event] = (...args) => {\n            to.emit(event, ...args);\n        };\n        from.on(event, fns[event]);\n    }\n    return () => {\n        for (const event of events) {\n            from.off(event, fns[event]);\n        }\n    };\n}\nexports[\"default\"] = default_1;\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvc3dhcm0tanMvbm9kZV9tb2R1bGVzL2dvdC9kaXN0L3NvdXJjZS9jb3JlL3V0aWxzL3Byb3h5LWV2ZW50cy5qcyIsIm1hcHBpbmdzIjoiQUFBYTtBQUNiLDhDQUE2QyxFQUFFLGFBQWEsRUFBQztBQUM3RDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esa0JBQWUiLCJzb3VyY2VzIjpbIi9Vc2Vycy9wYW56YS9Eb2N1bWVudHMvUGVyc29uYWxQcm9qZWN0cy9wcmVkaWsvbm9kZV9tb2R1bGVzL3N3YXJtLWpzL25vZGVfbW9kdWxlcy9nb3QvZGlzdC9zb3VyY2UvY29yZS91dGlscy9wcm94eS1ldmVudHMuanMiXSwic291cmNlc0NvbnRlbnQiOlsiXCJ1c2Ugc3RyaWN0XCI7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XG5mdW5jdGlvbiBkZWZhdWx0XzEoZnJvbSwgdG8sIGV2ZW50cykge1xuICAgIGNvbnN0IGZucyA9IHt9O1xuICAgIGZvciAoY29uc3QgZXZlbnQgb2YgZXZlbnRzKSB7XG4gICAgICAgIGZuc1tldmVudF0gPSAoLi4uYXJncykgPT4ge1xuICAgICAgICAgICAgdG8uZW1pdChldmVudCwgLi4uYXJncyk7XG4gICAgICAgIH07XG4gICAgICAgIGZyb20ub24oZXZlbnQsIGZuc1tldmVudF0pO1xuICAgIH1cbiAgICByZXR1cm4gKCkgPT4ge1xuICAgICAgICBmb3IgKGNvbnN0IGV2ZW50IG9mIGV2ZW50cykge1xuICAgICAgICAgICAgZnJvbS5vZmYoZXZlbnQsIGZuc1tldmVudF0pO1xuICAgICAgICB9XG4gICAgfTtcbn1cbmV4cG9ydHMuZGVmYXVsdCA9IGRlZmF1bHRfMTtcbiJdLCJuYW1lcyI6W10sImlnbm9yZUxpc3QiOlswXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/swarm-js/node_modules/got/dist/source/core/utils/proxy-events.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/swarm-js/node_modules/got/dist/source/core/utils/timed-out.js":
/*!************************************************************************************!*\
  !*** ./node_modules/swarm-js/node_modules/got/dist/source/core/utils/timed-out.js ***!
  \************************************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";
eval("\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nexports.TimeoutError = void 0;\nconst net = __webpack_require__(/*! net */ \"net\");\nconst unhandle_1 = __webpack_require__(/*! ./unhandle */ \"(ssr)/./node_modules/swarm-js/node_modules/got/dist/source/core/utils/unhandle.js\");\nconst reentry = Symbol('reentry');\nconst noop = () => { };\nclass TimeoutError extends Error {\n    constructor(threshold, event) {\n        super(`Timeout awaiting '${event}' for ${threshold}ms`);\n        this.event = event;\n        this.name = 'TimeoutError';\n        this.code = 'ETIMEDOUT';\n    }\n}\nexports.TimeoutError = TimeoutError;\nexports[\"default\"] = (request, delays, options) => {\n    if (reentry in request) {\n        return noop;\n    }\n    request[reentry] = true;\n    const cancelers = [];\n    const { once, unhandleAll } = unhandle_1.default();\n    const addTimeout = (delay, callback, event) => {\n        var _a;\n        const timeout = setTimeout(callback, delay, delay, event);\n        (_a = timeout.unref) === null || _a === void 0 ? void 0 : _a.call(timeout);\n        const cancel = () => {\n            clearTimeout(timeout);\n        };\n        cancelers.push(cancel);\n        return cancel;\n    };\n    const { host, hostname } = options;\n    const timeoutHandler = (delay, event) => {\n        request.destroy(new TimeoutError(delay, event));\n    };\n    const cancelTimeouts = () => {\n        for (const cancel of cancelers) {\n            cancel();\n        }\n        unhandleAll();\n    };\n    request.once('error', error => {\n        cancelTimeouts();\n        // Save original behavior\n        /* istanbul ignore next */\n        if (request.listenerCount('error') === 0) {\n            throw error;\n        }\n    });\n    request.once('close', cancelTimeouts);\n    once(request, 'response', (response) => {\n        once(response, 'end', cancelTimeouts);\n    });\n    if (typeof delays.request !== 'undefined') {\n        addTimeout(delays.request, timeoutHandler, 'request');\n    }\n    if (typeof delays.socket !== 'undefined') {\n        const socketTimeoutHandler = () => {\n            timeoutHandler(delays.socket, 'socket');\n        };\n        request.setTimeout(delays.socket, socketTimeoutHandler);\n        // `request.setTimeout(0)` causes a memory leak.\n        // We can just remove the listener and forget about the timer - it's unreffed.\n        // See https://github.com/sindresorhus/got/issues/690\n        cancelers.push(() => {\n            request.removeListener('timeout', socketTimeoutHandler);\n        });\n    }\n    once(request, 'socket', (socket) => {\n        var _a;\n        const { socketPath } = request;\n        /* istanbul ignore next: hard to test */\n        if (socket.connecting) {\n            const hasPath = Boolean(socketPath !== null && socketPath !== void 0 ? socketPath : net.isIP((_a = hostname !== null && hostname !== void 0 ? hostname : host) !== null && _a !== void 0 ? _a : '') !== 0);\n            if (typeof delays.lookup !== 'undefined' && !hasPath && typeof socket.address().address === 'undefined') {\n                const cancelTimeout = addTimeout(delays.lookup, timeoutHandler, 'lookup');\n                once(socket, 'lookup', cancelTimeout);\n            }\n            if (typeof delays.connect !== 'undefined') {\n                const timeConnect = () => addTimeout(delays.connect, timeoutHandler, 'connect');\n                if (hasPath) {\n                    once(socket, 'connect', timeConnect());\n                }\n                else {\n                    once(socket, 'lookup', (error) => {\n                        if (error === null) {\n                            once(socket, 'connect', timeConnect());\n                        }\n                    });\n                }\n            }\n            if (typeof delays.secureConnect !== 'undefined' && options.protocol === 'https:') {\n                once(socket, 'connect', () => {\n                    const cancelTimeout = addTimeout(delays.secureConnect, timeoutHandler, 'secureConnect');\n                    once(socket, 'secureConnect', cancelTimeout);\n                });\n            }\n        }\n        if (typeof delays.send !== 'undefined') {\n            const timeRequest = () => addTimeout(delays.send, timeoutHandler, 'send');\n            /* istanbul ignore next: hard to test */\n            if (socket.connecting) {\n                once(socket, 'connect', () => {\n                    once(request, 'upload-complete', timeRequest());\n                });\n            }\n            else {\n                once(request, 'upload-complete', timeRequest());\n            }\n        }\n    });\n    if (typeof delays.response !== 'undefined') {\n        once(request, 'upload-complete', () => {\n            const cancelTimeout = addTimeout(delays.response, timeoutHandler, 'response');\n            once(request, 'response', cancelTimeout);\n        });\n    }\n    return cancelTimeouts;\n};\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvc3dhcm0tanMvbm9kZV9tb2R1bGVzL2dvdC9kaXN0L3NvdXJjZS9jb3JlL3V0aWxzL3RpbWVkLW91dC5qcyIsIm1hcHBpbmdzIjoiQUFBYTtBQUNiLDhDQUE2QyxFQUFFLGFBQWEsRUFBQztBQUM3RCxvQkFBb0I7QUFDcEIsWUFBWSxtQkFBTyxDQUFDLGdCQUFLO0FBQ3pCLG1CQUFtQixtQkFBTyxDQUFDLHFHQUFZO0FBQ3ZDO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsbUNBQW1DLE1BQU0sUUFBUSxVQUFVO0FBQzNEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxvQkFBb0I7QUFDcEIsa0JBQWU7QUFDZjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsWUFBWSxvQkFBb0I7QUFDaEM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxZQUFZLGlCQUFpQjtBQUM3QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0EsZ0JBQWdCLGFBQWE7QUFDN0I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHFCQUFxQjtBQUNyQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxpQkFBaUI7QUFDakI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGlCQUFpQjtBQUNqQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQSIsInNvdXJjZXMiOlsiL1VzZXJzL3BhbnphL0RvY3VtZW50cy9QZXJzb25hbFByb2plY3RzL3ByZWRpay9ub2RlX21vZHVsZXMvc3dhcm0tanMvbm9kZV9tb2R1bGVzL2dvdC9kaXN0L3NvdXJjZS9jb3JlL3V0aWxzL3RpbWVkLW91dC5qcyJdLCJzb3VyY2VzQ29udGVudCI6WyJcInVzZSBzdHJpY3RcIjtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcbmV4cG9ydHMuVGltZW91dEVycm9yID0gdm9pZCAwO1xuY29uc3QgbmV0ID0gcmVxdWlyZShcIm5ldFwiKTtcbmNvbnN0IHVuaGFuZGxlXzEgPSByZXF1aXJlKFwiLi91bmhhbmRsZVwiKTtcbmNvbnN0IHJlZW50cnkgPSBTeW1ib2woJ3JlZW50cnknKTtcbmNvbnN0IG5vb3AgPSAoKSA9PiB7IH07XG5jbGFzcyBUaW1lb3V0RXJyb3IgZXh0ZW5kcyBFcnJvciB7XG4gICAgY29uc3RydWN0b3IodGhyZXNob2xkLCBldmVudCkge1xuICAgICAgICBzdXBlcihgVGltZW91dCBhd2FpdGluZyAnJHtldmVudH0nIGZvciAke3RocmVzaG9sZH1tc2ApO1xuICAgICAgICB0aGlzLmV2ZW50ID0gZXZlbnQ7XG4gICAgICAgIHRoaXMubmFtZSA9ICdUaW1lb3V0RXJyb3InO1xuICAgICAgICB0aGlzLmNvZGUgPSAnRVRJTUVET1VUJztcbiAgICB9XG59XG5leHBvcnRzLlRpbWVvdXRFcnJvciA9IFRpbWVvdXRFcnJvcjtcbmV4cG9ydHMuZGVmYXVsdCA9IChyZXF1ZXN0LCBkZWxheXMsIG9wdGlvbnMpID0+IHtcbiAgICBpZiAocmVlbnRyeSBpbiByZXF1ZXN0KSB7XG4gICAgICAgIHJldHVybiBub29wO1xuICAgIH1cbiAgICByZXF1ZXN0W3JlZW50cnldID0gdHJ1ZTtcbiAgICBjb25zdCBjYW5jZWxlcnMgPSBbXTtcbiAgICBjb25zdCB7IG9uY2UsIHVuaGFuZGxlQWxsIH0gPSB1bmhhbmRsZV8xLmRlZmF1bHQoKTtcbiAgICBjb25zdCBhZGRUaW1lb3V0ID0gKGRlbGF5LCBjYWxsYmFjaywgZXZlbnQpID0+IHtcbiAgICAgICAgdmFyIF9hO1xuICAgICAgICBjb25zdCB0aW1lb3V0ID0gc2V0VGltZW91dChjYWxsYmFjaywgZGVsYXksIGRlbGF5LCBldmVudCk7XG4gICAgICAgIChfYSA9IHRpbWVvdXQudW5yZWYpID09PSBudWxsIHx8IF9hID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfYS5jYWxsKHRpbWVvdXQpO1xuICAgICAgICBjb25zdCBjYW5jZWwgPSAoKSA9PiB7XG4gICAgICAgICAgICBjbGVhclRpbWVvdXQodGltZW91dCk7XG4gICAgICAgIH07XG4gICAgICAgIGNhbmNlbGVycy5wdXNoKGNhbmNlbCk7XG4gICAgICAgIHJldHVybiBjYW5jZWw7XG4gICAgfTtcbiAgICBjb25zdCB7IGhvc3QsIGhvc3RuYW1lIH0gPSBvcHRpb25zO1xuICAgIGNvbnN0IHRpbWVvdXRIYW5kbGVyID0gKGRlbGF5LCBldmVudCkgPT4ge1xuICAgICAgICByZXF1ZXN0LmRlc3Ryb3kobmV3IFRpbWVvdXRFcnJvcihkZWxheSwgZXZlbnQpKTtcbiAgICB9O1xuICAgIGNvbnN0IGNhbmNlbFRpbWVvdXRzID0gKCkgPT4ge1xuICAgICAgICBmb3IgKGNvbnN0IGNhbmNlbCBvZiBjYW5jZWxlcnMpIHtcbiAgICAgICAgICAgIGNhbmNlbCgpO1xuICAgICAgICB9XG4gICAgICAgIHVuaGFuZGxlQWxsKCk7XG4gICAgfTtcbiAgICByZXF1ZXN0Lm9uY2UoJ2Vycm9yJywgZXJyb3IgPT4ge1xuICAgICAgICBjYW5jZWxUaW1lb3V0cygpO1xuICAgICAgICAvLyBTYXZlIG9yaWdpbmFsIGJlaGF2aW9yXG4gICAgICAgIC8qIGlzdGFuYnVsIGlnbm9yZSBuZXh0ICovXG4gICAgICAgIGlmIChyZXF1ZXN0Lmxpc3RlbmVyQ291bnQoJ2Vycm9yJykgPT09IDApIHtcbiAgICAgICAgICAgIHRocm93IGVycm9yO1xuICAgICAgICB9XG4gICAgfSk7XG4gICAgcmVxdWVzdC5vbmNlKCdjbG9zZScsIGNhbmNlbFRpbWVvdXRzKTtcbiAgICBvbmNlKHJlcXVlc3QsICdyZXNwb25zZScsIChyZXNwb25zZSkgPT4ge1xuICAgICAgICBvbmNlKHJlc3BvbnNlLCAnZW5kJywgY2FuY2VsVGltZW91dHMpO1xuICAgIH0pO1xuICAgIGlmICh0eXBlb2YgZGVsYXlzLnJlcXVlc3QgIT09ICd1bmRlZmluZWQnKSB7XG4gICAgICAgIGFkZFRpbWVvdXQoZGVsYXlzLnJlcXVlc3QsIHRpbWVvdXRIYW5kbGVyLCAncmVxdWVzdCcpO1xuICAgIH1cbiAgICBpZiAodHlwZW9mIGRlbGF5cy5zb2NrZXQgIT09ICd1bmRlZmluZWQnKSB7XG4gICAgICAgIGNvbnN0IHNvY2tldFRpbWVvdXRIYW5kbGVyID0gKCkgPT4ge1xuICAgICAgICAgICAgdGltZW91dEhhbmRsZXIoZGVsYXlzLnNvY2tldCwgJ3NvY2tldCcpO1xuICAgICAgICB9O1xuICAgICAgICByZXF1ZXN0LnNldFRpbWVvdXQoZGVsYXlzLnNvY2tldCwgc29ja2V0VGltZW91dEhhbmRsZXIpO1xuICAgICAgICAvLyBgcmVxdWVzdC5zZXRUaW1lb3V0KDApYCBjYXVzZXMgYSBtZW1vcnkgbGVhay5cbiAgICAgICAgLy8gV2UgY2FuIGp1c3QgcmVtb3ZlIHRoZSBsaXN0ZW5lciBhbmQgZm9yZ2V0IGFib3V0IHRoZSB0aW1lciAtIGl0J3MgdW5yZWZmZWQuXG4gICAgICAgIC8vIFNlZSBodHRwczovL2dpdGh1Yi5jb20vc2luZHJlc29yaHVzL2dvdC9pc3N1ZXMvNjkwXG4gICAgICAgIGNhbmNlbGVycy5wdXNoKCgpID0+IHtcbiAgICAgICAgICAgIHJlcXVlc3QucmVtb3ZlTGlzdGVuZXIoJ3RpbWVvdXQnLCBzb2NrZXRUaW1lb3V0SGFuZGxlcik7XG4gICAgICAgIH0pO1xuICAgIH1cbiAgICBvbmNlKHJlcXVlc3QsICdzb2NrZXQnLCAoc29ja2V0KSA9PiB7XG4gICAgICAgIHZhciBfYTtcbiAgICAgICAgY29uc3QgeyBzb2NrZXRQYXRoIH0gPSByZXF1ZXN0O1xuICAgICAgICAvKiBpc3RhbmJ1bCBpZ25vcmUgbmV4dDogaGFyZCB0byB0ZXN0ICovXG4gICAgICAgIGlmIChzb2NrZXQuY29ubmVjdGluZykge1xuICAgICAgICAgICAgY29uc3QgaGFzUGF0aCA9IEJvb2xlYW4oc29ja2V0UGF0aCAhPT0gbnVsbCAmJiBzb2NrZXRQYXRoICE9PSB2b2lkIDAgPyBzb2NrZXRQYXRoIDogbmV0LmlzSVAoKF9hID0gaG9zdG5hbWUgIT09IG51bGwgJiYgaG9zdG5hbWUgIT09IHZvaWQgMCA/IGhvc3RuYW1lIDogaG9zdCkgIT09IG51bGwgJiYgX2EgIT09IHZvaWQgMCA/IF9hIDogJycpICE9PSAwKTtcbiAgICAgICAgICAgIGlmICh0eXBlb2YgZGVsYXlzLmxvb2t1cCAhPT0gJ3VuZGVmaW5lZCcgJiYgIWhhc1BhdGggJiYgdHlwZW9mIHNvY2tldC5hZGRyZXNzKCkuYWRkcmVzcyA9PT0gJ3VuZGVmaW5lZCcpIHtcbiAgICAgICAgICAgICAgICBjb25zdCBjYW5jZWxUaW1lb3V0ID0gYWRkVGltZW91dChkZWxheXMubG9va3VwLCB0aW1lb3V0SGFuZGxlciwgJ2xvb2t1cCcpO1xuICAgICAgICAgICAgICAgIG9uY2Uoc29ja2V0LCAnbG9va3VwJywgY2FuY2VsVGltZW91dCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAodHlwZW9mIGRlbGF5cy5jb25uZWN0ICE9PSAndW5kZWZpbmVkJykge1xuICAgICAgICAgICAgICAgIGNvbnN0IHRpbWVDb25uZWN0ID0gKCkgPT4gYWRkVGltZW91dChkZWxheXMuY29ubmVjdCwgdGltZW91dEhhbmRsZXIsICdjb25uZWN0Jyk7XG4gICAgICAgICAgICAgICAgaWYgKGhhc1BhdGgpIHtcbiAgICAgICAgICAgICAgICAgICAgb25jZShzb2NrZXQsICdjb25uZWN0JywgdGltZUNvbm5lY3QoKSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICBvbmNlKHNvY2tldCwgJ2xvb2t1cCcsIChlcnJvcikgPT4ge1xuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKGVycm9yID09PSBudWxsKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgb25jZShzb2NrZXQsICdjb25uZWN0JywgdGltZUNvbm5lY3QoKSk7XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmICh0eXBlb2YgZGVsYXlzLnNlY3VyZUNvbm5lY3QgIT09ICd1bmRlZmluZWQnICYmIG9wdGlvbnMucHJvdG9jb2wgPT09ICdodHRwczonKSB7XG4gICAgICAgICAgICAgICAgb25jZShzb2NrZXQsICdjb25uZWN0JywgKCkgPT4ge1xuICAgICAgICAgICAgICAgICAgICBjb25zdCBjYW5jZWxUaW1lb3V0ID0gYWRkVGltZW91dChkZWxheXMuc2VjdXJlQ29ubmVjdCwgdGltZW91dEhhbmRsZXIsICdzZWN1cmVDb25uZWN0Jyk7XG4gICAgICAgICAgICAgICAgICAgIG9uY2Uoc29ja2V0LCAnc2VjdXJlQ29ubmVjdCcsIGNhbmNlbFRpbWVvdXQpO1xuICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGlmICh0eXBlb2YgZGVsYXlzLnNlbmQgIT09ICd1bmRlZmluZWQnKSB7XG4gICAgICAgICAgICBjb25zdCB0aW1lUmVxdWVzdCA9ICgpID0+IGFkZFRpbWVvdXQoZGVsYXlzLnNlbmQsIHRpbWVvdXRIYW5kbGVyLCAnc2VuZCcpO1xuICAgICAgICAgICAgLyogaXN0YW5idWwgaWdub3JlIG5leHQ6IGhhcmQgdG8gdGVzdCAqL1xuICAgICAgICAgICAgaWYgKHNvY2tldC5jb25uZWN0aW5nKSB7XG4gICAgICAgICAgICAgICAgb25jZShzb2NrZXQsICdjb25uZWN0JywgKCkgPT4ge1xuICAgICAgICAgICAgICAgICAgICBvbmNlKHJlcXVlc3QsICd1cGxvYWQtY29tcGxldGUnLCB0aW1lUmVxdWVzdCgpKTtcbiAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgIG9uY2UocmVxdWVzdCwgJ3VwbG9hZC1jb21wbGV0ZScsIHRpbWVSZXF1ZXN0KCkpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfSk7XG4gICAgaWYgKHR5cGVvZiBkZWxheXMucmVzcG9uc2UgIT09ICd1bmRlZmluZWQnKSB7XG4gICAgICAgIG9uY2UocmVxdWVzdCwgJ3VwbG9hZC1jb21wbGV0ZScsICgpID0+IHtcbiAgICAgICAgICAgIGNvbnN0IGNhbmNlbFRpbWVvdXQgPSBhZGRUaW1lb3V0KGRlbGF5cy5yZXNwb25zZSwgdGltZW91dEhhbmRsZXIsICdyZXNwb25zZScpO1xuICAgICAgICAgICAgb25jZShyZXF1ZXN0LCAncmVzcG9uc2UnLCBjYW5jZWxUaW1lb3V0KTtcbiAgICAgICAgfSk7XG4gICAgfVxuICAgIHJldHVybiBjYW5jZWxUaW1lb3V0cztcbn07XG4iXSwibmFtZXMiOltdLCJpZ25vcmVMaXN0IjpbMF0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/swarm-js/node_modules/got/dist/source/core/utils/timed-out.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/swarm-js/node_modules/got/dist/source/core/utils/unhandle.js":
/*!***********************************************************************************!*\
  !*** ./node_modules/swarm-js/node_modules/got/dist/source/core/utils/unhandle.js ***!
  \***********************************************************************************/
/***/ ((__unused_webpack_module, exports) => {

"use strict";
eval("\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\n// When attaching listeners, it's very easy to forget about them.\n// Especially if you do error handling and set timeouts.\n// So instead of checking if it's proper to throw an error on every timeout ever,\n// use this simple tool which will remove all listeners you have attached.\nexports[\"default\"] = () => {\n    const handlers = [];\n    return {\n        once(origin, event, fn) {\n            origin.once(event, fn);\n            handlers.push({ origin, event, fn });\n        },\n        unhandleAll() {\n            for (const handler of handlers) {\n                const { origin, event, fn } = handler;\n                origin.removeListener(event, fn);\n            }\n            handlers.length = 0;\n        }\n    };\n};\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvc3dhcm0tanMvbm9kZV9tb2R1bGVzL2dvdC9kaXN0L3NvdXJjZS9jb3JlL3V0aWxzL3VuaGFuZGxlLmpzIiwibWFwcGluZ3MiOiJBQUFhO0FBQ2IsOENBQTZDLEVBQUUsYUFBYSxFQUFDO0FBQzdEO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esa0JBQWU7QUFDZjtBQUNBO0FBQ0E7QUFDQTtBQUNBLDRCQUE0QixtQkFBbUI7QUFDL0MsU0FBUztBQUNUO0FBQ0E7QUFDQSx3QkFBd0Isb0JBQW9CO0FBQzVDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSIsInNvdXJjZXMiOlsiL1VzZXJzL3BhbnphL0RvY3VtZW50cy9QZXJzb25hbFByb2plY3RzL3ByZWRpay9ub2RlX21vZHVsZXMvc3dhcm0tanMvbm9kZV9tb2R1bGVzL2dvdC9kaXN0L3NvdXJjZS9jb3JlL3V0aWxzL3VuaGFuZGxlLmpzIl0sInNvdXJjZXNDb250ZW50IjpbIlwidXNlIHN0cmljdFwiO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xuLy8gV2hlbiBhdHRhY2hpbmcgbGlzdGVuZXJzLCBpdCdzIHZlcnkgZWFzeSB0byBmb3JnZXQgYWJvdXQgdGhlbS5cbi8vIEVzcGVjaWFsbHkgaWYgeW91IGRvIGVycm9yIGhhbmRsaW5nIGFuZCBzZXQgdGltZW91dHMuXG4vLyBTbyBpbnN0ZWFkIG9mIGNoZWNraW5nIGlmIGl0J3MgcHJvcGVyIHRvIHRocm93IGFuIGVycm9yIG9uIGV2ZXJ5IHRpbWVvdXQgZXZlcixcbi8vIHVzZSB0aGlzIHNpbXBsZSB0b29sIHdoaWNoIHdpbGwgcmVtb3ZlIGFsbCBsaXN0ZW5lcnMgeW91IGhhdmUgYXR0YWNoZWQuXG5leHBvcnRzLmRlZmF1bHQgPSAoKSA9PiB7XG4gICAgY29uc3QgaGFuZGxlcnMgPSBbXTtcbiAgICByZXR1cm4ge1xuICAgICAgICBvbmNlKG9yaWdpbiwgZXZlbnQsIGZuKSB7XG4gICAgICAgICAgICBvcmlnaW4ub25jZShldmVudCwgZm4pO1xuICAgICAgICAgICAgaGFuZGxlcnMucHVzaCh7IG9yaWdpbiwgZXZlbnQsIGZuIH0pO1xuICAgICAgICB9LFxuICAgICAgICB1bmhhbmRsZUFsbCgpIHtcbiAgICAgICAgICAgIGZvciAoY29uc3QgaGFuZGxlciBvZiBoYW5kbGVycykge1xuICAgICAgICAgICAgICAgIGNvbnN0IHsgb3JpZ2luLCBldmVudCwgZm4gfSA9IGhhbmRsZXI7XG4gICAgICAgICAgICAgICAgb3JpZ2luLnJlbW92ZUxpc3RlbmVyKGV2ZW50LCBmbik7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBoYW5kbGVycy5sZW5ndGggPSAwO1xuICAgICAgICB9XG4gICAgfTtcbn07XG4iXSwibmFtZXMiOltdLCJpZ25vcmVMaXN0IjpbMF0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/swarm-js/node_modules/got/dist/source/core/utils/unhandle.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/swarm-js/node_modules/got/dist/source/core/utils/url-to-options.js":
/*!*****************************************************************************************!*\
  !*** ./node_modules/swarm-js/node_modules/got/dist/source/core/utils/url-to-options.js ***!
  \*****************************************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";
eval("\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nconst is_1 = __webpack_require__(/*! @sindresorhus/is */ \"(ssr)/./node_modules/@sindresorhus/is/dist/index.js\");\nexports[\"default\"] = (url) => {\n    // Cast to URL\n    url = url;\n    const options = {\n        protocol: url.protocol,\n        hostname: is_1.default.string(url.hostname) && url.hostname.startsWith('[') ? url.hostname.slice(1, -1) : url.hostname,\n        host: url.host,\n        hash: url.hash,\n        search: url.search,\n        pathname: url.pathname,\n        href: url.href,\n        path: `${url.pathname || ''}${url.search || ''}`\n    };\n    if (is_1.default.string(url.port) && url.port.length > 0) {\n        options.port = Number(url.port);\n    }\n    if (url.username || url.password) {\n        options.auth = `${url.username || ''}:${url.password || ''}`;\n    }\n    return options;\n};\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvc3dhcm0tanMvbm9kZV9tb2R1bGVzL2dvdC9kaXN0L3NvdXJjZS9jb3JlL3V0aWxzL3VybC10by1vcHRpb25zLmpzIiwibWFwcGluZ3MiOiJBQUFhO0FBQ2IsOENBQTZDLEVBQUUsYUFBYSxFQUFDO0FBQzdELGFBQWEsbUJBQU8sQ0FBQyw2RUFBa0I7QUFDdkMsa0JBQWU7QUFDZjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGlCQUFpQixtQkFBbUIsRUFBRSxpQkFBaUI7QUFDdkQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDBCQUEwQixtQkFBbUIsR0FBRyxtQkFBbUI7QUFDbkU7QUFDQTtBQUNBIiwic291cmNlcyI6WyIvVXNlcnMvcGFuemEvRG9jdW1lbnRzL1BlcnNvbmFsUHJvamVjdHMvcHJlZGlrL25vZGVfbW9kdWxlcy9zd2FybS1qcy9ub2RlX21vZHVsZXMvZ290L2Rpc3Qvc291cmNlL2NvcmUvdXRpbHMvdXJsLXRvLW9wdGlvbnMuanMiXSwic291cmNlc0NvbnRlbnQiOlsiXCJ1c2Ugc3RyaWN0XCI7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XG5jb25zdCBpc18xID0gcmVxdWlyZShcIkBzaW5kcmVzb3JodXMvaXNcIik7XG5leHBvcnRzLmRlZmF1bHQgPSAodXJsKSA9PiB7XG4gICAgLy8gQ2FzdCB0byBVUkxcbiAgICB1cmwgPSB1cmw7XG4gICAgY29uc3Qgb3B0aW9ucyA9IHtcbiAgICAgICAgcHJvdG9jb2w6IHVybC5wcm90b2NvbCxcbiAgICAgICAgaG9zdG5hbWU6IGlzXzEuZGVmYXVsdC5zdHJpbmcodXJsLmhvc3RuYW1lKSAmJiB1cmwuaG9zdG5hbWUuc3RhcnRzV2l0aCgnWycpID8gdXJsLmhvc3RuYW1lLnNsaWNlKDEsIC0xKSA6IHVybC5ob3N0bmFtZSxcbiAgICAgICAgaG9zdDogdXJsLmhvc3QsXG4gICAgICAgIGhhc2g6IHVybC5oYXNoLFxuICAgICAgICBzZWFyY2g6IHVybC5zZWFyY2gsXG4gICAgICAgIHBhdGhuYW1lOiB1cmwucGF0aG5hbWUsXG4gICAgICAgIGhyZWY6IHVybC5ocmVmLFxuICAgICAgICBwYXRoOiBgJHt1cmwucGF0aG5hbWUgfHwgJyd9JHt1cmwuc2VhcmNoIHx8ICcnfWBcbiAgICB9O1xuICAgIGlmIChpc18xLmRlZmF1bHQuc3RyaW5nKHVybC5wb3J0KSAmJiB1cmwucG9ydC5sZW5ndGggPiAwKSB7XG4gICAgICAgIG9wdGlvbnMucG9ydCA9IE51bWJlcih1cmwucG9ydCk7XG4gICAgfVxuICAgIGlmICh1cmwudXNlcm5hbWUgfHwgdXJsLnBhc3N3b3JkKSB7XG4gICAgICAgIG9wdGlvbnMuYXV0aCA9IGAke3VybC51c2VybmFtZSB8fCAnJ306JHt1cmwucGFzc3dvcmQgfHwgJyd9YDtcbiAgICB9XG4gICAgcmV0dXJuIG9wdGlvbnM7XG59O1xuIl0sIm5hbWVzIjpbXSwiaWdub3JlTGlzdCI6WzBdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/swarm-js/node_modules/got/dist/source/core/utils/url-to-options.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/swarm-js/node_modules/got/dist/source/core/utils/weakable-map.js":
/*!***************************************************************************************!*\
  !*** ./node_modules/swarm-js/node_modules/got/dist/source/core/utils/weakable-map.js ***!
  \***************************************************************************************/
/***/ ((__unused_webpack_module, exports) => {

"use strict";
eval("\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nclass WeakableMap {\n    constructor() {\n        this.weakMap = new WeakMap();\n        this.map = new Map();\n    }\n    set(key, value) {\n        if (typeof key === 'object') {\n            this.weakMap.set(key, value);\n        }\n        else {\n            this.map.set(key, value);\n        }\n    }\n    get(key) {\n        if (typeof key === 'object') {\n            return this.weakMap.get(key);\n        }\n        return this.map.get(key);\n    }\n    has(key) {\n        if (typeof key === 'object') {\n            return this.weakMap.has(key);\n        }\n        return this.map.has(key);\n    }\n}\nexports[\"default\"] = WeakableMap;\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvc3dhcm0tanMvbm9kZV9tb2R1bGVzL2dvdC9kaXN0L3NvdXJjZS9jb3JlL3V0aWxzL3dlYWthYmxlLW1hcC5qcyIsIm1hcHBpbmdzIjoiQUFBYTtBQUNiLDhDQUE2QyxFQUFFLGFBQWEsRUFBQztBQUM3RDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esa0JBQWUiLCJzb3VyY2VzIjpbIi9Vc2Vycy9wYW56YS9Eb2N1bWVudHMvUGVyc29uYWxQcm9qZWN0cy9wcmVkaWsvbm9kZV9tb2R1bGVzL3N3YXJtLWpzL25vZGVfbW9kdWxlcy9nb3QvZGlzdC9zb3VyY2UvY29yZS91dGlscy93ZWFrYWJsZS1tYXAuanMiXSwic291cmNlc0NvbnRlbnQiOlsiXCJ1c2Ugc3RyaWN0XCI7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XG5jbGFzcyBXZWFrYWJsZU1hcCB7XG4gICAgY29uc3RydWN0b3IoKSB7XG4gICAgICAgIHRoaXMud2Vha01hcCA9IG5ldyBXZWFrTWFwKCk7XG4gICAgICAgIHRoaXMubWFwID0gbmV3IE1hcCgpO1xuICAgIH1cbiAgICBzZXQoa2V5LCB2YWx1ZSkge1xuICAgICAgICBpZiAodHlwZW9mIGtleSA9PT0gJ29iamVjdCcpIHtcbiAgICAgICAgICAgIHRoaXMud2Vha01hcC5zZXQoa2V5LCB2YWx1ZSk7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICB0aGlzLm1hcC5zZXQoa2V5LCB2YWx1ZSk7XG4gICAgICAgIH1cbiAgICB9XG4gICAgZ2V0KGtleSkge1xuICAgICAgICBpZiAodHlwZW9mIGtleSA9PT0gJ29iamVjdCcpIHtcbiAgICAgICAgICAgIHJldHVybiB0aGlzLndlYWtNYXAuZ2V0KGtleSk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHRoaXMubWFwLmdldChrZXkpO1xuICAgIH1cbiAgICBoYXMoa2V5KSB7XG4gICAgICAgIGlmICh0eXBlb2Yga2V5ID09PSAnb2JqZWN0Jykge1xuICAgICAgICAgICAgcmV0dXJuIHRoaXMud2Vha01hcC5oYXMoa2V5KTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gdGhpcy5tYXAuaGFzKGtleSk7XG4gICAgfVxufVxuZXhwb3J0cy5kZWZhdWx0ID0gV2Vha2FibGVNYXA7XG4iXSwibmFtZXMiOltdLCJpZ25vcmVMaXN0IjpbMF0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/swarm-js/node_modules/got/dist/source/core/utils/weakable-map.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/swarm-js/node_modules/got/dist/source/create.js":
/*!**********************************************************************!*\
  !*** ./node_modules/swarm-js/node_modules/got/dist/source/create.js ***!
  \**********************************************************************/
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

"use strict";
eval("\nvar __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {\n    if (k2 === undefined) k2 = k;\n    Object.defineProperty(o, k2, { enumerable: true, get: function() { return m[k]; } });\n}) : (function(o, m, k, k2) {\n    if (k2 === undefined) k2 = k;\n    o[k2] = m[k];\n}));\nvar __exportStar = (this && this.__exportStar) || function(m, exports) {\n    for (var p in m) if (p !== \"default\" && !Object.prototype.hasOwnProperty.call(exports, p)) __createBinding(exports, m, p);\n};\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nexports.defaultHandler = void 0;\nconst is_1 = __webpack_require__(/*! @sindresorhus/is */ \"(ssr)/./node_modules/@sindresorhus/is/dist/index.js\");\nconst as_promise_1 = __webpack_require__(/*! ./as-promise */ \"(ssr)/./node_modules/swarm-js/node_modules/got/dist/source/as-promise/index.js\");\nconst create_rejection_1 = __webpack_require__(/*! ./as-promise/create-rejection */ \"(ssr)/./node_modules/swarm-js/node_modules/got/dist/source/as-promise/create-rejection.js\");\nconst core_1 = __webpack_require__(/*! ./core */ \"(ssr)/./node_modules/swarm-js/node_modules/got/dist/source/core/index.js\");\nconst deep_freeze_1 = __webpack_require__(/*! ./utils/deep-freeze */ \"(ssr)/./node_modules/swarm-js/node_modules/got/dist/source/utils/deep-freeze.js\");\nconst errors = {\n    RequestError: as_promise_1.RequestError,\n    CacheError: as_promise_1.CacheError,\n    ReadError: as_promise_1.ReadError,\n    HTTPError: as_promise_1.HTTPError,\n    MaxRedirectsError: as_promise_1.MaxRedirectsError,\n    TimeoutError: as_promise_1.TimeoutError,\n    ParseError: as_promise_1.ParseError,\n    CancelError: as_promise_1.CancelError,\n    UnsupportedProtocolError: as_promise_1.UnsupportedProtocolError,\n    UploadError: as_promise_1.UploadError\n};\n// The `delay` package weighs 10KB (!)\nconst delay = async (ms) => new Promise(resolve => {\n    setTimeout(resolve, ms);\n});\nconst { normalizeArguments } = core_1.default;\nconst mergeOptions = (...sources) => {\n    let mergedOptions;\n    for (const source of sources) {\n        mergedOptions = normalizeArguments(undefined, source, mergedOptions);\n    }\n    return mergedOptions;\n};\nconst getPromiseOrStream = (options) => options.isStream ? new core_1.default(undefined, options) : as_promise_1.default(options);\nconst isGotInstance = (value) => ('defaults' in value && 'options' in value.defaults);\nconst aliases = [\n    'get',\n    'post',\n    'put',\n    'patch',\n    'head',\n    'delete'\n];\nexports.defaultHandler = (options, next) => next(options);\nconst callInitHooks = (hooks, options) => {\n    if (hooks) {\n        for (const hook of hooks) {\n            hook(options);\n        }\n    }\n};\nconst create = (defaults) => {\n    // Proxy properties from next handlers\n    defaults._rawHandlers = defaults.handlers;\n    defaults.handlers = defaults.handlers.map(fn => ((options, next) => {\n        // This will be assigned by assigning result\n        let root;\n        const result = fn(options, newOptions => {\n            root = next(newOptions);\n            return root;\n        });\n        if (result !== root && !options.isStream && root) {\n            const typedResult = result;\n            const { then: promiseThen, catch: promiseCatch, finally: promiseFianlly } = typedResult;\n            Object.setPrototypeOf(typedResult, Object.getPrototypeOf(root));\n            Object.defineProperties(typedResult, Object.getOwnPropertyDescriptors(root));\n            // These should point to the new promise\n            // eslint-disable-next-line promise/prefer-await-to-then\n            typedResult.then = promiseThen;\n            typedResult.catch = promiseCatch;\n            typedResult.finally = promiseFianlly;\n        }\n        return result;\n    }));\n    // Got interface\n    const got = ((url, options = {}, _defaults) => {\n        var _a, _b;\n        let iteration = 0;\n        const iterateHandlers = (newOptions) => {\n            return defaults.handlers[iteration++](newOptions, iteration === defaults.handlers.length ? getPromiseOrStream : iterateHandlers);\n        };\n        // TODO: Remove this in Got 12.\n        if (is_1.default.plainObject(url)) {\n            const mergedOptions = {\n                ...url,\n                ...options\n            };\n            core_1.setNonEnumerableProperties([url, options], mergedOptions);\n            options = mergedOptions;\n            url = undefined;\n        }\n        try {\n            // Call `init` hooks\n            let initHookError;\n            try {\n                callInitHooks(defaults.options.hooks.init, options);\n                callInitHooks((_a = options.hooks) === null || _a === void 0 ? void 0 : _a.init, options);\n            }\n            catch (error) {\n                initHookError = error;\n            }\n            // Normalize options & call handlers\n            const normalizedOptions = normalizeArguments(url, options, _defaults !== null && _defaults !== void 0 ? _defaults : defaults.options);\n            normalizedOptions[core_1.kIsNormalizedAlready] = true;\n            if (initHookError) {\n                throw new as_promise_1.RequestError(initHookError.message, initHookError, normalizedOptions);\n            }\n            return iterateHandlers(normalizedOptions);\n        }\n        catch (error) {\n            if (options.isStream) {\n                throw error;\n            }\n            else {\n                return create_rejection_1.default(error, defaults.options.hooks.beforeError, (_b = options.hooks) === null || _b === void 0 ? void 0 : _b.beforeError);\n            }\n        }\n    });\n    got.extend = (...instancesOrOptions) => {\n        const optionsArray = [defaults.options];\n        let handlers = [...defaults._rawHandlers];\n        let isMutableDefaults;\n        for (const value of instancesOrOptions) {\n            if (isGotInstance(value)) {\n                optionsArray.push(value.defaults.options);\n                handlers.push(...value.defaults._rawHandlers);\n                isMutableDefaults = value.defaults.mutableDefaults;\n            }\n            else {\n                optionsArray.push(value);\n                if ('handlers' in value) {\n                    handlers.push(...value.handlers);\n                }\n                isMutableDefaults = value.mutableDefaults;\n            }\n        }\n        handlers = handlers.filter(handler => handler !== exports.defaultHandler);\n        if (handlers.length === 0) {\n            handlers.push(exports.defaultHandler);\n        }\n        return create({\n            options: mergeOptions(...optionsArray),\n            handlers,\n            mutableDefaults: Boolean(isMutableDefaults)\n        });\n    };\n    // Pagination\n    const paginateEach = (async function* (url, options) {\n        // TODO: Remove this `@ts-expect-error` when upgrading to TypeScript 4.\n        // Error: Argument of type 'Merge<Options, PaginationOptions<T, R>> | undefined' is not assignable to parameter of type 'Options | undefined'.\n        // @ts-expect-error\n        let normalizedOptions = normalizeArguments(url, options, defaults.options);\n        normalizedOptions.resolveBodyOnly = false;\n        const pagination = normalizedOptions.pagination;\n        if (!is_1.default.object(pagination)) {\n            throw new TypeError('`options.pagination` must be implemented');\n        }\n        const all = [];\n        let { countLimit } = pagination;\n        let numberOfRequests = 0;\n        while (numberOfRequests < pagination.requestLimit) {\n            if (numberOfRequests !== 0) {\n                // eslint-disable-next-line no-await-in-loop\n                await delay(pagination.backoff);\n            }\n            // @ts-expect-error FIXME!\n            // TODO: Throw when result is not an instance of Response\n            // eslint-disable-next-line no-await-in-loop\n            const result = (await got(undefined, undefined, normalizedOptions));\n            // eslint-disable-next-line no-await-in-loop\n            const parsed = await pagination.transform(result);\n            const current = [];\n            for (const item of parsed) {\n                if (pagination.filter(item, all, current)) {\n                    if (!pagination.shouldContinue(item, all, current)) {\n                        return;\n                    }\n                    yield item;\n                    if (pagination.stackAllItems) {\n                        all.push(item);\n                    }\n                    current.push(item);\n                    if (--countLimit <= 0) {\n                        return;\n                    }\n                }\n            }\n            const optionsToMerge = pagination.paginate(result, all, current);\n            if (optionsToMerge === false) {\n                return;\n            }\n            if (optionsToMerge === result.request.options) {\n                normalizedOptions = result.request.options;\n            }\n            else if (optionsToMerge !== undefined) {\n                normalizedOptions = normalizeArguments(undefined, optionsToMerge, normalizedOptions);\n            }\n            numberOfRequests++;\n        }\n    });\n    got.paginate = paginateEach;\n    got.paginate.all = (async (url, options) => {\n        const results = [];\n        for await (const item of paginateEach(url, options)) {\n            results.push(item);\n        }\n        return results;\n    });\n    // For those who like very descriptive names\n    got.paginate.each = paginateEach;\n    // Stream API\n    got.stream = ((url, options) => got(url, { ...options, isStream: true }));\n    // Shortcuts\n    for (const method of aliases) {\n        got[method] = ((url, options) => got(url, { ...options, method }));\n        got.stream[method] = ((url, options) => {\n            return got(url, { ...options, method, isStream: true });\n        });\n    }\n    Object.assign(got, errors);\n    Object.defineProperty(got, 'defaults', {\n        value: defaults.mutableDefaults ? defaults : deep_freeze_1.default(defaults),\n        writable: defaults.mutableDefaults,\n        configurable: defaults.mutableDefaults,\n        enumerable: true\n    });\n    got.mergeOptions = mergeOptions;\n    return got;\n};\nexports[\"default\"] = create;\n__exportStar(__webpack_require__(/*! ./types */ \"(ssr)/./node_modules/swarm-js/node_modules/got/dist/source/types.js\"), exports);\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvc3dhcm0tanMvbm9kZV9tb2R1bGVzL2dvdC9kaXN0L3NvdXJjZS9jcmVhdGUuanMiLCJtYXBwaW5ncyI6IkFBQWE7QUFDYjtBQUNBO0FBQ0EsbUNBQW1DLG9DQUFvQyxnQkFBZ0I7QUFDdkYsQ0FBQztBQUNEO0FBQ0E7QUFDQSxDQUFDO0FBQ0Q7QUFDQTtBQUNBO0FBQ0EsOENBQTZDLEVBQUUsYUFBYSxFQUFDO0FBQzdELHNCQUFzQjtBQUN0QixhQUFhLG1CQUFPLENBQUMsNkVBQWtCO0FBQ3ZDLHFCQUFxQixtQkFBTyxDQUFDLG9HQUFjO0FBQzNDLDJCQUEyQixtQkFBTyxDQUFDLGdJQUErQjtBQUNsRSxlQUFlLG1CQUFPLENBQUMsd0ZBQVE7QUFDL0Isc0JBQXNCLG1CQUFPLENBQUMsNEdBQXFCO0FBQ25EO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUM7QUFDRCxRQUFRLHFCQUFxQjtBQUM3QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esc0JBQXNCO0FBQ3RCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQSxvQkFBb0Isa0VBQWtFO0FBQ3RGO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBLG1DQUFtQztBQUNuQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxjQUFjLGFBQWE7QUFDM0I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0EsK0NBQStDLDRCQUE0QjtBQUMzRTtBQUNBO0FBQ0Esb0RBQW9ELG9CQUFvQjtBQUN4RTtBQUNBLDhCQUE4QixvQ0FBb0M7QUFDbEUsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBLGtCQUFlO0FBQ2YsYUFBYSxtQkFBTyxDQUFDLG9GQUFTIiwic291cmNlcyI6WyIvVXNlcnMvcGFuemEvRG9jdW1lbnRzL1BlcnNvbmFsUHJvamVjdHMvcHJlZGlrL25vZGVfbW9kdWxlcy9zd2FybS1qcy9ub2RlX21vZHVsZXMvZ290L2Rpc3Qvc291cmNlL2NyZWF0ZS5qcyJdLCJzb3VyY2VzQ29udGVudCI6WyJcInVzZSBzdHJpY3RcIjtcbnZhciBfX2NyZWF0ZUJpbmRpbmcgPSAodGhpcyAmJiB0aGlzLl9fY3JlYXRlQmluZGluZykgfHwgKE9iamVjdC5jcmVhdGUgPyAoZnVuY3Rpb24obywgbSwgaywgazIpIHtcbiAgICBpZiAoazIgPT09IHVuZGVmaW5lZCkgazIgPSBrO1xuICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShvLCBrMiwgeyBlbnVtZXJhYmxlOiB0cnVlLCBnZXQ6IGZ1bmN0aW9uKCkgeyByZXR1cm4gbVtrXTsgfSB9KTtcbn0pIDogKGZ1bmN0aW9uKG8sIG0sIGssIGsyKSB7XG4gICAgaWYgKGsyID09PSB1bmRlZmluZWQpIGsyID0gaztcbiAgICBvW2syXSA9IG1ba107XG59KSk7XG52YXIgX19leHBvcnRTdGFyID0gKHRoaXMgJiYgdGhpcy5fX2V4cG9ydFN0YXIpIHx8IGZ1bmN0aW9uKG0sIGV4cG9ydHMpIHtcbiAgICBmb3IgKHZhciBwIGluIG0pIGlmIChwICE9PSBcImRlZmF1bHRcIiAmJiAhT2JqZWN0LnByb3RvdHlwZS5oYXNPd25Qcm9wZXJ0eS5jYWxsKGV4cG9ydHMsIHApKSBfX2NyZWF0ZUJpbmRpbmcoZXhwb3J0cywgbSwgcCk7XG59O1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xuZXhwb3J0cy5kZWZhdWx0SGFuZGxlciA9IHZvaWQgMDtcbmNvbnN0IGlzXzEgPSByZXF1aXJlKFwiQHNpbmRyZXNvcmh1cy9pc1wiKTtcbmNvbnN0IGFzX3Byb21pc2VfMSA9IHJlcXVpcmUoXCIuL2FzLXByb21pc2VcIik7XG5jb25zdCBjcmVhdGVfcmVqZWN0aW9uXzEgPSByZXF1aXJlKFwiLi9hcy1wcm9taXNlL2NyZWF0ZS1yZWplY3Rpb25cIik7XG5jb25zdCBjb3JlXzEgPSByZXF1aXJlKFwiLi9jb3JlXCIpO1xuY29uc3QgZGVlcF9mcmVlemVfMSA9IHJlcXVpcmUoXCIuL3V0aWxzL2RlZXAtZnJlZXplXCIpO1xuY29uc3QgZXJyb3JzID0ge1xuICAgIFJlcXVlc3RFcnJvcjogYXNfcHJvbWlzZV8xLlJlcXVlc3RFcnJvcixcbiAgICBDYWNoZUVycm9yOiBhc19wcm9taXNlXzEuQ2FjaGVFcnJvcixcbiAgICBSZWFkRXJyb3I6IGFzX3Byb21pc2VfMS5SZWFkRXJyb3IsXG4gICAgSFRUUEVycm9yOiBhc19wcm9taXNlXzEuSFRUUEVycm9yLFxuICAgIE1heFJlZGlyZWN0c0Vycm9yOiBhc19wcm9taXNlXzEuTWF4UmVkaXJlY3RzRXJyb3IsXG4gICAgVGltZW91dEVycm9yOiBhc19wcm9taXNlXzEuVGltZW91dEVycm9yLFxuICAgIFBhcnNlRXJyb3I6IGFzX3Byb21pc2VfMS5QYXJzZUVycm9yLFxuICAgIENhbmNlbEVycm9yOiBhc19wcm9taXNlXzEuQ2FuY2VsRXJyb3IsXG4gICAgVW5zdXBwb3J0ZWRQcm90b2NvbEVycm9yOiBhc19wcm9taXNlXzEuVW5zdXBwb3J0ZWRQcm90b2NvbEVycm9yLFxuICAgIFVwbG9hZEVycm9yOiBhc19wcm9taXNlXzEuVXBsb2FkRXJyb3Jcbn07XG4vLyBUaGUgYGRlbGF5YCBwYWNrYWdlIHdlaWdocyAxMEtCICghKVxuY29uc3QgZGVsYXkgPSBhc3luYyAobXMpID0+IG5ldyBQcm9taXNlKHJlc29sdmUgPT4ge1xuICAgIHNldFRpbWVvdXQocmVzb2x2ZSwgbXMpO1xufSk7XG5jb25zdCB7IG5vcm1hbGl6ZUFyZ3VtZW50cyB9ID0gY29yZV8xLmRlZmF1bHQ7XG5jb25zdCBtZXJnZU9wdGlvbnMgPSAoLi4uc291cmNlcykgPT4ge1xuICAgIGxldCBtZXJnZWRPcHRpb25zO1xuICAgIGZvciAoY29uc3Qgc291cmNlIG9mIHNvdXJjZXMpIHtcbiAgICAgICAgbWVyZ2VkT3B0aW9ucyA9IG5vcm1hbGl6ZUFyZ3VtZW50cyh1bmRlZmluZWQsIHNvdXJjZSwgbWVyZ2VkT3B0aW9ucyk7XG4gICAgfVxuICAgIHJldHVybiBtZXJnZWRPcHRpb25zO1xufTtcbmNvbnN0IGdldFByb21pc2VPclN0cmVhbSA9IChvcHRpb25zKSA9PiBvcHRpb25zLmlzU3RyZWFtID8gbmV3IGNvcmVfMS5kZWZhdWx0KHVuZGVmaW5lZCwgb3B0aW9ucykgOiBhc19wcm9taXNlXzEuZGVmYXVsdChvcHRpb25zKTtcbmNvbnN0IGlzR290SW5zdGFuY2UgPSAodmFsdWUpID0+ICgnZGVmYXVsdHMnIGluIHZhbHVlICYmICdvcHRpb25zJyBpbiB2YWx1ZS5kZWZhdWx0cyk7XG5jb25zdCBhbGlhc2VzID0gW1xuICAgICdnZXQnLFxuICAgICdwb3N0JyxcbiAgICAncHV0JyxcbiAgICAncGF0Y2gnLFxuICAgICdoZWFkJyxcbiAgICAnZGVsZXRlJ1xuXTtcbmV4cG9ydHMuZGVmYXVsdEhhbmRsZXIgPSAob3B0aW9ucywgbmV4dCkgPT4gbmV4dChvcHRpb25zKTtcbmNvbnN0IGNhbGxJbml0SG9va3MgPSAoaG9va3MsIG9wdGlvbnMpID0+IHtcbiAgICBpZiAoaG9va3MpIHtcbiAgICAgICAgZm9yIChjb25zdCBob29rIG9mIGhvb2tzKSB7XG4gICAgICAgICAgICBob29rKG9wdGlvbnMpO1xuICAgICAgICB9XG4gICAgfVxufTtcbmNvbnN0IGNyZWF0ZSA9IChkZWZhdWx0cykgPT4ge1xuICAgIC8vIFByb3h5IHByb3BlcnRpZXMgZnJvbSBuZXh0IGhhbmRsZXJzXG4gICAgZGVmYXVsdHMuX3Jhd0hhbmRsZXJzID0gZGVmYXVsdHMuaGFuZGxlcnM7XG4gICAgZGVmYXVsdHMuaGFuZGxlcnMgPSBkZWZhdWx0cy5oYW5kbGVycy5tYXAoZm4gPT4gKChvcHRpb25zLCBuZXh0KSA9PiB7XG4gICAgICAgIC8vIFRoaXMgd2lsbCBiZSBhc3NpZ25lZCBieSBhc3NpZ25pbmcgcmVzdWx0XG4gICAgICAgIGxldCByb290O1xuICAgICAgICBjb25zdCByZXN1bHQgPSBmbihvcHRpb25zLCBuZXdPcHRpb25zID0+IHtcbiAgICAgICAgICAgIHJvb3QgPSBuZXh0KG5ld09wdGlvbnMpO1xuICAgICAgICAgICAgcmV0dXJuIHJvb3Q7XG4gICAgICAgIH0pO1xuICAgICAgICBpZiAocmVzdWx0ICE9PSByb290ICYmICFvcHRpb25zLmlzU3RyZWFtICYmIHJvb3QpIHtcbiAgICAgICAgICAgIGNvbnN0IHR5cGVkUmVzdWx0ID0gcmVzdWx0O1xuICAgICAgICAgICAgY29uc3QgeyB0aGVuOiBwcm9taXNlVGhlbiwgY2F0Y2g6IHByb21pc2VDYXRjaCwgZmluYWxseTogcHJvbWlzZUZpYW5sbHkgfSA9IHR5cGVkUmVzdWx0O1xuICAgICAgICAgICAgT2JqZWN0LnNldFByb3RvdHlwZU9mKHR5cGVkUmVzdWx0LCBPYmplY3QuZ2V0UHJvdG90eXBlT2Yocm9vdCkpO1xuICAgICAgICAgICAgT2JqZWN0LmRlZmluZVByb3BlcnRpZXModHlwZWRSZXN1bHQsIE9iamVjdC5nZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3JzKHJvb3QpKTtcbiAgICAgICAgICAgIC8vIFRoZXNlIHNob3VsZCBwb2ludCB0byB0aGUgbmV3IHByb21pc2VcbiAgICAgICAgICAgIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBwcm9taXNlL3ByZWZlci1hd2FpdC10by10aGVuXG4gICAgICAgICAgICB0eXBlZFJlc3VsdC50aGVuID0gcHJvbWlzZVRoZW47XG4gICAgICAgICAgICB0eXBlZFJlc3VsdC5jYXRjaCA9IHByb21pc2VDYXRjaDtcbiAgICAgICAgICAgIHR5cGVkUmVzdWx0LmZpbmFsbHkgPSBwcm9taXNlRmlhbmxseTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gcmVzdWx0O1xuICAgIH0pKTtcbiAgICAvLyBHb3QgaW50ZXJmYWNlXG4gICAgY29uc3QgZ290ID0gKCh1cmwsIG9wdGlvbnMgPSB7fSwgX2RlZmF1bHRzKSA9PiB7XG4gICAgICAgIHZhciBfYSwgX2I7XG4gICAgICAgIGxldCBpdGVyYXRpb24gPSAwO1xuICAgICAgICBjb25zdCBpdGVyYXRlSGFuZGxlcnMgPSAobmV3T3B0aW9ucykgPT4ge1xuICAgICAgICAgICAgcmV0dXJuIGRlZmF1bHRzLmhhbmRsZXJzW2l0ZXJhdGlvbisrXShuZXdPcHRpb25zLCBpdGVyYXRpb24gPT09IGRlZmF1bHRzLmhhbmRsZXJzLmxlbmd0aCA/IGdldFByb21pc2VPclN0cmVhbSA6IGl0ZXJhdGVIYW5kbGVycyk7XG4gICAgICAgIH07XG4gICAgICAgIC8vIFRPRE86IFJlbW92ZSB0aGlzIGluIEdvdCAxMi5cbiAgICAgICAgaWYgKGlzXzEuZGVmYXVsdC5wbGFpbk9iamVjdCh1cmwpKSB7XG4gICAgICAgICAgICBjb25zdCBtZXJnZWRPcHRpb25zID0ge1xuICAgICAgICAgICAgICAgIC4uLnVybCxcbiAgICAgICAgICAgICAgICAuLi5vcHRpb25zXG4gICAgICAgICAgICB9O1xuICAgICAgICAgICAgY29yZV8xLnNldE5vbkVudW1lcmFibGVQcm9wZXJ0aWVzKFt1cmwsIG9wdGlvbnNdLCBtZXJnZWRPcHRpb25zKTtcbiAgICAgICAgICAgIG9wdGlvbnMgPSBtZXJnZWRPcHRpb25zO1xuICAgICAgICAgICAgdXJsID0gdW5kZWZpbmVkO1xuICAgICAgICB9XG4gICAgICAgIHRyeSB7XG4gICAgICAgICAgICAvLyBDYWxsIGBpbml0YCBob29rc1xuICAgICAgICAgICAgbGV0IGluaXRIb29rRXJyb3I7XG4gICAgICAgICAgICB0cnkge1xuICAgICAgICAgICAgICAgIGNhbGxJbml0SG9va3MoZGVmYXVsdHMub3B0aW9ucy5ob29rcy5pbml0LCBvcHRpb25zKTtcbiAgICAgICAgICAgICAgICBjYWxsSW5pdEhvb2tzKChfYSA9IG9wdGlvbnMuaG9va3MpID09PSBudWxsIHx8IF9hID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfYS5pbml0LCBvcHRpb25zKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGNhdGNoIChlcnJvcikge1xuICAgICAgICAgICAgICAgIGluaXRIb29rRXJyb3IgPSBlcnJvcjtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIC8vIE5vcm1hbGl6ZSBvcHRpb25zICYgY2FsbCBoYW5kbGVyc1xuICAgICAgICAgICAgY29uc3Qgbm9ybWFsaXplZE9wdGlvbnMgPSBub3JtYWxpemVBcmd1bWVudHModXJsLCBvcHRpb25zLCBfZGVmYXVsdHMgIT09IG51bGwgJiYgX2RlZmF1bHRzICE9PSB2b2lkIDAgPyBfZGVmYXVsdHMgOiBkZWZhdWx0cy5vcHRpb25zKTtcbiAgICAgICAgICAgIG5vcm1hbGl6ZWRPcHRpb25zW2NvcmVfMS5rSXNOb3JtYWxpemVkQWxyZWFkeV0gPSB0cnVlO1xuICAgICAgICAgICAgaWYgKGluaXRIb29rRXJyb3IpIHtcbiAgICAgICAgICAgICAgICB0aHJvdyBuZXcgYXNfcHJvbWlzZV8xLlJlcXVlc3RFcnJvcihpbml0SG9va0Vycm9yLm1lc3NhZ2UsIGluaXRIb29rRXJyb3IsIG5vcm1hbGl6ZWRPcHRpb25zKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiBpdGVyYXRlSGFuZGxlcnMobm9ybWFsaXplZE9wdGlvbnMpO1xuICAgICAgICB9XG4gICAgICAgIGNhdGNoIChlcnJvcikge1xuICAgICAgICAgICAgaWYgKG9wdGlvbnMuaXNTdHJlYW0pIHtcbiAgICAgICAgICAgICAgICB0aHJvdyBlcnJvcjtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgIHJldHVybiBjcmVhdGVfcmVqZWN0aW9uXzEuZGVmYXVsdChlcnJvciwgZGVmYXVsdHMub3B0aW9ucy5ob29rcy5iZWZvcmVFcnJvciwgKF9iID0gb3B0aW9ucy5ob29rcykgPT09IG51bGwgfHwgX2IgPT09IHZvaWQgMCA/IHZvaWQgMCA6IF9iLmJlZm9yZUVycm9yKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH0pO1xuICAgIGdvdC5leHRlbmQgPSAoLi4uaW5zdGFuY2VzT3JPcHRpb25zKSA9PiB7XG4gICAgICAgIGNvbnN0IG9wdGlvbnNBcnJheSA9IFtkZWZhdWx0cy5vcHRpb25zXTtcbiAgICAgICAgbGV0IGhhbmRsZXJzID0gWy4uLmRlZmF1bHRzLl9yYXdIYW5kbGVyc107XG4gICAgICAgIGxldCBpc011dGFibGVEZWZhdWx0cztcbiAgICAgICAgZm9yIChjb25zdCB2YWx1ZSBvZiBpbnN0YW5jZXNPck9wdGlvbnMpIHtcbiAgICAgICAgICAgIGlmIChpc0dvdEluc3RhbmNlKHZhbHVlKSkge1xuICAgICAgICAgICAgICAgIG9wdGlvbnNBcnJheS5wdXNoKHZhbHVlLmRlZmF1bHRzLm9wdGlvbnMpO1xuICAgICAgICAgICAgICAgIGhhbmRsZXJzLnB1c2goLi4udmFsdWUuZGVmYXVsdHMuX3Jhd0hhbmRsZXJzKTtcbiAgICAgICAgICAgICAgICBpc011dGFibGVEZWZhdWx0cyA9IHZhbHVlLmRlZmF1bHRzLm11dGFibGVEZWZhdWx0cztcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgIG9wdGlvbnNBcnJheS5wdXNoKHZhbHVlKTtcbiAgICAgICAgICAgICAgICBpZiAoJ2hhbmRsZXJzJyBpbiB2YWx1ZSkge1xuICAgICAgICAgICAgICAgICAgICBoYW5kbGVycy5wdXNoKC4uLnZhbHVlLmhhbmRsZXJzKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgaXNNdXRhYmxlRGVmYXVsdHMgPSB2YWx1ZS5tdXRhYmxlRGVmYXVsdHM7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgaGFuZGxlcnMgPSBoYW5kbGVycy5maWx0ZXIoaGFuZGxlciA9PiBoYW5kbGVyICE9PSBleHBvcnRzLmRlZmF1bHRIYW5kbGVyKTtcbiAgICAgICAgaWYgKGhhbmRsZXJzLmxlbmd0aCA9PT0gMCkge1xuICAgICAgICAgICAgaGFuZGxlcnMucHVzaChleHBvcnRzLmRlZmF1bHRIYW5kbGVyKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gY3JlYXRlKHtcbiAgICAgICAgICAgIG9wdGlvbnM6IG1lcmdlT3B0aW9ucyguLi5vcHRpb25zQXJyYXkpLFxuICAgICAgICAgICAgaGFuZGxlcnMsXG4gICAgICAgICAgICBtdXRhYmxlRGVmYXVsdHM6IEJvb2xlYW4oaXNNdXRhYmxlRGVmYXVsdHMpXG4gICAgICAgIH0pO1xuICAgIH07XG4gICAgLy8gUGFnaW5hdGlvblxuICAgIGNvbnN0IHBhZ2luYXRlRWFjaCA9IChhc3luYyBmdW5jdGlvbiogKHVybCwgb3B0aW9ucykge1xuICAgICAgICAvLyBUT0RPOiBSZW1vdmUgdGhpcyBgQHRzLWV4cGVjdC1lcnJvcmAgd2hlbiB1cGdyYWRpbmcgdG8gVHlwZVNjcmlwdCA0LlxuICAgICAgICAvLyBFcnJvcjogQXJndW1lbnQgb2YgdHlwZSAnTWVyZ2U8T3B0aW9ucywgUGFnaW5hdGlvbk9wdGlvbnM8VCwgUj4+IHwgdW5kZWZpbmVkJyBpcyBub3QgYXNzaWduYWJsZSB0byBwYXJhbWV0ZXIgb2YgdHlwZSAnT3B0aW9ucyB8IHVuZGVmaW5lZCcuXG4gICAgICAgIC8vIEB0cy1leHBlY3QtZXJyb3JcbiAgICAgICAgbGV0IG5vcm1hbGl6ZWRPcHRpb25zID0gbm9ybWFsaXplQXJndW1lbnRzKHVybCwgb3B0aW9ucywgZGVmYXVsdHMub3B0aW9ucyk7XG4gICAgICAgIG5vcm1hbGl6ZWRPcHRpb25zLnJlc29sdmVCb2R5T25seSA9IGZhbHNlO1xuICAgICAgICBjb25zdCBwYWdpbmF0aW9uID0gbm9ybWFsaXplZE9wdGlvbnMucGFnaW5hdGlvbjtcbiAgICAgICAgaWYgKCFpc18xLmRlZmF1bHQub2JqZWN0KHBhZ2luYXRpb24pKSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgVHlwZUVycm9yKCdgb3B0aW9ucy5wYWdpbmF0aW9uYCBtdXN0IGJlIGltcGxlbWVudGVkJyk7XG4gICAgICAgIH1cbiAgICAgICAgY29uc3QgYWxsID0gW107XG4gICAgICAgIGxldCB7IGNvdW50TGltaXQgfSA9IHBhZ2luYXRpb247XG4gICAgICAgIGxldCBudW1iZXJPZlJlcXVlc3RzID0gMDtcbiAgICAgICAgd2hpbGUgKG51bWJlck9mUmVxdWVzdHMgPCBwYWdpbmF0aW9uLnJlcXVlc3RMaW1pdCkge1xuICAgICAgICAgICAgaWYgKG51bWJlck9mUmVxdWVzdHMgIT09IDApIHtcbiAgICAgICAgICAgICAgICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgbm8tYXdhaXQtaW4tbG9vcFxuICAgICAgICAgICAgICAgIGF3YWl0IGRlbGF5KHBhZ2luYXRpb24uYmFja29mZik7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICAvLyBAdHMtZXhwZWN0LWVycm9yIEZJWE1FIVxuICAgICAgICAgICAgLy8gVE9ETzogVGhyb3cgd2hlbiByZXN1bHQgaXMgbm90IGFuIGluc3RhbmNlIG9mIFJlc3BvbnNlXG4gICAgICAgICAgICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgbm8tYXdhaXQtaW4tbG9vcFxuICAgICAgICAgICAgY29uc3QgcmVzdWx0ID0gKGF3YWl0IGdvdCh1bmRlZmluZWQsIHVuZGVmaW5lZCwgbm9ybWFsaXplZE9wdGlvbnMpKTtcbiAgICAgICAgICAgIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBuby1hd2FpdC1pbi1sb29wXG4gICAgICAgICAgICBjb25zdCBwYXJzZWQgPSBhd2FpdCBwYWdpbmF0aW9uLnRyYW5zZm9ybShyZXN1bHQpO1xuICAgICAgICAgICAgY29uc3QgY3VycmVudCA9IFtdO1xuICAgICAgICAgICAgZm9yIChjb25zdCBpdGVtIG9mIHBhcnNlZCkge1xuICAgICAgICAgICAgICAgIGlmIChwYWdpbmF0aW9uLmZpbHRlcihpdGVtLCBhbGwsIGN1cnJlbnQpKSB7XG4gICAgICAgICAgICAgICAgICAgIGlmICghcGFnaW5hdGlvbi5zaG91bGRDb250aW51ZShpdGVtLCBhbGwsIGN1cnJlbnQpKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgeWllbGQgaXRlbTtcbiAgICAgICAgICAgICAgICAgICAgaWYgKHBhZ2luYXRpb24uc3RhY2tBbGxJdGVtcykge1xuICAgICAgICAgICAgICAgICAgICAgICAgYWxsLnB1c2goaXRlbSk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgY3VycmVudC5wdXNoKGl0ZW0pO1xuICAgICAgICAgICAgICAgICAgICBpZiAoLS1jb3VudExpbWl0IDw9IDApIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGNvbnN0IG9wdGlvbnNUb01lcmdlID0gcGFnaW5hdGlvbi5wYWdpbmF0ZShyZXN1bHQsIGFsbCwgY3VycmVudCk7XG4gICAgICAgICAgICBpZiAob3B0aW9uc1RvTWVyZ2UgPT09IGZhbHNlKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKG9wdGlvbnNUb01lcmdlID09PSByZXN1bHQucmVxdWVzdC5vcHRpb25zKSB7XG4gICAgICAgICAgICAgICAgbm9ybWFsaXplZE9wdGlvbnMgPSByZXN1bHQucmVxdWVzdC5vcHRpb25zO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSBpZiAob3B0aW9uc1RvTWVyZ2UgIT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgICAgIG5vcm1hbGl6ZWRPcHRpb25zID0gbm9ybWFsaXplQXJndW1lbnRzKHVuZGVmaW5lZCwgb3B0aW9uc1RvTWVyZ2UsIG5vcm1hbGl6ZWRPcHRpb25zKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIG51bWJlck9mUmVxdWVzdHMrKztcbiAgICAgICAgfVxuICAgIH0pO1xuICAgIGdvdC5wYWdpbmF0ZSA9IHBhZ2luYXRlRWFjaDtcbiAgICBnb3QucGFnaW5hdGUuYWxsID0gKGFzeW5jICh1cmwsIG9wdGlvbnMpID0+IHtcbiAgICAgICAgY29uc3QgcmVzdWx0cyA9IFtdO1xuICAgICAgICBmb3IgYXdhaXQgKGNvbnN0IGl0ZW0gb2YgcGFnaW5hdGVFYWNoKHVybCwgb3B0aW9ucykpIHtcbiAgICAgICAgICAgIHJlc3VsdHMucHVzaChpdGVtKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gcmVzdWx0cztcbiAgICB9KTtcbiAgICAvLyBGb3IgdGhvc2Ugd2hvIGxpa2UgdmVyeSBkZXNjcmlwdGl2ZSBuYW1lc1xuICAgIGdvdC5wYWdpbmF0ZS5lYWNoID0gcGFnaW5hdGVFYWNoO1xuICAgIC8vIFN0cmVhbSBBUElcbiAgICBnb3Quc3RyZWFtID0gKCh1cmwsIG9wdGlvbnMpID0+IGdvdCh1cmwsIHsgLi4ub3B0aW9ucywgaXNTdHJlYW06IHRydWUgfSkpO1xuICAgIC8vIFNob3J0Y3V0c1xuICAgIGZvciAoY29uc3QgbWV0aG9kIG9mIGFsaWFzZXMpIHtcbiAgICAgICAgZ290W21ldGhvZF0gPSAoKHVybCwgb3B0aW9ucykgPT4gZ290KHVybCwgeyAuLi5vcHRpb25zLCBtZXRob2QgfSkpO1xuICAgICAgICBnb3Quc3RyZWFtW21ldGhvZF0gPSAoKHVybCwgb3B0aW9ucykgPT4ge1xuICAgICAgICAgICAgcmV0dXJuIGdvdCh1cmwsIHsgLi4ub3B0aW9ucywgbWV0aG9kLCBpc1N0cmVhbTogdHJ1ZSB9KTtcbiAgICAgICAgfSk7XG4gICAgfVxuICAgIE9iamVjdC5hc3NpZ24oZ290LCBlcnJvcnMpO1xuICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShnb3QsICdkZWZhdWx0cycsIHtcbiAgICAgICAgdmFsdWU6IGRlZmF1bHRzLm11dGFibGVEZWZhdWx0cyA/IGRlZmF1bHRzIDogZGVlcF9mcmVlemVfMS5kZWZhdWx0KGRlZmF1bHRzKSxcbiAgICAgICAgd3JpdGFibGU6IGRlZmF1bHRzLm11dGFibGVEZWZhdWx0cyxcbiAgICAgICAgY29uZmlndXJhYmxlOiBkZWZhdWx0cy5tdXRhYmxlRGVmYXVsdHMsXG4gICAgICAgIGVudW1lcmFibGU6IHRydWVcbiAgICB9KTtcbiAgICBnb3QubWVyZ2VPcHRpb25zID0gbWVyZ2VPcHRpb25zO1xuICAgIHJldHVybiBnb3Q7XG59O1xuZXhwb3J0cy5kZWZhdWx0ID0gY3JlYXRlO1xuX19leHBvcnRTdGFyKHJlcXVpcmUoXCIuL3R5cGVzXCIpLCBleHBvcnRzKTtcbiJdLCJuYW1lcyI6W10sImlnbm9yZUxpc3QiOlswXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/swarm-js/node_modules/got/dist/source/create.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/swarm-js/node_modules/got/dist/source/index.js":
/*!*********************************************************************!*\
  !*** ./node_modules/swarm-js/node_modules/got/dist/source/index.js ***!
  \*********************************************************************/
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\nvar __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {\n    if (k2 === undefined) k2 = k;\n    Object.defineProperty(o, k2, { enumerable: true, get: function() { return m[k]; } });\n}) : (function(o, m, k, k2) {\n    if (k2 === undefined) k2 = k;\n    o[k2] = m[k];\n}));\nvar __exportStar = (this && this.__exportStar) || function(m, exports) {\n    for (var p in m) if (p !== \"default\" && !Object.prototype.hasOwnProperty.call(exports, p)) __createBinding(exports, m, p);\n};\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nconst url_1 = __webpack_require__(/*! url */ \"url\");\nconst create_1 = __webpack_require__(/*! ./create */ \"(ssr)/./node_modules/swarm-js/node_modules/got/dist/source/create.js\");\nconst defaults = {\n    options: {\n        method: 'GET',\n        retry: {\n            limit: 2,\n            methods: [\n                'GET',\n                'PUT',\n                'HEAD',\n                'DELETE',\n                'OPTIONS',\n                'TRACE'\n            ],\n            statusCodes: [\n                408,\n                413,\n                429,\n                500,\n                502,\n                503,\n                504,\n                521,\n                522,\n                524\n            ],\n            errorCodes: [\n                'ETIMEDOUT',\n                'ECONNRESET',\n                'EADDRINUSE',\n                'ECONNREFUSED',\n                'EPIPE',\n                'ENOTFOUND',\n                'ENETUNREACH',\n                'EAI_AGAIN'\n            ],\n            maxRetryAfter: undefined,\n            calculateDelay: ({ computedValue }) => computedValue\n        },\n        timeout: {},\n        headers: {\n            'user-agent': 'got (https://github.com/sindresorhus/got)'\n        },\n        hooks: {\n            init: [],\n            beforeRequest: [],\n            beforeRedirect: [],\n            beforeRetry: [],\n            beforeError: [],\n            afterResponse: []\n        },\n        cache: undefined,\n        dnsCache: undefined,\n        decompress: true,\n        throwHttpErrors: true,\n        followRedirect: true,\n        isStream: false,\n        responseType: 'text',\n        resolveBodyOnly: false,\n        maxRedirects: 10,\n        prefixUrl: '',\n        methodRewriting: true,\n        ignoreInvalidCookies: false,\n        context: {},\n        // TODO: Set this to `true` when Got 12 gets released\n        http2: false,\n        allowGetBody: false,\n        https: undefined,\n        pagination: {\n            transform: (response) => {\n                if (response.request.options.responseType === 'json') {\n                    return response.body;\n                }\n                return JSON.parse(response.body);\n            },\n            paginate: response => {\n                if (!Reflect.has(response.headers, 'link')) {\n                    return false;\n                }\n                const items = response.headers.link.split(',');\n                let next;\n                for (const item of items) {\n                    const parsed = item.split(';');\n                    if (parsed[1].includes('next')) {\n                        next = parsed[0].trimStart().trim();\n                        next = next.slice(1, -1);\n                        break;\n                    }\n                }\n                if (next) {\n                    const options = {\n                        url: new url_1.URL(next)\n                    };\n                    return options;\n                }\n                return false;\n            },\n            filter: () => true,\n            shouldContinue: () => true,\n            countLimit: Infinity,\n            backoff: 0,\n            requestLimit: 10000,\n            stackAllItems: true\n        },\n        parseJson: (text) => JSON.parse(text),\n        stringifyJson: (object) => JSON.stringify(object),\n        cacheOptions: {}\n    },\n    handlers: [create_1.defaultHandler],\n    mutableDefaults: false\n};\nconst got = create_1.default(defaults);\nexports[\"default\"] = got;\n// For CommonJS default export support\nmodule.exports = got;\nmodule.exports[\"default\"] = got;\nmodule.exports.__esModule = true; // Workaround for TS issue: https://github.com/sindresorhus/got/pull/1267\n__exportStar(__webpack_require__(/*! ./create */ \"(ssr)/./node_modules/swarm-js/node_modules/got/dist/source/create.js\"), exports);\n__exportStar(__webpack_require__(/*! ./as-promise */ \"(ssr)/./node_modules/swarm-js/node_modules/got/dist/source/as-promise/index.js\"), exports);\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvc3dhcm0tanMvbm9kZV9tb2R1bGVzL2dvdC9kaXN0L3NvdXJjZS9pbmRleC5qcyIsIm1hcHBpbmdzIjoiQUFBYTtBQUNiO0FBQ0E7QUFDQSxtQ0FBbUMsb0NBQW9DLGdCQUFnQjtBQUN2RixDQUFDO0FBQ0Q7QUFDQTtBQUNBLENBQUM7QUFDRDtBQUNBO0FBQ0E7QUFDQSw4Q0FBNkMsRUFBRSxhQUFhLEVBQUM7QUFDN0QsY0FBYyxtQkFBTyxDQUFDLGdCQUFLO0FBQzNCLGlCQUFpQixtQkFBTyxDQUFDLHNGQUFVO0FBQ25DO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLCtCQUErQixlQUFlO0FBQzlDLFNBQVM7QUFDVCxtQkFBbUI7QUFDbkI7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxtQkFBbUI7QUFDbkI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxnREFBZ0Q7QUFDaEQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBLGtCQUFlO0FBQ2Y7QUFDQTtBQUNBLHlCQUFzQjtBQUN0Qix5QkFBeUIsU0FBUztBQUNsQyxhQUFhLG1CQUFPLENBQUMsc0ZBQVU7QUFDL0IsYUFBYSxtQkFBTyxDQUFDLG9HQUFjIiwic291cmNlcyI6WyIvVXNlcnMvcGFuemEvRG9jdW1lbnRzL1BlcnNvbmFsUHJvamVjdHMvcHJlZGlrL25vZGVfbW9kdWxlcy9zd2FybS1qcy9ub2RlX21vZHVsZXMvZ290L2Rpc3Qvc291cmNlL2luZGV4LmpzIl0sInNvdXJjZXNDb250ZW50IjpbIlwidXNlIHN0cmljdFwiO1xudmFyIF9fY3JlYXRlQmluZGluZyA9ICh0aGlzICYmIHRoaXMuX19jcmVhdGVCaW5kaW5nKSB8fCAoT2JqZWN0LmNyZWF0ZSA/IChmdW5jdGlvbihvLCBtLCBrLCBrMikge1xuICAgIGlmIChrMiA9PT0gdW5kZWZpbmVkKSBrMiA9IGs7XG4gICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KG8sIGsyLCB7IGVudW1lcmFibGU6IHRydWUsIGdldDogZnVuY3Rpb24oKSB7IHJldHVybiBtW2tdOyB9IH0pO1xufSkgOiAoZnVuY3Rpb24obywgbSwgaywgazIpIHtcbiAgICBpZiAoazIgPT09IHVuZGVmaW5lZCkgazIgPSBrO1xuICAgIG9bazJdID0gbVtrXTtcbn0pKTtcbnZhciBfX2V4cG9ydFN0YXIgPSAodGhpcyAmJiB0aGlzLl9fZXhwb3J0U3RhcikgfHwgZnVuY3Rpb24obSwgZXhwb3J0cykge1xuICAgIGZvciAodmFyIHAgaW4gbSkgaWYgKHAgIT09IFwiZGVmYXVsdFwiICYmICFPYmplY3QucHJvdG90eXBlLmhhc093blByb3BlcnR5LmNhbGwoZXhwb3J0cywgcCkpIF9fY3JlYXRlQmluZGluZyhleHBvcnRzLCBtLCBwKTtcbn07XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XG5jb25zdCB1cmxfMSA9IHJlcXVpcmUoXCJ1cmxcIik7XG5jb25zdCBjcmVhdGVfMSA9IHJlcXVpcmUoXCIuL2NyZWF0ZVwiKTtcbmNvbnN0IGRlZmF1bHRzID0ge1xuICAgIG9wdGlvbnM6IHtcbiAgICAgICAgbWV0aG9kOiAnR0VUJyxcbiAgICAgICAgcmV0cnk6IHtcbiAgICAgICAgICAgIGxpbWl0OiAyLFxuICAgICAgICAgICAgbWV0aG9kczogW1xuICAgICAgICAgICAgICAgICdHRVQnLFxuICAgICAgICAgICAgICAgICdQVVQnLFxuICAgICAgICAgICAgICAgICdIRUFEJyxcbiAgICAgICAgICAgICAgICAnREVMRVRFJyxcbiAgICAgICAgICAgICAgICAnT1BUSU9OUycsXG4gICAgICAgICAgICAgICAgJ1RSQUNFJ1xuICAgICAgICAgICAgXSxcbiAgICAgICAgICAgIHN0YXR1c0NvZGVzOiBbXG4gICAgICAgICAgICAgICAgNDA4LFxuICAgICAgICAgICAgICAgIDQxMyxcbiAgICAgICAgICAgICAgICA0MjksXG4gICAgICAgICAgICAgICAgNTAwLFxuICAgICAgICAgICAgICAgIDUwMixcbiAgICAgICAgICAgICAgICA1MDMsXG4gICAgICAgICAgICAgICAgNTA0LFxuICAgICAgICAgICAgICAgIDUyMSxcbiAgICAgICAgICAgICAgICA1MjIsXG4gICAgICAgICAgICAgICAgNTI0XG4gICAgICAgICAgICBdLFxuICAgICAgICAgICAgZXJyb3JDb2RlczogW1xuICAgICAgICAgICAgICAgICdFVElNRURPVVQnLFxuICAgICAgICAgICAgICAgICdFQ09OTlJFU0VUJyxcbiAgICAgICAgICAgICAgICAnRUFERFJJTlVTRScsXG4gICAgICAgICAgICAgICAgJ0VDT05OUkVGVVNFRCcsXG4gICAgICAgICAgICAgICAgJ0VQSVBFJyxcbiAgICAgICAgICAgICAgICAnRU5PVEZPVU5EJyxcbiAgICAgICAgICAgICAgICAnRU5FVFVOUkVBQ0gnLFxuICAgICAgICAgICAgICAgICdFQUlfQUdBSU4nXG4gICAgICAgICAgICBdLFxuICAgICAgICAgICAgbWF4UmV0cnlBZnRlcjogdW5kZWZpbmVkLFxuICAgICAgICAgICAgY2FsY3VsYXRlRGVsYXk6ICh7IGNvbXB1dGVkVmFsdWUgfSkgPT4gY29tcHV0ZWRWYWx1ZVxuICAgICAgICB9LFxuICAgICAgICB0aW1lb3V0OiB7fSxcbiAgICAgICAgaGVhZGVyczoge1xuICAgICAgICAgICAgJ3VzZXItYWdlbnQnOiAnZ290IChodHRwczovL2dpdGh1Yi5jb20vc2luZHJlc29yaHVzL2dvdCknXG4gICAgICAgIH0sXG4gICAgICAgIGhvb2tzOiB7XG4gICAgICAgICAgICBpbml0OiBbXSxcbiAgICAgICAgICAgIGJlZm9yZVJlcXVlc3Q6IFtdLFxuICAgICAgICAgICAgYmVmb3JlUmVkaXJlY3Q6IFtdLFxuICAgICAgICAgICAgYmVmb3JlUmV0cnk6IFtdLFxuICAgICAgICAgICAgYmVmb3JlRXJyb3I6IFtdLFxuICAgICAgICAgICAgYWZ0ZXJSZXNwb25zZTogW11cbiAgICAgICAgfSxcbiAgICAgICAgY2FjaGU6IHVuZGVmaW5lZCxcbiAgICAgICAgZG5zQ2FjaGU6IHVuZGVmaW5lZCxcbiAgICAgICAgZGVjb21wcmVzczogdHJ1ZSxcbiAgICAgICAgdGhyb3dIdHRwRXJyb3JzOiB0cnVlLFxuICAgICAgICBmb2xsb3dSZWRpcmVjdDogdHJ1ZSxcbiAgICAgICAgaXNTdHJlYW06IGZhbHNlLFxuICAgICAgICByZXNwb25zZVR5cGU6ICd0ZXh0JyxcbiAgICAgICAgcmVzb2x2ZUJvZHlPbmx5OiBmYWxzZSxcbiAgICAgICAgbWF4UmVkaXJlY3RzOiAxMCxcbiAgICAgICAgcHJlZml4VXJsOiAnJyxcbiAgICAgICAgbWV0aG9kUmV3cml0aW5nOiB0cnVlLFxuICAgICAgICBpZ25vcmVJbnZhbGlkQ29va2llczogZmFsc2UsXG4gICAgICAgIGNvbnRleHQ6IHt9LFxuICAgICAgICAvLyBUT0RPOiBTZXQgdGhpcyB0byBgdHJ1ZWAgd2hlbiBHb3QgMTIgZ2V0cyByZWxlYXNlZFxuICAgICAgICBodHRwMjogZmFsc2UsXG4gICAgICAgIGFsbG93R2V0Qm9keTogZmFsc2UsXG4gICAgICAgIGh0dHBzOiB1bmRlZmluZWQsXG4gICAgICAgIHBhZ2luYXRpb246IHtcbiAgICAgICAgICAgIHRyYW5zZm9ybTogKHJlc3BvbnNlKSA9PiB7XG4gICAgICAgICAgICAgICAgaWYgKHJlc3BvbnNlLnJlcXVlc3Qub3B0aW9ucy5yZXNwb25zZVR5cGUgPT09ICdqc29uJykge1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gcmVzcG9uc2UuYm9keTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgcmV0dXJuIEpTT04ucGFyc2UocmVzcG9uc2UuYm9keSk7XG4gICAgICAgICAgICB9LFxuICAgICAgICAgICAgcGFnaW5hdGU6IHJlc3BvbnNlID0+IHtcbiAgICAgICAgICAgICAgICBpZiAoIVJlZmxlY3QuaGFzKHJlc3BvbnNlLmhlYWRlcnMsICdsaW5rJykpIHtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBjb25zdCBpdGVtcyA9IHJlc3BvbnNlLmhlYWRlcnMubGluay5zcGxpdCgnLCcpO1xuICAgICAgICAgICAgICAgIGxldCBuZXh0O1xuICAgICAgICAgICAgICAgIGZvciAoY29uc3QgaXRlbSBvZiBpdGVtcykge1xuICAgICAgICAgICAgICAgICAgICBjb25zdCBwYXJzZWQgPSBpdGVtLnNwbGl0KCc7Jyk7XG4gICAgICAgICAgICAgICAgICAgIGlmIChwYXJzZWRbMV0uaW5jbHVkZXMoJ25leHQnKSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgbmV4dCA9IHBhcnNlZFswXS50cmltU3RhcnQoKS50cmltKCk7XG4gICAgICAgICAgICAgICAgICAgICAgICBuZXh0ID0gbmV4dC5zbGljZSgxLCAtMSk7XG4gICAgICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBpZiAobmV4dCkge1xuICAgICAgICAgICAgICAgICAgICBjb25zdCBvcHRpb25zID0ge1xuICAgICAgICAgICAgICAgICAgICAgICAgdXJsOiBuZXcgdXJsXzEuVVJMKG5leHQpXG4gICAgICAgICAgICAgICAgICAgIH07XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBvcHRpb25zO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgICAgICB9LFxuICAgICAgICAgICAgZmlsdGVyOiAoKSA9PiB0cnVlLFxuICAgICAgICAgICAgc2hvdWxkQ29udGludWU6ICgpID0+IHRydWUsXG4gICAgICAgICAgICBjb3VudExpbWl0OiBJbmZpbml0eSxcbiAgICAgICAgICAgIGJhY2tvZmY6IDAsXG4gICAgICAgICAgICByZXF1ZXN0TGltaXQ6IDEwMDAwLFxuICAgICAgICAgICAgc3RhY2tBbGxJdGVtczogdHJ1ZVxuICAgICAgICB9LFxuICAgICAgICBwYXJzZUpzb246ICh0ZXh0KSA9PiBKU09OLnBhcnNlKHRleHQpLFxuICAgICAgICBzdHJpbmdpZnlKc29uOiAob2JqZWN0KSA9PiBKU09OLnN0cmluZ2lmeShvYmplY3QpLFxuICAgICAgICBjYWNoZU9wdGlvbnM6IHt9XG4gICAgfSxcbiAgICBoYW5kbGVyczogW2NyZWF0ZV8xLmRlZmF1bHRIYW5kbGVyXSxcbiAgICBtdXRhYmxlRGVmYXVsdHM6IGZhbHNlXG59O1xuY29uc3QgZ290ID0gY3JlYXRlXzEuZGVmYXVsdChkZWZhdWx0cyk7XG5leHBvcnRzLmRlZmF1bHQgPSBnb3Q7XG4vLyBGb3IgQ29tbW9uSlMgZGVmYXVsdCBleHBvcnQgc3VwcG9ydFxubW9kdWxlLmV4cG9ydHMgPSBnb3Q7XG5tb2R1bGUuZXhwb3J0cy5kZWZhdWx0ID0gZ290O1xubW9kdWxlLmV4cG9ydHMuX19lc01vZHVsZSA9IHRydWU7IC8vIFdvcmthcm91bmQgZm9yIFRTIGlzc3VlOiBodHRwczovL2dpdGh1Yi5jb20vc2luZHJlc29yaHVzL2dvdC9wdWxsLzEyNjdcbl9fZXhwb3J0U3RhcihyZXF1aXJlKFwiLi9jcmVhdGVcIiksIGV4cG9ydHMpO1xuX19leHBvcnRTdGFyKHJlcXVpcmUoXCIuL2FzLXByb21pc2VcIiksIGV4cG9ydHMpO1xuIl0sIm5hbWVzIjpbXSwiaWdub3JlTGlzdCI6WzBdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/swarm-js/node_modules/got/dist/source/index.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/swarm-js/node_modules/got/dist/source/types.js":
/*!*********************************************************************!*\
  !*** ./node_modules/swarm-js/node_modules/got/dist/source/types.js ***!
  \*********************************************************************/
/***/ ((__unused_webpack_module, exports) => {

"use strict";
eval("\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvc3dhcm0tanMvbm9kZV9tb2R1bGVzL2dvdC9kaXN0L3NvdXJjZS90eXBlcy5qcyIsIm1hcHBpbmdzIjoiQUFBYTtBQUNiLDhDQUE2QyxFQUFFLGFBQWEsRUFBQyIsInNvdXJjZXMiOlsiL1VzZXJzL3BhbnphL0RvY3VtZW50cy9QZXJzb25hbFByb2plY3RzL3ByZWRpay9ub2RlX21vZHVsZXMvc3dhcm0tanMvbm9kZV9tb2R1bGVzL2dvdC9kaXN0L3NvdXJjZS90eXBlcy5qcyJdLCJzb3VyY2VzQ29udGVudCI6WyJcInVzZSBzdHJpY3RcIjtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcbiJdLCJuYW1lcyI6W10sImlnbm9yZUxpc3QiOlswXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/swarm-js/node_modules/got/dist/source/types.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/swarm-js/node_modules/got/dist/source/utils/deep-freeze.js":
/*!*********************************************************************************!*\
  !*** ./node_modules/swarm-js/node_modules/got/dist/source/utils/deep-freeze.js ***!
  \*********************************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";
eval("\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nconst is_1 = __webpack_require__(/*! @sindresorhus/is */ \"(ssr)/./node_modules/@sindresorhus/is/dist/index.js\");\nfunction deepFreeze(object) {\n    for (const value of Object.values(object)) {\n        if (is_1.default.plainObject(value) || is_1.default.array(value)) {\n            deepFreeze(value);\n        }\n    }\n    return Object.freeze(object);\n}\nexports[\"default\"] = deepFreeze;\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvc3dhcm0tanMvbm9kZV9tb2R1bGVzL2dvdC9kaXN0L3NvdXJjZS91dGlscy9kZWVwLWZyZWV6ZS5qcyIsIm1hcHBpbmdzIjoiQUFBYTtBQUNiLDhDQUE2QyxFQUFFLGFBQWEsRUFBQztBQUM3RCxhQUFhLG1CQUFPLENBQUMsNkVBQWtCO0FBQ3ZDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxrQkFBZSIsInNvdXJjZXMiOlsiL1VzZXJzL3BhbnphL0RvY3VtZW50cy9QZXJzb25hbFByb2plY3RzL3ByZWRpay9ub2RlX21vZHVsZXMvc3dhcm0tanMvbm9kZV9tb2R1bGVzL2dvdC9kaXN0L3NvdXJjZS91dGlscy9kZWVwLWZyZWV6ZS5qcyJdLCJzb3VyY2VzQ29udGVudCI6WyJcInVzZSBzdHJpY3RcIjtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcbmNvbnN0IGlzXzEgPSByZXF1aXJlKFwiQHNpbmRyZXNvcmh1cy9pc1wiKTtcbmZ1bmN0aW9uIGRlZXBGcmVlemUob2JqZWN0KSB7XG4gICAgZm9yIChjb25zdCB2YWx1ZSBvZiBPYmplY3QudmFsdWVzKG9iamVjdCkpIHtcbiAgICAgICAgaWYgKGlzXzEuZGVmYXVsdC5wbGFpbk9iamVjdCh2YWx1ZSkgfHwgaXNfMS5kZWZhdWx0LmFycmF5KHZhbHVlKSkge1xuICAgICAgICAgICAgZGVlcEZyZWV6ZSh2YWx1ZSk7XG4gICAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIE9iamVjdC5mcmVlemUob2JqZWN0KTtcbn1cbmV4cG9ydHMuZGVmYXVsdCA9IGRlZXBGcmVlemU7XG4iXSwibmFtZXMiOltdLCJpZ25vcmVMaXN0IjpbMF0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/swarm-js/node_modules/got/dist/source/utils/deep-freeze.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/swarm-js/node_modules/got/dist/source/utils/deprecation-warning.js":
/*!*****************************************************************************************!*\
  !*** ./node_modules/swarm-js/node_modules/got/dist/source/utils/deprecation-warning.js ***!
  \*****************************************************************************************/
/***/ ((__unused_webpack_module, exports) => {

"use strict";
eval("\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nconst alreadyWarned = new Set();\nexports[\"default\"] = (message) => {\n    if (alreadyWarned.has(message)) {\n        return;\n    }\n    alreadyWarned.add(message);\n    // @ts-expect-error Missing types.\n    process.emitWarning(`Got: ${message}`, {\n        type: 'DeprecationWarning'\n    });\n};\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvc3dhcm0tanMvbm9kZV9tb2R1bGVzL2dvdC9kaXN0L3NvdXJjZS91dGlscy9kZXByZWNhdGlvbi13YXJuaW5nLmpzIiwibWFwcGluZ3MiOiJBQUFhO0FBQ2IsOENBQTZDLEVBQUUsYUFBYSxFQUFDO0FBQzdEO0FBQ0Esa0JBQWU7QUFDZjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZ0NBQWdDLFFBQVE7QUFDeEM7QUFDQSxLQUFLO0FBQ0wiLCJzb3VyY2VzIjpbIi9Vc2Vycy9wYW56YS9Eb2N1bWVudHMvUGVyc29uYWxQcm9qZWN0cy9wcmVkaWsvbm9kZV9tb2R1bGVzL3N3YXJtLWpzL25vZGVfbW9kdWxlcy9nb3QvZGlzdC9zb3VyY2UvdXRpbHMvZGVwcmVjYXRpb24td2FybmluZy5qcyJdLCJzb3VyY2VzQ29udGVudCI6WyJcInVzZSBzdHJpY3RcIjtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcbmNvbnN0IGFscmVhZHlXYXJuZWQgPSBuZXcgU2V0KCk7XG5leHBvcnRzLmRlZmF1bHQgPSAobWVzc2FnZSkgPT4ge1xuICAgIGlmIChhbHJlYWR5V2FybmVkLmhhcyhtZXNzYWdlKSkge1xuICAgICAgICByZXR1cm47XG4gICAgfVxuICAgIGFscmVhZHlXYXJuZWQuYWRkKG1lc3NhZ2UpO1xuICAgIC8vIEB0cy1leHBlY3QtZXJyb3IgTWlzc2luZyB0eXBlcy5cbiAgICBwcm9jZXNzLmVtaXRXYXJuaW5nKGBHb3Q6ICR7bWVzc2FnZX1gLCB7XG4gICAgICAgIHR5cGU6ICdEZXByZWNhdGlvbldhcm5pbmcnXG4gICAgfSk7XG59O1xuIl0sIm5hbWVzIjpbXSwiaWdub3JlTGlzdCI6WzBdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/swarm-js/node_modules/got/dist/source/utils/deprecation-warning.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/swarm-js/node_modules/http2-wrapper/source/agent.js":
/*!**************************************************************************!*\
  !*** ./node_modules/swarm-js/node_modules/http2-wrapper/source/agent.js ***!
  \**************************************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";
eval("\nconst EventEmitter = __webpack_require__(/*! events */ \"events\");\nconst tls = __webpack_require__(/*! tls */ \"tls\");\nconst http2 = __webpack_require__(/*! http2 */ \"http2\");\nconst QuickLRU = __webpack_require__(/*! quick-lru */ \"(ssr)/./node_modules/quick-lru/index.js\");\n\nconst kCurrentStreamsCount = Symbol('currentStreamsCount');\nconst kRequest = Symbol('request');\nconst kOriginSet = Symbol('cachedOriginSet');\nconst kGracefullyClosing = Symbol('gracefullyClosing');\n\nconst nameKeys = [\n\t// `http2.connect()` options\n\t'maxDeflateDynamicTableSize',\n\t'maxSessionMemory',\n\t'maxHeaderListPairs',\n\t'maxOutstandingPings',\n\t'maxReservedRemoteStreams',\n\t'maxSendHeaderBlockLength',\n\t'paddingStrategy',\n\n\t// `tls.connect()` options\n\t'localAddress',\n\t'path',\n\t'rejectUnauthorized',\n\t'minDHSize',\n\n\t// `tls.createSecureContext()` options\n\t'ca',\n\t'cert',\n\t'clientCertEngine',\n\t'ciphers',\n\t'key',\n\t'pfx',\n\t'servername',\n\t'minVersion',\n\t'maxVersion',\n\t'secureProtocol',\n\t'crl',\n\t'honorCipherOrder',\n\t'ecdhCurve',\n\t'dhparam',\n\t'secureOptions',\n\t'sessionIdContext'\n];\n\nconst getSortedIndex = (array, value, compare) => {\n\tlet low = 0;\n\tlet high = array.length;\n\n\twhile (low < high) {\n\t\tconst mid = (low + high) >>> 1;\n\n\t\t/* istanbul ignore next */\n\t\tif (compare(array[mid], value)) {\n\t\t\t// This never gets called because we use descending sort. Better to have this anyway.\n\t\t\tlow = mid + 1;\n\t\t} else {\n\t\t\thigh = mid;\n\t\t}\n\t}\n\n\treturn low;\n};\n\nconst compareSessions = (a, b) => {\n\treturn a.remoteSettings.maxConcurrentStreams > b.remoteSettings.maxConcurrentStreams;\n};\n\n// See https://tools.ietf.org/html/rfc8336\nconst closeCoveredSessions = (where, session) => {\n\t// Clients SHOULD NOT emit new requests on any connection whose Origin\n\t// Set is a proper subset of another connection's Origin Set, and they\n\t// SHOULD close it once all outstanding requests are satisfied.\n\tfor (const coveredSession of where) {\n\t\tif (\n\t\t\t// The set is a proper subset when its length is less than the other set.\n\t\t\tcoveredSession[kOriginSet].length < session[kOriginSet].length &&\n\n\t\t\t// And the other set includes all elements of the subset.\n\t\t\tcoveredSession[kOriginSet].every(origin => session[kOriginSet].includes(origin)) &&\n\n\t\t\t// Makes sure that the session can handle all requests from the covered session.\n\t\t\tcoveredSession[kCurrentStreamsCount] + session[kCurrentStreamsCount] <= session.remoteSettings.maxConcurrentStreams\n\t\t) {\n\t\t\t// This allows pending requests to finish and prevents making new requests.\n\t\t\tgracefullyClose(coveredSession);\n\t\t}\n\t}\n};\n\n// This is basically inverted `closeCoveredSessions(...)`.\nconst closeSessionIfCovered = (where, coveredSession) => {\n\tfor (const session of where) {\n\t\tif (\n\t\t\tcoveredSession[kOriginSet].length < session[kOriginSet].length &&\n\t\t\tcoveredSession[kOriginSet].every(origin => session[kOriginSet].includes(origin)) &&\n\t\t\tcoveredSession[kCurrentStreamsCount] + session[kCurrentStreamsCount] <= session.remoteSettings.maxConcurrentStreams\n\t\t) {\n\t\t\tgracefullyClose(coveredSession);\n\t\t}\n\t}\n};\n\nconst getSessions = ({agent, isFree}) => {\n\tconst result = {};\n\n\t// eslint-disable-next-line guard-for-in\n\tfor (const normalizedOptions in agent.sessions) {\n\t\tconst sessions = agent.sessions[normalizedOptions];\n\n\t\tconst filtered = sessions.filter(session => {\n\t\t\tconst result = session[Agent.kCurrentStreamsCount] < session.remoteSettings.maxConcurrentStreams;\n\n\t\t\treturn isFree ? result : !result;\n\t\t});\n\n\t\tif (filtered.length !== 0) {\n\t\t\tresult[normalizedOptions] = filtered;\n\t\t}\n\t}\n\n\treturn result;\n};\n\nconst gracefullyClose = session => {\n\tsession[kGracefullyClosing] = true;\n\n\tif (session[kCurrentStreamsCount] === 0) {\n\t\tsession.close();\n\t}\n};\n\nclass Agent extends EventEmitter {\n\tconstructor({timeout = 60000, maxSessions = Infinity, maxFreeSessions = 10, maxCachedTlsSessions = 100} = {}) {\n\t\tsuper();\n\n\t\t// A session is considered busy when its current streams count\n\t\t// is equal to or greater than the `maxConcurrentStreams` value.\n\n\t\t// A session is considered free when its current streams count\n\t\t// is less than the `maxConcurrentStreams` value.\n\n\t\t// SESSIONS[NORMALIZED_OPTIONS] = [];\n\t\tthis.sessions = {};\n\n\t\t// The queue for creating new sessions. It looks like this:\n\t\t// QUEUE[NORMALIZED_OPTIONS][NORMALIZED_ORIGIN] = ENTRY_FUNCTION\n\t\t//\n\t\t// The entry function has `listeners`, `completed` and `destroyed` properties.\n\t\t// `listeners` is an array of objects containing `resolve` and `reject` functions.\n\t\t// `completed` is a boolean. It's set to true after ENTRY_FUNCTION is executed.\n\t\t// `destroyed` is a boolean. If it's set to true, the session will be destroyed if hasn't connected yet.\n\t\tthis.queue = {};\n\n\t\t// Each session will use this timeout value.\n\t\tthis.timeout = timeout;\n\n\t\t// Max sessions in total\n\t\tthis.maxSessions = maxSessions;\n\n\t\t// Max free sessions in total\n\t\t// TODO: decreasing `maxFreeSessions` should close some sessions\n\t\tthis.maxFreeSessions = maxFreeSessions;\n\n\t\tthis._freeSessionsCount = 0;\n\t\tthis._sessionsCount = 0;\n\n\t\t// We don't support push streams by default.\n\t\tthis.settings = {\n\t\t\tenablePush: false\n\t\t};\n\n\t\t// Reusing TLS sessions increases performance.\n\t\tthis.tlsSessionCache = new QuickLRU({maxSize: maxCachedTlsSessions});\n\t}\n\n\tstatic normalizeOrigin(url, servername) {\n\t\tif (typeof url === 'string') {\n\t\t\turl = new URL(url);\n\t\t}\n\n\t\tif (servername && url.hostname !== servername) {\n\t\t\turl.hostname = servername;\n\t\t}\n\n\t\treturn url.origin;\n\t}\n\n\tnormalizeOptions(options) {\n\t\tlet normalized = '';\n\n\t\tif (options) {\n\t\t\tfor (const key of nameKeys) {\n\t\t\t\tif (options[key]) {\n\t\t\t\t\tnormalized += `:${options[key]}`;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\treturn normalized;\n\t}\n\n\t_tryToCreateNewSession(normalizedOptions, normalizedOrigin) {\n\t\tif (!(normalizedOptions in this.queue) || !(normalizedOrigin in this.queue[normalizedOptions])) {\n\t\t\treturn;\n\t\t}\n\n\t\tconst item = this.queue[normalizedOptions][normalizedOrigin];\n\n\t\t// The entry function can be run only once.\n\t\t// BUG: The session may be never created when:\n\t\t// - the first condition is false AND\n\t\t// - this function is never called with the same arguments in the future.\n\t\tif (this._sessionsCount < this.maxSessions && !item.completed) {\n\t\t\titem.completed = true;\n\n\t\t\titem();\n\t\t}\n\t}\n\n\tgetSession(origin, options, listeners) {\n\t\treturn new Promise((resolve, reject) => {\n\t\t\tif (Array.isArray(listeners)) {\n\t\t\t\tlisteners = [...listeners];\n\n\t\t\t\t// Resolve the current promise ASAP, we're just moving the listeners.\n\t\t\t\t// They will be executed at a different time.\n\t\t\t\tresolve();\n\t\t\t} else {\n\t\t\t\tlisteners = [{resolve, reject}];\n\t\t\t}\n\n\t\t\tconst normalizedOptions = this.normalizeOptions(options);\n\t\t\tconst normalizedOrigin = Agent.normalizeOrigin(origin, options && options.servername);\n\n\t\t\tif (normalizedOrigin === undefined) {\n\t\t\t\tfor (const {reject} of listeners) {\n\t\t\t\t\treject(new TypeError('The `origin` argument needs to be a string or an URL object'));\n\t\t\t\t}\n\n\t\t\t\treturn;\n\t\t\t}\n\n\t\t\tif (normalizedOptions in this.sessions) {\n\t\t\t\tconst sessions = this.sessions[normalizedOptions];\n\n\t\t\t\tlet maxConcurrentStreams = -1;\n\t\t\t\tlet currentStreamsCount = -1;\n\t\t\t\tlet optimalSession;\n\n\t\t\t\t// We could just do this.sessions[normalizedOptions].find(...) but that isn't optimal.\n\t\t\t\t// Additionally, we are looking for session which has biggest current pending streams count.\n\t\t\t\tfor (const session of sessions) {\n\t\t\t\t\tconst sessionMaxConcurrentStreams = session.remoteSettings.maxConcurrentStreams;\n\n\t\t\t\t\tif (sessionMaxConcurrentStreams < maxConcurrentStreams) {\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\n\t\t\t\t\tif (session[kOriginSet].includes(normalizedOrigin)) {\n\t\t\t\t\t\tconst sessionCurrentStreamsCount = session[kCurrentStreamsCount];\n\n\t\t\t\t\t\tif (\n\t\t\t\t\t\t\tsessionCurrentStreamsCount >= sessionMaxConcurrentStreams ||\n\t\t\t\t\t\t\tsession[kGracefullyClosing] ||\n\t\t\t\t\t\t\t// Unfortunately the `close` event isn't called immediately,\n\t\t\t\t\t\t\t// so `session.destroyed` is `true`, but `session.closed` is `false`.\n\t\t\t\t\t\t\tsession.destroyed\n\t\t\t\t\t\t) {\n\t\t\t\t\t\t\tcontinue;\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\t// We only need set this once.\n\t\t\t\t\t\tif (!optimalSession) {\n\t\t\t\t\t\t\tmaxConcurrentStreams = sessionMaxConcurrentStreams;\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\t// We're looking for the session which has biggest current pending stream count,\n\t\t\t\t\t\t// in order to minimalize the amount of active sessions.\n\t\t\t\t\t\tif (sessionCurrentStreamsCount > currentStreamsCount) {\n\t\t\t\t\t\t\toptimalSession = session;\n\t\t\t\t\t\t\tcurrentStreamsCount = sessionCurrentStreamsCount;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\n\t\t\t\tif (optimalSession) {\n\t\t\t\t\t/* istanbul ignore next: safety check */\n\t\t\t\t\tif (listeners.length !== 1) {\n\t\t\t\t\t\tfor (const {reject} of listeners) {\n\t\t\t\t\t\t\tconst error = new Error(\n\t\t\t\t\t\t\t\t`Expected the length of listeners to be 1, got ${listeners.length}.\\n` +\n\t\t\t\t\t\t\t\t'Please report this to https://github.com/szmarczak/http2-wrapper/'\n\t\t\t\t\t\t\t);\n\n\t\t\t\t\t\t\treject(error);\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\treturn;\n\t\t\t\t\t}\n\n\t\t\t\t\tlisteners[0].resolve(optimalSession);\n\t\t\t\t\treturn;\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tif (normalizedOptions in this.queue) {\n\t\t\t\tif (normalizedOrigin in this.queue[normalizedOptions]) {\n\t\t\t\t\t// There's already an item in the queue, just attach ourselves to it.\n\t\t\t\t\tthis.queue[normalizedOptions][normalizedOrigin].listeners.push(...listeners);\n\n\t\t\t\t\t// This shouldn't be executed here.\n\t\t\t\t\t// See the comment inside _tryToCreateNewSession.\n\t\t\t\t\tthis._tryToCreateNewSession(normalizedOptions, normalizedOrigin);\n\t\t\t\t\treturn;\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\tthis.queue[normalizedOptions] = {};\n\t\t\t}\n\n\t\t\t// The entry must be removed from the queue IMMEDIATELY when:\n\t\t\t// 1. the session connects successfully,\n\t\t\t// 2. an error occurs.\n\t\t\tconst removeFromQueue = () => {\n\t\t\t\t// Our entry can be replaced. We cannot remove the new one.\n\t\t\t\tif (normalizedOptions in this.queue && this.queue[normalizedOptions][normalizedOrigin] === entry) {\n\t\t\t\t\tdelete this.queue[normalizedOptions][normalizedOrigin];\n\n\t\t\t\t\tif (Object.keys(this.queue[normalizedOptions]).length === 0) {\n\t\t\t\t\t\tdelete this.queue[normalizedOptions];\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t};\n\n\t\t\t// The main logic is here\n\t\t\tconst entry = () => {\n\t\t\t\tconst name = `${normalizedOrigin}:${normalizedOptions}`;\n\t\t\t\tlet receivedSettings = false;\n\n\t\t\t\ttry {\n\t\t\t\t\tconst session = http2.connect(origin, {\n\t\t\t\t\t\tcreateConnection: this.createConnection,\n\t\t\t\t\t\tsettings: this.settings,\n\t\t\t\t\t\tsession: this.tlsSessionCache.get(name),\n\t\t\t\t\t\t...options\n\t\t\t\t\t});\n\t\t\t\t\tsession[kCurrentStreamsCount] = 0;\n\t\t\t\t\tsession[kGracefullyClosing] = false;\n\n\t\t\t\t\tconst isFree = () => session[kCurrentStreamsCount] < session.remoteSettings.maxConcurrentStreams;\n\t\t\t\t\tlet wasFree = true;\n\n\t\t\t\t\tsession.socket.once('session', tlsSession => {\n\t\t\t\t\t\tthis.tlsSessionCache.set(name, tlsSession);\n\t\t\t\t\t});\n\n\t\t\t\t\tsession.once('error', error => {\n\t\t\t\t\t\t// Listeners are empty when the session successfully connected.\n\t\t\t\t\t\tfor (const {reject} of listeners) {\n\t\t\t\t\t\t\treject(error);\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\t// The connection got broken, purge the cache.\n\t\t\t\t\t\tthis.tlsSessionCache.delete(name);\n\t\t\t\t\t});\n\n\t\t\t\t\tsession.setTimeout(this.timeout, () => {\n\t\t\t\t\t\t// Terminates all streams owned by this session.\n\t\t\t\t\t\t// TODO: Maybe the streams should have a \"Session timed out\" error?\n\t\t\t\t\t\tsession.destroy();\n\t\t\t\t\t});\n\n\t\t\t\t\tsession.once('close', () => {\n\t\t\t\t\t\tif (receivedSettings) {\n\t\t\t\t\t\t\t// 1. If it wasn't free then no need to decrease because\n\t\t\t\t\t\t\t//    it has been decreased already in session.request().\n\t\t\t\t\t\t\t// 2. `stream.once('close')` won't increment the count\n\t\t\t\t\t\t\t//    because the session is already closed.\n\t\t\t\t\t\t\tif (wasFree) {\n\t\t\t\t\t\t\t\tthis._freeSessionsCount--;\n\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t\tthis._sessionsCount--;\n\n\t\t\t\t\t\t\t// This cannot be moved to the stream logic,\n\t\t\t\t\t\t\t// because there may be a session that hadn't made a single request.\n\t\t\t\t\t\t\tconst where = this.sessions[normalizedOptions];\n\t\t\t\t\t\t\twhere.splice(where.indexOf(session), 1);\n\n\t\t\t\t\t\t\tif (where.length === 0) {\n\t\t\t\t\t\t\t\tdelete this.sessions[normalizedOptions];\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\t// Broken connection\n\t\t\t\t\t\t\tconst error = new Error('Session closed without receiving a SETTINGS frame');\n\t\t\t\t\t\t\terror.code = 'HTTP2WRAPPER_NOSETTINGS';\n\n\t\t\t\t\t\t\tfor (const {reject} of listeners) {\n\t\t\t\t\t\t\t\treject(error);\n\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t\tremoveFromQueue();\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\t// There may be another session awaiting.\n\t\t\t\t\t\tthis._tryToCreateNewSession(normalizedOptions, normalizedOrigin);\n\t\t\t\t\t});\n\n\t\t\t\t\t// Iterates over the queue and processes listeners.\n\t\t\t\t\tconst processListeners = () => {\n\t\t\t\t\t\tif (!(normalizedOptions in this.queue) || !isFree()) {\n\t\t\t\t\t\t\treturn;\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\tfor (const origin of session[kOriginSet]) {\n\t\t\t\t\t\t\tif (origin in this.queue[normalizedOptions]) {\n\t\t\t\t\t\t\t\tconst {listeners} = this.queue[normalizedOptions][origin];\n\n\t\t\t\t\t\t\t\t// Prevents session overloading.\n\t\t\t\t\t\t\t\twhile (listeners.length !== 0 && isFree()) {\n\t\t\t\t\t\t\t\t\t// We assume `resolve(...)` calls `request(...)` *directly*,\n\t\t\t\t\t\t\t\t\t// otherwise the session will get overloaded.\n\t\t\t\t\t\t\t\t\tlisteners.shift().resolve(session);\n\t\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t\t\tconst where = this.queue[normalizedOptions];\n\t\t\t\t\t\t\t\tif (where[origin].listeners.length === 0) {\n\t\t\t\t\t\t\t\t\tdelete where[origin];\n\n\t\t\t\t\t\t\t\t\tif (Object.keys(where).length === 0) {\n\t\t\t\t\t\t\t\t\t\tdelete this.queue[normalizedOptions];\n\t\t\t\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t\t\t// We're no longer free, no point in continuing.\n\t\t\t\t\t\t\t\tif (!isFree()) {\n\t\t\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t};\n\n\t\t\t\t\t// The Origin Set cannot shrink. No need to check if it suddenly became covered by another one.\n\t\t\t\t\tsession.on('origin', () => {\n\t\t\t\t\t\tsession[kOriginSet] = session.originSet;\n\n\t\t\t\t\t\tif (!isFree()) {\n\t\t\t\t\t\t\t// The session is full.\n\t\t\t\t\t\t\treturn;\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\tprocessListeners();\n\n\t\t\t\t\t\t// Close covered sessions (if possible).\n\t\t\t\t\t\tcloseCoveredSessions(this.sessions[normalizedOptions], session);\n\t\t\t\t\t});\n\n\t\t\t\t\tsession.once('remoteSettings', () => {\n\t\t\t\t\t\t// Fix Node.js bug preventing the process from exiting\n\t\t\t\t\t\tsession.ref();\n\t\t\t\t\t\tsession.unref();\n\n\t\t\t\t\t\tthis._sessionsCount++;\n\n\t\t\t\t\t\t// The Agent could have been destroyed already.\n\t\t\t\t\t\tif (entry.destroyed) {\n\t\t\t\t\t\t\tconst error = new Error('Agent has been destroyed');\n\n\t\t\t\t\t\t\tfor (const listener of listeners) {\n\t\t\t\t\t\t\t\tlistener.reject(error);\n\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t\tsession.destroy();\n\t\t\t\t\t\t\treturn;\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\tsession[kOriginSet] = session.originSet;\n\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\tconst where = this.sessions;\n\n\t\t\t\t\t\t\tif (normalizedOptions in where) {\n\t\t\t\t\t\t\t\tconst sessions = where[normalizedOptions];\n\t\t\t\t\t\t\t\tsessions.splice(getSortedIndex(sessions, session, compareSessions), 0, session);\n\t\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\t\twhere[normalizedOptions] = [session];\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\tthis._freeSessionsCount += 1;\n\t\t\t\t\t\treceivedSettings = true;\n\n\t\t\t\t\t\tthis.emit('session', session);\n\n\t\t\t\t\t\tprocessListeners();\n\t\t\t\t\t\tremoveFromQueue();\n\n\t\t\t\t\t\t// TODO: Close last recently used (or least used?) session\n\t\t\t\t\t\tif (session[kCurrentStreamsCount] === 0 && this._freeSessionsCount > this.maxFreeSessions) {\n\t\t\t\t\t\t\tsession.close();\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\t// Check if we haven't managed to execute all listeners.\n\t\t\t\t\t\tif (listeners.length !== 0) {\n\t\t\t\t\t\t\t// Request for a new session with predefined listeners.\n\t\t\t\t\t\t\tthis.getSession(normalizedOrigin, options, listeners);\n\t\t\t\t\t\t\tlisteners.length = 0;\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\t// `session.remoteSettings.maxConcurrentStreams` might get increased\n\t\t\t\t\t\tsession.on('remoteSettings', () => {\n\t\t\t\t\t\t\tprocessListeners();\n\n\t\t\t\t\t\t\t// In case the Origin Set changes\n\t\t\t\t\t\t\tcloseCoveredSessions(this.sessions[normalizedOptions], session);\n\t\t\t\t\t\t});\n\t\t\t\t\t});\n\n\t\t\t\t\t// Shim `session.request()` in order to catch all streams\n\t\t\t\t\tsession[kRequest] = session.request;\n\t\t\t\t\tsession.request = (headers, streamOptions) => {\n\t\t\t\t\t\tif (session[kGracefullyClosing]) {\n\t\t\t\t\t\t\tthrow new Error('The session is gracefully closing. No new streams are allowed.');\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\tconst stream = session[kRequest](headers, streamOptions);\n\n\t\t\t\t\t\t// The process won't exit until the session is closed or all requests are gone.\n\t\t\t\t\t\tsession.ref();\n\n\t\t\t\t\t\t++session[kCurrentStreamsCount];\n\n\t\t\t\t\t\tif (session[kCurrentStreamsCount] === session.remoteSettings.maxConcurrentStreams) {\n\t\t\t\t\t\t\tthis._freeSessionsCount--;\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\tstream.once('close', () => {\n\t\t\t\t\t\t\twasFree = isFree();\n\n\t\t\t\t\t\t\t--session[kCurrentStreamsCount];\n\n\t\t\t\t\t\t\tif (!session.destroyed && !session.closed) {\n\t\t\t\t\t\t\t\tcloseSessionIfCovered(this.sessions[normalizedOptions], session);\n\n\t\t\t\t\t\t\t\tif (isFree() && !session.closed) {\n\t\t\t\t\t\t\t\t\tif (!wasFree) {\n\t\t\t\t\t\t\t\t\t\tthis._freeSessionsCount++;\n\n\t\t\t\t\t\t\t\t\t\twasFree = true;\n\t\t\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t\t\t\tconst isEmpty = session[kCurrentStreamsCount] === 0;\n\n\t\t\t\t\t\t\t\t\tif (isEmpty) {\n\t\t\t\t\t\t\t\t\t\tsession.unref();\n\t\t\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t\t\t\tif (\n\t\t\t\t\t\t\t\t\t\tisEmpty &&\n\t\t\t\t\t\t\t\t\t\t(\n\t\t\t\t\t\t\t\t\t\t\tthis._freeSessionsCount > this.maxFreeSessions ||\n\t\t\t\t\t\t\t\t\t\t\tsession[kGracefullyClosing]\n\t\t\t\t\t\t\t\t\t\t)\n\t\t\t\t\t\t\t\t\t) {\n\t\t\t\t\t\t\t\t\t\tsession.close();\n\t\t\t\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\t\t\t\tcloseCoveredSessions(this.sessions[normalizedOptions], session);\n\t\t\t\t\t\t\t\t\t\tprocessListeners();\n\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t});\n\n\t\t\t\t\t\treturn stream;\n\t\t\t\t\t};\n\t\t\t\t} catch (error) {\n\t\t\t\t\tfor (const listener of listeners) {\n\t\t\t\t\t\tlistener.reject(error);\n\t\t\t\t\t}\n\n\t\t\t\t\tremoveFromQueue();\n\t\t\t\t}\n\t\t\t};\n\n\t\t\tentry.listeners = listeners;\n\t\t\tentry.completed = false;\n\t\t\tentry.destroyed = false;\n\n\t\t\tthis.queue[normalizedOptions][normalizedOrigin] = entry;\n\t\t\tthis._tryToCreateNewSession(normalizedOptions, normalizedOrigin);\n\t\t});\n\t}\n\n\trequest(origin, options, headers, streamOptions) {\n\t\treturn new Promise((resolve, reject) => {\n\t\t\tthis.getSession(origin, options, [{\n\t\t\t\treject,\n\t\t\t\tresolve: session => {\n\t\t\t\t\ttry {\n\t\t\t\t\t\tresolve(session.request(headers, streamOptions));\n\t\t\t\t\t} catch (error) {\n\t\t\t\t\t\treject(error);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}]);\n\t\t});\n\t}\n\n\tcreateConnection(origin, options) {\n\t\treturn Agent.connect(origin, options);\n\t}\n\n\tstatic connect(origin, options) {\n\t\toptions.ALPNProtocols = ['h2'];\n\n\t\tconst port = origin.port || 443;\n\t\tconst host = origin.hostname || origin.host;\n\n\t\tif (typeof options.servername === 'undefined') {\n\t\t\toptions.servername = host;\n\t\t}\n\n\t\treturn tls.connect(port, host, options);\n\t}\n\n\tcloseFreeSessions() {\n\t\tfor (const sessions of Object.values(this.sessions)) {\n\t\t\tfor (const session of sessions) {\n\t\t\t\tif (session[kCurrentStreamsCount] === 0) {\n\t\t\t\t\tsession.close();\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\n\tdestroy(reason) {\n\t\tfor (const sessions of Object.values(this.sessions)) {\n\t\t\tfor (const session of sessions) {\n\t\t\t\tsession.destroy(reason);\n\t\t\t}\n\t\t}\n\n\t\tfor (const entriesOfAuthority of Object.values(this.queue)) {\n\t\t\tfor (const entry of Object.values(entriesOfAuthority)) {\n\t\t\t\tentry.destroyed = true;\n\t\t\t}\n\t\t}\n\n\t\t// New requests should NOT attach to destroyed sessions\n\t\tthis.queue = {};\n\t}\n\n\tget freeSessions() {\n\t\treturn getSessions({agent: this, isFree: true});\n\t}\n\n\tget busySessions() {\n\t\treturn getSessions({agent: this, isFree: false});\n\t}\n}\n\nAgent.kCurrentStreamsCount = kCurrentStreamsCount;\nAgent.kGracefullyClosing = kGracefullyClosing;\n\nmodule.exports = {\n\tAgent,\n\tglobalAgent: new Agent()\n};\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvc3dhcm0tanMvbm9kZV9tb2R1bGVzL2h0dHAyLXdyYXBwZXIvc291cmNlL2FnZW50LmpzIiwibWFwcGluZ3MiOiJBQUFhO0FBQ2IscUJBQXFCLG1CQUFPLENBQUMsc0JBQVE7QUFDckMsWUFBWSxtQkFBTyxDQUFDLGdCQUFLO0FBQ3pCLGNBQWMsbUJBQU8sQ0FBQyxvQkFBTztBQUM3QixpQkFBaUIsbUJBQU8sQ0FBQywwREFBVzs7QUFFcEM7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsSUFBSTtBQUNKO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQSxzQkFBc0IsY0FBYztBQUNwQzs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBLEdBQUc7O0FBRUg7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0EsY0FBYywyRkFBMkYsSUFBSTtBQUM3Rzs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLHVDQUF1Qyw4QkFBOEI7QUFDckU7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSx1QkFBdUIsYUFBYTtBQUNwQztBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTCxrQkFBa0IsZ0JBQWdCO0FBQ2xDOztBQUVBO0FBQ0E7O0FBRUE7QUFDQSxnQkFBZ0IsUUFBUTtBQUN4QjtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0Esa0JBQWtCLFFBQVE7QUFDMUI7QUFDQSx5REFBeUQsaUJBQWlCO0FBQzFFO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxvQkFBb0IsaUJBQWlCLEdBQUcsa0JBQWtCO0FBQzFEOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLE1BQU07O0FBRU47QUFDQTtBQUNBLGtCQUFrQixRQUFRO0FBQzFCO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLE1BQU07O0FBRU47QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNOztBQUVOO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxRQUFRO0FBQ1I7QUFDQTtBQUNBOztBQUVBLG1CQUFtQixRQUFRO0FBQzNCO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsTUFBTTs7QUFFTjtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxlQUFlLFdBQVc7O0FBRTFCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBLE1BQU07O0FBRU47QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxPQUFPO0FBQ1AsTUFBTTs7QUFFTjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsV0FBVztBQUNYO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPOztBQUVQO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLEdBQUc7QUFDSDs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQSxJQUFJO0FBQ0osR0FBRztBQUNIOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLHNCQUFzQiwwQkFBMEI7QUFDaEQ7O0FBRUE7QUFDQSxzQkFBc0IsMkJBQTJCO0FBQ2pEO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSIsInNvdXJjZXMiOlsiL1VzZXJzL3BhbnphL0RvY3VtZW50cy9QZXJzb25hbFByb2plY3RzL3ByZWRpay9ub2RlX21vZHVsZXMvc3dhcm0tanMvbm9kZV9tb2R1bGVzL2h0dHAyLXdyYXBwZXIvc291cmNlL2FnZW50LmpzIl0sInNvdXJjZXNDb250ZW50IjpbIid1c2Ugc3RyaWN0JztcbmNvbnN0IEV2ZW50RW1pdHRlciA9IHJlcXVpcmUoJ2V2ZW50cycpO1xuY29uc3QgdGxzID0gcmVxdWlyZSgndGxzJyk7XG5jb25zdCBodHRwMiA9IHJlcXVpcmUoJ2h0dHAyJyk7XG5jb25zdCBRdWlja0xSVSA9IHJlcXVpcmUoJ3F1aWNrLWxydScpO1xuXG5jb25zdCBrQ3VycmVudFN0cmVhbXNDb3VudCA9IFN5bWJvbCgnY3VycmVudFN0cmVhbXNDb3VudCcpO1xuY29uc3Qga1JlcXVlc3QgPSBTeW1ib2woJ3JlcXVlc3QnKTtcbmNvbnN0IGtPcmlnaW5TZXQgPSBTeW1ib2woJ2NhY2hlZE9yaWdpblNldCcpO1xuY29uc3Qga0dyYWNlZnVsbHlDbG9zaW5nID0gU3ltYm9sKCdncmFjZWZ1bGx5Q2xvc2luZycpO1xuXG5jb25zdCBuYW1lS2V5cyA9IFtcblx0Ly8gYGh0dHAyLmNvbm5lY3QoKWAgb3B0aW9uc1xuXHQnbWF4RGVmbGF0ZUR5bmFtaWNUYWJsZVNpemUnLFxuXHQnbWF4U2Vzc2lvbk1lbW9yeScsXG5cdCdtYXhIZWFkZXJMaXN0UGFpcnMnLFxuXHQnbWF4T3V0c3RhbmRpbmdQaW5ncycsXG5cdCdtYXhSZXNlcnZlZFJlbW90ZVN0cmVhbXMnLFxuXHQnbWF4U2VuZEhlYWRlckJsb2NrTGVuZ3RoJyxcblx0J3BhZGRpbmdTdHJhdGVneScsXG5cblx0Ly8gYHRscy5jb25uZWN0KClgIG9wdGlvbnNcblx0J2xvY2FsQWRkcmVzcycsXG5cdCdwYXRoJyxcblx0J3JlamVjdFVuYXV0aG9yaXplZCcsXG5cdCdtaW5ESFNpemUnLFxuXG5cdC8vIGB0bHMuY3JlYXRlU2VjdXJlQ29udGV4dCgpYCBvcHRpb25zXG5cdCdjYScsXG5cdCdjZXJ0Jyxcblx0J2NsaWVudENlcnRFbmdpbmUnLFxuXHQnY2lwaGVycycsXG5cdCdrZXknLFxuXHQncGZ4Jyxcblx0J3NlcnZlcm5hbWUnLFxuXHQnbWluVmVyc2lvbicsXG5cdCdtYXhWZXJzaW9uJyxcblx0J3NlY3VyZVByb3RvY29sJyxcblx0J2NybCcsXG5cdCdob25vckNpcGhlck9yZGVyJyxcblx0J2VjZGhDdXJ2ZScsXG5cdCdkaHBhcmFtJyxcblx0J3NlY3VyZU9wdGlvbnMnLFxuXHQnc2Vzc2lvbklkQ29udGV4dCdcbl07XG5cbmNvbnN0IGdldFNvcnRlZEluZGV4ID0gKGFycmF5LCB2YWx1ZSwgY29tcGFyZSkgPT4ge1xuXHRsZXQgbG93ID0gMDtcblx0bGV0IGhpZ2ggPSBhcnJheS5sZW5ndGg7XG5cblx0d2hpbGUgKGxvdyA8IGhpZ2gpIHtcblx0XHRjb25zdCBtaWQgPSAobG93ICsgaGlnaCkgPj4+IDE7XG5cblx0XHQvKiBpc3RhbmJ1bCBpZ25vcmUgbmV4dCAqL1xuXHRcdGlmIChjb21wYXJlKGFycmF5W21pZF0sIHZhbHVlKSkge1xuXHRcdFx0Ly8gVGhpcyBuZXZlciBnZXRzIGNhbGxlZCBiZWNhdXNlIHdlIHVzZSBkZXNjZW5kaW5nIHNvcnQuIEJldHRlciB0byBoYXZlIHRoaXMgYW55d2F5LlxuXHRcdFx0bG93ID0gbWlkICsgMTtcblx0XHR9IGVsc2Uge1xuXHRcdFx0aGlnaCA9IG1pZDtcblx0XHR9XG5cdH1cblxuXHRyZXR1cm4gbG93O1xufTtcblxuY29uc3QgY29tcGFyZVNlc3Npb25zID0gKGEsIGIpID0+IHtcblx0cmV0dXJuIGEucmVtb3RlU2V0dGluZ3MubWF4Q29uY3VycmVudFN0cmVhbXMgPiBiLnJlbW90ZVNldHRpbmdzLm1heENvbmN1cnJlbnRTdHJlYW1zO1xufTtcblxuLy8gU2VlIGh0dHBzOi8vdG9vbHMuaWV0Zi5vcmcvaHRtbC9yZmM4MzM2XG5jb25zdCBjbG9zZUNvdmVyZWRTZXNzaW9ucyA9ICh3aGVyZSwgc2Vzc2lvbikgPT4ge1xuXHQvLyBDbGllbnRzIFNIT1VMRCBOT1QgZW1pdCBuZXcgcmVxdWVzdHMgb24gYW55IGNvbm5lY3Rpb24gd2hvc2UgT3JpZ2luXG5cdC8vIFNldCBpcyBhIHByb3BlciBzdWJzZXQgb2YgYW5vdGhlciBjb25uZWN0aW9uJ3MgT3JpZ2luIFNldCwgYW5kIHRoZXlcblx0Ly8gU0hPVUxEIGNsb3NlIGl0IG9uY2UgYWxsIG91dHN0YW5kaW5nIHJlcXVlc3RzIGFyZSBzYXRpc2ZpZWQuXG5cdGZvciAoY29uc3QgY292ZXJlZFNlc3Npb24gb2Ygd2hlcmUpIHtcblx0XHRpZiAoXG5cdFx0XHQvLyBUaGUgc2V0IGlzIGEgcHJvcGVyIHN1YnNldCB3aGVuIGl0cyBsZW5ndGggaXMgbGVzcyB0aGFuIHRoZSBvdGhlciBzZXQuXG5cdFx0XHRjb3ZlcmVkU2Vzc2lvbltrT3JpZ2luU2V0XS5sZW5ndGggPCBzZXNzaW9uW2tPcmlnaW5TZXRdLmxlbmd0aCAmJlxuXG5cdFx0XHQvLyBBbmQgdGhlIG90aGVyIHNldCBpbmNsdWRlcyBhbGwgZWxlbWVudHMgb2YgdGhlIHN1YnNldC5cblx0XHRcdGNvdmVyZWRTZXNzaW9uW2tPcmlnaW5TZXRdLmV2ZXJ5KG9yaWdpbiA9PiBzZXNzaW9uW2tPcmlnaW5TZXRdLmluY2x1ZGVzKG9yaWdpbikpICYmXG5cblx0XHRcdC8vIE1ha2VzIHN1cmUgdGhhdCB0aGUgc2Vzc2lvbiBjYW4gaGFuZGxlIGFsbCByZXF1ZXN0cyBmcm9tIHRoZSBjb3ZlcmVkIHNlc3Npb24uXG5cdFx0XHRjb3ZlcmVkU2Vzc2lvbltrQ3VycmVudFN0cmVhbXNDb3VudF0gKyBzZXNzaW9uW2tDdXJyZW50U3RyZWFtc0NvdW50XSA8PSBzZXNzaW9uLnJlbW90ZVNldHRpbmdzLm1heENvbmN1cnJlbnRTdHJlYW1zXG5cdFx0KSB7XG5cdFx0XHQvLyBUaGlzIGFsbG93cyBwZW5kaW5nIHJlcXVlc3RzIHRvIGZpbmlzaCBhbmQgcHJldmVudHMgbWFraW5nIG5ldyByZXF1ZXN0cy5cblx0XHRcdGdyYWNlZnVsbHlDbG9zZShjb3ZlcmVkU2Vzc2lvbik7XG5cdFx0fVxuXHR9XG59O1xuXG4vLyBUaGlzIGlzIGJhc2ljYWxseSBpbnZlcnRlZCBgY2xvc2VDb3ZlcmVkU2Vzc2lvbnMoLi4uKWAuXG5jb25zdCBjbG9zZVNlc3Npb25JZkNvdmVyZWQgPSAod2hlcmUsIGNvdmVyZWRTZXNzaW9uKSA9PiB7XG5cdGZvciAoY29uc3Qgc2Vzc2lvbiBvZiB3aGVyZSkge1xuXHRcdGlmIChcblx0XHRcdGNvdmVyZWRTZXNzaW9uW2tPcmlnaW5TZXRdLmxlbmd0aCA8IHNlc3Npb25ba09yaWdpblNldF0ubGVuZ3RoICYmXG5cdFx0XHRjb3ZlcmVkU2Vzc2lvbltrT3JpZ2luU2V0XS5ldmVyeShvcmlnaW4gPT4gc2Vzc2lvbltrT3JpZ2luU2V0XS5pbmNsdWRlcyhvcmlnaW4pKSAmJlxuXHRcdFx0Y292ZXJlZFNlc3Npb25ba0N1cnJlbnRTdHJlYW1zQ291bnRdICsgc2Vzc2lvbltrQ3VycmVudFN0cmVhbXNDb3VudF0gPD0gc2Vzc2lvbi5yZW1vdGVTZXR0aW5ncy5tYXhDb25jdXJyZW50U3RyZWFtc1xuXHRcdCkge1xuXHRcdFx0Z3JhY2VmdWxseUNsb3NlKGNvdmVyZWRTZXNzaW9uKTtcblx0XHR9XG5cdH1cbn07XG5cbmNvbnN0IGdldFNlc3Npb25zID0gKHthZ2VudCwgaXNGcmVlfSkgPT4ge1xuXHRjb25zdCByZXN1bHQgPSB7fTtcblxuXHQvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgZ3VhcmQtZm9yLWluXG5cdGZvciAoY29uc3Qgbm9ybWFsaXplZE9wdGlvbnMgaW4gYWdlbnQuc2Vzc2lvbnMpIHtcblx0XHRjb25zdCBzZXNzaW9ucyA9IGFnZW50LnNlc3Npb25zW25vcm1hbGl6ZWRPcHRpb25zXTtcblxuXHRcdGNvbnN0IGZpbHRlcmVkID0gc2Vzc2lvbnMuZmlsdGVyKHNlc3Npb24gPT4ge1xuXHRcdFx0Y29uc3QgcmVzdWx0ID0gc2Vzc2lvbltBZ2VudC5rQ3VycmVudFN0cmVhbXNDb3VudF0gPCBzZXNzaW9uLnJlbW90ZVNldHRpbmdzLm1heENvbmN1cnJlbnRTdHJlYW1zO1xuXG5cdFx0XHRyZXR1cm4gaXNGcmVlID8gcmVzdWx0IDogIXJlc3VsdDtcblx0XHR9KTtcblxuXHRcdGlmIChmaWx0ZXJlZC5sZW5ndGggIT09IDApIHtcblx0XHRcdHJlc3VsdFtub3JtYWxpemVkT3B0aW9uc10gPSBmaWx0ZXJlZDtcblx0XHR9XG5cdH1cblxuXHRyZXR1cm4gcmVzdWx0O1xufTtcblxuY29uc3QgZ3JhY2VmdWxseUNsb3NlID0gc2Vzc2lvbiA9PiB7XG5cdHNlc3Npb25ba0dyYWNlZnVsbHlDbG9zaW5nXSA9IHRydWU7XG5cblx0aWYgKHNlc3Npb25ba0N1cnJlbnRTdHJlYW1zQ291bnRdID09PSAwKSB7XG5cdFx0c2Vzc2lvbi5jbG9zZSgpO1xuXHR9XG59O1xuXG5jbGFzcyBBZ2VudCBleHRlbmRzIEV2ZW50RW1pdHRlciB7XG5cdGNvbnN0cnVjdG9yKHt0aW1lb3V0ID0gNjAwMDAsIG1heFNlc3Npb25zID0gSW5maW5pdHksIG1heEZyZWVTZXNzaW9ucyA9IDEwLCBtYXhDYWNoZWRUbHNTZXNzaW9ucyA9IDEwMH0gPSB7fSkge1xuXHRcdHN1cGVyKCk7XG5cblx0XHQvLyBBIHNlc3Npb24gaXMgY29uc2lkZXJlZCBidXN5IHdoZW4gaXRzIGN1cnJlbnQgc3RyZWFtcyBjb3VudFxuXHRcdC8vIGlzIGVxdWFsIHRvIG9yIGdyZWF0ZXIgdGhhbiB0aGUgYG1heENvbmN1cnJlbnRTdHJlYW1zYCB2YWx1ZS5cblxuXHRcdC8vIEEgc2Vzc2lvbiBpcyBjb25zaWRlcmVkIGZyZWUgd2hlbiBpdHMgY3VycmVudCBzdHJlYW1zIGNvdW50XG5cdFx0Ly8gaXMgbGVzcyB0aGFuIHRoZSBgbWF4Q29uY3VycmVudFN0cmVhbXNgIHZhbHVlLlxuXG5cdFx0Ly8gU0VTU0lPTlNbTk9STUFMSVpFRF9PUFRJT05TXSA9IFtdO1xuXHRcdHRoaXMuc2Vzc2lvbnMgPSB7fTtcblxuXHRcdC8vIFRoZSBxdWV1ZSBmb3IgY3JlYXRpbmcgbmV3IHNlc3Npb25zLiBJdCBsb29rcyBsaWtlIHRoaXM6XG5cdFx0Ly8gUVVFVUVbTk9STUFMSVpFRF9PUFRJT05TXVtOT1JNQUxJWkVEX09SSUdJTl0gPSBFTlRSWV9GVU5DVElPTlxuXHRcdC8vXG5cdFx0Ly8gVGhlIGVudHJ5IGZ1bmN0aW9uIGhhcyBgbGlzdGVuZXJzYCwgYGNvbXBsZXRlZGAgYW5kIGBkZXN0cm95ZWRgIHByb3BlcnRpZXMuXG5cdFx0Ly8gYGxpc3RlbmVyc2AgaXMgYW4gYXJyYXkgb2Ygb2JqZWN0cyBjb250YWluaW5nIGByZXNvbHZlYCBhbmQgYHJlamVjdGAgZnVuY3Rpb25zLlxuXHRcdC8vIGBjb21wbGV0ZWRgIGlzIGEgYm9vbGVhbi4gSXQncyBzZXQgdG8gdHJ1ZSBhZnRlciBFTlRSWV9GVU5DVElPTiBpcyBleGVjdXRlZC5cblx0XHQvLyBgZGVzdHJveWVkYCBpcyBhIGJvb2xlYW4uIElmIGl0J3Mgc2V0IHRvIHRydWUsIHRoZSBzZXNzaW9uIHdpbGwgYmUgZGVzdHJveWVkIGlmIGhhc24ndCBjb25uZWN0ZWQgeWV0LlxuXHRcdHRoaXMucXVldWUgPSB7fTtcblxuXHRcdC8vIEVhY2ggc2Vzc2lvbiB3aWxsIHVzZSB0aGlzIHRpbWVvdXQgdmFsdWUuXG5cdFx0dGhpcy50aW1lb3V0ID0gdGltZW91dDtcblxuXHRcdC8vIE1heCBzZXNzaW9ucyBpbiB0b3RhbFxuXHRcdHRoaXMubWF4U2Vzc2lvbnMgPSBtYXhTZXNzaW9ucztcblxuXHRcdC8vIE1heCBmcmVlIHNlc3Npb25zIGluIHRvdGFsXG5cdFx0Ly8gVE9ETzogZGVjcmVhc2luZyBgbWF4RnJlZVNlc3Npb25zYCBzaG91bGQgY2xvc2Ugc29tZSBzZXNzaW9uc1xuXHRcdHRoaXMubWF4RnJlZVNlc3Npb25zID0gbWF4RnJlZVNlc3Npb25zO1xuXG5cdFx0dGhpcy5fZnJlZVNlc3Npb25zQ291bnQgPSAwO1xuXHRcdHRoaXMuX3Nlc3Npb25zQ291bnQgPSAwO1xuXG5cdFx0Ly8gV2UgZG9uJ3Qgc3VwcG9ydCBwdXNoIHN0cmVhbXMgYnkgZGVmYXVsdC5cblx0XHR0aGlzLnNldHRpbmdzID0ge1xuXHRcdFx0ZW5hYmxlUHVzaDogZmFsc2Vcblx0XHR9O1xuXG5cdFx0Ly8gUmV1c2luZyBUTFMgc2Vzc2lvbnMgaW5jcmVhc2VzIHBlcmZvcm1hbmNlLlxuXHRcdHRoaXMudGxzU2Vzc2lvbkNhY2hlID0gbmV3IFF1aWNrTFJVKHttYXhTaXplOiBtYXhDYWNoZWRUbHNTZXNzaW9uc30pO1xuXHR9XG5cblx0c3RhdGljIG5vcm1hbGl6ZU9yaWdpbih1cmwsIHNlcnZlcm5hbWUpIHtcblx0XHRpZiAodHlwZW9mIHVybCA9PT0gJ3N0cmluZycpIHtcblx0XHRcdHVybCA9IG5ldyBVUkwodXJsKTtcblx0XHR9XG5cblx0XHRpZiAoc2VydmVybmFtZSAmJiB1cmwuaG9zdG5hbWUgIT09IHNlcnZlcm5hbWUpIHtcblx0XHRcdHVybC5ob3N0bmFtZSA9IHNlcnZlcm5hbWU7XG5cdFx0fVxuXG5cdFx0cmV0dXJuIHVybC5vcmlnaW47XG5cdH1cblxuXHRub3JtYWxpemVPcHRpb25zKG9wdGlvbnMpIHtcblx0XHRsZXQgbm9ybWFsaXplZCA9ICcnO1xuXG5cdFx0aWYgKG9wdGlvbnMpIHtcblx0XHRcdGZvciAoY29uc3Qga2V5IG9mIG5hbWVLZXlzKSB7XG5cdFx0XHRcdGlmIChvcHRpb25zW2tleV0pIHtcblx0XHRcdFx0XHRub3JtYWxpemVkICs9IGA6JHtvcHRpb25zW2tleV19YDtcblx0XHRcdFx0fVxuXHRcdFx0fVxuXHRcdH1cblxuXHRcdHJldHVybiBub3JtYWxpemVkO1xuXHR9XG5cblx0X3RyeVRvQ3JlYXRlTmV3U2Vzc2lvbihub3JtYWxpemVkT3B0aW9ucywgbm9ybWFsaXplZE9yaWdpbikge1xuXHRcdGlmICghKG5vcm1hbGl6ZWRPcHRpb25zIGluIHRoaXMucXVldWUpIHx8ICEobm9ybWFsaXplZE9yaWdpbiBpbiB0aGlzLnF1ZXVlW25vcm1hbGl6ZWRPcHRpb25zXSkpIHtcblx0XHRcdHJldHVybjtcblx0XHR9XG5cblx0XHRjb25zdCBpdGVtID0gdGhpcy5xdWV1ZVtub3JtYWxpemVkT3B0aW9uc11bbm9ybWFsaXplZE9yaWdpbl07XG5cblx0XHQvLyBUaGUgZW50cnkgZnVuY3Rpb24gY2FuIGJlIHJ1biBvbmx5IG9uY2UuXG5cdFx0Ly8gQlVHOiBUaGUgc2Vzc2lvbiBtYXkgYmUgbmV2ZXIgY3JlYXRlZCB3aGVuOlxuXHRcdC8vIC0gdGhlIGZpcnN0IGNvbmRpdGlvbiBpcyBmYWxzZSBBTkRcblx0XHQvLyAtIHRoaXMgZnVuY3Rpb24gaXMgbmV2ZXIgY2FsbGVkIHdpdGggdGhlIHNhbWUgYXJndW1lbnRzIGluIHRoZSBmdXR1cmUuXG5cdFx0aWYgKHRoaXMuX3Nlc3Npb25zQ291bnQgPCB0aGlzLm1heFNlc3Npb25zICYmICFpdGVtLmNvbXBsZXRlZCkge1xuXHRcdFx0aXRlbS5jb21wbGV0ZWQgPSB0cnVlO1xuXG5cdFx0XHRpdGVtKCk7XG5cdFx0fVxuXHR9XG5cblx0Z2V0U2Vzc2lvbihvcmlnaW4sIG9wdGlvbnMsIGxpc3RlbmVycykge1xuXHRcdHJldHVybiBuZXcgUHJvbWlzZSgocmVzb2x2ZSwgcmVqZWN0KSA9PiB7XG5cdFx0XHRpZiAoQXJyYXkuaXNBcnJheShsaXN0ZW5lcnMpKSB7XG5cdFx0XHRcdGxpc3RlbmVycyA9IFsuLi5saXN0ZW5lcnNdO1xuXG5cdFx0XHRcdC8vIFJlc29sdmUgdGhlIGN1cnJlbnQgcHJvbWlzZSBBU0FQLCB3ZSdyZSBqdXN0IG1vdmluZyB0aGUgbGlzdGVuZXJzLlxuXHRcdFx0XHQvLyBUaGV5IHdpbGwgYmUgZXhlY3V0ZWQgYXQgYSBkaWZmZXJlbnQgdGltZS5cblx0XHRcdFx0cmVzb2x2ZSgpO1xuXHRcdFx0fSBlbHNlIHtcblx0XHRcdFx0bGlzdGVuZXJzID0gW3tyZXNvbHZlLCByZWplY3R9XTtcblx0XHRcdH1cblxuXHRcdFx0Y29uc3Qgbm9ybWFsaXplZE9wdGlvbnMgPSB0aGlzLm5vcm1hbGl6ZU9wdGlvbnMob3B0aW9ucyk7XG5cdFx0XHRjb25zdCBub3JtYWxpemVkT3JpZ2luID0gQWdlbnQubm9ybWFsaXplT3JpZ2luKG9yaWdpbiwgb3B0aW9ucyAmJiBvcHRpb25zLnNlcnZlcm5hbWUpO1xuXG5cdFx0XHRpZiAobm9ybWFsaXplZE9yaWdpbiA9PT0gdW5kZWZpbmVkKSB7XG5cdFx0XHRcdGZvciAoY29uc3Qge3JlamVjdH0gb2YgbGlzdGVuZXJzKSB7XG5cdFx0XHRcdFx0cmVqZWN0KG5ldyBUeXBlRXJyb3IoJ1RoZSBgb3JpZ2luYCBhcmd1bWVudCBuZWVkcyB0byBiZSBhIHN0cmluZyBvciBhbiBVUkwgb2JqZWN0JykpO1xuXHRcdFx0XHR9XG5cblx0XHRcdFx0cmV0dXJuO1xuXHRcdFx0fVxuXG5cdFx0XHRpZiAobm9ybWFsaXplZE9wdGlvbnMgaW4gdGhpcy5zZXNzaW9ucykge1xuXHRcdFx0XHRjb25zdCBzZXNzaW9ucyA9IHRoaXMuc2Vzc2lvbnNbbm9ybWFsaXplZE9wdGlvbnNdO1xuXG5cdFx0XHRcdGxldCBtYXhDb25jdXJyZW50U3RyZWFtcyA9IC0xO1xuXHRcdFx0XHRsZXQgY3VycmVudFN0cmVhbXNDb3VudCA9IC0xO1xuXHRcdFx0XHRsZXQgb3B0aW1hbFNlc3Npb247XG5cblx0XHRcdFx0Ly8gV2UgY291bGQganVzdCBkbyB0aGlzLnNlc3Npb25zW25vcm1hbGl6ZWRPcHRpb25zXS5maW5kKC4uLikgYnV0IHRoYXQgaXNuJ3Qgb3B0aW1hbC5cblx0XHRcdFx0Ly8gQWRkaXRpb25hbGx5LCB3ZSBhcmUgbG9va2luZyBmb3Igc2Vzc2lvbiB3aGljaCBoYXMgYmlnZ2VzdCBjdXJyZW50IHBlbmRpbmcgc3RyZWFtcyBjb3VudC5cblx0XHRcdFx0Zm9yIChjb25zdCBzZXNzaW9uIG9mIHNlc3Npb25zKSB7XG5cdFx0XHRcdFx0Y29uc3Qgc2Vzc2lvbk1heENvbmN1cnJlbnRTdHJlYW1zID0gc2Vzc2lvbi5yZW1vdGVTZXR0aW5ncy5tYXhDb25jdXJyZW50U3RyZWFtcztcblxuXHRcdFx0XHRcdGlmIChzZXNzaW9uTWF4Q29uY3VycmVudFN0cmVhbXMgPCBtYXhDb25jdXJyZW50U3RyZWFtcykge1xuXHRcdFx0XHRcdFx0YnJlYWs7XG5cdFx0XHRcdFx0fVxuXG5cdFx0XHRcdFx0aWYgKHNlc3Npb25ba09yaWdpblNldF0uaW5jbHVkZXMobm9ybWFsaXplZE9yaWdpbikpIHtcblx0XHRcdFx0XHRcdGNvbnN0IHNlc3Npb25DdXJyZW50U3RyZWFtc0NvdW50ID0gc2Vzc2lvbltrQ3VycmVudFN0cmVhbXNDb3VudF07XG5cblx0XHRcdFx0XHRcdGlmIChcblx0XHRcdFx0XHRcdFx0c2Vzc2lvbkN1cnJlbnRTdHJlYW1zQ291bnQgPj0gc2Vzc2lvbk1heENvbmN1cnJlbnRTdHJlYW1zIHx8XG5cdFx0XHRcdFx0XHRcdHNlc3Npb25ba0dyYWNlZnVsbHlDbG9zaW5nXSB8fFxuXHRcdFx0XHRcdFx0XHQvLyBVbmZvcnR1bmF0ZWx5IHRoZSBgY2xvc2VgIGV2ZW50IGlzbid0IGNhbGxlZCBpbW1lZGlhdGVseSxcblx0XHRcdFx0XHRcdFx0Ly8gc28gYHNlc3Npb24uZGVzdHJveWVkYCBpcyBgdHJ1ZWAsIGJ1dCBgc2Vzc2lvbi5jbG9zZWRgIGlzIGBmYWxzZWAuXG5cdFx0XHRcdFx0XHRcdHNlc3Npb24uZGVzdHJveWVkXG5cdFx0XHRcdFx0XHQpIHtcblx0XHRcdFx0XHRcdFx0Y29udGludWU7XG5cdFx0XHRcdFx0XHR9XG5cblx0XHRcdFx0XHRcdC8vIFdlIG9ubHkgbmVlZCBzZXQgdGhpcyBvbmNlLlxuXHRcdFx0XHRcdFx0aWYgKCFvcHRpbWFsU2Vzc2lvbikge1xuXHRcdFx0XHRcdFx0XHRtYXhDb25jdXJyZW50U3RyZWFtcyA9IHNlc3Npb25NYXhDb25jdXJyZW50U3RyZWFtcztcblx0XHRcdFx0XHRcdH1cblxuXHRcdFx0XHRcdFx0Ly8gV2UncmUgbG9va2luZyBmb3IgdGhlIHNlc3Npb24gd2hpY2ggaGFzIGJpZ2dlc3QgY3VycmVudCBwZW5kaW5nIHN0cmVhbSBjb3VudCxcblx0XHRcdFx0XHRcdC8vIGluIG9yZGVyIHRvIG1pbmltYWxpemUgdGhlIGFtb3VudCBvZiBhY3RpdmUgc2Vzc2lvbnMuXG5cdFx0XHRcdFx0XHRpZiAoc2Vzc2lvbkN1cnJlbnRTdHJlYW1zQ291bnQgPiBjdXJyZW50U3RyZWFtc0NvdW50KSB7XG5cdFx0XHRcdFx0XHRcdG9wdGltYWxTZXNzaW9uID0gc2Vzc2lvbjtcblx0XHRcdFx0XHRcdFx0Y3VycmVudFN0cmVhbXNDb3VudCA9IHNlc3Npb25DdXJyZW50U3RyZWFtc0NvdW50O1xuXHRcdFx0XHRcdFx0fVxuXHRcdFx0XHRcdH1cblx0XHRcdFx0fVxuXG5cdFx0XHRcdGlmIChvcHRpbWFsU2Vzc2lvbikge1xuXHRcdFx0XHRcdC8qIGlzdGFuYnVsIGlnbm9yZSBuZXh0OiBzYWZldHkgY2hlY2sgKi9cblx0XHRcdFx0XHRpZiAobGlzdGVuZXJzLmxlbmd0aCAhPT0gMSkge1xuXHRcdFx0XHRcdFx0Zm9yIChjb25zdCB7cmVqZWN0fSBvZiBsaXN0ZW5lcnMpIHtcblx0XHRcdFx0XHRcdFx0Y29uc3QgZXJyb3IgPSBuZXcgRXJyb3IoXG5cdFx0XHRcdFx0XHRcdFx0YEV4cGVjdGVkIHRoZSBsZW5ndGggb2YgbGlzdGVuZXJzIHRvIGJlIDEsIGdvdCAke2xpc3RlbmVycy5sZW5ndGh9LlxcbmAgK1xuXHRcdFx0XHRcdFx0XHRcdCdQbGVhc2UgcmVwb3J0IHRoaXMgdG8gaHR0cHM6Ly9naXRodWIuY29tL3N6bWFyY3phay9odHRwMi13cmFwcGVyLydcblx0XHRcdFx0XHRcdFx0KTtcblxuXHRcdFx0XHRcdFx0XHRyZWplY3QoZXJyb3IpO1xuXHRcdFx0XHRcdFx0fVxuXG5cdFx0XHRcdFx0XHRyZXR1cm47XG5cdFx0XHRcdFx0fVxuXG5cdFx0XHRcdFx0bGlzdGVuZXJzWzBdLnJlc29sdmUob3B0aW1hbFNlc3Npb24pO1xuXHRcdFx0XHRcdHJldHVybjtcblx0XHRcdFx0fVxuXHRcdFx0fVxuXG5cdFx0XHRpZiAobm9ybWFsaXplZE9wdGlvbnMgaW4gdGhpcy5xdWV1ZSkge1xuXHRcdFx0XHRpZiAobm9ybWFsaXplZE9yaWdpbiBpbiB0aGlzLnF1ZXVlW25vcm1hbGl6ZWRPcHRpb25zXSkge1xuXHRcdFx0XHRcdC8vIFRoZXJlJ3MgYWxyZWFkeSBhbiBpdGVtIGluIHRoZSBxdWV1ZSwganVzdCBhdHRhY2ggb3Vyc2VsdmVzIHRvIGl0LlxuXHRcdFx0XHRcdHRoaXMucXVldWVbbm9ybWFsaXplZE9wdGlvbnNdW25vcm1hbGl6ZWRPcmlnaW5dLmxpc3RlbmVycy5wdXNoKC4uLmxpc3RlbmVycyk7XG5cblx0XHRcdFx0XHQvLyBUaGlzIHNob3VsZG4ndCBiZSBleGVjdXRlZCBoZXJlLlxuXHRcdFx0XHRcdC8vIFNlZSB0aGUgY29tbWVudCBpbnNpZGUgX3RyeVRvQ3JlYXRlTmV3U2Vzc2lvbi5cblx0XHRcdFx0XHR0aGlzLl90cnlUb0NyZWF0ZU5ld1Nlc3Npb24obm9ybWFsaXplZE9wdGlvbnMsIG5vcm1hbGl6ZWRPcmlnaW4pO1xuXHRcdFx0XHRcdHJldHVybjtcblx0XHRcdFx0fVxuXHRcdFx0fSBlbHNlIHtcblx0XHRcdFx0dGhpcy5xdWV1ZVtub3JtYWxpemVkT3B0aW9uc10gPSB7fTtcblx0XHRcdH1cblxuXHRcdFx0Ly8gVGhlIGVudHJ5IG11c3QgYmUgcmVtb3ZlZCBmcm9tIHRoZSBxdWV1ZSBJTU1FRElBVEVMWSB3aGVuOlxuXHRcdFx0Ly8gMS4gdGhlIHNlc3Npb24gY29ubmVjdHMgc3VjY2Vzc2Z1bGx5LFxuXHRcdFx0Ly8gMi4gYW4gZXJyb3Igb2NjdXJzLlxuXHRcdFx0Y29uc3QgcmVtb3ZlRnJvbVF1ZXVlID0gKCkgPT4ge1xuXHRcdFx0XHQvLyBPdXIgZW50cnkgY2FuIGJlIHJlcGxhY2VkLiBXZSBjYW5ub3QgcmVtb3ZlIHRoZSBuZXcgb25lLlxuXHRcdFx0XHRpZiAobm9ybWFsaXplZE9wdGlvbnMgaW4gdGhpcy5xdWV1ZSAmJiB0aGlzLnF1ZXVlW25vcm1hbGl6ZWRPcHRpb25zXVtub3JtYWxpemVkT3JpZ2luXSA9PT0gZW50cnkpIHtcblx0XHRcdFx0XHRkZWxldGUgdGhpcy5xdWV1ZVtub3JtYWxpemVkT3B0aW9uc11bbm9ybWFsaXplZE9yaWdpbl07XG5cblx0XHRcdFx0XHRpZiAoT2JqZWN0LmtleXModGhpcy5xdWV1ZVtub3JtYWxpemVkT3B0aW9uc10pLmxlbmd0aCA9PT0gMCkge1xuXHRcdFx0XHRcdFx0ZGVsZXRlIHRoaXMucXVldWVbbm9ybWFsaXplZE9wdGlvbnNdO1xuXHRcdFx0XHRcdH1cblx0XHRcdFx0fVxuXHRcdFx0fTtcblxuXHRcdFx0Ly8gVGhlIG1haW4gbG9naWMgaXMgaGVyZVxuXHRcdFx0Y29uc3QgZW50cnkgPSAoKSA9PiB7XG5cdFx0XHRcdGNvbnN0IG5hbWUgPSBgJHtub3JtYWxpemVkT3JpZ2lufToke25vcm1hbGl6ZWRPcHRpb25zfWA7XG5cdFx0XHRcdGxldCByZWNlaXZlZFNldHRpbmdzID0gZmFsc2U7XG5cblx0XHRcdFx0dHJ5IHtcblx0XHRcdFx0XHRjb25zdCBzZXNzaW9uID0gaHR0cDIuY29ubmVjdChvcmlnaW4sIHtcblx0XHRcdFx0XHRcdGNyZWF0ZUNvbm5lY3Rpb246IHRoaXMuY3JlYXRlQ29ubmVjdGlvbixcblx0XHRcdFx0XHRcdHNldHRpbmdzOiB0aGlzLnNldHRpbmdzLFxuXHRcdFx0XHRcdFx0c2Vzc2lvbjogdGhpcy50bHNTZXNzaW9uQ2FjaGUuZ2V0KG5hbWUpLFxuXHRcdFx0XHRcdFx0Li4ub3B0aW9uc1xuXHRcdFx0XHRcdH0pO1xuXHRcdFx0XHRcdHNlc3Npb25ba0N1cnJlbnRTdHJlYW1zQ291bnRdID0gMDtcblx0XHRcdFx0XHRzZXNzaW9uW2tHcmFjZWZ1bGx5Q2xvc2luZ10gPSBmYWxzZTtcblxuXHRcdFx0XHRcdGNvbnN0IGlzRnJlZSA9ICgpID0+IHNlc3Npb25ba0N1cnJlbnRTdHJlYW1zQ291bnRdIDwgc2Vzc2lvbi5yZW1vdGVTZXR0aW5ncy5tYXhDb25jdXJyZW50U3RyZWFtcztcblx0XHRcdFx0XHRsZXQgd2FzRnJlZSA9IHRydWU7XG5cblx0XHRcdFx0XHRzZXNzaW9uLnNvY2tldC5vbmNlKCdzZXNzaW9uJywgdGxzU2Vzc2lvbiA9PiB7XG5cdFx0XHRcdFx0XHR0aGlzLnRsc1Nlc3Npb25DYWNoZS5zZXQobmFtZSwgdGxzU2Vzc2lvbik7XG5cdFx0XHRcdFx0fSk7XG5cblx0XHRcdFx0XHRzZXNzaW9uLm9uY2UoJ2Vycm9yJywgZXJyb3IgPT4ge1xuXHRcdFx0XHRcdFx0Ly8gTGlzdGVuZXJzIGFyZSBlbXB0eSB3aGVuIHRoZSBzZXNzaW9uIHN1Y2Nlc3NmdWxseSBjb25uZWN0ZWQuXG5cdFx0XHRcdFx0XHRmb3IgKGNvbnN0IHtyZWplY3R9IG9mIGxpc3RlbmVycykge1xuXHRcdFx0XHRcdFx0XHRyZWplY3QoZXJyb3IpO1xuXHRcdFx0XHRcdFx0fVxuXG5cdFx0XHRcdFx0XHQvLyBUaGUgY29ubmVjdGlvbiBnb3QgYnJva2VuLCBwdXJnZSB0aGUgY2FjaGUuXG5cdFx0XHRcdFx0XHR0aGlzLnRsc1Nlc3Npb25DYWNoZS5kZWxldGUobmFtZSk7XG5cdFx0XHRcdFx0fSk7XG5cblx0XHRcdFx0XHRzZXNzaW9uLnNldFRpbWVvdXQodGhpcy50aW1lb3V0LCAoKSA9PiB7XG5cdFx0XHRcdFx0XHQvLyBUZXJtaW5hdGVzIGFsbCBzdHJlYW1zIG93bmVkIGJ5IHRoaXMgc2Vzc2lvbi5cblx0XHRcdFx0XHRcdC8vIFRPRE86IE1heWJlIHRoZSBzdHJlYW1zIHNob3VsZCBoYXZlIGEgXCJTZXNzaW9uIHRpbWVkIG91dFwiIGVycm9yP1xuXHRcdFx0XHRcdFx0c2Vzc2lvbi5kZXN0cm95KCk7XG5cdFx0XHRcdFx0fSk7XG5cblx0XHRcdFx0XHRzZXNzaW9uLm9uY2UoJ2Nsb3NlJywgKCkgPT4ge1xuXHRcdFx0XHRcdFx0aWYgKHJlY2VpdmVkU2V0dGluZ3MpIHtcblx0XHRcdFx0XHRcdFx0Ly8gMS4gSWYgaXQgd2Fzbid0IGZyZWUgdGhlbiBubyBuZWVkIHRvIGRlY3JlYXNlIGJlY2F1c2Vcblx0XHRcdFx0XHRcdFx0Ly8gICAgaXQgaGFzIGJlZW4gZGVjcmVhc2VkIGFscmVhZHkgaW4gc2Vzc2lvbi5yZXF1ZXN0KCkuXG5cdFx0XHRcdFx0XHRcdC8vIDIuIGBzdHJlYW0ub25jZSgnY2xvc2UnKWAgd29uJ3QgaW5jcmVtZW50IHRoZSBjb3VudFxuXHRcdFx0XHRcdFx0XHQvLyAgICBiZWNhdXNlIHRoZSBzZXNzaW9uIGlzIGFscmVhZHkgY2xvc2VkLlxuXHRcdFx0XHRcdFx0XHRpZiAod2FzRnJlZSkge1xuXHRcdFx0XHRcdFx0XHRcdHRoaXMuX2ZyZWVTZXNzaW9uc0NvdW50LS07XG5cdFx0XHRcdFx0XHRcdH1cblxuXHRcdFx0XHRcdFx0XHR0aGlzLl9zZXNzaW9uc0NvdW50LS07XG5cblx0XHRcdFx0XHRcdFx0Ly8gVGhpcyBjYW5ub3QgYmUgbW92ZWQgdG8gdGhlIHN0cmVhbSBsb2dpYyxcblx0XHRcdFx0XHRcdFx0Ly8gYmVjYXVzZSB0aGVyZSBtYXkgYmUgYSBzZXNzaW9uIHRoYXQgaGFkbid0IG1hZGUgYSBzaW5nbGUgcmVxdWVzdC5cblx0XHRcdFx0XHRcdFx0Y29uc3Qgd2hlcmUgPSB0aGlzLnNlc3Npb25zW25vcm1hbGl6ZWRPcHRpb25zXTtcblx0XHRcdFx0XHRcdFx0d2hlcmUuc3BsaWNlKHdoZXJlLmluZGV4T2Yoc2Vzc2lvbiksIDEpO1xuXG5cdFx0XHRcdFx0XHRcdGlmICh3aGVyZS5sZW5ndGggPT09IDApIHtcblx0XHRcdFx0XHRcdFx0XHRkZWxldGUgdGhpcy5zZXNzaW9uc1tub3JtYWxpemVkT3B0aW9uc107XG5cdFx0XHRcdFx0XHRcdH1cblx0XHRcdFx0XHRcdH0gZWxzZSB7XG5cdFx0XHRcdFx0XHRcdC8vIEJyb2tlbiBjb25uZWN0aW9uXG5cdFx0XHRcdFx0XHRcdGNvbnN0IGVycm9yID0gbmV3IEVycm9yKCdTZXNzaW9uIGNsb3NlZCB3aXRob3V0IHJlY2VpdmluZyBhIFNFVFRJTkdTIGZyYW1lJyk7XG5cdFx0XHRcdFx0XHRcdGVycm9yLmNvZGUgPSAnSFRUUDJXUkFQUEVSX05PU0VUVElOR1MnO1xuXG5cdFx0XHRcdFx0XHRcdGZvciAoY29uc3Qge3JlamVjdH0gb2YgbGlzdGVuZXJzKSB7XG5cdFx0XHRcdFx0XHRcdFx0cmVqZWN0KGVycm9yKTtcblx0XHRcdFx0XHRcdFx0fVxuXG5cdFx0XHRcdFx0XHRcdHJlbW92ZUZyb21RdWV1ZSgpO1xuXHRcdFx0XHRcdFx0fVxuXG5cdFx0XHRcdFx0XHQvLyBUaGVyZSBtYXkgYmUgYW5vdGhlciBzZXNzaW9uIGF3YWl0aW5nLlxuXHRcdFx0XHRcdFx0dGhpcy5fdHJ5VG9DcmVhdGVOZXdTZXNzaW9uKG5vcm1hbGl6ZWRPcHRpb25zLCBub3JtYWxpemVkT3JpZ2luKTtcblx0XHRcdFx0XHR9KTtcblxuXHRcdFx0XHRcdC8vIEl0ZXJhdGVzIG92ZXIgdGhlIHF1ZXVlIGFuZCBwcm9jZXNzZXMgbGlzdGVuZXJzLlxuXHRcdFx0XHRcdGNvbnN0IHByb2Nlc3NMaXN0ZW5lcnMgPSAoKSA9PiB7XG5cdFx0XHRcdFx0XHRpZiAoIShub3JtYWxpemVkT3B0aW9ucyBpbiB0aGlzLnF1ZXVlKSB8fCAhaXNGcmVlKCkpIHtcblx0XHRcdFx0XHRcdFx0cmV0dXJuO1xuXHRcdFx0XHRcdFx0fVxuXG5cdFx0XHRcdFx0XHRmb3IgKGNvbnN0IG9yaWdpbiBvZiBzZXNzaW9uW2tPcmlnaW5TZXRdKSB7XG5cdFx0XHRcdFx0XHRcdGlmIChvcmlnaW4gaW4gdGhpcy5xdWV1ZVtub3JtYWxpemVkT3B0aW9uc10pIHtcblx0XHRcdFx0XHRcdFx0XHRjb25zdCB7bGlzdGVuZXJzfSA9IHRoaXMucXVldWVbbm9ybWFsaXplZE9wdGlvbnNdW29yaWdpbl07XG5cblx0XHRcdFx0XHRcdFx0XHQvLyBQcmV2ZW50cyBzZXNzaW9uIG92ZXJsb2FkaW5nLlxuXHRcdFx0XHRcdFx0XHRcdHdoaWxlIChsaXN0ZW5lcnMubGVuZ3RoICE9PSAwICYmIGlzRnJlZSgpKSB7XG5cdFx0XHRcdFx0XHRcdFx0XHQvLyBXZSBhc3N1bWUgYHJlc29sdmUoLi4uKWAgY2FsbHMgYHJlcXVlc3QoLi4uKWAgKmRpcmVjdGx5Kixcblx0XHRcdFx0XHRcdFx0XHRcdC8vIG90aGVyd2lzZSB0aGUgc2Vzc2lvbiB3aWxsIGdldCBvdmVybG9hZGVkLlxuXHRcdFx0XHRcdFx0XHRcdFx0bGlzdGVuZXJzLnNoaWZ0KCkucmVzb2x2ZShzZXNzaW9uKTtcblx0XHRcdFx0XHRcdFx0XHR9XG5cblx0XHRcdFx0XHRcdFx0XHRjb25zdCB3aGVyZSA9IHRoaXMucXVldWVbbm9ybWFsaXplZE9wdGlvbnNdO1xuXHRcdFx0XHRcdFx0XHRcdGlmICh3aGVyZVtvcmlnaW5dLmxpc3RlbmVycy5sZW5ndGggPT09IDApIHtcblx0XHRcdFx0XHRcdFx0XHRcdGRlbGV0ZSB3aGVyZVtvcmlnaW5dO1xuXG5cdFx0XHRcdFx0XHRcdFx0XHRpZiAoT2JqZWN0LmtleXMod2hlcmUpLmxlbmd0aCA9PT0gMCkge1xuXHRcdFx0XHRcdFx0XHRcdFx0XHRkZWxldGUgdGhpcy5xdWV1ZVtub3JtYWxpemVkT3B0aW9uc107XG5cdFx0XHRcdFx0XHRcdFx0XHRcdGJyZWFrO1xuXHRcdFx0XHRcdFx0XHRcdFx0fVxuXHRcdFx0XHRcdFx0XHRcdH1cblxuXHRcdFx0XHRcdFx0XHRcdC8vIFdlJ3JlIG5vIGxvbmdlciBmcmVlLCBubyBwb2ludCBpbiBjb250aW51aW5nLlxuXHRcdFx0XHRcdFx0XHRcdGlmICghaXNGcmVlKCkpIHtcblx0XHRcdFx0XHRcdFx0XHRcdGJyZWFrO1xuXHRcdFx0XHRcdFx0XHRcdH1cblx0XHRcdFx0XHRcdFx0fVxuXHRcdFx0XHRcdFx0fVxuXHRcdFx0XHRcdH07XG5cblx0XHRcdFx0XHQvLyBUaGUgT3JpZ2luIFNldCBjYW5ub3Qgc2hyaW5rLiBObyBuZWVkIHRvIGNoZWNrIGlmIGl0IHN1ZGRlbmx5IGJlY2FtZSBjb3ZlcmVkIGJ5IGFub3RoZXIgb25lLlxuXHRcdFx0XHRcdHNlc3Npb24ub24oJ29yaWdpbicsICgpID0+IHtcblx0XHRcdFx0XHRcdHNlc3Npb25ba09yaWdpblNldF0gPSBzZXNzaW9uLm9yaWdpblNldDtcblxuXHRcdFx0XHRcdFx0aWYgKCFpc0ZyZWUoKSkge1xuXHRcdFx0XHRcdFx0XHQvLyBUaGUgc2Vzc2lvbiBpcyBmdWxsLlxuXHRcdFx0XHRcdFx0XHRyZXR1cm47XG5cdFx0XHRcdFx0XHR9XG5cblx0XHRcdFx0XHRcdHByb2Nlc3NMaXN0ZW5lcnMoKTtcblxuXHRcdFx0XHRcdFx0Ly8gQ2xvc2UgY292ZXJlZCBzZXNzaW9ucyAoaWYgcG9zc2libGUpLlxuXHRcdFx0XHRcdFx0Y2xvc2VDb3ZlcmVkU2Vzc2lvbnModGhpcy5zZXNzaW9uc1tub3JtYWxpemVkT3B0aW9uc10sIHNlc3Npb24pO1xuXHRcdFx0XHRcdH0pO1xuXG5cdFx0XHRcdFx0c2Vzc2lvbi5vbmNlKCdyZW1vdGVTZXR0aW5ncycsICgpID0+IHtcblx0XHRcdFx0XHRcdC8vIEZpeCBOb2RlLmpzIGJ1ZyBwcmV2ZW50aW5nIHRoZSBwcm9jZXNzIGZyb20gZXhpdGluZ1xuXHRcdFx0XHRcdFx0c2Vzc2lvbi5yZWYoKTtcblx0XHRcdFx0XHRcdHNlc3Npb24udW5yZWYoKTtcblxuXHRcdFx0XHRcdFx0dGhpcy5fc2Vzc2lvbnNDb3VudCsrO1xuXG5cdFx0XHRcdFx0XHQvLyBUaGUgQWdlbnQgY291bGQgaGF2ZSBiZWVuIGRlc3Ryb3llZCBhbHJlYWR5LlxuXHRcdFx0XHRcdFx0aWYgKGVudHJ5LmRlc3Ryb3llZCkge1xuXHRcdFx0XHRcdFx0XHRjb25zdCBlcnJvciA9IG5ldyBFcnJvcignQWdlbnQgaGFzIGJlZW4gZGVzdHJveWVkJyk7XG5cblx0XHRcdFx0XHRcdFx0Zm9yIChjb25zdCBsaXN0ZW5lciBvZiBsaXN0ZW5lcnMpIHtcblx0XHRcdFx0XHRcdFx0XHRsaXN0ZW5lci5yZWplY3QoZXJyb3IpO1xuXHRcdFx0XHRcdFx0XHR9XG5cblx0XHRcdFx0XHRcdFx0c2Vzc2lvbi5kZXN0cm95KCk7XG5cdFx0XHRcdFx0XHRcdHJldHVybjtcblx0XHRcdFx0XHRcdH1cblxuXHRcdFx0XHRcdFx0c2Vzc2lvbltrT3JpZ2luU2V0XSA9IHNlc3Npb24ub3JpZ2luU2V0O1xuXG5cdFx0XHRcdFx0XHR7XG5cdFx0XHRcdFx0XHRcdGNvbnN0IHdoZXJlID0gdGhpcy5zZXNzaW9ucztcblxuXHRcdFx0XHRcdFx0XHRpZiAobm9ybWFsaXplZE9wdGlvbnMgaW4gd2hlcmUpIHtcblx0XHRcdFx0XHRcdFx0XHRjb25zdCBzZXNzaW9ucyA9IHdoZXJlW25vcm1hbGl6ZWRPcHRpb25zXTtcblx0XHRcdFx0XHRcdFx0XHRzZXNzaW9ucy5zcGxpY2UoZ2V0U29ydGVkSW5kZXgoc2Vzc2lvbnMsIHNlc3Npb24sIGNvbXBhcmVTZXNzaW9ucyksIDAsIHNlc3Npb24pO1xuXHRcdFx0XHRcdFx0XHR9IGVsc2Uge1xuXHRcdFx0XHRcdFx0XHRcdHdoZXJlW25vcm1hbGl6ZWRPcHRpb25zXSA9IFtzZXNzaW9uXTtcblx0XHRcdFx0XHRcdFx0fVxuXHRcdFx0XHRcdFx0fVxuXG5cdFx0XHRcdFx0XHR0aGlzLl9mcmVlU2Vzc2lvbnNDb3VudCArPSAxO1xuXHRcdFx0XHRcdFx0cmVjZWl2ZWRTZXR0aW5ncyA9IHRydWU7XG5cblx0XHRcdFx0XHRcdHRoaXMuZW1pdCgnc2Vzc2lvbicsIHNlc3Npb24pO1xuXG5cdFx0XHRcdFx0XHRwcm9jZXNzTGlzdGVuZXJzKCk7XG5cdFx0XHRcdFx0XHRyZW1vdmVGcm9tUXVldWUoKTtcblxuXHRcdFx0XHRcdFx0Ly8gVE9ETzogQ2xvc2UgbGFzdCByZWNlbnRseSB1c2VkIChvciBsZWFzdCB1c2VkPykgc2Vzc2lvblxuXHRcdFx0XHRcdFx0aWYgKHNlc3Npb25ba0N1cnJlbnRTdHJlYW1zQ291bnRdID09PSAwICYmIHRoaXMuX2ZyZWVTZXNzaW9uc0NvdW50ID4gdGhpcy5tYXhGcmVlU2Vzc2lvbnMpIHtcblx0XHRcdFx0XHRcdFx0c2Vzc2lvbi5jbG9zZSgpO1xuXHRcdFx0XHRcdFx0fVxuXG5cdFx0XHRcdFx0XHQvLyBDaGVjayBpZiB3ZSBoYXZlbid0IG1hbmFnZWQgdG8gZXhlY3V0ZSBhbGwgbGlzdGVuZXJzLlxuXHRcdFx0XHRcdFx0aWYgKGxpc3RlbmVycy5sZW5ndGggIT09IDApIHtcblx0XHRcdFx0XHRcdFx0Ly8gUmVxdWVzdCBmb3IgYSBuZXcgc2Vzc2lvbiB3aXRoIHByZWRlZmluZWQgbGlzdGVuZXJzLlxuXHRcdFx0XHRcdFx0XHR0aGlzLmdldFNlc3Npb24obm9ybWFsaXplZE9yaWdpbiwgb3B0aW9ucywgbGlzdGVuZXJzKTtcblx0XHRcdFx0XHRcdFx0bGlzdGVuZXJzLmxlbmd0aCA9IDA7XG5cdFx0XHRcdFx0XHR9XG5cblx0XHRcdFx0XHRcdC8vIGBzZXNzaW9uLnJlbW90ZVNldHRpbmdzLm1heENvbmN1cnJlbnRTdHJlYW1zYCBtaWdodCBnZXQgaW5jcmVhc2VkXG5cdFx0XHRcdFx0XHRzZXNzaW9uLm9uKCdyZW1vdGVTZXR0aW5ncycsICgpID0+IHtcblx0XHRcdFx0XHRcdFx0cHJvY2Vzc0xpc3RlbmVycygpO1xuXG5cdFx0XHRcdFx0XHRcdC8vIEluIGNhc2UgdGhlIE9yaWdpbiBTZXQgY2hhbmdlc1xuXHRcdFx0XHRcdFx0XHRjbG9zZUNvdmVyZWRTZXNzaW9ucyh0aGlzLnNlc3Npb25zW25vcm1hbGl6ZWRPcHRpb25zXSwgc2Vzc2lvbik7XG5cdFx0XHRcdFx0XHR9KTtcblx0XHRcdFx0XHR9KTtcblxuXHRcdFx0XHRcdC8vIFNoaW0gYHNlc3Npb24ucmVxdWVzdCgpYCBpbiBvcmRlciB0byBjYXRjaCBhbGwgc3RyZWFtc1xuXHRcdFx0XHRcdHNlc3Npb25ba1JlcXVlc3RdID0gc2Vzc2lvbi5yZXF1ZXN0O1xuXHRcdFx0XHRcdHNlc3Npb24ucmVxdWVzdCA9IChoZWFkZXJzLCBzdHJlYW1PcHRpb25zKSA9PiB7XG5cdFx0XHRcdFx0XHRpZiAoc2Vzc2lvbltrR3JhY2VmdWxseUNsb3NpbmddKSB7XG5cdFx0XHRcdFx0XHRcdHRocm93IG5ldyBFcnJvcignVGhlIHNlc3Npb24gaXMgZ3JhY2VmdWxseSBjbG9zaW5nLiBObyBuZXcgc3RyZWFtcyBhcmUgYWxsb3dlZC4nKTtcblx0XHRcdFx0XHRcdH1cblxuXHRcdFx0XHRcdFx0Y29uc3Qgc3RyZWFtID0gc2Vzc2lvbltrUmVxdWVzdF0oaGVhZGVycywgc3RyZWFtT3B0aW9ucyk7XG5cblx0XHRcdFx0XHRcdC8vIFRoZSBwcm9jZXNzIHdvbid0IGV4aXQgdW50aWwgdGhlIHNlc3Npb24gaXMgY2xvc2VkIG9yIGFsbCByZXF1ZXN0cyBhcmUgZ29uZS5cblx0XHRcdFx0XHRcdHNlc3Npb24ucmVmKCk7XG5cblx0XHRcdFx0XHRcdCsrc2Vzc2lvbltrQ3VycmVudFN0cmVhbXNDb3VudF07XG5cblx0XHRcdFx0XHRcdGlmIChzZXNzaW9uW2tDdXJyZW50U3RyZWFtc0NvdW50XSA9PT0gc2Vzc2lvbi5yZW1vdGVTZXR0aW5ncy5tYXhDb25jdXJyZW50U3RyZWFtcykge1xuXHRcdFx0XHRcdFx0XHR0aGlzLl9mcmVlU2Vzc2lvbnNDb3VudC0tO1xuXHRcdFx0XHRcdFx0fVxuXG5cdFx0XHRcdFx0XHRzdHJlYW0ub25jZSgnY2xvc2UnLCAoKSA9PiB7XG5cdFx0XHRcdFx0XHRcdHdhc0ZyZWUgPSBpc0ZyZWUoKTtcblxuXHRcdFx0XHRcdFx0XHQtLXNlc3Npb25ba0N1cnJlbnRTdHJlYW1zQ291bnRdO1xuXG5cdFx0XHRcdFx0XHRcdGlmICghc2Vzc2lvbi5kZXN0cm95ZWQgJiYgIXNlc3Npb24uY2xvc2VkKSB7XG5cdFx0XHRcdFx0XHRcdFx0Y2xvc2VTZXNzaW9uSWZDb3ZlcmVkKHRoaXMuc2Vzc2lvbnNbbm9ybWFsaXplZE9wdGlvbnNdLCBzZXNzaW9uKTtcblxuXHRcdFx0XHRcdFx0XHRcdGlmIChpc0ZyZWUoKSAmJiAhc2Vzc2lvbi5jbG9zZWQpIHtcblx0XHRcdFx0XHRcdFx0XHRcdGlmICghd2FzRnJlZSkge1xuXHRcdFx0XHRcdFx0XHRcdFx0XHR0aGlzLl9mcmVlU2Vzc2lvbnNDb3VudCsrO1xuXG5cdFx0XHRcdFx0XHRcdFx0XHRcdHdhc0ZyZWUgPSB0cnVlO1xuXHRcdFx0XHRcdFx0XHRcdFx0fVxuXG5cdFx0XHRcdFx0XHRcdFx0XHRjb25zdCBpc0VtcHR5ID0gc2Vzc2lvbltrQ3VycmVudFN0cmVhbXNDb3VudF0gPT09IDA7XG5cblx0XHRcdFx0XHRcdFx0XHRcdGlmIChpc0VtcHR5KSB7XG5cdFx0XHRcdFx0XHRcdFx0XHRcdHNlc3Npb24udW5yZWYoKTtcblx0XHRcdFx0XHRcdFx0XHRcdH1cblxuXHRcdFx0XHRcdFx0XHRcdFx0aWYgKFxuXHRcdFx0XHRcdFx0XHRcdFx0XHRpc0VtcHR5ICYmXG5cdFx0XHRcdFx0XHRcdFx0XHRcdChcblx0XHRcdFx0XHRcdFx0XHRcdFx0XHR0aGlzLl9mcmVlU2Vzc2lvbnNDb3VudCA+IHRoaXMubWF4RnJlZVNlc3Npb25zIHx8XG5cdFx0XHRcdFx0XHRcdFx0XHRcdFx0c2Vzc2lvbltrR3JhY2VmdWxseUNsb3NpbmddXG5cdFx0XHRcdFx0XHRcdFx0XHRcdClcblx0XHRcdFx0XHRcdFx0XHRcdCkge1xuXHRcdFx0XHRcdFx0XHRcdFx0XHRzZXNzaW9uLmNsb3NlKCk7XG5cdFx0XHRcdFx0XHRcdFx0XHR9IGVsc2Uge1xuXHRcdFx0XHRcdFx0XHRcdFx0XHRjbG9zZUNvdmVyZWRTZXNzaW9ucyh0aGlzLnNlc3Npb25zW25vcm1hbGl6ZWRPcHRpb25zXSwgc2Vzc2lvbik7XG5cdFx0XHRcdFx0XHRcdFx0XHRcdHByb2Nlc3NMaXN0ZW5lcnMoKTtcblx0XHRcdFx0XHRcdFx0XHRcdH1cblx0XHRcdFx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0XHRcdH1cblx0XHRcdFx0XHRcdH0pO1xuXG5cdFx0XHRcdFx0XHRyZXR1cm4gc3RyZWFtO1xuXHRcdFx0XHRcdH07XG5cdFx0XHRcdH0gY2F0Y2ggKGVycm9yKSB7XG5cdFx0XHRcdFx0Zm9yIChjb25zdCBsaXN0ZW5lciBvZiBsaXN0ZW5lcnMpIHtcblx0XHRcdFx0XHRcdGxpc3RlbmVyLnJlamVjdChlcnJvcik7XG5cdFx0XHRcdFx0fVxuXG5cdFx0XHRcdFx0cmVtb3ZlRnJvbVF1ZXVlKCk7XG5cdFx0XHRcdH1cblx0XHRcdH07XG5cblx0XHRcdGVudHJ5Lmxpc3RlbmVycyA9IGxpc3RlbmVycztcblx0XHRcdGVudHJ5LmNvbXBsZXRlZCA9IGZhbHNlO1xuXHRcdFx0ZW50cnkuZGVzdHJveWVkID0gZmFsc2U7XG5cblx0XHRcdHRoaXMucXVldWVbbm9ybWFsaXplZE9wdGlvbnNdW25vcm1hbGl6ZWRPcmlnaW5dID0gZW50cnk7XG5cdFx0XHR0aGlzLl90cnlUb0NyZWF0ZU5ld1Nlc3Npb24obm9ybWFsaXplZE9wdGlvbnMsIG5vcm1hbGl6ZWRPcmlnaW4pO1xuXHRcdH0pO1xuXHR9XG5cblx0cmVxdWVzdChvcmlnaW4sIG9wdGlvbnMsIGhlYWRlcnMsIHN0cmVhbU9wdGlvbnMpIHtcblx0XHRyZXR1cm4gbmV3IFByb21pc2UoKHJlc29sdmUsIHJlamVjdCkgPT4ge1xuXHRcdFx0dGhpcy5nZXRTZXNzaW9uKG9yaWdpbiwgb3B0aW9ucywgW3tcblx0XHRcdFx0cmVqZWN0LFxuXHRcdFx0XHRyZXNvbHZlOiBzZXNzaW9uID0+IHtcblx0XHRcdFx0XHR0cnkge1xuXHRcdFx0XHRcdFx0cmVzb2x2ZShzZXNzaW9uLnJlcXVlc3QoaGVhZGVycywgc3RyZWFtT3B0aW9ucykpO1xuXHRcdFx0XHRcdH0gY2F0Y2ggKGVycm9yKSB7XG5cdFx0XHRcdFx0XHRyZWplY3QoZXJyb3IpO1xuXHRcdFx0XHRcdH1cblx0XHRcdFx0fVxuXHRcdFx0fV0pO1xuXHRcdH0pO1xuXHR9XG5cblx0Y3JlYXRlQ29ubmVjdGlvbihvcmlnaW4sIG9wdGlvbnMpIHtcblx0XHRyZXR1cm4gQWdlbnQuY29ubmVjdChvcmlnaW4sIG9wdGlvbnMpO1xuXHR9XG5cblx0c3RhdGljIGNvbm5lY3Qob3JpZ2luLCBvcHRpb25zKSB7XG5cdFx0b3B0aW9ucy5BTFBOUHJvdG9jb2xzID0gWydoMiddO1xuXG5cdFx0Y29uc3QgcG9ydCA9IG9yaWdpbi5wb3J0IHx8IDQ0Mztcblx0XHRjb25zdCBob3N0ID0gb3JpZ2luLmhvc3RuYW1lIHx8IG9yaWdpbi5ob3N0O1xuXG5cdFx0aWYgKHR5cGVvZiBvcHRpb25zLnNlcnZlcm5hbWUgPT09ICd1bmRlZmluZWQnKSB7XG5cdFx0XHRvcHRpb25zLnNlcnZlcm5hbWUgPSBob3N0O1xuXHRcdH1cblxuXHRcdHJldHVybiB0bHMuY29ubmVjdChwb3J0LCBob3N0LCBvcHRpb25zKTtcblx0fVxuXG5cdGNsb3NlRnJlZVNlc3Npb25zKCkge1xuXHRcdGZvciAoY29uc3Qgc2Vzc2lvbnMgb2YgT2JqZWN0LnZhbHVlcyh0aGlzLnNlc3Npb25zKSkge1xuXHRcdFx0Zm9yIChjb25zdCBzZXNzaW9uIG9mIHNlc3Npb25zKSB7XG5cdFx0XHRcdGlmIChzZXNzaW9uW2tDdXJyZW50U3RyZWFtc0NvdW50XSA9PT0gMCkge1xuXHRcdFx0XHRcdHNlc3Npb24uY2xvc2UoKTtcblx0XHRcdFx0fVxuXHRcdFx0fVxuXHRcdH1cblx0fVxuXG5cdGRlc3Ryb3kocmVhc29uKSB7XG5cdFx0Zm9yIChjb25zdCBzZXNzaW9ucyBvZiBPYmplY3QudmFsdWVzKHRoaXMuc2Vzc2lvbnMpKSB7XG5cdFx0XHRmb3IgKGNvbnN0IHNlc3Npb24gb2Ygc2Vzc2lvbnMpIHtcblx0XHRcdFx0c2Vzc2lvbi5kZXN0cm95KHJlYXNvbik7XG5cdFx0XHR9XG5cdFx0fVxuXG5cdFx0Zm9yIChjb25zdCBlbnRyaWVzT2ZBdXRob3JpdHkgb2YgT2JqZWN0LnZhbHVlcyh0aGlzLnF1ZXVlKSkge1xuXHRcdFx0Zm9yIChjb25zdCBlbnRyeSBvZiBPYmplY3QudmFsdWVzKGVudHJpZXNPZkF1dGhvcml0eSkpIHtcblx0XHRcdFx0ZW50cnkuZGVzdHJveWVkID0gdHJ1ZTtcblx0XHRcdH1cblx0XHR9XG5cblx0XHQvLyBOZXcgcmVxdWVzdHMgc2hvdWxkIE5PVCBhdHRhY2ggdG8gZGVzdHJveWVkIHNlc3Npb25zXG5cdFx0dGhpcy5xdWV1ZSA9IHt9O1xuXHR9XG5cblx0Z2V0IGZyZWVTZXNzaW9ucygpIHtcblx0XHRyZXR1cm4gZ2V0U2Vzc2lvbnMoe2FnZW50OiB0aGlzLCBpc0ZyZWU6IHRydWV9KTtcblx0fVxuXG5cdGdldCBidXN5U2Vzc2lvbnMoKSB7XG5cdFx0cmV0dXJuIGdldFNlc3Npb25zKHthZ2VudDogdGhpcywgaXNGcmVlOiBmYWxzZX0pO1xuXHR9XG59XG5cbkFnZW50LmtDdXJyZW50U3RyZWFtc0NvdW50ID0ga0N1cnJlbnRTdHJlYW1zQ291bnQ7XG5BZ2VudC5rR3JhY2VmdWxseUNsb3NpbmcgPSBrR3JhY2VmdWxseUNsb3Npbmc7XG5cbm1vZHVsZS5leHBvcnRzID0ge1xuXHRBZ2VudCxcblx0Z2xvYmFsQWdlbnQ6IG5ldyBBZ2VudCgpXG59O1xuIl0sIm5hbWVzIjpbXSwiaWdub3JlTGlzdCI6WzBdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/swarm-js/node_modules/http2-wrapper/source/agent.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/swarm-js/node_modules/http2-wrapper/source/auto.js":
/*!*************************************************************************!*\
  !*** ./node_modules/swarm-js/node_modules/http2-wrapper/source/auto.js ***!
  \*************************************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";
eval("\nconst http = __webpack_require__(/*! http */ \"http\");\nconst https = __webpack_require__(/*! https */ \"https\");\nconst resolveALPN = __webpack_require__(/*! resolve-alpn */ \"(ssr)/./node_modules/resolve-alpn/index.js\");\nconst QuickLRU = __webpack_require__(/*! quick-lru */ \"(ssr)/./node_modules/quick-lru/index.js\");\nconst Http2ClientRequest = __webpack_require__(/*! ./client-request */ \"(ssr)/./node_modules/swarm-js/node_modules/http2-wrapper/source/client-request.js\");\nconst calculateServerName = __webpack_require__(/*! ./utils/calculate-server-name */ \"(ssr)/./node_modules/swarm-js/node_modules/http2-wrapper/source/utils/calculate-server-name.js\");\nconst urlToOptions = __webpack_require__(/*! ./utils/url-to-options */ \"(ssr)/./node_modules/swarm-js/node_modules/http2-wrapper/source/utils/url-to-options.js\");\n\nconst cache = new QuickLRU({maxSize: 100});\nconst queue = new Map();\n\nconst installSocket = (agent, socket, options) => {\n\tsocket._httpMessage = {shouldKeepAlive: true};\n\n\tconst onFree = () => {\n\t\tagent.emit('free', socket, options);\n\t};\n\n\tsocket.on('free', onFree);\n\n\tconst onClose = () => {\n\t\tagent.removeSocket(socket, options);\n\t};\n\n\tsocket.on('close', onClose);\n\n\tconst onRemove = () => {\n\t\tagent.removeSocket(socket, options);\n\t\tsocket.off('close', onClose);\n\t\tsocket.off('free', onFree);\n\t\tsocket.off('agentRemove', onRemove);\n\t};\n\n\tsocket.on('agentRemove', onRemove);\n\n\tagent.emit('free', socket, options);\n};\n\nconst resolveProtocol = async options => {\n\tconst name = `${options.host}:${options.port}:${options.ALPNProtocols.sort()}`;\n\n\tif (!cache.has(name)) {\n\t\tif (queue.has(name)) {\n\t\t\tconst result = await queue.get(name);\n\t\t\treturn result.alpnProtocol;\n\t\t}\n\n\t\tconst {path, agent} = options;\n\t\toptions.path = options.socketPath;\n\n\t\tconst resultPromise = resolveALPN(options);\n\t\tqueue.set(name, resultPromise);\n\n\t\ttry {\n\t\t\tconst {socket, alpnProtocol} = await resultPromise;\n\t\t\tcache.set(name, alpnProtocol);\n\n\t\t\toptions.path = path;\n\n\t\t\tif (alpnProtocol === 'h2') {\n\t\t\t\t// https://github.com/nodejs/node/issues/33343\n\t\t\t\tsocket.destroy();\n\t\t\t} else {\n\t\t\t\tconst {globalAgent} = https;\n\t\t\t\tconst defaultCreateConnection = https.Agent.prototype.createConnection;\n\n\t\t\t\tif (agent) {\n\t\t\t\t\tif (agent.createConnection === defaultCreateConnection) {\n\t\t\t\t\t\tinstallSocket(agent, socket, options);\n\t\t\t\t\t} else {\n\t\t\t\t\t\tsocket.destroy();\n\t\t\t\t\t}\n\t\t\t\t} else if (globalAgent.createConnection === defaultCreateConnection) {\n\t\t\t\t\tinstallSocket(globalAgent, socket, options);\n\t\t\t\t} else {\n\t\t\t\t\tsocket.destroy();\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tqueue.delete(name);\n\n\t\t\treturn alpnProtocol;\n\t\t} catch (error) {\n\t\t\tqueue.delete(name);\n\n\t\t\tthrow error;\n\t\t}\n\t}\n\n\treturn cache.get(name);\n};\n\nmodule.exports = async (input, options, callback) => {\n\tif (typeof input === 'string' || input instanceof URL) {\n\t\tinput = urlToOptions(new URL(input));\n\t}\n\n\tif (typeof options === 'function') {\n\t\tcallback = options;\n\t\toptions = undefined;\n\t}\n\n\toptions = {\n\t\tALPNProtocols: ['h2', 'http/1.1'],\n\t\t...input,\n\t\t...options,\n\t\tresolveSocket: true\n\t};\n\n\tif (!Array.isArray(options.ALPNProtocols) || options.ALPNProtocols.length === 0) {\n\t\tthrow new Error('The `ALPNProtocols` option must be an Array with at least one entry');\n\t}\n\n\toptions.protocol = options.protocol || 'https:';\n\tconst isHttps = options.protocol === 'https:';\n\n\toptions.host = options.hostname || options.host || 'localhost';\n\toptions.session = options.tlsSession;\n\toptions.servername = options.servername || calculateServerName(options);\n\toptions.port = options.port || (isHttps ? 443 : 80);\n\toptions._defaultAgent = isHttps ? https.globalAgent : http.globalAgent;\n\n\tconst agents = options.agent;\n\n\tif (agents) {\n\t\tif (agents.addRequest) {\n\t\t\tthrow new Error('The `options.agent` object can contain only `http`, `https` or `http2` properties');\n\t\t}\n\n\t\toptions.agent = agents[isHttps ? 'https' : 'http'];\n\t}\n\n\tif (isHttps) {\n\t\tconst protocol = await resolveProtocol(options);\n\n\t\tif (protocol === 'h2') {\n\t\t\tif (agents) {\n\t\t\t\toptions.agent = agents.http2;\n\t\t\t}\n\n\t\t\treturn new Http2ClientRequest(options, callback);\n\t\t}\n\t}\n\n\treturn http.request(options, callback);\n};\n\nmodule.exports.protocolCache = cache;\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvc3dhcm0tanMvbm9kZV9tb2R1bGVzL2h0dHAyLXdyYXBwZXIvc291cmNlL2F1dG8uanMiLCJtYXBwaW5ncyI6IkFBQWE7QUFDYixhQUFhLG1CQUFPLENBQUMsa0JBQU07QUFDM0IsY0FBYyxtQkFBTyxDQUFDLG9CQUFPO0FBQzdCLG9CQUFvQixtQkFBTyxDQUFDLGdFQUFjO0FBQzFDLGlCQUFpQixtQkFBTyxDQUFDLDBEQUFXO0FBQ3BDLDJCQUEyQixtQkFBTyxDQUFDLDJHQUFrQjtBQUNyRCw0QkFBNEIsbUJBQU8sQ0FBQyxxSUFBK0I7QUFDbkUscUJBQXFCLG1CQUFPLENBQUMsdUhBQXdCOztBQUVyRCw0QkFBNEIsYUFBYTtBQUN6Qzs7QUFFQTtBQUNBLHdCQUF3Qjs7QUFFeEI7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQTtBQUNBLGlCQUFpQixhQUFhLEdBQUcsYUFBYSxHQUFHLDZCQUE2Qjs7QUFFOUU7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQSxTQUFTLGFBQWE7QUFDdEI7O0FBRUE7QUFDQTs7QUFFQTtBQUNBLFVBQVUsc0JBQXNCO0FBQ2hDOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTCxXQUFXLGFBQWE7QUFDeEI7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0EsSUFBSTtBQUNKOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQSw0QkFBNEIiLCJzb3VyY2VzIjpbIi9Vc2Vycy9wYW56YS9Eb2N1bWVudHMvUGVyc29uYWxQcm9qZWN0cy9wcmVkaWsvbm9kZV9tb2R1bGVzL3N3YXJtLWpzL25vZGVfbW9kdWxlcy9odHRwMi13cmFwcGVyL3NvdXJjZS9hdXRvLmpzIl0sInNvdXJjZXNDb250ZW50IjpbIid1c2Ugc3RyaWN0JztcbmNvbnN0IGh0dHAgPSByZXF1aXJlKCdodHRwJyk7XG5jb25zdCBodHRwcyA9IHJlcXVpcmUoJ2h0dHBzJyk7XG5jb25zdCByZXNvbHZlQUxQTiA9IHJlcXVpcmUoJ3Jlc29sdmUtYWxwbicpO1xuY29uc3QgUXVpY2tMUlUgPSByZXF1aXJlKCdxdWljay1scnUnKTtcbmNvbnN0IEh0dHAyQ2xpZW50UmVxdWVzdCA9IHJlcXVpcmUoJy4vY2xpZW50LXJlcXVlc3QnKTtcbmNvbnN0IGNhbGN1bGF0ZVNlcnZlck5hbWUgPSByZXF1aXJlKCcuL3V0aWxzL2NhbGN1bGF0ZS1zZXJ2ZXItbmFtZScpO1xuY29uc3QgdXJsVG9PcHRpb25zID0gcmVxdWlyZSgnLi91dGlscy91cmwtdG8tb3B0aW9ucycpO1xuXG5jb25zdCBjYWNoZSA9IG5ldyBRdWlja0xSVSh7bWF4U2l6ZTogMTAwfSk7XG5jb25zdCBxdWV1ZSA9IG5ldyBNYXAoKTtcblxuY29uc3QgaW5zdGFsbFNvY2tldCA9IChhZ2VudCwgc29ja2V0LCBvcHRpb25zKSA9PiB7XG5cdHNvY2tldC5faHR0cE1lc3NhZ2UgPSB7c2hvdWxkS2VlcEFsaXZlOiB0cnVlfTtcblxuXHRjb25zdCBvbkZyZWUgPSAoKSA9PiB7XG5cdFx0YWdlbnQuZW1pdCgnZnJlZScsIHNvY2tldCwgb3B0aW9ucyk7XG5cdH07XG5cblx0c29ja2V0Lm9uKCdmcmVlJywgb25GcmVlKTtcblxuXHRjb25zdCBvbkNsb3NlID0gKCkgPT4ge1xuXHRcdGFnZW50LnJlbW92ZVNvY2tldChzb2NrZXQsIG9wdGlvbnMpO1xuXHR9O1xuXG5cdHNvY2tldC5vbignY2xvc2UnLCBvbkNsb3NlKTtcblxuXHRjb25zdCBvblJlbW92ZSA9ICgpID0+IHtcblx0XHRhZ2VudC5yZW1vdmVTb2NrZXQoc29ja2V0LCBvcHRpb25zKTtcblx0XHRzb2NrZXQub2ZmKCdjbG9zZScsIG9uQ2xvc2UpO1xuXHRcdHNvY2tldC5vZmYoJ2ZyZWUnLCBvbkZyZWUpO1xuXHRcdHNvY2tldC5vZmYoJ2FnZW50UmVtb3ZlJywgb25SZW1vdmUpO1xuXHR9O1xuXG5cdHNvY2tldC5vbignYWdlbnRSZW1vdmUnLCBvblJlbW92ZSk7XG5cblx0YWdlbnQuZW1pdCgnZnJlZScsIHNvY2tldCwgb3B0aW9ucyk7XG59O1xuXG5jb25zdCByZXNvbHZlUHJvdG9jb2wgPSBhc3luYyBvcHRpb25zID0+IHtcblx0Y29uc3QgbmFtZSA9IGAke29wdGlvbnMuaG9zdH06JHtvcHRpb25zLnBvcnR9OiR7b3B0aW9ucy5BTFBOUHJvdG9jb2xzLnNvcnQoKX1gO1xuXG5cdGlmICghY2FjaGUuaGFzKG5hbWUpKSB7XG5cdFx0aWYgKHF1ZXVlLmhhcyhuYW1lKSkge1xuXHRcdFx0Y29uc3QgcmVzdWx0ID0gYXdhaXQgcXVldWUuZ2V0KG5hbWUpO1xuXHRcdFx0cmV0dXJuIHJlc3VsdC5hbHBuUHJvdG9jb2w7XG5cdFx0fVxuXG5cdFx0Y29uc3Qge3BhdGgsIGFnZW50fSA9IG9wdGlvbnM7XG5cdFx0b3B0aW9ucy5wYXRoID0gb3B0aW9ucy5zb2NrZXRQYXRoO1xuXG5cdFx0Y29uc3QgcmVzdWx0UHJvbWlzZSA9IHJlc29sdmVBTFBOKG9wdGlvbnMpO1xuXHRcdHF1ZXVlLnNldChuYW1lLCByZXN1bHRQcm9taXNlKTtcblxuXHRcdHRyeSB7XG5cdFx0XHRjb25zdCB7c29ja2V0LCBhbHBuUHJvdG9jb2x9ID0gYXdhaXQgcmVzdWx0UHJvbWlzZTtcblx0XHRcdGNhY2hlLnNldChuYW1lLCBhbHBuUHJvdG9jb2wpO1xuXG5cdFx0XHRvcHRpb25zLnBhdGggPSBwYXRoO1xuXG5cdFx0XHRpZiAoYWxwblByb3RvY29sID09PSAnaDInKSB7XG5cdFx0XHRcdC8vIGh0dHBzOi8vZ2l0aHViLmNvbS9ub2RlanMvbm9kZS9pc3N1ZXMvMzMzNDNcblx0XHRcdFx0c29ja2V0LmRlc3Ryb3koKTtcblx0XHRcdH0gZWxzZSB7XG5cdFx0XHRcdGNvbnN0IHtnbG9iYWxBZ2VudH0gPSBodHRwcztcblx0XHRcdFx0Y29uc3QgZGVmYXVsdENyZWF0ZUNvbm5lY3Rpb24gPSBodHRwcy5BZ2VudC5wcm90b3R5cGUuY3JlYXRlQ29ubmVjdGlvbjtcblxuXHRcdFx0XHRpZiAoYWdlbnQpIHtcblx0XHRcdFx0XHRpZiAoYWdlbnQuY3JlYXRlQ29ubmVjdGlvbiA9PT0gZGVmYXVsdENyZWF0ZUNvbm5lY3Rpb24pIHtcblx0XHRcdFx0XHRcdGluc3RhbGxTb2NrZXQoYWdlbnQsIHNvY2tldCwgb3B0aW9ucyk7XG5cdFx0XHRcdFx0fSBlbHNlIHtcblx0XHRcdFx0XHRcdHNvY2tldC5kZXN0cm95KCk7XG5cdFx0XHRcdFx0fVxuXHRcdFx0XHR9IGVsc2UgaWYgKGdsb2JhbEFnZW50LmNyZWF0ZUNvbm5lY3Rpb24gPT09IGRlZmF1bHRDcmVhdGVDb25uZWN0aW9uKSB7XG5cdFx0XHRcdFx0aW5zdGFsbFNvY2tldChnbG9iYWxBZ2VudCwgc29ja2V0LCBvcHRpb25zKTtcblx0XHRcdFx0fSBlbHNlIHtcblx0XHRcdFx0XHRzb2NrZXQuZGVzdHJveSgpO1xuXHRcdFx0XHR9XG5cdFx0XHR9XG5cblx0XHRcdHF1ZXVlLmRlbGV0ZShuYW1lKTtcblxuXHRcdFx0cmV0dXJuIGFscG5Qcm90b2NvbDtcblx0XHR9IGNhdGNoIChlcnJvcikge1xuXHRcdFx0cXVldWUuZGVsZXRlKG5hbWUpO1xuXG5cdFx0XHR0aHJvdyBlcnJvcjtcblx0XHR9XG5cdH1cblxuXHRyZXR1cm4gY2FjaGUuZ2V0KG5hbWUpO1xufTtcblxubW9kdWxlLmV4cG9ydHMgPSBhc3luYyAoaW5wdXQsIG9wdGlvbnMsIGNhbGxiYWNrKSA9PiB7XG5cdGlmICh0eXBlb2YgaW5wdXQgPT09ICdzdHJpbmcnIHx8IGlucHV0IGluc3RhbmNlb2YgVVJMKSB7XG5cdFx0aW5wdXQgPSB1cmxUb09wdGlvbnMobmV3IFVSTChpbnB1dCkpO1xuXHR9XG5cblx0aWYgKHR5cGVvZiBvcHRpb25zID09PSAnZnVuY3Rpb24nKSB7XG5cdFx0Y2FsbGJhY2sgPSBvcHRpb25zO1xuXHRcdG9wdGlvbnMgPSB1bmRlZmluZWQ7XG5cdH1cblxuXHRvcHRpb25zID0ge1xuXHRcdEFMUE5Qcm90b2NvbHM6IFsnaDInLCAnaHR0cC8xLjEnXSxcblx0XHQuLi5pbnB1dCxcblx0XHQuLi5vcHRpb25zLFxuXHRcdHJlc29sdmVTb2NrZXQ6IHRydWVcblx0fTtcblxuXHRpZiAoIUFycmF5LmlzQXJyYXkob3B0aW9ucy5BTFBOUHJvdG9jb2xzKSB8fCBvcHRpb25zLkFMUE5Qcm90b2NvbHMubGVuZ3RoID09PSAwKSB7XG5cdFx0dGhyb3cgbmV3IEVycm9yKCdUaGUgYEFMUE5Qcm90b2NvbHNgIG9wdGlvbiBtdXN0IGJlIGFuIEFycmF5IHdpdGggYXQgbGVhc3Qgb25lIGVudHJ5Jyk7XG5cdH1cblxuXHRvcHRpb25zLnByb3RvY29sID0gb3B0aW9ucy5wcm90b2NvbCB8fCAnaHR0cHM6Jztcblx0Y29uc3QgaXNIdHRwcyA9IG9wdGlvbnMucHJvdG9jb2wgPT09ICdodHRwczonO1xuXG5cdG9wdGlvbnMuaG9zdCA9IG9wdGlvbnMuaG9zdG5hbWUgfHwgb3B0aW9ucy5ob3N0IHx8ICdsb2NhbGhvc3QnO1xuXHRvcHRpb25zLnNlc3Npb24gPSBvcHRpb25zLnRsc1Nlc3Npb247XG5cdG9wdGlvbnMuc2VydmVybmFtZSA9IG9wdGlvbnMuc2VydmVybmFtZSB8fCBjYWxjdWxhdGVTZXJ2ZXJOYW1lKG9wdGlvbnMpO1xuXHRvcHRpb25zLnBvcnQgPSBvcHRpb25zLnBvcnQgfHwgKGlzSHR0cHMgPyA0NDMgOiA4MCk7XG5cdG9wdGlvbnMuX2RlZmF1bHRBZ2VudCA9IGlzSHR0cHMgPyBodHRwcy5nbG9iYWxBZ2VudCA6IGh0dHAuZ2xvYmFsQWdlbnQ7XG5cblx0Y29uc3QgYWdlbnRzID0gb3B0aW9ucy5hZ2VudDtcblxuXHRpZiAoYWdlbnRzKSB7XG5cdFx0aWYgKGFnZW50cy5hZGRSZXF1ZXN0KSB7XG5cdFx0XHR0aHJvdyBuZXcgRXJyb3IoJ1RoZSBgb3B0aW9ucy5hZ2VudGAgb2JqZWN0IGNhbiBjb250YWluIG9ubHkgYGh0dHBgLCBgaHR0cHNgIG9yIGBodHRwMmAgcHJvcGVydGllcycpO1xuXHRcdH1cblxuXHRcdG9wdGlvbnMuYWdlbnQgPSBhZ2VudHNbaXNIdHRwcyA/ICdodHRwcycgOiAnaHR0cCddO1xuXHR9XG5cblx0aWYgKGlzSHR0cHMpIHtcblx0XHRjb25zdCBwcm90b2NvbCA9IGF3YWl0IHJlc29sdmVQcm90b2NvbChvcHRpb25zKTtcblxuXHRcdGlmIChwcm90b2NvbCA9PT0gJ2gyJykge1xuXHRcdFx0aWYgKGFnZW50cykge1xuXHRcdFx0XHRvcHRpb25zLmFnZW50ID0gYWdlbnRzLmh0dHAyO1xuXHRcdFx0fVxuXG5cdFx0XHRyZXR1cm4gbmV3IEh0dHAyQ2xpZW50UmVxdWVzdChvcHRpb25zLCBjYWxsYmFjayk7XG5cdFx0fVxuXHR9XG5cblx0cmV0dXJuIGh0dHAucmVxdWVzdChvcHRpb25zLCBjYWxsYmFjayk7XG59O1xuXG5tb2R1bGUuZXhwb3J0cy5wcm90b2NvbENhY2hlID0gY2FjaGU7XG4iXSwibmFtZXMiOltdLCJpZ25vcmVMaXN0IjpbMF0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/swarm-js/node_modules/http2-wrapper/source/auto.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/swarm-js/node_modules/http2-wrapper/source/client-request.js":
/*!***********************************************************************************!*\
  !*** ./node_modules/swarm-js/node_modules/http2-wrapper/source/client-request.js ***!
  \***********************************************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";
eval("\nconst http2 = __webpack_require__(/*! http2 */ \"http2\");\nconst {Writable} = __webpack_require__(/*! stream */ \"stream\");\nconst {Agent, globalAgent} = __webpack_require__(/*! ./agent */ \"(ssr)/./node_modules/swarm-js/node_modules/http2-wrapper/source/agent.js\");\nconst IncomingMessage = __webpack_require__(/*! ./incoming-message */ \"(ssr)/./node_modules/swarm-js/node_modules/http2-wrapper/source/incoming-message.js\");\nconst urlToOptions = __webpack_require__(/*! ./utils/url-to-options */ \"(ssr)/./node_modules/swarm-js/node_modules/http2-wrapper/source/utils/url-to-options.js\");\nconst proxyEvents = __webpack_require__(/*! ./utils/proxy-events */ \"(ssr)/./node_modules/swarm-js/node_modules/http2-wrapper/source/utils/proxy-events.js\");\nconst isRequestPseudoHeader = __webpack_require__(/*! ./utils/is-request-pseudo-header */ \"(ssr)/./node_modules/swarm-js/node_modules/http2-wrapper/source/utils/is-request-pseudo-header.js\");\nconst {\n\tERR_INVALID_ARG_TYPE,\n\tERR_INVALID_PROTOCOL,\n\tERR_HTTP_HEADERS_SENT,\n\tERR_INVALID_HTTP_TOKEN,\n\tERR_HTTP_INVALID_HEADER_VALUE,\n\tERR_INVALID_CHAR\n} = __webpack_require__(/*! ./utils/errors */ \"(ssr)/./node_modules/swarm-js/node_modules/http2-wrapper/source/utils/errors.js\");\n\nconst {\n\tHTTP2_HEADER_STATUS,\n\tHTTP2_HEADER_METHOD,\n\tHTTP2_HEADER_PATH,\n\tHTTP2_METHOD_CONNECT\n} = http2.constants;\n\nconst kHeaders = Symbol('headers');\nconst kOrigin = Symbol('origin');\nconst kSession = Symbol('session');\nconst kOptions = Symbol('options');\nconst kFlushedHeaders = Symbol('flushedHeaders');\nconst kJobs = Symbol('jobs');\n\nconst isValidHttpToken = /^[\\^`\\-\\w!#$%&*+.|~]+$/;\nconst isInvalidHeaderValue = /[^\\t\\u0020-\\u007E\\u0080-\\u00FF]/;\n\nclass ClientRequest extends Writable {\n\tconstructor(input, options, callback) {\n\t\tsuper({\n\t\t\tautoDestroy: false\n\t\t});\n\n\t\tconst hasInput = typeof input === 'string' || input instanceof URL;\n\t\tif (hasInput) {\n\t\t\tinput = urlToOptions(input instanceof URL ? input : new URL(input));\n\t\t}\n\n\t\tif (typeof options === 'function' || options === undefined) {\n\t\t\t// (options, callback)\n\t\t\tcallback = options;\n\t\t\toptions = hasInput ? input : {...input};\n\t\t} else {\n\t\t\t// (input, options, callback)\n\t\t\toptions = {...input, ...options};\n\t\t}\n\n\t\tif (options.h2session) {\n\t\t\tthis[kSession] = options.h2session;\n\t\t} else if (options.agent === false) {\n\t\t\tthis.agent = new Agent({maxFreeSessions: 0});\n\t\t} else if (typeof options.agent === 'undefined' || options.agent === null) {\n\t\t\tif (typeof options.createConnection === 'function') {\n\t\t\t\t// This is a workaround - we don't have to create the session on our own.\n\t\t\t\tthis.agent = new Agent({maxFreeSessions: 0});\n\t\t\t\tthis.agent.createConnection = options.createConnection;\n\t\t\t} else {\n\t\t\t\tthis.agent = globalAgent;\n\t\t\t}\n\t\t} else if (typeof options.agent.request === 'function') {\n\t\t\tthis.agent = options.agent;\n\t\t} else {\n\t\t\tthrow new ERR_INVALID_ARG_TYPE('options.agent', ['Agent-like Object', 'undefined', 'false'], options.agent);\n\t\t}\n\n\t\tif (options.protocol && options.protocol !== 'https:') {\n\t\t\tthrow new ERR_INVALID_PROTOCOL(options.protocol, 'https:');\n\t\t}\n\n\t\tconst port = options.port || options.defaultPort || (this.agent && this.agent.defaultPort) || 443;\n\t\tconst host = options.hostname || options.host || 'localhost';\n\n\t\t// Don't enforce the origin via options. It may be changed in an Agent.\n\t\tdelete options.hostname;\n\t\tdelete options.host;\n\t\tdelete options.port;\n\n\t\tconst {timeout} = options;\n\t\toptions.timeout = undefined;\n\n\t\tthis[kHeaders] = Object.create(null);\n\t\tthis[kJobs] = [];\n\n\t\tthis.socket = null;\n\t\tthis.connection = null;\n\n\t\tthis.method = options.method || 'GET';\n\t\tthis.path = options.path;\n\n\t\tthis.res = null;\n\t\tthis.aborted = false;\n\t\tthis.reusedSocket = false;\n\n\t\tif (options.headers) {\n\t\t\tfor (const [header, value] of Object.entries(options.headers)) {\n\t\t\t\tthis.setHeader(header, value);\n\t\t\t}\n\t\t}\n\n\t\tif (options.auth && !('authorization' in this[kHeaders])) {\n\t\t\tthis[kHeaders].authorization = 'Basic ' + Buffer.from(options.auth).toString('base64');\n\t\t}\n\n\t\toptions.session = options.tlsSession;\n\t\toptions.path = options.socketPath;\n\n\t\tthis[kOptions] = options;\n\n\t\t// Clients that generate HTTP/2 requests directly SHOULD use the :authority pseudo-header field instead of the Host header field.\n\t\tif (port === 443) {\n\t\t\tthis[kOrigin] = `https://${host}`;\n\n\t\t\tif (!(':authority' in this[kHeaders])) {\n\t\t\t\tthis[kHeaders][':authority'] = host;\n\t\t\t}\n\t\t} else {\n\t\t\tthis[kOrigin] = `https://${host}:${port}`;\n\n\t\t\tif (!(':authority' in this[kHeaders])) {\n\t\t\t\tthis[kHeaders][':authority'] = `${host}:${port}`;\n\t\t\t}\n\t\t}\n\n\t\tif (timeout) {\n\t\t\tthis.setTimeout(timeout);\n\t\t}\n\n\t\tif (callback) {\n\t\t\tthis.once('response', callback);\n\t\t}\n\n\t\tthis[kFlushedHeaders] = false;\n\t}\n\n\tget method() {\n\t\treturn this[kHeaders][HTTP2_HEADER_METHOD];\n\t}\n\n\tset method(value) {\n\t\tif (value) {\n\t\t\tthis[kHeaders][HTTP2_HEADER_METHOD] = value.toUpperCase();\n\t\t}\n\t}\n\n\tget path() {\n\t\treturn this[kHeaders][HTTP2_HEADER_PATH];\n\t}\n\n\tset path(value) {\n\t\tif (value) {\n\t\t\tthis[kHeaders][HTTP2_HEADER_PATH] = value;\n\t\t}\n\t}\n\n\tget _mustNotHaveABody() {\n\t\treturn this.method === 'GET' || this.method === 'HEAD' || this.method === 'DELETE';\n\t}\n\n\t_write(chunk, encoding, callback) {\n\t\t// https://github.com/nodejs/node/blob/654df09ae0c5e17d1b52a900a545f0664d8c7627/lib/internal/http2/util.js#L148-L156\n\t\tif (this._mustNotHaveABody) {\n\t\t\tcallback(new Error('The GET, HEAD and DELETE methods must NOT have a body'));\n\t\t\t/* istanbul ignore next: Node.js 12 throws directly */\n\t\t\treturn;\n\t\t}\n\n\t\tthis.flushHeaders();\n\n\t\tconst callWrite = () => this._request.write(chunk, encoding, callback);\n\t\tif (this._request) {\n\t\t\tcallWrite();\n\t\t} else {\n\t\t\tthis[kJobs].push(callWrite);\n\t\t}\n\t}\n\n\t_final(callback) {\n\t\tif (this.destroyed) {\n\t\t\treturn;\n\t\t}\n\n\t\tthis.flushHeaders();\n\n\t\tconst callEnd = () => {\n\t\t\t// For GET, HEAD and DELETE\n\t\t\tif (this._mustNotHaveABody) {\n\t\t\t\tcallback();\n\t\t\t\treturn;\n\t\t\t}\n\n\t\t\tthis._request.end(callback);\n\t\t};\n\n\t\tif (this._request) {\n\t\t\tcallEnd();\n\t\t} else {\n\t\t\tthis[kJobs].push(callEnd);\n\t\t}\n\t}\n\n\tabort() {\n\t\tif (this.res && this.res.complete) {\n\t\t\treturn;\n\t\t}\n\n\t\tif (!this.aborted) {\n\t\t\tprocess.nextTick(() => this.emit('abort'));\n\t\t}\n\n\t\tthis.aborted = true;\n\n\t\tthis.destroy();\n\t}\n\n\t_destroy(error, callback) {\n\t\tif (this.res) {\n\t\t\tthis.res._dump();\n\t\t}\n\n\t\tif (this._request) {\n\t\t\tthis._request.destroy();\n\t\t}\n\n\t\tcallback(error);\n\t}\n\n\tasync flushHeaders() {\n\t\tif (this[kFlushedHeaders] || this.destroyed) {\n\t\t\treturn;\n\t\t}\n\n\t\tthis[kFlushedHeaders] = true;\n\n\t\tconst isConnectMethod = this.method === HTTP2_METHOD_CONNECT;\n\n\t\t// The real magic is here\n\t\tconst onStream = stream => {\n\t\t\tthis._request = stream;\n\n\t\t\tif (this.destroyed) {\n\t\t\t\tstream.destroy();\n\t\t\t\treturn;\n\t\t\t}\n\n\t\t\t// Forwards `timeout`, `continue`, `close` and `error` events to this instance.\n\t\t\tif (!isConnectMethod) {\n\t\t\t\tproxyEvents(stream, this, ['timeout', 'continue', 'close', 'error']);\n\t\t\t}\n\n\t\t\t// Wait for the `finish` event. We don't want to emit the `response` event\n\t\t\t// before `request.end()` is called.\n\t\t\tconst waitForEnd = fn => {\n\t\t\t\treturn (...args) => {\n\t\t\t\t\tif (!this.writable && !this.destroyed) {\n\t\t\t\t\t\tfn(...args);\n\t\t\t\t\t} else {\n\t\t\t\t\t\tthis.once('finish', () => {\n\t\t\t\t\t\t\tfn(...args);\n\t\t\t\t\t\t});\n\t\t\t\t\t}\n\t\t\t\t};\n\t\t\t};\n\n\t\t\t// This event tells we are ready to listen for the data.\n\t\t\tstream.once('response', waitForEnd((headers, flags, rawHeaders) => {\n\t\t\t\t// If we were to emit raw request stream, it would be as fast as the native approach.\n\t\t\t\t// Note that wrapping the raw stream in a Proxy instance won't improve the performance (already tested it).\n\t\t\t\tconst response = new IncomingMessage(this.socket, stream.readableHighWaterMark);\n\t\t\t\tthis.res = response;\n\n\t\t\t\tresponse.req = this;\n\t\t\t\tresponse.statusCode = headers[HTTP2_HEADER_STATUS];\n\t\t\t\tresponse.headers = headers;\n\t\t\t\tresponse.rawHeaders = rawHeaders;\n\n\t\t\t\tresponse.once('end', () => {\n\t\t\t\t\tif (this.aborted) {\n\t\t\t\t\t\tresponse.aborted = true;\n\t\t\t\t\t\tresponse.emit('aborted');\n\t\t\t\t\t} else {\n\t\t\t\t\t\tresponse.complete = true;\n\n\t\t\t\t\t\t// Has no effect, just be consistent with the Node.js behavior\n\t\t\t\t\t\tresponse.socket = null;\n\t\t\t\t\t\tresponse.connection = null;\n\t\t\t\t\t}\n\t\t\t\t});\n\n\t\t\t\tif (isConnectMethod) {\n\t\t\t\t\tresponse.upgrade = true;\n\n\t\t\t\t\t// The HTTP1 API says the socket is detached here,\n\t\t\t\t\t// but we can't do that so we pass the original HTTP2 request.\n\t\t\t\t\tif (this.emit('connect', response, stream, Buffer.alloc(0))) {\n\t\t\t\t\t\tthis.emit('close');\n\t\t\t\t\t} else {\n\t\t\t\t\t\t// No listeners attached, destroy the original request.\n\t\t\t\t\t\tstream.destroy();\n\t\t\t\t\t}\n\t\t\t\t} else {\n\t\t\t\t\t// Forwards data\n\t\t\t\t\tstream.on('data', chunk => {\n\t\t\t\t\t\tif (!response._dumped && !response.push(chunk)) {\n\t\t\t\t\t\t\tstream.pause();\n\t\t\t\t\t\t}\n\t\t\t\t\t});\n\n\t\t\t\t\tstream.once('end', () => {\n\t\t\t\t\t\tresponse.push(null);\n\t\t\t\t\t});\n\n\t\t\t\t\tif (!this.emit('response', response)) {\n\t\t\t\t\t\t// No listeners attached, dump the response.\n\t\t\t\t\t\tresponse._dump();\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}));\n\n\t\t\t// Emits `information` event\n\t\t\tstream.once('headers', waitForEnd(\n\t\t\t\theaders => this.emit('information', {statusCode: headers[HTTP2_HEADER_STATUS]})\n\t\t\t));\n\n\t\t\tstream.once('trailers', waitForEnd((trailers, flags, rawTrailers) => {\n\t\t\t\tconst {res} = this;\n\n\t\t\t\t// Assigns trailers to the response object.\n\t\t\t\tres.trailers = trailers;\n\t\t\t\tres.rawTrailers = rawTrailers;\n\t\t\t}));\n\n\t\t\tconst {socket} = stream.session;\n\t\t\tthis.socket = socket;\n\t\t\tthis.connection = socket;\n\n\t\t\tfor (const job of this[kJobs]) {\n\t\t\t\tjob();\n\t\t\t}\n\n\t\t\tthis.emit('socket', this.socket);\n\t\t};\n\n\t\t// Makes a HTTP2 request\n\t\tif (this[kSession]) {\n\t\t\ttry {\n\t\t\t\tonStream(this[kSession].request(this[kHeaders]));\n\t\t\t} catch (error) {\n\t\t\t\tthis.emit('error', error);\n\t\t\t}\n\t\t} else {\n\t\t\tthis.reusedSocket = true;\n\n\t\t\ttry {\n\t\t\t\tonStream(await this.agent.request(this[kOrigin], this[kOptions], this[kHeaders]));\n\t\t\t} catch (error) {\n\t\t\t\tthis.emit('error', error);\n\t\t\t}\n\t\t}\n\t}\n\n\tgetHeader(name) {\n\t\tif (typeof name !== 'string') {\n\t\t\tthrow new ERR_INVALID_ARG_TYPE('name', 'string', name);\n\t\t}\n\n\t\treturn this[kHeaders][name.toLowerCase()];\n\t}\n\n\tget headersSent() {\n\t\treturn this[kFlushedHeaders];\n\t}\n\n\tremoveHeader(name) {\n\t\tif (typeof name !== 'string') {\n\t\t\tthrow new ERR_INVALID_ARG_TYPE('name', 'string', name);\n\t\t}\n\n\t\tif (this.headersSent) {\n\t\t\tthrow new ERR_HTTP_HEADERS_SENT('remove');\n\t\t}\n\n\t\tdelete this[kHeaders][name.toLowerCase()];\n\t}\n\n\tsetHeader(name, value) {\n\t\tif (this.headersSent) {\n\t\t\tthrow new ERR_HTTP_HEADERS_SENT('set');\n\t\t}\n\n\t\tif (typeof name !== 'string' || (!isValidHttpToken.test(name) && !isRequestPseudoHeader(name))) {\n\t\t\tthrow new ERR_INVALID_HTTP_TOKEN('Header name', name);\n\t\t}\n\n\t\tif (typeof value === 'undefined') {\n\t\t\tthrow new ERR_HTTP_INVALID_HEADER_VALUE(value, name);\n\t\t}\n\n\t\tif (isInvalidHeaderValue.test(value)) {\n\t\t\tthrow new ERR_INVALID_CHAR('header content', name);\n\t\t}\n\n\t\tthis[kHeaders][name.toLowerCase()] = value;\n\t}\n\n\tsetNoDelay() {\n\t\t// HTTP2 sockets cannot be malformed, do nothing.\n\t}\n\n\tsetSocketKeepAlive() {\n\t\t// HTTP2 sockets cannot be malformed, do nothing.\n\t}\n\n\tsetTimeout(ms, callback) {\n\t\tconst applyTimeout = () => this._request.setTimeout(ms, callback);\n\n\t\tif (this._request) {\n\t\t\tapplyTimeout();\n\t\t} else {\n\t\t\tthis[kJobs].push(applyTimeout);\n\t\t}\n\n\t\treturn this;\n\t}\n\n\tget maxHeadersCount() {\n\t\tif (!this.destroyed && this._request) {\n\t\t\treturn this._request.session.localSettings.maxHeaderListSize;\n\t\t}\n\n\t\treturn undefined;\n\t}\n\n\tset maxHeadersCount(_value) {\n\t\t// Updating HTTP2 settings would affect all requests, do nothing.\n\t}\n}\n\nmodule.exports = ClientRequest;\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvc3dhcm0tanMvbm9kZV9tb2R1bGVzL2h0dHAyLXdyYXBwZXIvc291cmNlL2NsaWVudC1yZXF1ZXN0LmpzIiwibWFwcGluZ3MiOiJBQUFhO0FBQ2IsY0FBYyxtQkFBTyxDQUFDLG9CQUFPO0FBQzdCLE9BQU8sVUFBVSxFQUFFLG1CQUFPLENBQUMsc0JBQVE7QUFDbkMsT0FBTyxvQkFBb0IsRUFBRSxtQkFBTyxDQUFDLHlGQUFTO0FBQzlDLHdCQUF3QixtQkFBTyxDQUFDLCtHQUFvQjtBQUNwRCxxQkFBcUIsbUJBQU8sQ0FBQyx1SEFBd0I7QUFDckQsb0JBQW9CLG1CQUFPLENBQUMsbUhBQXNCO0FBQ2xELDhCQUE4QixtQkFBTyxDQUFDLDJJQUFrQztBQUN4RTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEVBQUUsRUFBRSxtQkFBTyxDQUFDLHVHQUFnQjs7QUFFNUI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEVBQUU7O0FBRUY7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHOztBQUVIO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLGlDQUFpQztBQUNqQyxJQUFJO0FBQ0o7QUFDQSxjQUFjO0FBQ2Q7O0FBRUE7QUFDQTtBQUNBLElBQUk7QUFDSiwyQkFBMkIsbUJBQW1CO0FBQzlDLElBQUk7QUFDSjtBQUNBO0FBQ0EsNEJBQTRCLG1CQUFtQjtBQUMvQztBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0EsSUFBSTtBQUNKO0FBQ0EsSUFBSTtBQUNKO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUEsU0FBUyxTQUFTO0FBQ2xCOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQSw4QkFBOEIsS0FBSzs7QUFFbkM7QUFDQTtBQUNBO0FBQ0EsSUFBSTtBQUNKLDhCQUE4QixLQUFLLEdBQUcsS0FBSzs7QUFFM0M7QUFDQSxzQ0FBc0MsS0FBSyxHQUFHLEtBQUs7QUFDbkQ7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLElBQUk7QUFDSjtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLElBQUk7QUFDSjtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLOztBQUVMO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNOztBQUVOO0FBQ0E7QUFDQSxNQUFNOztBQUVOO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxJQUFJOztBQUVKO0FBQ0E7QUFDQSx5Q0FBeUMseUNBQXlDO0FBQ2xGOztBQUVBO0FBQ0EsV0FBVyxLQUFLOztBQUVoQjtBQUNBO0FBQ0E7QUFDQSxJQUFJOztBQUVKLFVBQVUsUUFBUTtBQUNsQjtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQSxJQUFJO0FBQ0o7O0FBRUE7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsSUFBSTtBQUNKO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBIiwic291cmNlcyI6WyIvVXNlcnMvcGFuemEvRG9jdW1lbnRzL1BlcnNvbmFsUHJvamVjdHMvcHJlZGlrL25vZGVfbW9kdWxlcy9zd2FybS1qcy9ub2RlX21vZHVsZXMvaHR0cDItd3JhcHBlci9zb3VyY2UvY2xpZW50LXJlcXVlc3QuanMiXSwic291cmNlc0NvbnRlbnQiOlsiJ3VzZSBzdHJpY3QnO1xuY29uc3QgaHR0cDIgPSByZXF1aXJlKCdodHRwMicpO1xuY29uc3Qge1dyaXRhYmxlfSA9IHJlcXVpcmUoJ3N0cmVhbScpO1xuY29uc3Qge0FnZW50LCBnbG9iYWxBZ2VudH0gPSByZXF1aXJlKCcuL2FnZW50Jyk7XG5jb25zdCBJbmNvbWluZ01lc3NhZ2UgPSByZXF1aXJlKCcuL2luY29taW5nLW1lc3NhZ2UnKTtcbmNvbnN0IHVybFRvT3B0aW9ucyA9IHJlcXVpcmUoJy4vdXRpbHMvdXJsLXRvLW9wdGlvbnMnKTtcbmNvbnN0IHByb3h5RXZlbnRzID0gcmVxdWlyZSgnLi91dGlscy9wcm94eS1ldmVudHMnKTtcbmNvbnN0IGlzUmVxdWVzdFBzZXVkb0hlYWRlciA9IHJlcXVpcmUoJy4vdXRpbHMvaXMtcmVxdWVzdC1wc2V1ZG8taGVhZGVyJyk7XG5jb25zdCB7XG5cdEVSUl9JTlZBTElEX0FSR19UWVBFLFxuXHRFUlJfSU5WQUxJRF9QUk9UT0NPTCxcblx0RVJSX0hUVFBfSEVBREVSU19TRU5ULFxuXHRFUlJfSU5WQUxJRF9IVFRQX1RPS0VOLFxuXHRFUlJfSFRUUF9JTlZBTElEX0hFQURFUl9WQUxVRSxcblx0RVJSX0lOVkFMSURfQ0hBUlxufSA9IHJlcXVpcmUoJy4vdXRpbHMvZXJyb3JzJyk7XG5cbmNvbnN0IHtcblx0SFRUUDJfSEVBREVSX1NUQVRVUyxcblx0SFRUUDJfSEVBREVSX01FVEhPRCxcblx0SFRUUDJfSEVBREVSX1BBVEgsXG5cdEhUVFAyX01FVEhPRF9DT05ORUNUXG59ID0gaHR0cDIuY29uc3RhbnRzO1xuXG5jb25zdCBrSGVhZGVycyA9IFN5bWJvbCgnaGVhZGVycycpO1xuY29uc3Qga09yaWdpbiA9IFN5bWJvbCgnb3JpZ2luJyk7XG5jb25zdCBrU2Vzc2lvbiA9IFN5bWJvbCgnc2Vzc2lvbicpO1xuY29uc3Qga09wdGlvbnMgPSBTeW1ib2woJ29wdGlvbnMnKTtcbmNvbnN0IGtGbHVzaGVkSGVhZGVycyA9IFN5bWJvbCgnZmx1c2hlZEhlYWRlcnMnKTtcbmNvbnN0IGtKb2JzID0gU3ltYm9sKCdqb2JzJyk7XG5cbmNvbnN0IGlzVmFsaWRIdHRwVG9rZW4gPSAvXltcXF5gXFwtXFx3ISMkJSYqKy58fl0rJC87XG5jb25zdCBpc0ludmFsaWRIZWFkZXJWYWx1ZSA9IC9bXlxcdFxcdTAwMjAtXFx1MDA3RVxcdTAwODAtXFx1MDBGRl0vO1xuXG5jbGFzcyBDbGllbnRSZXF1ZXN0IGV4dGVuZHMgV3JpdGFibGUge1xuXHRjb25zdHJ1Y3RvcihpbnB1dCwgb3B0aW9ucywgY2FsbGJhY2spIHtcblx0XHRzdXBlcih7XG5cdFx0XHRhdXRvRGVzdHJveTogZmFsc2Vcblx0XHR9KTtcblxuXHRcdGNvbnN0IGhhc0lucHV0ID0gdHlwZW9mIGlucHV0ID09PSAnc3RyaW5nJyB8fCBpbnB1dCBpbnN0YW5jZW9mIFVSTDtcblx0XHRpZiAoaGFzSW5wdXQpIHtcblx0XHRcdGlucHV0ID0gdXJsVG9PcHRpb25zKGlucHV0IGluc3RhbmNlb2YgVVJMID8gaW5wdXQgOiBuZXcgVVJMKGlucHV0KSk7XG5cdFx0fVxuXG5cdFx0aWYgKHR5cGVvZiBvcHRpb25zID09PSAnZnVuY3Rpb24nIHx8IG9wdGlvbnMgPT09IHVuZGVmaW5lZCkge1xuXHRcdFx0Ly8gKG9wdGlvbnMsIGNhbGxiYWNrKVxuXHRcdFx0Y2FsbGJhY2sgPSBvcHRpb25zO1xuXHRcdFx0b3B0aW9ucyA9IGhhc0lucHV0ID8gaW5wdXQgOiB7Li4uaW5wdXR9O1xuXHRcdH0gZWxzZSB7XG5cdFx0XHQvLyAoaW5wdXQsIG9wdGlvbnMsIGNhbGxiYWNrKVxuXHRcdFx0b3B0aW9ucyA9IHsuLi5pbnB1dCwgLi4ub3B0aW9uc307XG5cdFx0fVxuXG5cdFx0aWYgKG9wdGlvbnMuaDJzZXNzaW9uKSB7XG5cdFx0XHR0aGlzW2tTZXNzaW9uXSA9IG9wdGlvbnMuaDJzZXNzaW9uO1xuXHRcdH0gZWxzZSBpZiAob3B0aW9ucy5hZ2VudCA9PT0gZmFsc2UpIHtcblx0XHRcdHRoaXMuYWdlbnQgPSBuZXcgQWdlbnQoe21heEZyZWVTZXNzaW9uczogMH0pO1xuXHRcdH0gZWxzZSBpZiAodHlwZW9mIG9wdGlvbnMuYWdlbnQgPT09ICd1bmRlZmluZWQnIHx8IG9wdGlvbnMuYWdlbnQgPT09IG51bGwpIHtcblx0XHRcdGlmICh0eXBlb2Ygb3B0aW9ucy5jcmVhdGVDb25uZWN0aW9uID09PSAnZnVuY3Rpb24nKSB7XG5cdFx0XHRcdC8vIFRoaXMgaXMgYSB3b3JrYXJvdW5kIC0gd2UgZG9uJ3QgaGF2ZSB0byBjcmVhdGUgdGhlIHNlc3Npb24gb24gb3VyIG93bi5cblx0XHRcdFx0dGhpcy5hZ2VudCA9IG5ldyBBZ2VudCh7bWF4RnJlZVNlc3Npb25zOiAwfSk7XG5cdFx0XHRcdHRoaXMuYWdlbnQuY3JlYXRlQ29ubmVjdGlvbiA9IG9wdGlvbnMuY3JlYXRlQ29ubmVjdGlvbjtcblx0XHRcdH0gZWxzZSB7XG5cdFx0XHRcdHRoaXMuYWdlbnQgPSBnbG9iYWxBZ2VudDtcblx0XHRcdH1cblx0XHR9IGVsc2UgaWYgKHR5cGVvZiBvcHRpb25zLmFnZW50LnJlcXVlc3QgPT09ICdmdW5jdGlvbicpIHtcblx0XHRcdHRoaXMuYWdlbnQgPSBvcHRpb25zLmFnZW50O1xuXHRcdH0gZWxzZSB7XG5cdFx0XHR0aHJvdyBuZXcgRVJSX0lOVkFMSURfQVJHX1RZUEUoJ29wdGlvbnMuYWdlbnQnLCBbJ0FnZW50LWxpa2UgT2JqZWN0JywgJ3VuZGVmaW5lZCcsICdmYWxzZSddLCBvcHRpb25zLmFnZW50KTtcblx0XHR9XG5cblx0XHRpZiAob3B0aW9ucy5wcm90b2NvbCAmJiBvcHRpb25zLnByb3RvY29sICE9PSAnaHR0cHM6Jykge1xuXHRcdFx0dGhyb3cgbmV3IEVSUl9JTlZBTElEX1BST1RPQ09MKG9wdGlvbnMucHJvdG9jb2wsICdodHRwczonKTtcblx0XHR9XG5cblx0XHRjb25zdCBwb3J0ID0gb3B0aW9ucy5wb3J0IHx8IG9wdGlvbnMuZGVmYXVsdFBvcnQgfHwgKHRoaXMuYWdlbnQgJiYgdGhpcy5hZ2VudC5kZWZhdWx0UG9ydCkgfHwgNDQzO1xuXHRcdGNvbnN0IGhvc3QgPSBvcHRpb25zLmhvc3RuYW1lIHx8IG9wdGlvbnMuaG9zdCB8fCAnbG9jYWxob3N0JztcblxuXHRcdC8vIERvbid0IGVuZm9yY2UgdGhlIG9yaWdpbiB2aWEgb3B0aW9ucy4gSXQgbWF5IGJlIGNoYW5nZWQgaW4gYW4gQWdlbnQuXG5cdFx0ZGVsZXRlIG9wdGlvbnMuaG9zdG5hbWU7XG5cdFx0ZGVsZXRlIG9wdGlvbnMuaG9zdDtcblx0XHRkZWxldGUgb3B0aW9ucy5wb3J0O1xuXG5cdFx0Y29uc3Qge3RpbWVvdXR9ID0gb3B0aW9ucztcblx0XHRvcHRpb25zLnRpbWVvdXQgPSB1bmRlZmluZWQ7XG5cblx0XHR0aGlzW2tIZWFkZXJzXSA9IE9iamVjdC5jcmVhdGUobnVsbCk7XG5cdFx0dGhpc1trSm9ic10gPSBbXTtcblxuXHRcdHRoaXMuc29ja2V0ID0gbnVsbDtcblx0XHR0aGlzLmNvbm5lY3Rpb24gPSBudWxsO1xuXG5cdFx0dGhpcy5tZXRob2QgPSBvcHRpb25zLm1ldGhvZCB8fCAnR0VUJztcblx0XHR0aGlzLnBhdGggPSBvcHRpb25zLnBhdGg7XG5cblx0XHR0aGlzLnJlcyA9IG51bGw7XG5cdFx0dGhpcy5hYm9ydGVkID0gZmFsc2U7XG5cdFx0dGhpcy5yZXVzZWRTb2NrZXQgPSBmYWxzZTtcblxuXHRcdGlmIChvcHRpb25zLmhlYWRlcnMpIHtcblx0XHRcdGZvciAoY29uc3QgW2hlYWRlciwgdmFsdWVdIG9mIE9iamVjdC5lbnRyaWVzKG9wdGlvbnMuaGVhZGVycykpIHtcblx0XHRcdFx0dGhpcy5zZXRIZWFkZXIoaGVhZGVyLCB2YWx1ZSk7XG5cdFx0XHR9XG5cdFx0fVxuXG5cdFx0aWYgKG9wdGlvbnMuYXV0aCAmJiAhKCdhdXRob3JpemF0aW9uJyBpbiB0aGlzW2tIZWFkZXJzXSkpIHtcblx0XHRcdHRoaXNba0hlYWRlcnNdLmF1dGhvcml6YXRpb24gPSAnQmFzaWMgJyArIEJ1ZmZlci5mcm9tKG9wdGlvbnMuYXV0aCkudG9TdHJpbmcoJ2Jhc2U2NCcpO1xuXHRcdH1cblxuXHRcdG9wdGlvbnMuc2Vzc2lvbiA9IG9wdGlvbnMudGxzU2Vzc2lvbjtcblx0XHRvcHRpb25zLnBhdGggPSBvcHRpb25zLnNvY2tldFBhdGg7XG5cblx0XHR0aGlzW2tPcHRpb25zXSA9IG9wdGlvbnM7XG5cblx0XHQvLyBDbGllbnRzIHRoYXQgZ2VuZXJhdGUgSFRUUC8yIHJlcXVlc3RzIGRpcmVjdGx5IFNIT1VMRCB1c2UgdGhlIDphdXRob3JpdHkgcHNldWRvLWhlYWRlciBmaWVsZCBpbnN0ZWFkIG9mIHRoZSBIb3N0IGhlYWRlciBmaWVsZC5cblx0XHRpZiAocG9ydCA9PT0gNDQzKSB7XG5cdFx0XHR0aGlzW2tPcmlnaW5dID0gYGh0dHBzOi8vJHtob3N0fWA7XG5cblx0XHRcdGlmICghKCc6YXV0aG9yaXR5JyBpbiB0aGlzW2tIZWFkZXJzXSkpIHtcblx0XHRcdFx0dGhpc1trSGVhZGVyc11bJzphdXRob3JpdHknXSA9IGhvc3Q7XG5cdFx0XHR9XG5cdFx0fSBlbHNlIHtcblx0XHRcdHRoaXNba09yaWdpbl0gPSBgaHR0cHM6Ly8ke2hvc3R9OiR7cG9ydH1gO1xuXG5cdFx0XHRpZiAoISgnOmF1dGhvcml0eScgaW4gdGhpc1trSGVhZGVyc10pKSB7XG5cdFx0XHRcdHRoaXNba0hlYWRlcnNdWyc6YXV0aG9yaXR5J10gPSBgJHtob3N0fToke3BvcnR9YDtcblx0XHRcdH1cblx0XHR9XG5cblx0XHRpZiAodGltZW91dCkge1xuXHRcdFx0dGhpcy5zZXRUaW1lb3V0KHRpbWVvdXQpO1xuXHRcdH1cblxuXHRcdGlmIChjYWxsYmFjaykge1xuXHRcdFx0dGhpcy5vbmNlKCdyZXNwb25zZScsIGNhbGxiYWNrKTtcblx0XHR9XG5cblx0XHR0aGlzW2tGbHVzaGVkSGVhZGVyc10gPSBmYWxzZTtcblx0fVxuXG5cdGdldCBtZXRob2QoKSB7XG5cdFx0cmV0dXJuIHRoaXNba0hlYWRlcnNdW0hUVFAyX0hFQURFUl9NRVRIT0RdO1xuXHR9XG5cblx0c2V0IG1ldGhvZCh2YWx1ZSkge1xuXHRcdGlmICh2YWx1ZSkge1xuXHRcdFx0dGhpc1trSGVhZGVyc11bSFRUUDJfSEVBREVSX01FVEhPRF0gPSB2YWx1ZS50b1VwcGVyQ2FzZSgpO1xuXHRcdH1cblx0fVxuXG5cdGdldCBwYXRoKCkge1xuXHRcdHJldHVybiB0aGlzW2tIZWFkZXJzXVtIVFRQMl9IRUFERVJfUEFUSF07XG5cdH1cblxuXHRzZXQgcGF0aCh2YWx1ZSkge1xuXHRcdGlmICh2YWx1ZSkge1xuXHRcdFx0dGhpc1trSGVhZGVyc11bSFRUUDJfSEVBREVSX1BBVEhdID0gdmFsdWU7XG5cdFx0fVxuXHR9XG5cblx0Z2V0IF9tdXN0Tm90SGF2ZUFCb2R5KCkge1xuXHRcdHJldHVybiB0aGlzLm1ldGhvZCA9PT0gJ0dFVCcgfHwgdGhpcy5tZXRob2QgPT09ICdIRUFEJyB8fCB0aGlzLm1ldGhvZCA9PT0gJ0RFTEVURSc7XG5cdH1cblxuXHRfd3JpdGUoY2h1bmssIGVuY29kaW5nLCBjYWxsYmFjaykge1xuXHRcdC8vIGh0dHBzOi8vZ2l0aHViLmNvbS9ub2RlanMvbm9kZS9ibG9iLzY1NGRmMDlhZTBjNWUxN2QxYjUyYTkwMGE1NDVmMDY2NGQ4Yzc2MjcvbGliL2ludGVybmFsL2h0dHAyL3V0aWwuanMjTDE0OC1MMTU2XG5cdFx0aWYgKHRoaXMuX211c3ROb3RIYXZlQUJvZHkpIHtcblx0XHRcdGNhbGxiYWNrKG5ldyBFcnJvcignVGhlIEdFVCwgSEVBRCBhbmQgREVMRVRFIG1ldGhvZHMgbXVzdCBOT1QgaGF2ZSBhIGJvZHknKSk7XG5cdFx0XHQvKiBpc3RhbmJ1bCBpZ25vcmUgbmV4dDogTm9kZS5qcyAxMiB0aHJvd3MgZGlyZWN0bHkgKi9cblx0XHRcdHJldHVybjtcblx0XHR9XG5cblx0XHR0aGlzLmZsdXNoSGVhZGVycygpO1xuXG5cdFx0Y29uc3QgY2FsbFdyaXRlID0gKCkgPT4gdGhpcy5fcmVxdWVzdC53cml0ZShjaHVuaywgZW5jb2RpbmcsIGNhbGxiYWNrKTtcblx0XHRpZiAodGhpcy5fcmVxdWVzdCkge1xuXHRcdFx0Y2FsbFdyaXRlKCk7XG5cdFx0fSBlbHNlIHtcblx0XHRcdHRoaXNba0pvYnNdLnB1c2goY2FsbFdyaXRlKTtcblx0XHR9XG5cdH1cblxuXHRfZmluYWwoY2FsbGJhY2spIHtcblx0XHRpZiAodGhpcy5kZXN0cm95ZWQpIHtcblx0XHRcdHJldHVybjtcblx0XHR9XG5cblx0XHR0aGlzLmZsdXNoSGVhZGVycygpO1xuXG5cdFx0Y29uc3QgY2FsbEVuZCA9ICgpID0+IHtcblx0XHRcdC8vIEZvciBHRVQsIEhFQUQgYW5kIERFTEVURVxuXHRcdFx0aWYgKHRoaXMuX211c3ROb3RIYXZlQUJvZHkpIHtcblx0XHRcdFx0Y2FsbGJhY2soKTtcblx0XHRcdFx0cmV0dXJuO1xuXHRcdFx0fVxuXG5cdFx0XHR0aGlzLl9yZXF1ZXN0LmVuZChjYWxsYmFjayk7XG5cdFx0fTtcblxuXHRcdGlmICh0aGlzLl9yZXF1ZXN0KSB7XG5cdFx0XHRjYWxsRW5kKCk7XG5cdFx0fSBlbHNlIHtcblx0XHRcdHRoaXNba0pvYnNdLnB1c2goY2FsbEVuZCk7XG5cdFx0fVxuXHR9XG5cblx0YWJvcnQoKSB7XG5cdFx0aWYgKHRoaXMucmVzICYmIHRoaXMucmVzLmNvbXBsZXRlKSB7XG5cdFx0XHRyZXR1cm47XG5cdFx0fVxuXG5cdFx0aWYgKCF0aGlzLmFib3J0ZWQpIHtcblx0XHRcdHByb2Nlc3MubmV4dFRpY2soKCkgPT4gdGhpcy5lbWl0KCdhYm9ydCcpKTtcblx0XHR9XG5cblx0XHR0aGlzLmFib3J0ZWQgPSB0cnVlO1xuXG5cdFx0dGhpcy5kZXN0cm95KCk7XG5cdH1cblxuXHRfZGVzdHJveShlcnJvciwgY2FsbGJhY2spIHtcblx0XHRpZiAodGhpcy5yZXMpIHtcblx0XHRcdHRoaXMucmVzLl9kdW1wKCk7XG5cdFx0fVxuXG5cdFx0aWYgKHRoaXMuX3JlcXVlc3QpIHtcblx0XHRcdHRoaXMuX3JlcXVlc3QuZGVzdHJveSgpO1xuXHRcdH1cblxuXHRcdGNhbGxiYWNrKGVycm9yKTtcblx0fVxuXG5cdGFzeW5jIGZsdXNoSGVhZGVycygpIHtcblx0XHRpZiAodGhpc1trRmx1c2hlZEhlYWRlcnNdIHx8IHRoaXMuZGVzdHJveWVkKSB7XG5cdFx0XHRyZXR1cm47XG5cdFx0fVxuXG5cdFx0dGhpc1trRmx1c2hlZEhlYWRlcnNdID0gdHJ1ZTtcblxuXHRcdGNvbnN0IGlzQ29ubmVjdE1ldGhvZCA9IHRoaXMubWV0aG9kID09PSBIVFRQMl9NRVRIT0RfQ09OTkVDVDtcblxuXHRcdC8vIFRoZSByZWFsIG1hZ2ljIGlzIGhlcmVcblx0XHRjb25zdCBvblN0cmVhbSA9IHN0cmVhbSA9PiB7XG5cdFx0XHR0aGlzLl9yZXF1ZXN0ID0gc3RyZWFtO1xuXG5cdFx0XHRpZiAodGhpcy5kZXN0cm95ZWQpIHtcblx0XHRcdFx0c3RyZWFtLmRlc3Ryb3koKTtcblx0XHRcdFx0cmV0dXJuO1xuXHRcdFx0fVxuXG5cdFx0XHQvLyBGb3J3YXJkcyBgdGltZW91dGAsIGBjb250aW51ZWAsIGBjbG9zZWAgYW5kIGBlcnJvcmAgZXZlbnRzIHRvIHRoaXMgaW5zdGFuY2UuXG5cdFx0XHRpZiAoIWlzQ29ubmVjdE1ldGhvZCkge1xuXHRcdFx0XHRwcm94eUV2ZW50cyhzdHJlYW0sIHRoaXMsIFsndGltZW91dCcsICdjb250aW51ZScsICdjbG9zZScsICdlcnJvciddKTtcblx0XHRcdH1cblxuXHRcdFx0Ly8gV2FpdCBmb3IgdGhlIGBmaW5pc2hgIGV2ZW50LiBXZSBkb24ndCB3YW50IHRvIGVtaXQgdGhlIGByZXNwb25zZWAgZXZlbnRcblx0XHRcdC8vIGJlZm9yZSBgcmVxdWVzdC5lbmQoKWAgaXMgY2FsbGVkLlxuXHRcdFx0Y29uc3Qgd2FpdEZvckVuZCA9IGZuID0+IHtcblx0XHRcdFx0cmV0dXJuICguLi5hcmdzKSA9PiB7XG5cdFx0XHRcdFx0aWYgKCF0aGlzLndyaXRhYmxlICYmICF0aGlzLmRlc3Ryb3llZCkge1xuXHRcdFx0XHRcdFx0Zm4oLi4uYXJncyk7XG5cdFx0XHRcdFx0fSBlbHNlIHtcblx0XHRcdFx0XHRcdHRoaXMub25jZSgnZmluaXNoJywgKCkgPT4ge1xuXHRcdFx0XHRcdFx0XHRmbiguLi5hcmdzKTtcblx0XHRcdFx0XHRcdH0pO1xuXHRcdFx0XHRcdH1cblx0XHRcdFx0fTtcblx0XHRcdH07XG5cblx0XHRcdC8vIFRoaXMgZXZlbnQgdGVsbHMgd2UgYXJlIHJlYWR5IHRvIGxpc3RlbiBmb3IgdGhlIGRhdGEuXG5cdFx0XHRzdHJlYW0ub25jZSgncmVzcG9uc2UnLCB3YWl0Rm9yRW5kKChoZWFkZXJzLCBmbGFncywgcmF3SGVhZGVycykgPT4ge1xuXHRcdFx0XHQvLyBJZiB3ZSB3ZXJlIHRvIGVtaXQgcmF3IHJlcXVlc3Qgc3RyZWFtLCBpdCB3b3VsZCBiZSBhcyBmYXN0IGFzIHRoZSBuYXRpdmUgYXBwcm9hY2guXG5cdFx0XHRcdC8vIE5vdGUgdGhhdCB3cmFwcGluZyB0aGUgcmF3IHN0cmVhbSBpbiBhIFByb3h5IGluc3RhbmNlIHdvbid0IGltcHJvdmUgdGhlIHBlcmZvcm1hbmNlIChhbHJlYWR5IHRlc3RlZCBpdCkuXG5cdFx0XHRcdGNvbnN0IHJlc3BvbnNlID0gbmV3IEluY29taW5nTWVzc2FnZSh0aGlzLnNvY2tldCwgc3RyZWFtLnJlYWRhYmxlSGlnaFdhdGVyTWFyayk7XG5cdFx0XHRcdHRoaXMucmVzID0gcmVzcG9uc2U7XG5cblx0XHRcdFx0cmVzcG9uc2UucmVxID0gdGhpcztcblx0XHRcdFx0cmVzcG9uc2Uuc3RhdHVzQ29kZSA9IGhlYWRlcnNbSFRUUDJfSEVBREVSX1NUQVRVU107XG5cdFx0XHRcdHJlc3BvbnNlLmhlYWRlcnMgPSBoZWFkZXJzO1xuXHRcdFx0XHRyZXNwb25zZS5yYXdIZWFkZXJzID0gcmF3SGVhZGVycztcblxuXHRcdFx0XHRyZXNwb25zZS5vbmNlKCdlbmQnLCAoKSA9PiB7XG5cdFx0XHRcdFx0aWYgKHRoaXMuYWJvcnRlZCkge1xuXHRcdFx0XHRcdFx0cmVzcG9uc2UuYWJvcnRlZCA9IHRydWU7XG5cdFx0XHRcdFx0XHRyZXNwb25zZS5lbWl0KCdhYm9ydGVkJyk7XG5cdFx0XHRcdFx0fSBlbHNlIHtcblx0XHRcdFx0XHRcdHJlc3BvbnNlLmNvbXBsZXRlID0gdHJ1ZTtcblxuXHRcdFx0XHRcdFx0Ly8gSGFzIG5vIGVmZmVjdCwganVzdCBiZSBjb25zaXN0ZW50IHdpdGggdGhlIE5vZGUuanMgYmVoYXZpb3Jcblx0XHRcdFx0XHRcdHJlc3BvbnNlLnNvY2tldCA9IG51bGw7XG5cdFx0XHRcdFx0XHRyZXNwb25zZS5jb25uZWN0aW9uID0gbnVsbDtcblx0XHRcdFx0XHR9XG5cdFx0XHRcdH0pO1xuXG5cdFx0XHRcdGlmIChpc0Nvbm5lY3RNZXRob2QpIHtcblx0XHRcdFx0XHRyZXNwb25zZS51cGdyYWRlID0gdHJ1ZTtcblxuXHRcdFx0XHRcdC8vIFRoZSBIVFRQMSBBUEkgc2F5cyB0aGUgc29ja2V0IGlzIGRldGFjaGVkIGhlcmUsXG5cdFx0XHRcdFx0Ly8gYnV0IHdlIGNhbid0IGRvIHRoYXQgc28gd2UgcGFzcyB0aGUgb3JpZ2luYWwgSFRUUDIgcmVxdWVzdC5cblx0XHRcdFx0XHRpZiAodGhpcy5lbWl0KCdjb25uZWN0JywgcmVzcG9uc2UsIHN0cmVhbSwgQnVmZmVyLmFsbG9jKDApKSkge1xuXHRcdFx0XHRcdFx0dGhpcy5lbWl0KCdjbG9zZScpO1xuXHRcdFx0XHRcdH0gZWxzZSB7XG5cdFx0XHRcdFx0XHQvLyBObyBsaXN0ZW5lcnMgYXR0YWNoZWQsIGRlc3Ryb3kgdGhlIG9yaWdpbmFsIHJlcXVlc3QuXG5cdFx0XHRcdFx0XHRzdHJlYW0uZGVzdHJveSgpO1xuXHRcdFx0XHRcdH1cblx0XHRcdFx0fSBlbHNlIHtcblx0XHRcdFx0XHQvLyBGb3J3YXJkcyBkYXRhXG5cdFx0XHRcdFx0c3RyZWFtLm9uKCdkYXRhJywgY2h1bmsgPT4ge1xuXHRcdFx0XHRcdFx0aWYgKCFyZXNwb25zZS5fZHVtcGVkICYmICFyZXNwb25zZS5wdXNoKGNodW5rKSkge1xuXHRcdFx0XHRcdFx0XHRzdHJlYW0ucGF1c2UoKTtcblx0XHRcdFx0XHRcdH1cblx0XHRcdFx0XHR9KTtcblxuXHRcdFx0XHRcdHN0cmVhbS5vbmNlKCdlbmQnLCAoKSA9PiB7XG5cdFx0XHRcdFx0XHRyZXNwb25zZS5wdXNoKG51bGwpO1xuXHRcdFx0XHRcdH0pO1xuXG5cdFx0XHRcdFx0aWYgKCF0aGlzLmVtaXQoJ3Jlc3BvbnNlJywgcmVzcG9uc2UpKSB7XG5cdFx0XHRcdFx0XHQvLyBObyBsaXN0ZW5lcnMgYXR0YWNoZWQsIGR1bXAgdGhlIHJlc3BvbnNlLlxuXHRcdFx0XHRcdFx0cmVzcG9uc2UuX2R1bXAoKTtcblx0XHRcdFx0XHR9XG5cdFx0XHRcdH1cblx0XHRcdH0pKTtcblxuXHRcdFx0Ly8gRW1pdHMgYGluZm9ybWF0aW9uYCBldmVudFxuXHRcdFx0c3RyZWFtLm9uY2UoJ2hlYWRlcnMnLCB3YWl0Rm9yRW5kKFxuXHRcdFx0XHRoZWFkZXJzID0+IHRoaXMuZW1pdCgnaW5mb3JtYXRpb24nLCB7c3RhdHVzQ29kZTogaGVhZGVyc1tIVFRQMl9IRUFERVJfU1RBVFVTXX0pXG5cdFx0XHQpKTtcblxuXHRcdFx0c3RyZWFtLm9uY2UoJ3RyYWlsZXJzJywgd2FpdEZvckVuZCgodHJhaWxlcnMsIGZsYWdzLCByYXdUcmFpbGVycykgPT4ge1xuXHRcdFx0XHRjb25zdCB7cmVzfSA9IHRoaXM7XG5cblx0XHRcdFx0Ly8gQXNzaWducyB0cmFpbGVycyB0byB0aGUgcmVzcG9uc2Ugb2JqZWN0LlxuXHRcdFx0XHRyZXMudHJhaWxlcnMgPSB0cmFpbGVycztcblx0XHRcdFx0cmVzLnJhd1RyYWlsZXJzID0gcmF3VHJhaWxlcnM7XG5cdFx0XHR9KSk7XG5cblx0XHRcdGNvbnN0IHtzb2NrZXR9ID0gc3RyZWFtLnNlc3Npb247XG5cdFx0XHR0aGlzLnNvY2tldCA9IHNvY2tldDtcblx0XHRcdHRoaXMuY29ubmVjdGlvbiA9IHNvY2tldDtcblxuXHRcdFx0Zm9yIChjb25zdCBqb2Igb2YgdGhpc1trSm9ic10pIHtcblx0XHRcdFx0am9iKCk7XG5cdFx0XHR9XG5cblx0XHRcdHRoaXMuZW1pdCgnc29ja2V0JywgdGhpcy5zb2NrZXQpO1xuXHRcdH07XG5cblx0XHQvLyBNYWtlcyBhIEhUVFAyIHJlcXVlc3Rcblx0XHRpZiAodGhpc1trU2Vzc2lvbl0pIHtcblx0XHRcdHRyeSB7XG5cdFx0XHRcdG9uU3RyZWFtKHRoaXNba1Nlc3Npb25dLnJlcXVlc3QodGhpc1trSGVhZGVyc10pKTtcblx0XHRcdH0gY2F0Y2ggKGVycm9yKSB7XG5cdFx0XHRcdHRoaXMuZW1pdCgnZXJyb3InLCBlcnJvcik7XG5cdFx0XHR9XG5cdFx0fSBlbHNlIHtcblx0XHRcdHRoaXMucmV1c2VkU29ja2V0ID0gdHJ1ZTtcblxuXHRcdFx0dHJ5IHtcblx0XHRcdFx0b25TdHJlYW0oYXdhaXQgdGhpcy5hZ2VudC5yZXF1ZXN0KHRoaXNba09yaWdpbl0sIHRoaXNba09wdGlvbnNdLCB0aGlzW2tIZWFkZXJzXSkpO1xuXHRcdFx0fSBjYXRjaCAoZXJyb3IpIHtcblx0XHRcdFx0dGhpcy5lbWl0KCdlcnJvcicsIGVycm9yKTtcblx0XHRcdH1cblx0XHR9XG5cdH1cblxuXHRnZXRIZWFkZXIobmFtZSkge1xuXHRcdGlmICh0eXBlb2YgbmFtZSAhPT0gJ3N0cmluZycpIHtcblx0XHRcdHRocm93IG5ldyBFUlJfSU5WQUxJRF9BUkdfVFlQRSgnbmFtZScsICdzdHJpbmcnLCBuYW1lKTtcblx0XHR9XG5cblx0XHRyZXR1cm4gdGhpc1trSGVhZGVyc11bbmFtZS50b0xvd2VyQ2FzZSgpXTtcblx0fVxuXG5cdGdldCBoZWFkZXJzU2VudCgpIHtcblx0XHRyZXR1cm4gdGhpc1trRmx1c2hlZEhlYWRlcnNdO1xuXHR9XG5cblx0cmVtb3ZlSGVhZGVyKG5hbWUpIHtcblx0XHRpZiAodHlwZW9mIG5hbWUgIT09ICdzdHJpbmcnKSB7XG5cdFx0XHR0aHJvdyBuZXcgRVJSX0lOVkFMSURfQVJHX1RZUEUoJ25hbWUnLCAnc3RyaW5nJywgbmFtZSk7XG5cdFx0fVxuXG5cdFx0aWYgKHRoaXMuaGVhZGVyc1NlbnQpIHtcblx0XHRcdHRocm93IG5ldyBFUlJfSFRUUF9IRUFERVJTX1NFTlQoJ3JlbW92ZScpO1xuXHRcdH1cblxuXHRcdGRlbGV0ZSB0aGlzW2tIZWFkZXJzXVtuYW1lLnRvTG93ZXJDYXNlKCldO1xuXHR9XG5cblx0c2V0SGVhZGVyKG5hbWUsIHZhbHVlKSB7XG5cdFx0aWYgKHRoaXMuaGVhZGVyc1NlbnQpIHtcblx0XHRcdHRocm93IG5ldyBFUlJfSFRUUF9IRUFERVJTX1NFTlQoJ3NldCcpO1xuXHRcdH1cblxuXHRcdGlmICh0eXBlb2YgbmFtZSAhPT0gJ3N0cmluZycgfHwgKCFpc1ZhbGlkSHR0cFRva2VuLnRlc3QobmFtZSkgJiYgIWlzUmVxdWVzdFBzZXVkb0hlYWRlcihuYW1lKSkpIHtcblx0XHRcdHRocm93IG5ldyBFUlJfSU5WQUxJRF9IVFRQX1RPS0VOKCdIZWFkZXIgbmFtZScsIG5hbWUpO1xuXHRcdH1cblxuXHRcdGlmICh0eXBlb2YgdmFsdWUgPT09ICd1bmRlZmluZWQnKSB7XG5cdFx0XHR0aHJvdyBuZXcgRVJSX0hUVFBfSU5WQUxJRF9IRUFERVJfVkFMVUUodmFsdWUsIG5hbWUpO1xuXHRcdH1cblxuXHRcdGlmIChpc0ludmFsaWRIZWFkZXJWYWx1ZS50ZXN0KHZhbHVlKSkge1xuXHRcdFx0dGhyb3cgbmV3IEVSUl9JTlZBTElEX0NIQVIoJ2hlYWRlciBjb250ZW50JywgbmFtZSk7XG5cdFx0fVxuXG5cdFx0dGhpc1trSGVhZGVyc11bbmFtZS50b0xvd2VyQ2FzZSgpXSA9IHZhbHVlO1xuXHR9XG5cblx0c2V0Tm9EZWxheSgpIHtcblx0XHQvLyBIVFRQMiBzb2NrZXRzIGNhbm5vdCBiZSBtYWxmb3JtZWQsIGRvIG5vdGhpbmcuXG5cdH1cblxuXHRzZXRTb2NrZXRLZWVwQWxpdmUoKSB7XG5cdFx0Ly8gSFRUUDIgc29ja2V0cyBjYW5ub3QgYmUgbWFsZm9ybWVkLCBkbyBub3RoaW5nLlxuXHR9XG5cblx0c2V0VGltZW91dChtcywgY2FsbGJhY2spIHtcblx0XHRjb25zdCBhcHBseVRpbWVvdXQgPSAoKSA9PiB0aGlzLl9yZXF1ZXN0LnNldFRpbWVvdXQobXMsIGNhbGxiYWNrKTtcblxuXHRcdGlmICh0aGlzLl9yZXF1ZXN0KSB7XG5cdFx0XHRhcHBseVRpbWVvdXQoKTtcblx0XHR9IGVsc2Uge1xuXHRcdFx0dGhpc1trSm9ic10ucHVzaChhcHBseVRpbWVvdXQpO1xuXHRcdH1cblxuXHRcdHJldHVybiB0aGlzO1xuXHR9XG5cblx0Z2V0IG1heEhlYWRlcnNDb3VudCgpIHtcblx0XHRpZiAoIXRoaXMuZGVzdHJveWVkICYmIHRoaXMuX3JlcXVlc3QpIHtcblx0XHRcdHJldHVybiB0aGlzLl9yZXF1ZXN0LnNlc3Npb24ubG9jYWxTZXR0aW5ncy5tYXhIZWFkZXJMaXN0U2l6ZTtcblx0XHR9XG5cblx0XHRyZXR1cm4gdW5kZWZpbmVkO1xuXHR9XG5cblx0c2V0IG1heEhlYWRlcnNDb3VudChfdmFsdWUpIHtcblx0XHQvLyBVcGRhdGluZyBIVFRQMiBzZXR0aW5ncyB3b3VsZCBhZmZlY3QgYWxsIHJlcXVlc3RzLCBkbyBub3RoaW5nLlxuXHR9XG59XG5cbm1vZHVsZS5leHBvcnRzID0gQ2xpZW50UmVxdWVzdDtcbiJdLCJuYW1lcyI6W10sImlnbm9yZUxpc3QiOlswXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/swarm-js/node_modules/http2-wrapper/source/client-request.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/swarm-js/node_modules/http2-wrapper/source/incoming-message.js":
/*!*************************************************************************************!*\
  !*** ./node_modules/swarm-js/node_modules/http2-wrapper/source/incoming-message.js ***!
  \*************************************************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";
eval("\nconst {Readable} = __webpack_require__(/*! stream */ \"stream\");\n\nclass IncomingMessage extends Readable {\n\tconstructor(socket, highWaterMark) {\n\t\tsuper({\n\t\t\thighWaterMark,\n\t\t\tautoDestroy: false\n\t\t});\n\n\t\tthis.statusCode = null;\n\t\tthis.statusMessage = '';\n\t\tthis.httpVersion = '2.0';\n\t\tthis.httpVersionMajor = 2;\n\t\tthis.httpVersionMinor = 0;\n\t\tthis.headers = {};\n\t\tthis.trailers = {};\n\t\tthis.req = null;\n\n\t\tthis.aborted = false;\n\t\tthis.complete = false;\n\t\tthis.upgrade = null;\n\n\t\tthis.rawHeaders = [];\n\t\tthis.rawTrailers = [];\n\n\t\tthis.socket = socket;\n\t\tthis.connection = socket;\n\n\t\tthis._dumped = false;\n\t}\n\n\t_destroy(error) {\n\t\tthis.req._request.destroy(error);\n\t}\n\n\tsetTimeout(ms, callback) {\n\t\tthis.req.setTimeout(ms, callback);\n\t\treturn this;\n\t}\n\n\t_dump() {\n\t\tif (!this._dumped) {\n\t\t\tthis._dumped = true;\n\n\t\t\tthis.removeAllListeners('data');\n\t\t\tthis.resume();\n\t\t}\n\t}\n\n\t_read() {\n\t\tif (this.req) {\n\t\t\tthis.req._request.resume();\n\t\t}\n\t}\n}\n\nmodule.exports = IncomingMessage;\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvc3dhcm0tanMvbm9kZV9tb2R1bGVzL2h0dHAyLXdyYXBwZXIvc291cmNlL2luY29taW5nLW1lc3NhZ2UuanMiLCJtYXBwaW5ncyI6IkFBQWE7QUFDYixPQUFPLFVBQVUsRUFBRSxtQkFBTyxDQUFDLHNCQUFROztBQUVuQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRzs7QUFFSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQSIsInNvdXJjZXMiOlsiL1VzZXJzL3BhbnphL0RvY3VtZW50cy9QZXJzb25hbFByb2plY3RzL3ByZWRpay9ub2RlX21vZHVsZXMvc3dhcm0tanMvbm9kZV9tb2R1bGVzL2h0dHAyLXdyYXBwZXIvc291cmNlL2luY29taW5nLW1lc3NhZ2UuanMiXSwic291cmNlc0NvbnRlbnQiOlsiJ3VzZSBzdHJpY3QnO1xuY29uc3Qge1JlYWRhYmxlfSA9IHJlcXVpcmUoJ3N0cmVhbScpO1xuXG5jbGFzcyBJbmNvbWluZ01lc3NhZ2UgZXh0ZW5kcyBSZWFkYWJsZSB7XG5cdGNvbnN0cnVjdG9yKHNvY2tldCwgaGlnaFdhdGVyTWFyaykge1xuXHRcdHN1cGVyKHtcblx0XHRcdGhpZ2hXYXRlck1hcmssXG5cdFx0XHRhdXRvRGVzdHJveTogZmFsc2Vcblx0XHR9KTtcblxuXHRcdHRoaXMuc3RhdHVzQ29kZSA9IG51bGw7XG5cdFx0dGhpcy5zdGF0dXNNZXNzYWdlID0gJyc7XG5cdFx0dGhpcy5odHRwVmVyc2lvbiA9ICcyLjAnO1xuXHRcdHRoaXMuaHR0cFZlcnNpb25NYWpvciA9IDI7XG5cdFx0dGhpcy5odHRwVmVyc2lvbk1pbm9yID0gMDtcblx0XHR0aGlzLmhlYWRlcnMgPSB7fTtcblx0XHR0aGlzLnRyYWlsZXJzID0ge307XG5cdFx0dGhpcy5yZXEgPSBudWxsO1xuXG5cdFx0dGhpcy5hYm9ydGVkID0gZmFsc2U7XG5cdFx0dGhpcy5jb21wbGV0ZSA9IGZhbHNlO1xuXHRcdHRoaXMudXBncmFkZSA9IG51bGw7XG5cblx0XHR0aGlzLnJhd0hlYWRlcnMgPSBbXTtcblx0XHR0aGlzLnJhd1RyYWlsZXJzID0gW107XG5cblx0XHR0aGlzLnNvY2tldCA9IHNvY2tldDtcblx0XHR0aGlzLmNvbm5lY3Rpb24gPSBzb2NrZXQ7XG5cblx0XHR0aGlzLl9kdW1wZWQgPSBmYWxzZTtcblx0fVxuXG5cdF9kZXN0cm95KGVycm9yKSB7XG5cdFx0dGhpcy5yZXEuX3JlcXVlc3QuZGVzdHJveShlcnJvcik7XG5cdH1cblxuXHRzZXRUaW1lb3V0KG1zLCBjYWxsYmFjaykge1xuXHRcdHRoaXMucmVxLnNldFRpbWVvdXQobXMsIGNhbGxiYWNrKTtcblx0XHRyZXR1cm4gdGhpcztcblx0fVxuXG5cdF9kdW1wKCkge1xuXHRcdGlmICghdGhpcy5fZHVtcGVkKSB7XG5cdFx0XHR0aGlzLl9kdW1wZWQgPSB0cnVlO1xuXG5cdFx0XHR0aGlzLnJlbW92ZUFsbExpc3RlbmVycygnZGF0YScpO1xuXHRcdFx0dGhpcy5yZXN1bWUoKTtcblx0XHR9XG5cdH1cblxuXHRfcmVhZCgpIHtcblx0XHRpZiAodGhpcy5yZXEpIHtcblx0XHRcdHRoaXMucmVxLl9yZXF1ZXN0LnJlc3VtZSgpO1xuXHRcdH1cblx0fVxufVxuXG5tb2R1bGUuZXhwb3J0cyA9IEluY29taW5nTWVzc2FnZTtcbiJdLCJuYW1lcyI6W10sImlnbm9yZUxpc3QiOlswXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/swarm-js/node_modules/http2-wrapper/source/incoming-message.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/swarm-js/node_modules/http2-wrapper/source/index.js":
/*!**************************************************************************!*\
  !*** ./node_modules/swarm-js/node_modules/http2-wrapper/source/index.js ***!
  \**************************************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";
eval("\nconst http2 = __webpack_require__(/*! http2 */ \"http2\");\nconst agent = __webpack_require__(/*! ./agent */ \"(ssr)/./node_modules/swarm-js/node_modules/http2-wrapper/source/agent.js\");\nconst ClientRequest = __webpack_require__(/*! ./client-request */ \"(ssr)/./node_modules/swarm-js/node_modules/http2-wrapper/source/client-request.js\");\nconst IncomingMessage = __webpack_require__(/*! ./incoming-message */ \"(ssr)/./node_modules/swarm-js/node_modules/http2-wrapper/source/incoming-message.js\");\nconst auto = __webpack_require__(/*! ./auto */ \"(ssr)/./node_modules/swarm-js/node_modules/http2-wrapper/source/auto.js\");\n\nconst request = (url, options, callback) => {\n\treturn new ClientRequest(url, options, callback);\n};\n\nconst get = (url, options, callback) => {\n\t// eslint-disable-next-line unicorn/prevent-abbreviations\n\tconst req = new ClientRequest(url, options, callback);\n\treq.end();\n\n\treturn req;\n};\n\nmodule.exports = {\n\t...http2,\n\tClientRequest,\n\tIncomingMessage,\n\t...agent,\n\trequest,\n\tget,\n\tauto\n};\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvc3dhcm0tanMvbm9kZV9tb2R1bGVzL2h0dHAyLXdyYXBwZXIvc291cmNlL2luZGV4LmpzIiwibWFwcGluZ3MiOiJBQUFhO0FBQ2IsY0FBYyxtQkFBTyxDQUFDLG9CQUFPO0FBQzdCLGNBQWMsbUJBQU8sQ0FBQyx5RkFBUztBQUMvQixzQkFBc0IsbUJBQU8sQ0FBQywyR0FBa0I7QUFDaEQsd0JBQXdCLG1CQUFPLENBQUMsK0dBQW9CO0FBQ3BELGFBQWEsbUJBQU8sQ0FBQyx1RkFBUTs7QUFFN0I7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBIiwic291cmNlcyI6WyIvVXNlcnMvcGFuemEvRG9jdW1lbnRzL1BlcnNvbmFsUHJvamVjdHMvcHJlZGlrL25vZGVfbW9kdWxlcy9zd2FybS1qcy9ub2RlX21vZHVsZXMvaHR0cDItd3JhcHBlci9zb3VyY2UvaW5kZXguanMiXSwic291cmNlc0NvbnRlbnQiOlsiJ3VzZSBzdHJpY3QnO1xuY29uc3QgaHR0cDIgPSByZXF1aXJlKCdodHRwMicpO1xuY29uc3QgYWdlbnQgPSByZXF1aXJlKCcuL2FnZW50Jyk7XG5jb25zdCBDbGllbnRSZXF1ZXN0ID0gcmVxdWlyZSgnLi9jbGllbnQtcmVxdWVzdCcpO1xuY29uc3QgSW5jb21pbmdNZXNzYWdlID0gcmVxdWlyZSgnLi9pbmNvbWluZy1tZXNzYWdlJyk7XG5jb25zdCBhdXRvID0gcmVxdWlyZSgnLi9hdXRvJyk7XG5cbmNvbnN0IHJlcXVlc3QgPSAodXJsLCBvcHRpb25zLCBjYWxsYmFjaykgPT4ge1xuXHRyZXR1cm4gbmV3IENsaWVudFJlcXVlc3QodXJsLCBvcHRpb25zLCBjYWxsYmFjayk7XG59O1xuXG5jb25zdCBnZXQgPSAodXJsLCBvcHRpb25zLCBjYWxsYmFjaykgPT4ge1xuXHQvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgdW5pY29ybi9wcmV2ZW50LWFiYnJldmlhdGlvbnNcblx0Y29uc3QgcmVxID0gbmV3IENsaWVudFJlcXVlc3QodXJsLCBvcHRpb25zLCBjYWxsYmFjayk7XG5cdHJlcS5lbmQoKTtcblxuXHRyZXR1cm4gcmVxO1xufTtcblxubW9kdWxlLmV4cG9ydHMgPSB7XG5cdC4uLmh0dHAyLFxuXHRDbGllbnRSZXF1ZXN0LFxuXHRJbmNvbWluZ01lc3NhZ2UsXG5cdC4uLmFnZW50LFxuXHRyZXF1ZXN0LFxuXHRnZXQsXG5cdGF1dG9cbn07XG4iXSwibmFtZXMiOltdLCJpZ25vcmVMaXN0IjpbMF0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/swarm-js/node_modules/http2-wrapper/source/index.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/swarm-js/node_modules/http2-wrapper/source/utils/calculate-server-name.js":
/*!************************************************************************************************!*\
  !*** ./node_modules/swarm-js/node_modules/http2-wrapper/source/utils/calculate-server-name.js ***!
  \************************************************************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";
eval("\nconst net = __webpack_require__(/*! net */ \"net\");\n/* istanbul ignore file: https://github.com/nodejs/node/blob/v13.0.1/lib/_http_agent.js */\n\nmodule.exports = options => {\n\tlet servername = options.host;\n\tconst hostHeader = options.headers && options.headers.host;\n\n\tif (hostHeader) {\n\t\tif (hostHeader.startsWith('[')) {\n\t\t\tconst index = hostHeader.indexOf(']');\n\t\t\tif (index === -1) {\n\t\t\t\tservername = hostHeader;\n\t\t\t} else {\n\t\t\t\tservername = hostHeader.slice(1, -1);\n\t\t\t}\n\t\t} else {\n\t\t\tservername = hostHeader.split(':', 1)[0];\n\t\t}\n\t}\n\n\tif (net.isIP(servername)) {\n\t\treturn '';\n\t}\n\n\treturn servername;\n};\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvc3dhcm0tanMvbm9kZV9tb2R1bGVzL2h0dHAyLXdyYXBwZXIvc291cmNlL3V0aWxzL2NhbGN1bGF0ZS1zZXJ2ZXItbmFtZS5qcyIsIm1hcHBpbmdzIjoiQUFBYTtBQUNiLFlBQVksbUJBQU8sQ0FBQyxnQkFBSztBQUN6Qjs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0EsSUFBSTtBQUNKO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSIsInNvdXJjZXMiOlsiL1VzZXJzL3BhbnphL0RvY3VtZW50cy9QZXJzb25hbFByb2plY3RzL3ByZWRpay9ub2RlX21vZHVsZXMvc3dhcm0tanMvbm9kZV9tb2R1bGVzL2h0dHAyLXdyYXBwZXIvc291cmNlL3V0aWxzL2NhbGN1bGF0ZS1zZXJ2ZXItbmFtZS5qcyJdLCJzb3VyY2VzQ29udGVudCI6WyIndXNlIHN0cmljdCc7XG5jb25zdCBuZXQgPSByZXF1aXJlKCduZXQnKTtcbi8qIGlzdGFuYnVsIGlnbm9yZSBmaWxlOiBodHRwczovL2dpdGh1Yi5jb20vbm9kZWpzL25vZGUvYmxvYi92MTMuMC4xL2xpYi9faHR0cF9hZ2VudC5qcyAqL1xuXG5tb2R1bGUuZXhwb3J0cyA9IG9wdGlvbnMgPT4ge1xuXHRsZXQgc2VydmVybmFtZSA9IG9wdGlvbnMuaG9zdDtcblx0Y29uc3QgaG9zdEhlYWRlciA9IG9wdGlvbnMuaGVhZGVycyAmJiBvcHRpb25zLmhlYWRlcnMuaG9zdDtcblxuXHRpZiAoaG9zdEhlYWRlcikge1xuXHRcdGlmIChob3N0SGVhZGVyLnN0YXJ0c1dpdGgoJ1snKSkge1xuXHRcdFx0Y29uc3QgaW5kZXggPSBob3N0SGVhZGVyLmluZGV4T2YoJ10nKTtcblx0XHRcdGlmIChpbmRleCA9PT0gLTEpIHtcblx0XHRcdFx0c2VydmVybmFtZSA9IGhvc3RIZWFkZXI7XG5cdFx0XHR9IGVsc2Uge1xuXHRcdFx0XHRzZXJ2ZXJuYW1lID0gaG9zdEhlYWRlci5zbGljZSgxLCAtMSk7XG5cdFx0XHR9XG5cdFx0fSBlbHNlIHtcblx0XHRcdHNlcnZlcm5hbWUgPSBob3N0SGVhZGVyLnNwbGl0KCc6JywgMSlbMF07XG5cdFx0fVxuXHR9XG5cblx0aWYgKG5ldC5pc0lQKHNlcnZlcm5hbWUpKSB7XG5cdFx0cmV0dXJuICcnO1xuXHR9XG5cblx0cmV0dXJuIHNlcnZlcm5hbWU7XG59O1xuIl0sIm5hbWVzIjpbXSwiaWdub3JlTGlzdCI6WzBdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/swarm-js/node_modules/http2-wrapper/source/utils/calculate-server-name.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/swarm-js/node_modules/http2-wrapper/source/utils/errors.js":
/*!*********************************************************************************!*\
  !*** ./node_modules/swarm-js/node_modules/http2-wrapper/source/utils/errors.js ***!
  \*********************************************************************************/
/***/ ((module) => {

"use strict";
eval("\n/* istanbul ignore file: https://github.com/nodejs/node/blob/master/lib/internal/errors.js */\n\nconst makeError = (Base, key, getMessage) => {\n\tmodule.exports[key] = class NodeError extends Base {\n\t\tconstructor(...args) {\n\t\t\tsuper(typeof getMessage === 'string' ? getMessage : getMessage(args));\n\t\t\tthis.name = `${super.name} [${key}]`;\n\t\t\tthis.code = key;\n\t\t}\n\t};\n};\n\nmakeError(TypeError, 'ERR_INVALID_ARG_TYPE', args => {\n\tconst type = args[0].includes('.') ? 'property' : 'argument';\n\n\tlet valid = args[1];\n\tconst isManyTypes = Array.isArray(valid);\n\n\tif (isManyTypes) {\n\t\tvalid = `${valid.slice(0, -1).join(', ')} or ${valid.slice(-1)}`;\n\t}\n\n\treturn `The \"${args[0]}\" ${type} must be ${isManyTypes ? 'one of' : 'of'} type ${valid}. Received ${typeof args[2]}`;\n});\n\nmakeError(TypeError, 'ERR_INVALID_PROTOCOL', args => {\n\treturn `Protocol \"${args[0]}\" not supported. Expected \"${args[1]}\"`;\n});\n\nmakeError(Error, 'ERR_HTTP_HEADERS_SENT', args => {\n\treturn `Cannot ${args[0]} headers after they are sent to the client`;\n});\n\nmakeError(TypeError, 'ERR_INVALID_HTTP_TOKEN', args => {\n\treturn `${args[0]} must be a valid HTTP token [${args[1]}]`;\n});\n\nmakeError(TypeError, 'ERR_HTTP_INVALID_HEADER_VALUE', args => {\n\treturn `Invalid value \"${args[0]} for header \"${args[1]}\"`;\n});\n\nmakeError(TypeError, 'ERR_INVALID_CHAR', args => {\n\treturn `Invalid character in ${args[0]} [${args[1]}]`;\n});\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvc3dhcm0tanMvbm9kZV9tb2R1bGVzL2h0dHAyLXdyYXBwZXIvc291cmNlL3V0aWxzL2Vycm9ycy5qcyIsIm1hcHBpbmdzIjoiQUFBYTtBQUNiOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esa0JBQWtCLFlBQVksR0FBRyxJQUFJO0FBQ3JDO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBLGFBQWEsK0JBQStCLEtBQUssZ0JBQWdCO0FBQ2pFOztBQUVBLGdCQUFnQixRQUFRLElBQUksTUFBTSxVQUFVLCtCQUErQixPQUFPLE1BQU0sYUFBYSxlQUFlO0FBQ3BILENBQUM7O0FBRUQ7QUFDQSxxQkFBcUIsUUFBUSw2QkFBNkIsUUFBUTtBQUNsRSxDQUFDOztBQUVEO0FBQ0Esa0JBQWtCLFNBQVM7QUFDM0IsQ0FBQzs7QUFFRDtBQUNBLFdBQVcsU0FBUyw4QkFBOEIsUUFBUTtBQUMxRCxDQUFDOztBQUVEO0FBQ0EsMEJBQTBCLFNBQVMsY0FBYyxRQUFRO0FBQ3pELENBQUM7O0FBRUQ7QUFDQSxnQ0FBZ0MsU0FBUyxHQUFHLFFBQVE7QUFDcEQsQ0FBQyIsInNvdXJjZXMiOlsiL1VzZXJzL3BhbnphL0RvY3VtZW50cy9QZXJzb25hbFByb2plY3RzL3ByZWRpay9ub2RlX21vZHVsZXMvc3dhcm0tanMvbm9kZV9tb2R1bGVzL2h0dHAyLXdyYXBwZXIvc291cmNlL3V0aWxzL2Vycm9ycy5qcyJdLCJzb3VyY2VzQ29udGVudCI6WyIndXNlIHN0cmljdCc7XG4vKiBpc3RhbmJ1bCBpZ25vcmUgZmlsZTogaHR0cHM6Ly9naXRodWIuY29tL25vZGVqcy9ub2RlL2Jsb2IvbWFzdGVyL2xpYi9pbnRlcm5hbC9lcnJvcnMuanMgKi9cblxuY29uc3QgbWFrZUVycm9yID0gKEJhc2UsIGtleSwgZ2V0TWVzc2FnZSkgPT4ge1xuXHRtb2R1bGUuZXhwb3J0c1trZXldID0gY2xhc3MgTm9kZUVycm9yIGV4dGVuZHMgQmFzZSB7XG5cdFx0Y29uc3RydWN0b3IoLi4uYXJncykge1xuXHRcdFx0c3VwZXIodHlwZW9mIGdldE1lc3NhZ2UgPT09ICdzdHJpbmcnID8gZ2V0TWVzc2FnZSA6IGdldE1lc3NhZ2UoYXJncykpO1xuXHRcdFx0dGhpcy5uYW1lID0gYCR7c3VwZXIubmFtZX0gWyR7a2V5fV1gO1xuXHRcdFx0dGhpcy5jb2RlID0ga2V5O1xuXHRcdH1cblx0fTtcbn07XG5cbm1ha2VFcnJvcihUeXBlRXJyb3IsICdFUlJfSU5WQUxJRF9BUkdfVFlQRScsIGFyZ3MgPT4ge1xuXHRjb25zdCB0eXBlID0gYXJnc1swXS5pbmNsdWRlcygnLicpID8gJ3Byb3BlcnR5JyA6ICdhcmd1bWVudCc7XG5cblx0bGV0IHZhbGlkID0gYXJnc1sxXTtcblx0Y29uc3QgaXNNYW55VHlwZXMgPSBBcnJheS5pc0FycmF5KHZhbGlkKTtcblxuXHRpZiAoaXNNYW55VHlwZXMpIHtcblx0XHR2YWxpZCA9IGAke3ZhbGlkLnNsaWNlKDAsIC0xKS5qb2luKCcsICcpfSBvciAke3ZhbGlkLnNsaWNlKC0xKX1gO1xuXHR9XG5cblx0cmV0dXJuIGBUaGUgXCIke2FyZ3NbMF19XCIgJHt0eXBlfSBtdXN0IGJlICR7aXNNYW55VHlwZXMgPyAnb25lIG9mJyA6ICdvZid9IHR5cGUgJHt2YWxpZH0uIFJlY2VpdmVkICR7dHlwZW9mIGFyZ3NbMl19YDtcbn0pO1xuXG5tYWtlRXJyb3IoVHlwZUVycm9yLCAnRVJSX0lOVkFMSURfUFJPVE9DT0wnLCBhcmdzID0+IHtcblx0cmV0dXJuIGBQcm90b2NvbCBcIiR7YXJnc1swXX1cIiBub3Qgc3VwcG9ydGVkLiBFeHBlY3RlZCBcIiR7YXJnc1sxXX1cImA7XG59KTtcblxubWFrZUVycm9yKEVycm9yLCAnRVJSX0hUVFBfSEVBREVSU19TRU5UJywgYXJncyA9PiB7XG5cdHJldHVybiBgQ2Fubm90ICR7YXJnc1swXX0gaGVhZGVycyBhZnRlciB0aGV5IGFyZSBzZW50IHRvIHRoZSBjbGllbnRgO1xufSk7XG5cbm1ha2VFcnJvcihUeXBlRXJyb3IsICdFUlJfSU5WQUxJRF9IVFRQX1RPS0VOJywgYXJncyA9PiB7XG5cdHJldHVybiBgJHthcmdzWzBdfSBtdXN0IGJlIGEgdmFsaWQgSFRUUCB0b2tlbiBbJHthcmdzWzFdfV1gO1xufSk7XG5cbm1ha2VFcnJvcihUeXBlRXJyb3IsICdFUlJfSFRUUF9JTlZBTElEX0hFQURFUl9WQUxVRScsIGFyZ3MgPT4ge1xuXHRyZXR1cm4gYEludmFsaWQgdmFsdWUgXCIke2FyZ3NbMF19IGZvciBoZWFkZXIgXCIke2FyZ3NbMV19XCJgO1xufSk7XG5cbm1ha2VFcnJvcihUeXBlRXJyb3IsICdFUlJfSU5WQUxJRF9DSEFSJywgYXJncyA9PiB7XG5cdHJldHVybiBgSW52YWxpZCBjaGFyYWN0ZXIgaW4gJHthcmdzWzBdfSBbJHthcmdzWzFdfV1gO1xufSk7XG4iXSwibmFtZXMiOltdLCJpZ25vcmVMaXN0IjpbMF0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/swarm-js/node_modules/http2-wrapper/source/utils/errors.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/swarm-js/node_modules/http2-wrapper/source/utils/is-request-pseudo-header.js":
/*!***************************************************************************************************!*\
  !*** ./node_modules/swarm-js/node_modules/http2-wrapper/source/utils/is-request-pseudo-header.js ***!
  \***************************************************************************************************/
/***/ ((module) => {

"use strict";
eval("\n\nmodule.exports = header => {\n\tswitch (header) {\n\t\tcase ':method':\n\t\tcase ':scheme':\n\t\tcase ':authority':\n\t\tcase ':path':\n\t\t\treturn true;\n\t\tdefault:\n\t\t\treturn false;\n\t}\n};\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvc3dhcm0tanMvbm9kZV9tb2R1bGVzL2h0dHAyLXdyYXBwZXIvc291cmNlL3V0aWxzL2lzLXJlcXVlc3QtcHNldWRvLWhlYWRlci5qcyIsIm1hcHBpbmdzIjoiQUFBYTs7QUFFYjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBIiwic291cmNlcyI6WyIvVXNlcnMvcGFuemEvRG9jdW1lbnRzL1BlcnNvbmFsUHJvamVjdHMvcHJlZGlrL25vZGVfbW9kdWxlcy9zd2FybS1qcy9ub2RlX21vZHVsZXMvaHR0cDItd3JhcHBlci9zb3VyY2UvdXRpbHMvaXMtcmVxdWVzdC1wc2V1ZG8taGVhZGVyLmpzIl0sInNvdXJjZXNDb250ZW50IjpbIid1c2Ugc3RyaWN0JztcblxubW9kdWxlLmV4cG9ydHMgPSBoZWFkZXIgPT4ge1xuXHRzd2l0Y2ggKGhlYWRlcikge1xuXHRcdGNhc2UgJzptZXRob2QnOlxuXHRcdGNhc2UgJzpzY2hlbWUnOlxuXHRcdGNhc2UgJzphdXRob3JpdHknOlxuXHRcdGNhc2UgJzpwYXRoJzpcblx0XHRcdHJldHVybiB0cnVlO1xuXHRcdGRlZmF1bHQ6XG5cdFx0XHRyZXR1cm4gZmFsc2U7XG5cdH1cbn07XG4iXSwibmFtZXMiOltdLCJpZ25vcmVMaXN0IjpbMF0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/swarm-js/node_modules/http2-wrapper/source/utils/is-request-pseudo-header.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/swarm-js/node_modules/http2-wrapper/source/utils/proxy-events.js":
/*!***************************************************************************************!*\
  !*** ./node_modules/swarm-js/node_modules/http2-wrapper/source/utils/proxy-events.js ***!
  \***************************************************************************************/
/***/ ((module) => {

"use strict";
eval("\n\nmodule.exports = (from, to, events) => {\n\tfor (const event of events) {\n\t\tfrom.on(event, (...args) => to.emit(event, ...args));\n\t}\n};\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvc3dhcm0tanMvbm9kZV9tb2R1bGVzL2h0dHAyLXdyYXBwZXIvc291cmNlL3V0aWxzL3Byb3h5LWV2ZW50cy5qcyIsIm1hcHBpbmdzIjoiQUFBYTs7QUFFYjtBQUNBO0FBQ0E7QUFDQTtBQUNBIiwic291cmNlcyI6WyIvVXNlcnMvcGFuemEvRG9jdW1lbnRzL1BlcnNvbmFsUHJvamVjdHMvcHJlZGlrL25vZGVfbW9kdWxlcy9zd2FybS1qcy9ub2RlX21vZHVsZXMvaHR0cDItd3JhcHBlci9zb3VyY2UvdXRpbHMvcHJveHktZXZlbnRzLmpzIl0sInNvdXJjZXNDb250ZW50IjpbIid1c2Ugc3RyaWN0JztcblxubW9kdWxlLmV4cG9ydHMgPSAoZnJvbSwgdG8sIGV2ZW50cykgPT4ge1xuXHRmb3IgKGNvbnN0IGV2ZW50IG9mIGV2ZW50cykge1xuXHRcdGZyb20ub24oZXZlbnQsICguLi5hcmdzKSA9PiB0by5lbWl0KGV2ZW50LCAuLi5hcmdzKSk7XG5cdH1cbn07XG4iXSwibmFtZXMiOltdLCJpZ25vcmVMaXN0IjpbMF0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/swarm-js/node_modules/http2-wrapper/source/utils/proxy-events.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/swarm-js/node_modules/http2-wrapper/source/utils/url-to-options.js":
/*!*****************************************************************************************!*\
  !*** ./node_modules/swarm-js/node_modules/http2-wrapper/source/utils/url-to-options.js ***!
  \*****************************************************************************************/
/***/ ((module) => {

"use strict";
eval("\n/* istanbul ignore file: https://github.com/nodejs/node/blob/a91293d4d9ab403046ab5eb022332e4e3d249bd3/lib/internal/url.js#L1257 */\n\nmodule.exports = url => {\n\tconst options = {\n\t\tprotocol: url.protocol,\n\t\thostname: typeof url.hostname === 'string' && url.hostname.startsWith('[') ? url.hostname.slice(1, -1) : url.hostname,\n\t\thost: url.host,\n\t\thash: url.hash,\n\t\tsearch: url.search,\n\t\tpathname: url.pathname,\n\t\thref: url.href,\n\t\tpath: `${url.pathname || ''}${url.search || ''}`\n\t};\n\n\tif (typeof url.port === 'string' && url.port.length !== 0) {\n\t\toptions.port = Number(url.port);\n\t}\n\n\tif (url.username || url.password) {\n\t\toptions.auth = `${url.username || ''}:${url.password || ''}`;\n\t}\n\n\treturn options;\n};\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvc3dhcm0tanMvbm9kZV9tb2R1bGVzL2h0dHAyLXdyYXBwZXIvc291cmNlL3V0aWxzL3VybC10by1vcHRpb25zLmpzIiwibWFwcGluZ3MiOiJBQUFhO0FBQ2I7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsV0FBVyxtQkFBbUIsRUFBRSxpQkFBaUI7QUFDakQ7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0Esb0JBQW9CLG1CQUFtQixHQUFHLG1CQUFtQjtBQUM3RDs7QUFFQTtBQUNBIiwic291cmNlcyI6WyIvVXNlcnMvcGFuemEvRG9jdW1lbnRzL1BlcnNvbmFsUHJvamVjdHMvcHJlZGlrL25vZGVfbW9kdWxlcy9zd2FybS1qcy9ub2RlX21vZHVsZXMvaHR0cDItd3JhcHBlci9zb3VyY2UvdXRpbHMvdXJsLXRvLW9wdGlvbnMuanMiXSwic291cmNlc0NvbnRlbnQiOlsiJ3VzZSBzdHJpY3QnO1xuLyogaXN0YW5idWwgaWdub3JlIGZpbGU6IGh0dHBzOi8vZ2l0aHViLmNvbS9ub2RlanMvbm9kZS9ibG9iL2E5MTI5M2Q0ZDlhYjQwMzA0NmFiNWViMDIyMzMyZTRlM2QyNDliZDMvbGliL2ludGVybmFsL3VybC5qcyNMMTI1NyAqL1xuXG5tb2R1bGUuZXhwb3J0cyA9IHVybCA9PiB7XG5cdGNvbnN0IG9wdGlvbnMgPSB7XG5cdFx0cHJvdG9jb2w6IHVybC5wcm90b2NvbCxcblx0XHRob3N0bmFtZTogdHlwZW9mIHVybC5ob3N0bmFtZSA9PT0gJ3N0cmluZycgJiYgdXJsLmhvc3RuYW1lLnN0YXJ0c1dpdGgoJ1snKSA/IHVybC5ob3N0bmFtZS5zbGljZSgxLCAtMSkgOiB1cmwuaG9zdG5hbWUsXG5cdFx0aG9zdDogdXJsLmhvc3QsXG5cdFx0aGFzaDogdXJsLmhhc2gsXG5cdFx0c2VhcmNoOiB1cmwuc2VhcmNoLFxuXHRcdHBhdGhuYW1lOiB1cmwucGF0aG5hbWUsXG5cdFx0aHJlZjogdXJsLmhyZWYsXG5cdFx0cGF0aDogYCR7dXJsLnBhdGhuYW1lIHx8ICcnfSR7dXJsLnNlYXJjaCB8fCAnJ31gXG5cdH07XG5cblx0aWYgKHR5cGVvZiB1cmwucG9ydCA9PT0gJ3N0cmluZycgJiYgdXJsLnBvcnQubGVuZ3RoICE9PSAwKSB7XG5cdFx0b3B0aW9ucy5wb3J0ID0gTnVtYmVyKHVybC5wb3J0KTtcblx0fVxuXG5cdGlmICh1cmwudXNlcm5hbWUgfHwgdXJsLnBhc3N3b3JkKSB7XG5cdFx0b3B0aW9ucy5hdXRoID0gYCR7dXJsLnVzZXJuYW1lIHx8ICcnfToke3VybC5wYXNzd29yZCB8fCAnJ31gO1xuXHR9XG5cblx0cmV0dXJuIG9wdGlvbnM7XG59O1xuIl0sIm5hbWVzIjpbXSwiaWdub3JlTGlzdCI6WzBdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/swarm-js/node_modules/http2-wrapper/source/utils/url-to-options.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/swarm-js/node_modules/lowercase-keys/index.js":
/*!********************************************************************!*\
  !*** ./node_modules/swarm-js/node_modules/lowercase-keys/index.js ***!
  \********************************************************************/
/***/ ((module) => {

"use strict";
eval("\nmodule.exports = object => {\n\tconst result = {};\n\n\tfor (const [key, value] of Object.entries(object)) {\n\t\tresult[key.toLowerCase()] = value;\n\t}\n\n\treturn result;\n};\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvc3dhcm0tanMvbm9kZV9tb2R1bGVzL2xvd2VyY2FzZS1rZXlzL2luZGV4LmpzIiwibWFwcGluZ3MiOiJBQUFhO0FBQ2I7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSIsInNvdXJjZXMiOlsiL1VzZXJzL3BhbnphL0RvY3VtZW50cy9QZXJzb25hbFByb2plY3RzL3ByZWRpay9ub2RlX21vZHVsZXMvc3dhcm0tanMvbm9kZV9tb2R1bGVzL2xvd2VyY2FzZS1rZXlzL2luZGV4LmpzIl0sInNvdXJjZXNDb250ZW50IjpbIid1c2Ugc3RyaWN0Jztcbm1vZHVsZS5leHBvcnRzID0gb2JqZWN0ID0+IHtcblx0Y29uc3QgcmVzdWx0ID0ge307XG5cblx0Zm9yIChjb25zdCBba2V5LCB2YWx1ZV0gb2YgT2JqZWN0LmVudHJpZXMob2JqZWN0KSkge1xuXHRcdHJlc3VsdFtrZXkudG9Mb3dlckNhc2UoKV0gPSB2YWx1ZTtcblx0fVxuXG5cdHJldHVybiByZXN1bHQ7XG59O1xuIl0sIm5hbWVzIjpbXSwiaWdub3JlTGlzdCI6WzBdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/swarm-js/node_modules/lowercase-keys/index.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/swarm-js/node_modules/minipass/index.js":
/*!**************************************************************!*\
  !*** ./node_modules/swarm-js/node_modules/minipass/index.js ***!
  \**************************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";
eval("\nconst EE = __webpack_require__(/*! events */ \"events\")\nconst Yallist = __webpack_require__(/*! yallist */ \"(ssr)/./node_modules/swarm-js/node_modules/yallist/yallist.js\")\nconst SD = (__webpack_require__(/*! string_decoder */ \"string_decoder\").StringDecoder)\n\nconst EOF = Symbol('EOF')\nconst MAYBE_EMIT_END = Symbol('maybeEmitEnd')\nconst EMITTED_END = Symbol('emittedEnd')\nconst EMITTING_END = Symbol('emittingEnd')\nconst CLOSED = Symbol('closed')\nconst READ = Symbol('read')\nconst FLUSH = Symbol('flush')\nconst FLUSHCHUNK = Symbol('flushChunk')\nconst ENCODING = Symbol('encoding')\nconst DECODER = Symbol('decoder')\nconst FLOWING = Symbol('flowing')\nconst PAUSED = Symbol('paused')\nconst RESUME = Symbol('resume')\nconst BUFFERLENGTH = Symbol('bufferLength')\nconst BUFFERPUSH = Symbol('bufferPush')\nconst BUFFERSHIFT = Symbol('bufferShift')\nconst OBJECTMODE = Symbol('objectMode')\nconst DESTROYED = Symbol('destroyed')\n\n// TODO remove when Node v8 support drops\nconst doIter = global._MP_NO_ITERATOR_SYMBOLS_  !== '1'\nconst ASYNCITERATOR = doIter && Symbol.asyncIterator\n  || Symbol('asyncIterator not implemented')\nconst ITERATOR = doIter && Symbol.iterator\n  || Symbol('iterator not implemented')\n\n// Buffer in node 4.x < 4.5.0 doesn't have working Buffer.from\n// or Buffer.alloc, and Buffer in node 10 deprecated the ctor.\n// .M, this is fine .\\^/M..\nconst B = Buffer.alloc ? Buffer\n  : /* istanbul ignore next */ (__webpack_require__(/*! safe-buffer */ \"(ssr)/./node_modules/safe-buffer/index.js\").Buffer)\n\n// events that mean 'the stream is over'\n// these are treated specially, and re-emitted\n// if they are listened for after emitting.\nconst isEndish = ev =>\n  ev === 'end' ||\n  ev === 'finish' ||\n  ev === 'prefinish'\n\nconst isArrayBuffer = b => b instanceof ArrayBuffer ||\n  typeof b === 'object' &&\n  b.constructor &&\n  b.constructor.name === 'ArrayBuffer' &&\n  b.byteLength >= 0\n\nconst isArrayBufferView = b => !B.isBuffer(b) && ArrayBuffer.isView(b)\n\nmodule.exports = class Minipass extends EE {\n  constructor (options) {\n    super()\n    this[FLOWING] = false\n    // whether we're explicitly paused\n    this[PAUSED] = false\n    this.pipes = new Yallist()\n    this.buffer = new Yallist()\n    this[OBJECTMODE] = options && options.objectMode || false\n    if (this[OBJECTMODE])\n      this[ENCODING] = null\n    else\n      this[ENCODING] = options && options.encoding || null\n    if (this[ENCODING] === 'buffer')\n      this[ENCODING] = null\n    this[DECODER] = this[ENCODING] ? new SD(this[ENCODING]) : null\n    this[EOF] = false\n    this[EMITTED_END] = false\n    this[EMITTING_END] = false\n    this[CLOSED] = false\n    this.writable = true\n    this.readable = true\n    this[BUFFERLENGTH] = 0\n    this[DESTROYED] = false\n  }\n\n  get bufferLength () { return this[BUFFERLENGTH] }\n\n  get encoding () { return this[ENCODING] }\n  set encoding (enc) {\n    if (this[OBJECTMODE])\n      throw new Error('cannot set encoding in objectMode')\n\n    if (this[ENCODING] && enc !== this[ENCODING] &&\n        (this[DECODER] && this[DECODER].lastNeed || this[BUFFERLENGTH]))\n      throw new Error('cannot change encoding')\n\n    if (this[ENCODING] !== enc) {\n      this[DECODER] = enc ? new SD(enc) : null\n      if (this.buffer.length)\n        this.buffer = this.buffer.map(chunk => this[DECODER].write(chunk))\n    }\n\n    this[ENCODING] = enc\n  }\n\n  setEncoding (enc) {\n    this.encoding = enc\n  }\n\n  get objectMode () { return this[OBJECTMODE] }\n  set objectMode (ॐ ) { this[OBJECTMODE] = this[OBJECTMODE] || !!ॐ  }\n\n  write (chunk, encoding, cb) {\n    if (this[EOF])\n      throw new Error('write after end')\n\n    if (this[DESTROYED]) {\n      this.emit('error', Object.assign(\n        new Error('Cannot call write after a stream was destroyed'),\n        { code: 'ERR_STREAM_DESTROYED' }\n      ))\n      return true\n    }\n\n    if (typeof encoding === 'function')\n      cb = encoding, encoding = 'utf8'\n\n    if (!encoding)\n      encoding = 'utf8'\n\n    // convert array buffers and typed array views into buffers\n    // at some point in the future, we may want to do the opposite!\n    // leave strings and buffers as-is\n    // anything else switches us into object mode\n    if (!this[OBJECTMODE] && !B.isBuffer(chunk)) {\n      if (isArrayBufferView(chunk))\n        chunk = B.from(chunk.buffer, chunk.byteOffset, chunk.byteLength)\n      else if (isArrayBuffer(chunk))\n        chunk = B.from(chunk)\n      else if (typeof chunk !== 'string')\n        // use the setter so we throw if we have encoding set\n        this.objectMode = true\n    }\n\n    // this ensures at this point that the chunk is a buffer or string\n    // don't buffer it up or send it to the decoder\n    if (!this.objectMode && !chunk.length) {\n      const ret = this.flowing\n      if (this[BUFFERLENGTH] !== 0)\n        this.emit('readable')\n      if (cb)\n        cb()\n      return ret\n    }\n\n    // fast-path writing strings of same encoding to a stream with\n    // an empty buffer, skipping the buffer/decoder dance\n    if (typeof chunk === 'string' && !this[OBJECTMODE] &&\n        // unless it is a string already ready for us to use\n        !(encoding === this[ENCODING] && !this[DECODER].lastNeed)) {\n      chunk = B.from(chunk, encoding)\n    }\n\n    if (B.isBuffer(chunk) && this[ENCODING])\n      chunk = this[DECODER].write(chunk)\n\n    try {\n      return this.flowing\n        ? (this.emit('data', chunk), this.flowing)\n        : (this[BUFFERPUSH](chunk), false)\n    } finally {\n      if (this[BUFFERLENGTH] !== 0)\n        this.emit('readable')\n      if (cb)\n        cb()\n    }\n  }\n\n  read (n) {\n    if (this[DESTROYED])\n      return null\n\n    try {\n      if (this[BUFFERLENGTH] === 0 || n === 0 || n > this[BUFFERLENGTH])\n        return null\n\n      if (this[OBJECTMODE])\n        n = null\n\n      if (this.buffer.length > 1 && !this[OBJECTMODE]) {\n        if (this.encoding)\n          this.buffer = new Yallist([\n            Array.from(this.buffer).join('')\n          ])\n        else\n          this.buffer = new Yallist([\n            B.concat(Array.from(this.buffer), this[BUFFERLENGTH])\n          ])\n      }\n\n      return this[READ](n || null, this.buffer.head.value)\n    } finally {\n      this[MAYBE_EMIT_END]()\n    }\n  }\n\n  [READ] (n, chunk) {\n    if (n === chunk.length || n === null)\n      this[BUFFERSHIFT]()\n    else {\n      this.buffer.head.value = chunk.slice(n)\n      chunk = chunk.slice(0, n)\n      this[BUFFERLENGTH] -= n\n    }\n\n    this.emit('data', chunk)\n\n    if (!this.buffer.length && !this[EOF])\n      this.emit('drain')\n\n    return chunk\n  }\n\n  end (chunk, encoding, cb) {\n    if (typeof chunk === 'function')\n      cb = chunk, chunk = null\n    if (typeof encoding === 'function')\n      cb = encoding, encoding = 'utf8'\n    if (chunk)\n      this.write(chunk, encoding)\n    if (cb)\n      this.once('end', cb)\n    this[EOF] = true\n    this.writable = false\n\n    // if we haven't written anything, then go ahead and emit,\n    // even if we're not reading.\n    // we'll re-emit if a new 'end' listener is added anyway.\n    // This makes MP more suitable to write-only use cases.\n    if (this.flowing || !this[PAUSED])\n      this[MAYBE_EMIT_END]()\n    return this\n  }\n\n  // don't let the internal resume be overwritten\n  [RESUME] () {\n    if (this[DESTROYED])\n      return\n\n    this[PAUSED] = false\n    this[FLOWING] = true\n    this.emit('resume')\n    if (this.buffer.length)\n      this[FLUSH]()\n    else if (this[EOF])\n      this[MAYBE_EMIT_END]()\n    else\n      this.emit('drain')\n  }\n\n  resume () {\n    return this[RESUME]()\n  }\n\n  pause () {\n    this[FLOWING] = false\n    this[PAUSED] = true\n  }\n\n  get destroyed () {\n    return this[DESTROYED]\n  }\n\n  get flowing () {\n    return this[FLOWING]\n  }\n\n  get paused () {\n    return this[PAUSED]\n  }\n\n  [BUFFERPUSH] (chunk) {\n    if (this[OBJECTMODE])\n      this[BUFFERLENGTH] += 1\n    else\n      this[BUFFERLENGTH] += chunk.length\n    return this.buffer.push(chunk)\n  }\n\n  [BUFFERSHIFT] () {\n    if (this.buffer.length) {\n      if (this[OBJECTMODE])\n        this[BUFFERLENGTH] -= 1\n      else\n        this[BUFFERLENGTH] -= this.buffer.head.value.length\n    }\n    return this.buffer.shift()\n  }\n\n  [FLUSH] () {\n    do {} while (this[FLUSHCHUNK](this[BUFFERSHIFT]()))\n\n    if (!this.buffer.length && !this[EOF])\n      this.emit('drain')\n  }\n\n  [FLUSHCHUNK] (chunk) {\n    return chunk ? (this.emit('data', chunk), this.flowing) : false\n  }\n\n  pipe (dest, opts) {\n    if (this[DESTROYED])\n      return\n\n    const ended = this[EMITTED_END]\n    opts = opts || {}\n    if (dest === process.stdout || dest === process.stderr)\n      opts.end = false\n    else\n      opts.end = opts.end !== false\n\n    const p = { dest: dest, opts: opts, ondrain: _ => this[RESUME]() }\n    this.pipes.push(p)\n\n    dest.on('drain', p.ondrain)\n    this[RESUME]()\n    // piping an ended stream ends immediately\n    if (ended && p.opts.end)\n      p.dest.end()\n    return dest\n  }\n\n  addListener (ev, fn) {\n    return this.on(ev, fn)\n  }\n\n  on (ev, fn) {\n    try {\n      return super.on(ev, fn)\n    } finally {\n      if (ev === 'data' && !this.pipes.length && !this.flowing)\n        this[RESUME]()\n      else if (isEndish(ev) && this[EMITTED_END]) {\n        super.emit(ev)\n        this.removeAllListeners(ev)\n      }\n    }\n  }\n\n  get emittedEnd () {\n    return this[EMITTED_END]\n  }\n\n  [MAYBE_EMIT_END] () {\n    if (!this[EMITTING_END] &&\n        !this[EMITTED_END] &&\n        !this[DESTROYED] &&\n        this.buffer.length === 0 &&\n        this[EOF]) {\n      this[EMITTING_END] = true\n      this.emit('end')\n      this.emit('prefinish')\n      this.emit('finish')\n      if (this[CLOSED])\n        this.emit('close')\n      this[EMITTING_END] = false\n    }\n  }\n\n  emit (ev, data) {\n    // error and close are only events allowed after calling destroy()\n    if (ev !== 'error' && ev !== 'close' && ev !== DESTROYED && this[DESTROYED])\n      return\n    else if (ev === 'data') {\n      if (!data)\n        return\n\n      if (this.pipes.length)\n        this.pipes.forEach(p =>\n          p.dest.write(data) === false && this.pause())\n    } else if (ev === 'end') {\n      // only actual end gets this treatment\n      if (this[EMITTED_END] === true)\n        return\n\n      this[EMITTED_END] = true\n      this.readable = false\n\n      if (this[DECODER]) {\n        data = this[DECODER].end()\n        if (data) {\n          this.pipes.forEach(p => p.dest.write(data))\n          super.emit('data', data)\n        }\n      }\n\n      this.pipes.forEach(p => {\n        p.dest.removeListener('drain', p.ondrain)\n        if (p.opts.end)\n          p.dest.end()\n      })\n    } else if (ev === 'close') {\n      this[CLOSED] = true\n      // don't emit close before 'end' and 'finish'\n      if (!this[EMITTED_END] && !this[DESTROYED])\n        return\n    }\n\n    // TODO: replace with a spread operator when Node v4 support drops\n    const args = new Array(arguments.length)\n    args[0] = ev\n    args[1] = data\n    if (arguments.length > 2) {\n      for (let i = 2; i < arguments.length; i++) {\n        args[i] = arguments[i]\n      }\n    }\n\n    try {\n      return super.emit.apply(this, args)\n    } finally {\n      if (!isEndish(ev))\n        this[MAYBE_EMIT_END]()\n      else\n        this.removeAllListeners(ev)\n    }\n  }\n\n  // const all = await stream.collect()\n  collect () {\n    const buf = []\n    buf.dataLength = 0\n    this.on('data', c => {\n      buf.push(c)\n      buf.dataLength += c.length\n    })\n    return this.promise().then(() => buf)\n  }\n\n  // const data = await stream.concat()\n  concat () {\n    return this[OBJECTMODE]\n      ? Promise.reject(new Error('cannot concat in objectMode'))\n      : this.collect().then(buf =>\n          this[OBJECTMODE]\n            ? Promise.reject(new Error('cannot concat in objectMode'))\n            : this[ENCODING] ? buf.join('') : B.concat(buf, buf.dataLength))\n  }\n\n  // stream.promise().then(() => done, er => emitted error)\n  promise () {\n    return new Promise((resolve, reject) => {\n      this.on(DESTROYED, () => reject(new Error('stream destroyed')))\n      this.on('end', () => resolve())\n      this.on('error', er => reject(er))\n    })\n  }\n\n  // for await (let chunk of stream)\n  [ASYNCITERATOR] () {\n    const next = () => {\n      const res = this.read()\n      if (res !== null)\n        return Promise.resolve({ done: false, value: res })\n\n      if (this[EOF])\n        return Promise.resolve({ done: true })\n\n      let resolve = null\n      let reject = null\n      const onerr = er => {\n        this.removeListener('data', ondata)\n        this.removeListener('end', onend)\n        reject(er)\n      }\n      const ondata = value => {\n        this.removeListener('error', onerr)\n        this.removeListener('end', onend)\n        this.pause()\n        resolve({ value: value, done: !!this[EOF] })\n      }\n      const onend = () => {\n        this.removeListener('error', onerr)\n        this.removeListener('data', ondata)\n        resolve({ done: true })\n      }\n      const ondestroy = () => onerr(new Error('stream destroyed'))\n      return new Promise((res, rej) => {\n        reject = rej\n        resolve = res\n        this.once(DESTROYED, ondestroy)\n        this.once('error', onerr)\n        this.once('end', onend)\n        this.once('data', ondata)\n      })\n    }\n\n    return { next }\n  }\n\n  // for (let chunk of stream)\n  [ITERATOR] () {\n    const next = () => {\n      const value = this.read()\n      const done = value === null\n      return { value, done }\n    }\n    return { next }\n  }\n\n  destroy (er) {\n    if (this[DESTROYED]) {\n      if (er)\n        this.emit('error', er)\n      else\n        this.emit(DESTROYED)\n      return this\n    }\n\n    this[DESTROYED] = true\n\n    // throw away all buffered data, it's never coming out\n    this.buffer = new Yallist()\n    this[BUFFERLENGTH] = 0\n\n    if (typeof this.close === 'function' && !this[CLOSED])\n      this.close()\n\n    if (er)\n      this.emit('error', er)\n    else // if no error to emit, still reject pending promises\n      this.emit(DESTROYED)\n\n    return this\n  }\n\n  static isStream (s) {\n    return !!s && (s instanceof Minipass || s instanceof EE && (\n      typeof s.pipe === 'function' || // readable\n      (typeof s.write === 'function' && typeof s.end === 'function') // writable\n    ))\n  }\n}\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvc3dhcm0tanMvbm9kZV9tb2R1bGVzL21pbmlwYXNzL2luZGV4LmpzIiwibWFwcGluZ3MiOiJBQUFZO0FBQ1osV0FBVyxtQkFBTyxDQUFDLHNCQUFRO0FBQzNCLGdCQUFnQixtQkFBTyxDQUFDLDhFQUFTO0FBQ2pDLFdBQVcsMkVBQXVDOztBQUVsRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsK0JBQStCLDRGQUE2Qjs7QUFFNUQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQSx3QkFBd0I7O0FBRXhCLG9CQUFvQjtBQUNwQjtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUEsc0JBQXNCO0FBQ3RCLHdCQUF3Qjs7QUFFeEI7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLFVBQVU7QUFDVjtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxVQUFVOztBQUVWO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQSxnQkFBZ0I7QUFDaEI7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQLE1BQU07QUFDTjtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxzQkFBc0Isc0JBQXNCO0FBQzVDO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGlDQUFpQyx5QkFBeUI7O0FBRTFEO0FBQ0EsaUNBQWlDLFlBQVk7O0FBRTdDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxrQkFBa0IsaUNBQWlDO0FBQ25EO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esa0JBQWtCLFlBQVk7QUFDOUI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQOztBQUVBLGFBQWE7QUFDYjs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZUFBZTtBQUNmO0FBQ0EsYUFBYTtBQUNiOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSIsInNvdXJjZXMiOlsiL1VzZXJzL3BhbnphL0RvY3VtZW50cy9QZXJzb25hbFByb2plY3RzL3ByZWRpay9ub2RlX21vZHVsZXMvc3dhcm0tanMvbm9kZV9tb2R1bGVzL21pbmlwYXNzL2luZGV4LmpzIl0sInNvdXJjZXNDb250ZW50IjpbIid1c2Ugc3RyaWN0J1xuY29uc3QgRUUgPSByZXF1aXJlKCdldmVudHMnKVxuY29uc3QgWWFsbGlzdCA9IHJlcXVpcmUoJ3lhbGxpc3QnKVxuY29uc3QgU0QgPSByZXF1aXJlKCdzdHJpbmdfZGVjb2RlcicpLlN0cmluZ0RlY29kZXJcblxuY29uc3QgRU9GID0gU3ltYm9sKCdFT0YnKVxuY29uc3QgTUFZQkVfRU1JVF9FTkQgPSBTeW1ib2woJ21heWJlRW1pdEVuZCcpXG5jb25zdCBFTUlUVEVEX0VORCA9IFN5bWJvbCgnZW1pdHRlZEVuZCcpXG5jb25zdCBFTUlUVElOR19FTkQgPSBTeW1ib2woJ2VtaXR0aW5nRW5kJylcbmNvbnN0IENMT1NFRCA9IFN5bWJvbCgnY2xvc2VkJylcbmNvbnN0IFJFQUQgPSBTeW1ib2woJ3JlYWQnKVxuY29uc3QgRkxVU0ggPSBTeW1ib2woJ2ZsdXNoJylcbmNvbnN0IEZMVVNIQ0hVTksgPSBTeW1ib2woJ2ZsdXNoQ2h1bmsnKVxuY29uc3QgRU5DT0RJTkcgPSBTeW1ib2woJ2VuY29kaW5nJylcbmNvbnN0IERFQ09ERVIgPSBTeW1ib2woJ2RlY29kZXInKVxuY29uc3QgRkxPV0lORyA9IFN5bWJvbCgnZmxvd2luZycpXG5jb25zdCBQQVVTRUQgPSBTeW1ib2woJ3BhdXNlZCcpXG5jb25zdCBSRVNVTUUgPSBTeW1ib2woJ3Jlc3VtZScpXG5jb25zdCBCVUZGRVJMRU5HVEggPSBTeW1ib2woJ2J1ZmZlckxlbmd0aCcpXG5jb25zdCBCVUZGRVJQVVNIID0gU3ltYm9sKCdidWZmZXJQdXNoJylcbmNvbnN0IEJVRkZFUlNISUZUID0gU3ltYm9sKCdidWZmZXJTaGlmdCcpXG5jb25zdCBPQkpFQ1RNT0RFID0gU3ltYm9sKCdvYmplY3RNb2RlJylcbmNvbnN0IERFU1RST1lFRCA9IFN5bWJvbCgnZGVzdHJveWVkJylcblxuLy8gVE9ETyByZW1vdmUgd2hlbiBOb2RlIHY4IHN1cHBvcnQgZHJvcHNcbmNvbnN0IGRvSXRlciA9IGdsb2JhbC5fTVBfTk9fSVRFUkFUT1JfU1lNQk9MU18gICE9PSAnMSdcbmNvbnN0IEFTWU5DSVRFUkFUT1IgPSBkb0l0ZXIgJiYgU3ltYm9sLmFzeW5jSXRlcmF0b3JcbiAgfHwgU3ltYm9sKCdhc3luY0l0ZXJhdG9yIG5vdCBpbXBsZW1lbnRlZCcpXG5jb25zdCBJVEVSQVRPUiA9IGRvSXRlciAmJiBTeW1ib2wuaXRlcmF0b3JcbiAgfHwgU3ltYm9sKCdpdGVyYXRvciBub3QgaW1wbGVtZW50ZWQnKVxuXG4vLyBCdWZmZXIgaW4gbm9kZSA0LnggPCA0LjUuMCBkb2Vzbid0IGhhdmUgd29ya2luZyBCdWZmZXIuZnJvbVxuLy8gb3IgQnVmZmVyLmFsbG9jLCBhbmQgQnVmZmVyIGluIG5vZGUgMTAgZGVwcmVjYXRlZCB0aGUgY3Rvci5cbi8vIC5NLCB0aGlzIGlzIGZpbmUgLlxcXi9NLi5cbmNvbnN0IEIgPSBCdWZmZXIuYWxsb2MgPyBCdWZmZXJcbiAgOiAvKiBpc3RhbmJ1bCBpZ25vcmUgbmV4dCAqLyByZXF1aXJlKCdzYWZlLWJ1ZmZlcicpLkJ1ZmZlclxuXG4vLyBldmVudHMgdGhhdCBtZWFuICd0aGUgc3RyZWFtIGlzIG92ZXInXG4vLyB0aGVzZSBhcmUgdHJlYXRlZCBzcGVjaWFsbHksIGFuZCByZS1lbWl0dGVkXG4vLyBpZiB0aGV5IGFyZSBsaXN0ZW5lZCBmb3IgYWZ0ZXIgZW1pdHRpbmcuXG5jb25zdCBpc0VuZGlzaCA9IGV2ID0+XG4gIGV2ID09PSAnZW5kJyB8fFxuICBldiA9PT0gJ2ZpbmlzaCcgfHxcbiAgZXYgPT09ICdwcmVmaW5pc2gnXG5cbmNvbnN0IGlzQXJyYXlCdWZmZXIgPSBiID0+IGIgaW5zdGFuY2VvZiBBcnJheUJ1ZmZlciB8fFxuICB0eXBlb2YgYiA9PT0gJ29iamVjdCcgJiZcbiAgYi5jb25zdHJ1Y3RvciAmJlxuICBiLmNvbnN0cnVjdG9yLm5hbWUgPT09ICdBcnJheUJ1ZmZlcicgJiZcbiAgYi5ieXRlTGVuZ3RoID49IDBcblxuY29uc3QgaXNBcnJheUJ1ZmZlclZpZXcgPSBiID0+ICFCLmlzQnVmZmVyKGIpICYmIEFycmF5QnVmZmVyLmlzVmlldyhiKVxuXG5tb2R1bGUuZXhwb3J0cyA9IGNsYXNzIE1pbmlwYXNzIGV4dGVuZHMgRUUge1xuICBjb25zdHJ1Y3RvciAob3B0aW9ucykge1xuICAgIHN1cGVyKClcbiAgICB0aGlzW0ZMT1dJTkddID0gZmFsc2VcbiAgICAvLyB3aGV0aGVyIHdlJ3JlIGV4cGxpY2l0bHkgcGF1c2VkXG4gICAgdGhpc1tQQVVTRURdID0gZmFsc2VcbiAgICB0aGlzLnBpcGVzID0gbmV3IFlhbGxpc3QoKVxuICAgIHRoaXMuYnVmZmVyID0gbmV3IFlhbGxpc3QoKVxuICAgIHRoaXNbT0JKRUNUTU9ERV0gPSBvcHRpb25zICYmIG9wdGlvbnMub2JqZWN0TW9kZSB8fCBmYWxzZVxuICAgIGlmICh0aGlzW09CSkVDVE1PREVdKVxuICAgICAgdGhpc1tFTkNPRElOR10gPSBudWxsXG4gICAgZWxzZVxuICAgICAgdGhpc1tFTkNPRElOR10gPSBvcHRpb25zICYmIG9wdGlvbnMuZW5jb2RpbmcgfHwgbnVsbFxuICAgIGlmICh0aGlzW0VOQ09ESU5HXSA9PT0gJ2J1ZmZlcicpXG4gICAgICB0aGlzW0VOQ09ESU5HXSA9IG51bGxcbiAgICB0aGlzW0RFQ09ERVJdID0gdGhpc1tFTkNPRElOR10gPyBuZXcgU0QodGhpc1tFTkNPRElOR10pIDogbnVsbFxuICAgIHRoaXNbRU9GXSA9IGZhbHNlXG4gICAgdGhpc1tFTUlUVEVEX0VORF0gPSBmYWxzZVxuICAgIHRoaXNbRU1JVFRJTkdfRU5EXSA9IGZhbHNlXG4gICAgdGhpc1tDTE9TRURdID0gZmFsc2VcbiAgICB0aGlzLndyaXRhYmxlID0gdHJ1ZVxuICAgIHRoaXMucmVhZGFibGUgPSB0cnVlXG4gICAgdGhpc1tCVUZGRVJMRU5HVEhdID0gMFxuICAgIHRoaXNbREVTVFJPWUVEXSA9IGZhbHNlXG4gIH1cblxuICBnZXQgYnVmZmVyTGVuZ3RoICgpIHsgcmV0dXJuIHRoaXNbQlVGRkVSTEVOR1RIXSB9XG5cbiAgZ2V0IGVuY29kaW5nICgpIHsgcmV0dXJuIHRoaXNbRU5DT0RJTkddIH1cbiAgc2V0IGVuY29kaW5nIChlbmMpIHtcbiAgICBpZiAodGhpc1tPQkpFQ1RNT0RFXSlcbiAgICAgIHRocm93IG5ldyBFcnJvcignY2Fubm90IHNldCBlbmNvZGluZyBpbiBvYmplY3RNb2RlJylcblxuICAgIGlmICh0aGlzW0VOQ09ESU5HXSAmJiBlbmMgIT09IHRoaXNbRU5DT0RJTkddICYmXG4gICAgICAgICh0aGlzW0RFQ09ERVJdICYmIHRoaXNbREVDT0RFUl0ubGFzdE5lZWQgfHwgdGhpc1tCVUZGRVJMRU5HVEhdKSlcbiAgICAgIHRocm93IG5ldyBFcnJvcignY2Fubm90IGNoYW5nZSBlbmNvZGluZycpXG5cbiAgICBpZiAodGhpc1tFTkNPRElOR10gIT09IGVuYykge1xuICAgICAgdGhpc1tERUNPREVSXSA9IGVuYyA/IG5ldyBTRChlbmMpIDogbnVsbFxuICAgICAgaWYgKHRoaXMuYnVmZmVyLmxlbmd0aClcbiAgICAgICAgdGhpcy5idWZmZXIgPSB0aGlzLmJ1ZmZlci5tYXAoY2h1bmsgPT4gdGhpc1tERUNPREVSXS53cml0ZShjaHVuaykpXG4gICAgfVxuXG4gICAgdGhpc1tFTkNPRElOR10gPSBlbmNcbiAgfVxuXG4gIHNldEVuY29kaW5nIChlbmMpIHtcbiAgICB0aGlzLmVuY29kaW5nID0gZW5jXG4gIH1cblxuICBnZXQgb2JqZWN0TW9kZSAoKSB7IHJldHVybiB0aGlzW09CSkVDVE1PREVdIH1cbiAgc2V0IG9iamVjdE1vZGUgKOClkCApIHsgdGhpc1tPQkpFQ1RNT0RFXSA9IHRoaXNbT0JKRUNUTU9ERV0gfHwgISHgpZAgIH1cblxuICB3cml0ZSAoY2h1bmssIGVuY29kaW5nLCBjYikge1xuICAgIGlmICh0aGlzW0VPRl0pXG4gICAgICB0aHJvdyBuZXcgRXJyb3IoJ3dyaXRlIGFmdGVyIGVuZCcpXG5cbiAgICBpZiAodGhpc1tERVNUUk9ZRURdKSB7XG4gICAgICB0aGlzLmVtaXQoJ2Vycm9yJywgT2JqZWN0LmFzc2lnbihcbiAgICAgICAgbmV3IEVycm9yKCdDYW5ub3QgY2FsbCB3cml0ZSBhZnRlciBhIHN0cmVhbSB3YXMgZGVzdHJveWVkJyksXG4gICAgICAgIHsgY29kZTogJ0VSUl9TVFJFQU1fREVTVFJPWUVEJyB9XG4gICAgICApKVxuICAgICAgcmV0dXJuIHRydWVcbiAgICB9XG5cbiAgICBpZiAodHlwZW9mIGVuY29kaW5nID09PSAnZnVuY3Rpb24nKVxuICAgICAgY2IgPSBlbmNvZGluZywgZW5jb2RpbmcgPSAndXRmOCdcblxuICAgIGlmICghZW5jb2RpbmcpXG4gICAgICBlbmNvZGluZyA9ICd1dGY4J1xuXG4gICAgLy8gY29udmVydCBhcnJheSBidWZmZXJzIGFuZCB0eXBlZCBhcnJheSB2aWV3cyBpbnRvIGJ1ZmZlcnNcbiAgICAvLyBhdCBzb21lIHBvaW50IGluIHRoZSBmdXR1cmUsIHdlIG1heSB3YW50IHRvIGRvIHRoZSBvcHBvc2l0ZSFcbiAgICAvLyBsZWF2ZSBzdHJpbmdzIGFuZCBidWZmZXJzIGFzLWlzXG4gICAgLy8gYW55dGhpbmcgZWxzZSBzd2l0Y2hlcyB1cyBpbnRvIG9iamVjdCBtb2RlXG4gICAgaWYgKCF0aGlzW09CSkVDVE1PREVdICYmICFCLmlzQnVmZmVyKGNodW5rKSkge1xuICAgICAgaWYgKGlzQXJyYXlCdWZmZXJWaWV3KGNodW5rKSlcbiAgICAgICAgY2h1bmsgPSBCLmZyb20oY2h1bmsuYnVmZmVyLCBjaHVuay5ieXRlT2Zmc2V0LCBjaHVuay5ieXRlTGVuZ3RoKVxuICAgICAgZWxzZSBpZiAoaXNBcnJheUJ1ZmZlcihjaHVuaykpXG4gICAgICAgIGNodW5rID0gQi5mcm9tKGNodW5rKVxuICAgICAgZWxzZSBpZiAodHlwZW9mIGNodW5rICE9PSAnc3RyaW5nJylcbiAgICAgICAgLy8gdXNlIHRoZSBzZXR0ZXIgc28gd2UgdGhyb3cgaWYgd2UgaGF2ZSBlbmNvZGluZyBzZXRcbiAgICAgICAgdGhpcy5vYmplY3RNb2RlID0gdHJ1ZVxuICAgIH1cblxuICAgIC8vIHRoaXMgZW5zdXJlcyBhdCB0aGlzIHBvaW50IHRoYXQgdGhlIGNodW5rIGlzIGEgYnVmZmVyIG9yIHN0cmluZ1xuICAgIC8vIGRvbid0IGJ1ZmZlciBpdCB1cCBvciBzZW5kIGl0IHRvIHRoZSBkZWNvZGVyXG4gICAgaWYgKCF0aGlzLm9iamVjdE1vZGUgJiYgIWNodW5rLmxlbmd0aCkge1xuICAgICAgY29uc3QgcmV0ID0gdGhpcy5mbG93aW5nXG4gICAgICBpZiAodGhpc1tCVUZGRVJMRU5HVEhdICE9PSAwKVxuICAgICAgICB0aGlzLmVtaXQoJ3JlYWRhYmxlJylcbiAgICAgIGlmIChjYilcbiAgICAgICAgY2IoKVxuICAgICAgcmV0dXJuIHJldFxuICAgIH1cblxuICAgIC8vIGZhc3QtcGF0aCB3cml0aW5nIHN0cmluZ3Mgb2Ygc2FtZSBlbmNvZGluZyB0byBhIHN0cmVhbSB3aXRoXG4gICAgLy8gYW4gZW1wdHkgYnVmZmVyLCBza2lwcGluZyB0aGUgYnVmZmVyL2RlY29kZXIgZGFuY2VcbiAgICBpZiAodHlwZW9mIGNodW5rID09PSAnc3RyaW5nJyAmJiAhdGhpc1tPQkpFQ1RNT0RFXSAmJlxuICAgICAgICAvLyB1bmxlc3MgaXQgaXMgYSBzdHJpbmcgYWxyZWFkeSByZWFkeSBmb3IgdXMgdG8gdXNlXG4gICAgICAgICEoZW5jb2RpbmcgPT09IHRoaXNbRU5DT0RJTkddICYmICF0aGlzW0RFQ09ERVJdLmxhc3ROZWVkKSkge1xuICAgICAgY2h1bmsgPSBCLmZyb20oY2h1bmssIGVuY29kaW5nKVxuICAgIH1cblxuICAgIGlmIChCLmlzQnVmZmVyKGNodW5rKSAmJiB0aGlzW0VOQ09ESU5HXSlcbiAgICAgIGNodW5rID0gdGhpc1tERUNPREVSXS53cml0ZShjaHVuaylcblxuICAgIHRyeSB7XG4gICAgICByZXR1cm4gdGhpcy5mbG93aW5nXG4gICAgICAgID8gKHRoaXMuZW1pdCgnZGF0YScsIGNodW5rKSwgdGhpcy5mbG93aW5nKVxuICAgICAgICA6ICh0aGlzW0JVRkZFUlBVU0hdKGNodW5rKSwgZmFsc2UpXG4gICAgfSBmaW5hbGx5IHtcbiAgICAgIGlmICh0aGlzW0JVRkZFUkxFTkdUSF0gIT09IDApXG4gICAgICAgIHRoaXMuZW1pdCgncmVhZGFibGUnKVxuICAgICAgaWYgKGNiKVxuICAgICAgICBjYigpXG4gICAgfVxuICB9XG5cbiAgcmVhZCAobikge1xuICAgIGlmICh0aGlzW0RFU1RST1lFRF0pXG4gICAgICByZXR1cm4gbnVsbFxuXG4gICAgdHJ5IHtcbiAgICAgIGlmICh0aGlzW0JVRkZFUkxFTkdUSF0gPT09IDAgfHwgbiA9PT0gMCB8fCBuID4gdGhpc1tCVUZGRVJMRU5HVEhdKVxuICAgICAgICByZXR1cm4gbnVsbFxuXG4gICAgICBpZiAodGhpc1tPQkpFQ1RNT0RFXSlcbiAgICAgICAgbiA9IG51bGxcblxuICAgICAgaWYgKHRoaXMuYnVmZmVyLmxlbmd0aCA+IDEgJiYgIXRoaXNbT0JKRUNUTU9ERV0pIHtcbiAgICAgICAgaWYgKHRoaXMuZW5jb2RpbmcpXG4gICAgICAgICAgdGhpcy5idWZmZXIgPSBuZXcgWWFsbGlzdChbXG4gICAgICAgICAgICBBcnJheS5mcm9tKHRoaXMuYnVmZmVyKS5qb2luKCcnKVxuICAgICAgICAgIF0pXG4gICAgICAgIGVsc2VcbiAgICAgICAgICB0aGlzLmJ1ZmZlciA9IG5ldyBZYWxsaXN0KFtcbiAgICAgICAgICAgIEIuY29uY2F0KEFycmF5LmZyb20odGhpcy5idWZmZXIpLCB0aGlzW0JVRkZFUkxFTkdUSF0pXG4gICAgICAgICAgXSlcbiAgICAgIH1cblxuICAgICAgcmV0dXJuIHRoaXNbUkVBRF0obiB8fCBudWxsLCB0aGlzLmJ1ZmZlci5oZWFkLnZhbHVlKVxuICAgIH0gZmluYWxseSB7XG4gICAgICB0aGlzW01BWUJFX0VNSVRfRU5EXSgpXG4gICAgfVxuICB9XG5cbiAgW1JFQURdIChuLCBjaHVuaykge1xuICAgIGlmIChuID09PSBjaHVuay5sZW5ndGggfHwgbiA9PT0gbnVsbClcbiAgICAgIHRoaXNbQlVGRkVSU0hJRlRdKClcbiAgICBlbHNlIHtcbiAgICAgIHRoaXMuYnVmZmVyLmhlYWQudmFsdWUgPSBjaHVuay5zbGljZShuKVxuICAgICAgY2h1bmsgPSBjaHVuay5zbGljZSgwLCBuKVxuICAgICAgdGhpc1tCVUZGRVJMRU5HVEhdIC09IG5cbiAgICB9XG5cbiAgICB0aGlzLmVtaXQoJ2RhdGEnLCBjaHVuaylcblxuICAgIGlmICghdGhpcy5idWZmZXIubGVuZ3RoICYmICF0aGlzW0VPRl0pXG4gICAgICB0aGlzLmVtaXQoJ2RyYWluJylcblxuICAgIHJldHVybiBjaHVua1xuICB9XG5cbiAgZW5kIChjaHVuaywgZW5jb2RpbmcsIGNiKSB7XG4gICAgaWYgKHR5cGVvZiBjaHVuayA9PT0gJ2Z1bmN0aW9uJylcbiAgICAgIGNiID0gY2h1bmssIGNodW5rID0gbnVsbFxuICAgIGlmICh0eXBlb2YgZW5jb2RpbmcgPT09ICdmdW5jdGlvbicpXG4gICAgICBjYiA9IGVuY29kaW5nLCBlbmNvZGluZyA9ICd1dGY4J1xuICAgIGlmIChjaHVuaylcbiAgICAgIHRoaXMud3JpdGUoY2h1bmssIGVuY29kaW5nKVxuICAgIGlmIChjYilcbiAgICAgIHRoaXMub25jZSgnZW5kJywgY2IpXG4gICAgdGhpc1tFT0ZdID0gdHJ1ZVxuICAgIHRoaXMud3JpdGFibGUgPSBmYWxzZVxuXG4gICAgLy8gaWYgd2UgaGF2ZW4ndCB3cml0dGVuIGFueXRoaW5nLCB0aGVuIGdvIGFoZWFkIGFuZCBlbWl0LFxuICAgIC8vIGV2ZW4gaWYgd2UncmUgbm90IHJlYWRpbmcuXG4gICAgLy8gd2UnbGwgcmUtZW1pdCBpZiBhIG5ldyAnZW5kJyBsaXN0ZW5lciBpcyBhZGRlZCBhbnl3YXkuXG4gICAgLy8gVGhpcyBtYWtlcyBNUCBtb3JlIHN1aXRhYmxlIHRvIHdyaXRlLW9ubHkgdXNlIGNhc2VzLlxuICAgIGlmICh0aGlzLmZsb3dpbmcgfHwgIXRoaXNbUEFVU0VEXSlcbiAgICAgIHRoaXNbTUFZQkVfRU1JVF9FTkRdKClcbiAgICByZXR1cm4gdGhpc1xuICB9XG5cbiAgLy8gZG9uJ3QgbGV0IHRoZSBpbnRlcm5hbCByZXN1bWUgYmUgb3ZlcndyaXR0ZW5cbiAgW1JFU1VNRV0gKCkge1xuICAgIGlmICh0aGlzW0RFU1RST1lFRF0pXG4gICAgICByZXR1cm5cblxuICAgIHRoaXNbUEFVU0VEXSA9IGZhbHNlXG4gICAgdGhpc1tGTE9XSU5HXSA9IHRydWVcbiAgICB0aGlzLmVtaXQoJ3Jlc3VtZScpXG4gICAgaWYgKHRoaXMuYnVmZmVyLmxlbmd0aClcbiAgICAgIHRoaXNbRkxVU0hdKClcbiAgICBlbHNlIGlmICh0aGlzW0VPRl0pXG4gICAgICB0aGlzW01BWUJFX0VNSVRfRU5EXSgpXG4gICAgZWxzZVxuICAgICAgdGhpcy5lbWl0KCdkcmFpbicpXG4gIH1cblxuICByZXN1bWUgKCkge1xuICAgIHJldHVybiB0aGlzW1JFU1VNRV0oKVxuICB9XG5cbiAgcGF1c2UgKCkge1xuICAgIHRoaXNbRkxPV0lOR10gPSBmYWxzZVxuICAgIHRoaXNbUEFVU0VEXSA9IHRydWVcbiAgfVxuXG4gIGdldCBkZXN0cm95ZWQgKCkge1xuICAgIHJldHVybiB0aGlzW0RFU1RST1lFRF1cbiAgfVxuXG4gIGdldCBmbG93aW5nICgpIHtcbiAgICByZXR1cm4gdGhpc1tGTE9XSU5HXVxuICB9XG5cbiAgZ2V0IHBhdXNlZCAoKSB7XG4gICAgcmV0dXJuIHRoaXNbUEFVU0VEXVxuICB9XG5cbiAgW0JVRkZFUlBVU0hdIChjaHVuaykge1xuICAgIGlmICh0aGlzW09CSkVDVE1PREVdKVxuICAgICAgdGhpc1tCVUZGRVJMRU5HVEhdICs9IDFcbiAgICBlbHNlXG4gICAgICB0aGlzW0JVRkZFUkxFTkdUSF0gKz0gY2h1bmsubGVuZ3RoXG4gICAgcmV0dXJuIHRoaXMuYnVmZmVyLnB1c2goY2h1bmspXG4gIH1cblxuICBbQlVGRkVSU0hJRlRdICgpIHtcbiAgICBpZiAodGhpcy5idWZmZXIubGVuZ3RoKSB7XG4gICAgICBpZiAodGhpc1tPQkpFQ1RNT0RFXSlcbiAgICAgICAgdGhpc1tCVUZGRVJMRU5HVEhdIC09IDFcbiAgICAgIGVsc2VcbiAgICAgICAgdGhpc1tCVUZGRVJMRU5HVEhdIC09IHRoaXMuYnVmZmVyLmhlYWQudmFsdWUubGVuZ3RoXG4gICAgfVxuICAgIHJldHVybiB0aGlzLmJ1ZmZlci5zaGlmdCgpXG4gIH1cblxuICBbRkxVU0hdICgpIHtcbiAgICBkbyB7fSB3aGlsZSAodGhpc1tGTFVTSENIVU5LXSh0aGlzW0JVRkZFUlNISUZUXSgpKSlcblxuICAgIGlmICghdGhpcy5idWZmZXIubGVuZ3RoICYmICF0aGlzW0VPRl0pXG4gICAgICB0aGlzLmVtaXQoJ2RyYWluJylcbiAgfVxuXG4gIFtGTFVTSENIVU5LXSAoY2h1bmspIHtcbiAgICByZXR1cm4gY2h1bmsgPyAodGhpcy5lbWl0KCdkYXRhJywgY2h1bmspLCB0aGlzLmZsb3dpbmcpIDogZmFsc2VcbiAgfVxuXG4gIHBpcGUgKGRlc3QsIG9wdHMpIHtcbiAgICBpZiAodGhpc1tERVNUUk9ZRURdKVxuICAgICAgcmV0dXJuXG5cbiAgICBjb25zdCBlbmRlZCA9IHRoaXNbRU1JVFRFRF9FTkRdXG4gICAgb3B0cyA9IG9wdHMgfHwge31cbiAgICBpZiAoZGVzdCA9PT0gcHJvY2Vzcy5zdGRvdXQgfHwgZGVzdCA9PT0gcHJvY2Vzcy5zdGRlcnIpXG4gICAgICBvcHRzLmVuZCA9IGZhbHNlXG4gICAgZWxzZVxuICAgICAgb3B0cy5lbmQgPSBvcHRzLmVuZCAhPT0gZmFsc2VcblxuICAgIGNvbnN0IHAgPSB7IGRlc3Q6IGRlc3QsIG9wdHM6IG9wdHMsIG9uZHJhaW46IF8gPT4gdGhpc1tSRVNVTUVdKCkgfVxuICAgIHRoaXMucGlwZXMucHVzaChwKVxuXG4gICAgZGVzdC5vbignZHJhaW4nLCBwLm9uZHJhaW4pXG4gICAgdGhpc1tSRVNVTUVdKClcbiAgICAvLyBwaXBpbmcgYW4gZW5kZWQgc3RyZWFtIGVuZHMgaW1tZWRpYXRlbHlcbiAgICBpZiAoZW5kZWQgJiYgcC5vcHRzLmVuZClcbiAgICAgIHAuZGVzdC5lbmQoKVxuICAgIHJldHVybiBkZXN0XG4gIH1cblxuICBhZGRMaXN0ZW5lciAoZXYsIGZuKSB7XG4gICAgcmV0dXJuIHRoaXMub24oZXYsIGZuKVxuICB9XG5cbiAgb24gKGV2LCBmbikge1xuICAgIHRyeSB7XG4gICAgICByZXR1cm4gc3VwZXIub24oZXYsIGZuKVxuICAgIH0gZmluYWxseSB7XG4gICAgICBpZiAoZXYgPT09ICdkYXRhJyAmJiAhdGhpcy5waXBlcy5sZW5ndGggJiYgIXRoaXMuZmxvd2luZylcbiAgICAgICAgdGhpc1tSRVNVTUVdKClcbiAgICAgIGVsc2UgaWYgKGlzRW5kaXNoKGV2KSAmJiB0aGlzW0VNSVRURURfRU5EXSkge1xuICAgICAgICBzdXBlci5lbWl0KGV2KVxuICAgICAgICB0aGlzLnJlbW92ZUFsbExpc3RlbmVycyhldilcbiAgICAgIH1cbiAgICB9XG4gIH1cblxuICBnZXQgZW1pdHRlZEVuZCAoKSB7XG4gICAgcmV0dXJuIHRoaXNbRU1JVFRFRF9FTkRdXG4gIH1cblxuICBbTUFZQkVfRU1JVF9FTkRdICgpIHtcbiAgICBpZiAoIXRoaXNbRU1JVFRJTkdfRU5EXSAmJlxuICAgICAgICAhdGhpc1tFTUlUVEVEX0VORF0gJiZcbiAgICAgICAgIXRoaXNbREVTVFJPWUVEXSAmJlxuICAgICAgICB0aGlzLmJ1ZmZlci5sZW5ndGggPT09IDAgJiZcbiAgICAgICAgdGhpc1tFT0ZdKSB7XG4gICAgICB0aGlzW0VNSVRUSU5HX0VORF0gPSB0cnVlXG4gICAgICB0aGlzLmVtaXQoJ2VuZCcpXG4gICAgICB0aGlzLmVtaXQoJ3ByZWZpbmlzaCcpXG4gICAgICB0aGlzLmVtaXQoJ2ZpbmlzaCcpXG4gICAgICBpZiAodGhpc1tDTE9TRURdKVxuICAgICAgICB0aGlzLmVtaXQoJ2Nsb3NlJylcbiAgICAgIHRoaXNbRU1JVFRJTkdfRU5EXSA9IGZhbHNlXG4gICAgfVxuICB9XG5cbiAgZW1pdCAoZXYsIGRhdGEpIHtcbiAgICAvLyBlcnJvciBhbmQgY2xvc2UgYXJlIG9ubHkgZXZlbnRzIGFsbG93ZWQgYWZ0ZXIgY2FsbGluZyBkZXN0cm95KClcbiAgICBpZiAoZXYgIT09ICdlcnJvcicgJiYgZXYgIT09ICdjbG9zZScgJiYgZXYgIT09IERFU1RST1lFRCAmJiB0aGlzW0RFU1RST1lFRF0pXG4gICAgICByZXR1cm5cbiAgICBlbHNlIGlmIChldiA9PT0gJ2RhdGEnKSB7XG4gICAgICBpZiAoIWRhdGEpXG4gICAgICAgIHJldHVyblxuXG4gICAgICBpZiAodGhpcy5waXBlcy5sZW5ndGgpXG4gICAgICAgIHRoaXMucGlwZXMuZm9yRWFjaChwID0+XG4gICAgICAgICAgcC5kZXN0LndyaXRlKGRhdGEpID09PSBmYWxzZSAmJiB0aGlzLnBhdXNlKCkpXG4gICAgfSBlbHNlIGlmIChldiA9PT0gJ2VuZCcpIHtcbiAgICAgIC8vIG9ubHkgYWN0dWFsIGVuZCBnZXRzIHRoaXMgdHJlYXRtZW50XG4gICAgICBpZiAodGhpc1tFTUlUVEVEX0VORF0gPT09IHRydWUpXG4gICAgICAgIHJldHVyblxuXG4gICAgICB0aGlzW0VNSVRURURfRU5EXSA9IHRydWVcbiAgICAgIHRoaXMucmVhZGFibGUgPSBmYWxzZVxuXG4gICAgICBpZiAodGhpc1tERUNPREVSXSkge1xuICAgICAgICBkYXRhID0gdGhpc1tERUNPREVSXS5lbmQoKVxuICAgICAgICBpZiAoZGF0YSkge1xuICAgICAgICAgIHRoaXMucGlwZXMuZm9yRWFjaChwID0+IHAuZGVzdC53cml0ZShkYXRhKSlcbiAgICAgICAgICBzdXBlci5lbWl0KCdkYXRhJywgZGF0YSlcbiAgICAgICAgfVxuICAgICAgfVxuXG4gICAgICB0aGlzLnBpcGVzLmZvckVhY2gocCA9PiB7XG4gICAgICAgIHAuZGVzdC5yZW1vdmVMaXN0ZW5lcignZHJhaW4nLCBwLm9uZHJhaW4pXG4gICAgICAgIGlmIChwLm9wdHMuZW5kKVxuICAgICAgICAgIHAuZGVzdC5lbmQoKVxuICAgICAgfSlcbiAgICB9IGVsc2UgaWYgKGV2ID09PSAnY2xvc2UnKSB7XG4gICAgICB0aGlzW0NMT1NFRF0gPSB0cnVlXG4gICAgICAvLyBkb24ndCBlbWl0IGNsb3NlIGJlZm9yZSAnZW5kJyBhbmQgJ2ZpbmlzaCdcbiAgICAgIGlmICghdGhpc1tFTUlUVEVEX0VORF0gJiYgIXRoaXNbREVTVFJPWUVEXSlcbiAgICAgICAgcmV0dXJuXG4gICAgfVxuXG4gICAgLy8gVE9ETzogcmVwbGFjZSB3aXRoIGEgc3ByZWFkIG9wZXJhdG9yIHdoZW4gTm9kZSB2NCBzdXBwb3J0IGRyb3BzXG4gICAgY29uc3QgYXJncyA9IG5ldyBBcnJheShhcmd1bWVudHMubGVuZ3RoKVxuICAgIGFyZ3NbMF0gPSBldlxuICAgIGFyZ3NbMV0gPSBkYXRhXG4gICAgaWYgKGFyZ3VtZW50cy5sZW5ndGggPiAyKSB7XG4gICAgICBmb3IgKGxldCBpID0gMjsgaSA8IGFyZ3VtZW50cy5sZW5ndGg7IGkrKykge1xuICAgICAgICBhcmdzW2ldID0gYXJndW1lbnRzW2ldXG4gICAgICB9XG4gICAgfVxuXG4gICAgdHJ5IHtcbiAgICAgIHJldHVybiBzdXBlci5lbWl0LmFwcGx5KHRoaXMsIGFyZ3MpXG4gICAgfSBmaW5hbGx5IHtcbiAgICAgIGlmICghaXNFbmRpc2goZXYpKVxuICAgICAgICB0aGlzW01BWUJFX0VNSVRfRU5EXSgpXG4gICAgICBlbHNlXG4gICAgICAgIHRoaXMucmVtb3ZlQWxsTGlzdGVuZXJzKGV2KVxuICAgIH1cbiAgfVxuXG4gIC8vIGNvbnN0IGFsbCA9IGF3YWl0IHN0cmVhbS5jb2xsZWN0KClcbiAgY29sbGVjdCAoKSB7XG4gICAgY29uc3QgYnVmID0gW11cbiAgICBidWYuZGF0YUxlbmd0aCA9IDBcbiAgICB0aGlzLm9uKCdkYXRhJywgYyA9PiB7XG4gICAgICBidWYucHVzaChjKVxuICAgICAgYnVmLmRhdGFMZW5ndGggKz0gYy5sZW5ndGhcbiAgICB9KVxuICAgIHJldHVybiB0aGlzLnByb21pc2UoKS50aGVuKCgpID0+IGJ1ZilcbiAgfVxuXG4gIC8vIGNvbnN0IGRhdGEgPSBhd2FpdCBzdHJlYW0uY29uY2F0KClcbiAgY29uY2F0ICgpIHtcbiAgICByZXR1cm4gdGhpc1tPQkpFQ1RNT0RFXVxuICAgICAgPyBQcm9taXNlLnJlamVjdChuZXcgRXJyb3IoJ2Nhbm5vdCBjb25jYXQgaW4gb2JqZWN0TW9kZScpKVxuICAgICAgOiB0aGlzLmNvbGxlY3QoKS50aGVuKGJ1ZiA9PlxuICAgICAgICAgIHRoaXNbT0JKRUNUTU9ERV1cbiAgICAgICAgICAgID8gUHJvbWlzZS5yZWplY3QobmV3IEVycm9yKCdjYW5ub3QgY29uY2F0IGluIG9iamVjdE1vZGUnKSlcbiAgICAgICAgICAgIDogdGhpc1tFTkNPRElOR10gPyBidWYuam9pbignJykgOiBCLmNvbmNhdChidWYsIGJ1Zi5kYXRhTGVuZ3RoKSlcbiAgfVxuXG4gIC8vIHN0cmVhbS5wcm9taXNlKCkudGhlbigoKSA9PiBkb25lLCBlciA9PiBlbWl0dGVkIGVycm9yKVxuICBwcm9taXNlICgpIHtcbiAgICByZXR1cm4gbmV3IFByb21pc2UoKHJlc29sdmUsIHJlamVjdCkgPT4ge1xuICAgICAgdGhpcy5vbihERVNUUk9ZRUQsICgpID0+IHJlamVjdChuZXcgRXJyb3IoJ3N0cmVhbSBkZXN0cm95ZWQnKSkpXG4gICAgICB0aGlzLm9uKCdlbmQnLCAoKSA9PiByZXNvbHZlKCkpXG4gICAgICB0aGlzLm9uKCdlcnJvcicsIGVyID0+IHJlamVjdChlcikpXG4gICAgfSlcbiAgfVxuXG4gIC8vIGZvciBhd2FpdCAobGV0IGNodW5rIG9mIHN0cmVhbSlcbiAgW0FTWU5DSVRFUkFUT1JdICgpIHtcbiAgICBjb25zdCBuZXh0ID0gKCkgPT4ge1xuICAgICAgY29uc3QgcmVzID0gdGhpcy5yZWFkKClcbiAgICAgIGlmIChyZXMgIT09IG51bGwpXG4gICAgICAgIHJldHVybiBQcm9taXNlLnJlc29sdmUoeyBkb25lOiBmYWxzZSwgdmFsdWU6IHJlcyB9KVxuXG4gICAgICBpZiAodGhpc1tFT0ZdKVxuICAgICAgICByZXR1cm4gUHJvbWlzZS5yZXNvbHZlKHsgZG9uZTogdHJ1ZSB9KVxuXG4gICAgICBsZXQgcmVzb2x2ZSA9IG51bGxcbiAgICAgIGxldCByZWplY3QgPSBudWxsXG4gICAgICBjb25zdCBvbmVyciA9IGVyID0+IHtcbiAgICAgICAgdGhpcy5yZW1vdmVMaXN0ZW5lcignZGF0YScsIG9uZGF0YSlcbiAgICAgICAgdGhpcy5yZW1vdmVMaXN0ZW5lcignZW5kJywgb25lbmQpXG4gICAgICAgIHJlamVjdChlcilcbiAgICAgIH1cbiAgICAgIGNvbnN0IG9uZGF0YSA9IHZhbHVlID0+IHtcbiAgICAgICAgdGhpcy5yZW1vdmVMaXN0ZW5lcignZXJyb3InLCBvbmVycilcbiAgICAgICAgdGhpcy5yZW1vdmVMaXN0ZW5lcignZW5kJywgb25lbmQpXG4gICAgICAgIHRoaXMucGF1c2UoKVxuICAgICAgICByZXNvbHZlKHsgdmFsdWU6IHZhbHVlLCBkb25lOiAhIXRoaXNbRU9GXSB9KVxuICAgICAgfVxuICAgICAgY29uc3Qgb25lbmQgPSAoKSA9PiB7XG4gICAgICAgIHRoaXMucmVtb3ZlTGlzdGVuZXIoJ2Vycm9yJywgb25lcnIpXG4gICAgICAgIHRoaXMucmVtb3ZlTGlzdGVuZXIoJ2RhdGEnLCBvbmRhdGEpXG4gICAgICAgIHJlc29sdmUoeyBkb25lOiB0cnVlIH0pXG4gICAgICB9XG4gICAgICBjb25zdCBvbmRlc3Ryb3kgPSAoKSA9PiBvbmVycihuZXcgRXJyb3IoJ3N0cmVhbSBkZXN0cm95ZWQnKSlcbiAgICAgIHJldHVybiBuZXcgUHJvbWlzZSgocmVzLCByZWopID0+IHtcbiAgICAgICAgcmVqZWN0ID0gcmVqXG4gICAgICAgIHJlc29sdmUgPSByZXNcbiAgICAgICAgdGhpcy5vbmNlKERFU1RST1lFRCwgb25kZXN0cm95KVxuICAgICAgICB0aGlzLm9uY2UoJ2Vycm9yJywgb25lcnIpXG4gICAgICAgIHRoaXMub25jZSgnZW5kJywgb25lbmQpXG4gICAgICAgIHRoaXMub25jZSgnZGF0YScsIG9uZGF0YSlcbiAgICAgIH0pXG4gICAgfVxuXG4gICAgcmV0dXJuIHsgbmV4dCB9XG4gIH1cblxuICAvLyBmb3IgKGxldCBjaHVuayBvZiBzdHJlYW0pXG4gIFtJVEVSQVRPUl0gKCkge1xuICAgIGNvbnN0IG5leHQgPSAoKSA9PiB7XG4gICAgICBjb25zdCB2YWx1ZSA9IHRoaXMucmVhZCgpXG4gICAgICBjb25zdCBkb25lID0gdmFsdWUgPT09IG51bGxcbiAgICAgIHJldHVybiB7IHZhbHVlLCBkb25lIH1cbiAgICB9XG4gICAgcmV0dXJuIHsgbmV4dCB9XG4gIH1cblxuICBkZXN0cm95IChlcikge1xuICAgIGlmICh0aGlzW0RFU1RST1lFRF0pIHtcbiAgICAgIGlmIChlcilcbiAgICAgICAgdGhpcy5lbWl0KCdlcnJvcicsIGVyKVxuICAgICAgZWxzZVxuICAgICAgICB0aGlzLmVtaXQoREVTVFJPWUVEKVxuICAgICAgcmV0dXJuIHRoaXNcbiAgICB9XG5cbiAgICB0aGlzW0RFU1RST1lFRF0gPSB0cnVlXG5cbiAgICAvLyB0aHJvdyBhd2F5IGFsbCBidWZmZXJlZCBkYXRhLCBpdCdzIG5ldmVyIGNvbWluZyBvdXRcbiAgICB0aGlzLmJ1ZmZlciA9IG5ldyBZYWxsaXN0KClcbiAgICB0aGlzW0JVRkZFUkxFTkdUSF0gPSAwXG5cbiAgICBpZiAodHlwZW9mIHRoaXMuY2xvc2UgPT09ICdmdW5jdGlvbicgJiYgIXRoaXNbQ0xPU0VEXSlcbiAgICAgIHRoaXMuY2xvc2UoKVxuXG4gICAgaWYgKGVyKVxuICAgICAgdGhpcy5lbWl0KCdlcnJvcicsIGVyKVxuICAgIGVsc2UgLy8gaWYgbm8gZXJyb3IgdG8gZW1pdCwgc3RpbGwgcmVqZWN0IHBlbmRpbmcgcHJvbWlzZXNcbiAgICAgIHRoaXMuZW1pdChERVNUUk9ZRUQpXG5cbiAgICByZXR1cm4gdGhpc1xuICB9XG5cbiAgc3RhdGljIGlzU3RyZWFtIChzKSB7XG4gICAgcmV0dXJuICEhcyAmJiAocyBpbnN0YW5jZW9mIE1pbmlwYXNzIHx8IHMgaW5zdGFuY2VvZiBFRSAmJiAoXG4gICAgICB0eXBlb2Ygcy5waXBlID09PSAnZnVuY3Rpb24nIHx8IC8vIHJlYWRhYmxlXG4gICAgICAodHlwZW9mIHMud3JpdGUgPT09ICdmdW5jdGlvbicgJiYgdHlwZW9mIHMuZW5kID09PSAnZnVuY3Rpb24nKSAvLyB3cml0YWJsZVxuICAgICkpXG4gIH1cbn1cbiJdLCJuYW1lcyI6W10sImlnbm9yZUxpc3QiOlswXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/swarm-js/node_modules/minipass/index.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/swarm-js/node_modules/minizlib/constants.js":
/*!******************************************************************!*\
  !*** ./node_modules/swarm-js/node_modules/minizlib/constants.js ***!
  \******************************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

eval("// Update with any zlib constants that are added or changed in the future.\n// Node v6 didn't export this, so we just hard code the version and rely\n// on all the other hard-coded values from zlib v4736.  When node v6\n// support drops, we can just export the realZlibConstants object.\nconst realZlibConstants = (__webpack_require__(/*! zlib */ \"zlib\").constants) ||\n  /* istanbul ignore next */ { ZLIB_VERNUM: 4736 }\n\nmodule.exports = Object.freeze(Object.assign(Object.create(null), {\n  Z_NO_FLUSH: 0,\n  Z_PARTIAL_FLUSH: 1,\n  Z_SYNC_FLUSH: 2,\n  Z_FULL_FLUSH: 3,\n  Z_FINISH: 4,\n  Z_BLOCK: 5,\n  Z_OK: 0,\n  Z_STREAM_END: 1,\n  Z_NEED_DICT: 2,\n  Z_ERRNO: -1,\n  Z_STREAM_ERROR: -2,\n  Z_DATA_ERROR: -3,\n  Z_MEM_ERROR: -4,\n  Z_BUF_ERROR: -5,\n  Z_VERSION_ERROR: -6,\n  Z_NO_COMPRESSION: 0,\n  Z_BEST_SPEED: 1,\n  Z_BEST_COMPRESSION: 9,\n  Z_DEFAULT_COMPRESSION: -1,\n  Z_FILTERED: 1,\n  Z_HUFFMAN_ONLY: 2,\n  Z_RLE: 3,\n  Z_FIXED: 4,\n  Z_DEFAULT_STRATEGY: 0,\n  DEFLATE: 1,\n  INFLATE: 2,\n  GZIP: 3,\n  GUNZIP: 4,\n  DEFLATERAW: 5,\n  INFLATERAW: 6,\n  UNZIP: 7,\n  BROTLI_DECODE: 8,\n  BROTLI_ENCODE: 9,\n  Z_MIN_WINDOWBITS: 8,\n  Z_MAX_WINDOWBITS: 15,\n  Z_DEFAULT_WINDOWBITS: 15,\n  Z_MIN_CHUNK: 64,\n  Z_MAX_CHUNK: Infinity,\n  Z_DEFAULT_CHUNK: 16384,\n  Z_MIN_MEMLEVEL: 1,\n  Z_MAX_MEMLEVEL: 9,\n  Z_DEFAULT_MEMLEVEL: 8,\n  Z_MIN_LEVEL: -1,\n  Z_MAX_LEVEL: 9,\n  Z_DEFAULT_LEVEL: -1,\n  BROTLI_OPERATION_PROCESS: 0,\n  BROTLI_OPERATION_FLUSH: 1,\n  BROTLI_OPERATION_FINISH: 2,\n  BROTLI_OPERATION_EMIT_METADATA: 3,\n  BROTLI_MODE_GENERIC: 0,\n  BROTLI_MODE_TEXT: 1,\n  BROTLI_MODE_FONT: 2,\n  BROTLI_DEFAULT_MODE: 0,\n  BROTLI_MIN_QUALITY: 0,\n  BROTLI_MAX_QUALITY: 11,\n  BROTLI_DEFAULT_QUALITY: 11,\n  BROTLI_MIN_WINDOW_BITS: 10,\n  BROTLI_MAX_WINDOW_BITS: 24,\n  BROTLI_LARGE_MAX_WINDOW_BITS: 30,\n  BROTLI_DEFAULT_WINDOW: 22,\n  BROTLI_MIN_INPUT_BLOCK_BITS: 16,\n  BROTLI_MAX_INPUT_BLOCK_BITS: 24,\n  BROTLI_PARAM_MODE: 0,\n  BROTLI_PARAM_QUALITY: 1,\n  BROTLI_PARAM_LGWIN: 2,\n  BROTLI_PARAM_LGBLOCK: 3,\n  BROTLI_PARAM_DISABLE_LITERAL_CONTEXT_MODELING: 4,\n  BROTLI_PARAM_SIZE_HINT: 5,\n  BROTLI_PARAM_LARGE_WINDOW: 6,\n  BROTLI_PARAM_NPOSTFIX: 7,\n  BROTLI_PARAM_NDIRECT: 8,\n  BROTLI_DECODER_RESULT_ERROR: 0,\n  BROTLI_DECODER_RESULT_SUCCESS: 1,\n  BROTLI_DECODER_RESULT_NEEDS_MORE_INPUT: 2,\n  BROTLI_DECODER_RESULT_NEEDS_MORE_OUTPUT: 3,\n  BROTLI_DECODER_PARAM_DISABLE_RING_BUFFER_REALLOCATION: 0,\n  BROTLI_DECODER_PARAM_LARGE_WINDOW: 1,\n  BROTLI_DECODER_NO_ERROR: 0,\n  BROTLI_DECODER_SUCCESS: 1,\n  BROTLI_DECODER_NEEDS_MORE_INPUT: 2,\n  BROTLI_DECODER_NEEDS_MORE_OUTPUT: 3,\n  BROTLI_DECODER_ERROR_FORMAT_EXUBERANT_NIBBLE: -1,\n  BROTLI_DECODER_ERROR_FORMAT_RESERVED: -2,\n  BROTLI_DECODER_ERROR_FORMAT_EXUBERANT_META_NIBBLE: -3,\n  BROTLI_DECODER_ERROR_FORMAT_SIMPLE_HUFFMAN_ALPHABET: -4,\n  BROTLI_DECODER_ERROR_FORMAT_SIMPLE_HUFFMAN_SAME: -5,\n  BROTLI_DECODER_ERROR_FORMAT_CL_SPACE: -6,\n  BROTLI_DECODER_ERROR_FORMAT_HUFFMAN_SPACE: -7,\n  BROTLI_DECODER_ERROR_FORMAT_CONTEXT_MAP_REPEAT: -8,\n  BROTLI_DECODER_ERROR_FORMAT_BLOCK_LENGTH_1: -9,\n  BROTLI_DECODER_ERROR_FORMAT_BLOCK_LENGTH_2: -10,\n  BROTLI_DECODER_ERROR_FORMAT_TRANSFORM: -11,\n  BROTLI_DECODER_ERROR_FORMAT_DICTIONARY: -12,\n  BROTLI_DECODER_ERROR_FORMAT_WINDOW_BITS: -13,\n  BROTLI_DECODER_ERROR_FORMAT_PADDING_1: -14,\n  BROTLI_DECODER_ERROR_FORMAT_PADDING_2: -15,\n  BROTLI_DECODER_ERROR_FORMAT_DISTANCE: -16,\n  BROTLI_DECODER_ERROR_DICTIONARY_NOT_SET: -19,\n  BROTLI_DECODER_ERROR_INVALID_ARGUMENTS: -20,\n  BROTLI_DECODER_ERROR_ALLOC_CONTEXT_MODES: -21,\n  BROTLI_DECODER_ERROR_ALLOC_TREE_GROUPS: -22,\n  BROTLI_DECODER_ERROR_ALLOC_CONTEXT_MAP: -25,\n  BROTLI_DECODER_ERROR_ALLOC_RING_BUFFER_1: -26,\n  BROTLI_DECODER_ERROR_ALLOC_RING_BUFFER_2: -27,\n  BROTLI_DECODER_ERROR_ALLOC_BLOCK_TYPE_TREES: -30,\n  BROTLI_DECODER_ERROR_UNREACHABLE: -31,\n}, realZlibConstants))\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvc3dhcm0tanMvbm9kZV9tb2R1bGVzL21pbml6bGliL2NvbnN0YW50cy5qcyIsIm1hcHBpbmdzIjoiQUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDBCQUEwQixtREFBeUI7QUFDbkQsK0JBQStCOztBQUUvQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQyIsInNvdXJjZXMiOlsiL1VzZXJzL3BhbnphL0RvY3VtZW50cy9QZXJzb25hbFByb2plY3RzL3ByZWRpay9ub2RlX21vZHVsZXMvc3dhcm0tanMvbm9kZV9tb2R1bGVzL21pbml6bGliL2NvbnN0YW50cy5qcyJdLCJzb3VyY2VzQ29udGVudCI6WyIvLyBVcGRhdGUgd2l0aCBhbnkgemxpYiBjb25zdGFudHMgdGhhdCBhcmUgYWRkZWQgb3IgY2hhbmdlZCBpbiB0aGUgZnV0dXJlLlxuLy8gTm9kZSB2NiBkaWRuJ3QgZXhwb3J0IHRoaXMsIHNvIHdlIGp1c3QgaGFyZCBjb2RlIHRoZSB2ZXJzaW9uIGFuZCByZWx5XG4vLyBvbiBhbGwgdGhlIG90aGVyIGhhcmQtY29kZWQgdmFsdWVzIGZyb20gemxpYiB2NDczNi4gIFdoZW4gbm9kZSB2NlxuLy8gc3VwcG9ydCBkcm9wcywgd2UgY2FuIGp1c3QgZXhwb3J0IHRoZSByZWFsWmxpYkNvbnN0YW50cyBvYmplY3QuXG5jb25zdCByZWFsWmxpYkNvbnN0YW50cyA9IHJlcXVpcmUoJ3psaWInKS5jb25zdGFudHMgfHxcbiAgLyogaXN0YW5idWwgaWdub3JlIG5leHQgKi8geyBaTElCX1ZFUk5VTTogNDczNiB9XG5cbm1vZHVsZS5leHBvcnRzID0gT2JqZWN0LmZyZWV6ZShPYmplY3QuYXNzaWduKE9iamVjdC5jcmVhdGUobnVsbCksIHtcbiAgWl9OT19GTFVTSDogMCxcbiAgWl9QQVJUSUFMX0ZMVVNIOiAxLFxuICBaX1NZTkNfRkxVU0g6IDIsXG4gIFpfRlVMTF9GTFVTSDogMyxcbiAgWl9GSU5JU0g6IDQsXG4gIFpfQkxPQ0s6IDUsXG4gIFpfT0s6IDAsXG4gIFpfU1RSRUFNX0VORDogMSxcbiAgWl9ORUVEX0RJQ1Q6IDIsXG4gIFpfRVJSTk86IC0xLFxuICBaX1NUUkVBTV9FUlJPUjogLTIsXG4gIFpfREFUQV9FUlJPUjogLTMsXG4gIFpfTUVNX0VSUk9SOiAtNCxcbiAgWl9CVUZfRVJST1I6IC01LFxuICBaX1ZFUlNJT05fRVJST1I6IC02LFxuICBaX05PX0NPTVBSRVNTSU9OOiAwLFxuICBaX0JFU1RfU1BFRUQ6IDEsXG4gIFpfQkVTVF9DT01QUkVTU0lPTjogOSxcbiAgWl9ERUZBVUxUX0NPTVBSRVNTSU9OOiAtMSxcbiAgWl9GSUxURVJFRDogMSxcbiAgWl9IVUZGTUFOX09OTFk6IDIsXG4gIFpfUkxFOiAzLFxuICBaX0ZJWEVEOiA0LFxuICBaX0RFRkFVTFRfU1RSQVRFR1k6IDAsXG4gIERFRkxBVEU6IDEsXG4gIElORkxBVEU6IDIsXG4gIEdaSVA6IDMsXG4gIEdVTlpJUDogNCxcbiAgREVGTEFURVJBVzogNSxcbiAgSU5GTEFURVJBVzogNixcbiAgVU5aSVA6IDcsXG4gIEJST1RMSV9ERUNPREU6IDgsXG4gIEJST1RMSV9FTkNPREU6IDksXG4gIFpfTUlOX1dJTkRPV0JJVFM6IDgsXG4gIFpfTUFYX1dJTkRPV0JJVFM6IDE1LFxuICBaX0RFRkFVTFRfV0lORE9XQklUUzogMTUsXG4gIFpfTUlOX0NIVU5LOiA2NCxcbiAgWl9NQVhfQ0hVTks6IEluZmluaXR5LFxuICBaX0RFRkFVTFRfQ0hVTks6IDE2Mzg0LFxuICBaX01JTl9NRU1MRVZFTDogMSxcbiAgWl9NQVhfTUVNTEVWRUw6IDksXG4gIFpfREVGQVVMVF9NRU1MRVZFTDogOCxcbiAgWl9NSU5fTEVWRUw6IC0xLFxuICBaX01BWF9MRVZFTDogOSxcbiAgWl9ERUZBVUxUX0xFVkVMOiAtMSxcbiAgQlJPVExJX09QRVJBVElPTl9QUk9DRVNTOiAwLFxuICBCUk9UTElfT1BFUkFUSU9OX0ZMVVNIOiAxLFxuICBCUk9UTElfT1BFUkFUSU9OX0ZJTklTSDogMixcbiAgQlJPVExJX09QRVJBVElPTl9FTUlUX01FVEFEQVRBOiAzLFxuICBCUk9UTElfTU9ERV9HRU5FUklDOiAwLFxuICBCUk9UTElfTU9ERV9URVhUOiAxLFxuICBCUk9UTElfTU9ERV9GT05UOiAyLFxuICBCUk9UTElfREVGQVVMVF9NT0RFOiAwLFxuICBCUk9UTElfTUlOX1FVQUxJVFk6IDAsXG4gIEJST1RMSV9NQVhfUVVBTElUWTogMTEsXG4gIEJST1RMSV9ERUZBVUxUX1FVQUxJVFk6IDExLFxuICBCUk9UTElfTUlOX1dJTkRPV19CSVRTOiAxMCxcbiAgQlJPVExJX01BWF9XSU5ET1dfQklUUzogMjQsXG4gIEJST1RMSV9MQVJHRV9NQVhfV0lORE9XX0JJVFM6IDMwLFxuICBCUk9UTElfREVGQVVMVF9XSU5ET1c6IDIyLFxuICBCUk9UTElfTUlOX0lOUFVUX0JMT0NLX0JJVFM6IDE2LFxuICBCUk9UTElfTUFYX0lOUFVUX0JMT0NLX0JJVFM6IDI0LFxuICBCUk9UTElfUEFSQU1fTU9ERTogMCxcbiAgQlJPVExJX1BBUkFNX1FVQUxJVFk6IDEsXG4gIEJST1RMSV9QQVJBTV9MR1dJTjogMixcbiAgQlJPVExJX1BBUkFNX0xHQkxPQ0s6IDMsXG4gIEJST1RMSV9QQVJBTV9ESVNBQkxFX0xJVEVSQUxfQ09OVEVYVF9NT0RFTElORzogNCxcbiAgQlJPVExJX1BBUkFNX1NJWkVfSElOVDogNSxcbiAgQlJPVExJX1BBUkFNX0xBUkdFX1dJTkRPVzogNixcbiAgQlJPVExJX1BBUkFNX05QT1NURklYOiA3LFxuICBCUk9UTElfUEFSQU1fTkRJUkVDVDogOCxcbiAgQlJPVExJX0RFQ09ERVJfUkVTVUxUX0VSUk9SOiAwLFxuICBCUk9UTElfREVDT0RFUl9SRVNVTFRfU1VDQ0VTUzogMSxcbiAgQlJPVExJX0RFQ09ERVJfUkVTVUxUX05FRURTX01PUkVfSU5QVVQ6IDIsXG4gIEJST1RMSV9ERUNPREVSX1JFU1VMVF9ORUVEU19NT1JFX09VVFBVVDogMyxcbiAgQlJPVExJX0RFQ09ERVJfUEFSQU1fRElTQUJMRV9SSU5HX0JVRkZFUl9SRUFMTE9DQVRJT046IDAsXG4gIEJST1RMSV9ERUNPREVSX1BBUkFNX0xBUkdFX1dJTkRPVzogMSxcbiAgQlJPVExJX0RFQ09ERVJfTk9fRVJST1I6IDAsXG4gIEJST1RMSV9ERUNPREVSX1NVQ0NFU1M6IDEsXG4gIEJST1RMSV9ERUNPREVSX05FRURTX01PUkVfSU5QVVQ6IDIsXG4gIEJST1RMSV9ERUNPREVSX05FRURTX01PUkVfT1VUUFVUOiAzLFxuICBCUk9UTElfREVDT0RFUl9FUlJPUl9GT1JNQVRfRVhVQkVSQU5UX05JQkJMRTogLTEsXG4gIEJST1RMSV9ERUNPREVSX0VSUk9SX0ZPUk1BVF9SRVNFUlZFRDogLTIsXG4gIEJST1RMSV9ERUNPREVSX0VSUk9SX0ZPUk1BVF9FWFVCRVJBTlRfTUVUQV9OSUJCTEU6IC0zLFxuICBCUk9UTElfREVDT0RFUl9FUlJPUl9GT1JNQVRfU0lNUExFX0hVRkZNQU5fQUxQSEFCRVQ6IC00LFxuICBCUk9UTElfREVDT0RFUl9FUlJPUl9GT1JNQVRfU0lNUExFX0hVRkZNQU5fU0FNRTogLTUsXG4gIEJST1RMSV9ERUNPREVSX0VSUk9SX0ZPUk1BVF9DTF9TUEFDRTogLTYsXG4gIEJST1RMSV9ERUNPREVSX0VSUk9SX0ZPUk1BVF9IVUZGTUFOX1NQQUNFOiAtNyxcbiAgQlJPVExJX0RFQ09ERVJfRVJST1JfRk9STUFUX0NPTlRFWFRfTUFQX1JFUEVBVDogLTgsXG4gIEJST1RMSV9ERUNPREVSX0VSUk9SX0ZPUk1BVF9CTE9DS19MRU5HVEhfMTogLTksXG4gIEJST1RMSV9ERUNPREVSX0VSUk9SX0ZPUk1BVF9CTE9DS19MRU5HVEhfMjogLTEwLFxuICBCUk9UTElfREVDT0RFUl9FUlJPUl9GT1JNQVRfVFJBTlNGT1JNOiAtMTEsXG4gIEJST1RMSV9ERUNPREVSX0VSUk9SX0ZPUk1BVF9ESUNUSU9OQVJZOiAtMTIsXG4gIEJST1RMSV9ERUNPREVSX0VSUk9SX0ZPUk1BVF9XSU5ET1dfQklUUzogLTEzLFxuICBCUk9UTElfREVDT0RFUl9FUlJPUl9GT1JNQVRfUEFERElOR18xOiAtMTQsXG4gIEJST1RMSV9ERUNPREVSX0VSUk9SX0ZPUk1BVF9QQURESU5HXzI6IC0xNSxcbiAgQlJPVExJX0RFQ09ERVJfRVJST1JfRk9STUFUX0RJU1RBTkNFOiAtMTYsXG4gIEJST1RMSV9ERUNPREVSX0VSUk9SX0RJQ1RJT05BUllfTk9UX1NFVDogLTE5LFxuICBCUk9UTElfREVDT0RFUl9FUlJPUl9JTlZBTElEX0FSR1VNRU5UUzogLTIwLFxuICBCUk9UTElfREVDT0RFUl9FUlJPUl9BTExPQ19DT05URVhUX01PREVTOiAtMjEsXG4gIEJST1RMSV9ERUNPREVSX0VSUk9SX0FMTE9DX1RSRUVfR1JPVVBTOiAtMjIsXG4gIEJST1RMSV9ERUNPREVSX0VSUk9SX0FMTE9DX0NPTlRFWFRfTUFQOiAtMjUsXG4gIEJST1RMSV9ERUNPREVSX0VSUk9SX0FMTE9DX1JJTkdfQlVGRkVSXzE6IC0yNixcbiAgQlJPVExJX0RFQ09ERVJfRVJST1JfQUxMT0NfUklOR19CVUZGRVJfMjogLTI3LFxuICBCUk9UTElfREVDT0RFUl9FUlJPUl9BTExPQ19CTE9DS19UWVBFX1RSRUVTOiAtMzAsXG4gIEJST1RMSV9ERUNPREVSX0VSUk9SX1VOUkVBQ0hBQkxFOiAtMzEsXG59LCByZWFsWmxpYkNvbnN0YW50cykpXG4iXSwibmFtZXMiOltdLCJpZ25vcmVMaXN0IjpbMF0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/swarm-js/node_modules/minizlib/constants.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/swarm-js/node_modules/minizlib/index.js":
/*!**************************************************************!*\
  !*** ./node_modules/swarm-js/node_modules/minizlib/index.js ***!
  \**************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";
eval("\n\nconst assert = __webpack_require__(/*! assert */ \"assert\")\nconst Buffer = (__webpack_require__(/*! buffer */ \"buffer\").Buffer)\nconst realZlib = __webpack_require__(/*! zlib */ \"zlib\")\n\nconst constants = exports.constants = __webpack_require__(/*! ./constants.js */ \"(ssr)/./node_modules/swarm-js/node_modules/minizlib/constants.js\")\nconst Minipass = __webpack_require__(/*! minipass */ \"(ssr)/./node_modules/swarm-js/node_modules/minipass/index.js\")\n\nconst OriginalBufferConcat = Buffer.concat\n\nclass ZlibError extends Error {\n  constructor (err) {\n    super('zlib: ' + err.message)\n    this.code = err.code\n    this.errno = err.errno\n    /* istanbul ignore if */\n    if (!this.code)\n      this.code = 'ZLIB_ERROR'\n\n    this.message = 'zlib: ' + err.message\n    Error.captureStackTrace(this, this.constructor)\n  }\n\n  get name () {\n    return 'ZlibError'\n  }\n}\n\n// the Zlib class they all inherit from\n// This thing manages the queue of requests, and returns\n// true or false if there is anything in the queue when\n// you call the .write() method.\nconst _opts = Symbol('opts')\nconst _flushFlag = Symbol('flushFlag')\nconst _finishFlushFlag = Symbol('finishFlushFlag')\nconst _fullFlushFlag = Symbol('fullFlushFlag')\nconst _handle = Symbol('handle')\nconst _onError = Symbol('onError')\nconst _sawError = Symbol('sawError')\nconst _level = Symbol('level')\nconst _strategy = Symbol('strategy')\nconst _ended = Symbol('ended')\nconst _defaultFullFlush = Symbol('_defaultFullFlush')\n\nclass ZlibBase extends Minipass {\n  constructor (opts, mode) {\n    if (!opts || typeof opts !== 'object')\n      throw new TypeError('invalid options for ZlibBase constructor')\n\n    super(opts)\n    this[_ended] = false\n    this[_opts] = opts\n\n    this[_flushFlag] = opts.flush\n    this[_finishFlushFlag] = opts.finishFlush\n    // this will throw if any options are invalid for the class selected\n    try {\n      this[_handle] = new realZlib[mode](opts)\n    } catch (er) {\n      // make sure that all errors get decorated properly\n      throw new ZlibError(er)\n    }\n\n    this[_onError] = (err) => {\n      this[_sawError] = true\n      // there is no way to cleanly recover.\n      // continuing only obscures problems.\n      this.close()\n      this.emit('error', err)\n    }\n\n    this[_handle].on('error', er => this[_onError](new ZlibError(er)))\n    this.once('end', () => this.close)\n  }\n\n  close () {\n    if (this[_handle]) {\n      this[_handle].close()\n      this[_handle] = null\n      this.emit('close')\n    }\n  }\n\n  reset () {\n    if (!this[_sawError]) {\n      assert(this[_handle], 'zlib binding closed')\n      return this[_handle].reset()\n    }\n  }\n\n  flush (flushFlag) {\n    if (this.ended)\n      return\n\n    if (typeof flushFlag !== 'number')\n      flushFlag = this[_fullFlushFlag]\n    this.write(Object.assign(Buffer.alloc(0), { [_flushFlag]: flushFlag }))\n  }\n\n  end (chunk, encoding, cb) {\n    if (chunk)\n      this.write(chunk, encoding)\n    this.flush(this[_finishFlushFlag])\n    this[_ended] = true\n    return super.end(null, null, cb)\n  }\n\n  get ended () {\n    return this[_ended]\n  }\n\n  write (chunk, encoding, cb) {\n    // process the chunk using the sync process\n    // then super.write() all the outputted chunks\n    if (typeof encoding === 'function')\n      cb = encoding, encoding = 'utf8'\n\n    if (typeof chunk === 'string')\n      chunk = Buffer.from(chunk, encoding)\n\n    if (this[_sawError])\n      return\n    assert(this[_handle], 'zlib binding closed')\n\n    // _processChunk tries to .close() the native handle after it's done, so we\n    // intercept that by temporarily making it a no-op.\n    const nativeHandle = this[_handle]._handle\n    const originalNativeClose = nativeHandle.close\n    nativeHandle.close = () => {}\n    const originalClose = this[_handle].close\n    this[_handle].close = () => {}\n    // It also calls `Buffer.concat()` at the end, which may be convenient\n    // for some, but which we are not interested in as it slows us down.\n    Buffer.concat = (args) => args\n    let result\n    try {\n      const flushFlag = typeof chunk[_flushFlag] === 'number'\n        ? chunk[_flushFlag] : this[_flushFlag]\n      result = this[_handle]._processChunk(chunk, flushFlag)\n      // if we don't throw, reset it back how it was\n      Buffer.concat = OriginalBufferConcat\n    } catch (err) {\n      // or if we do, put Buffer.concat() back before we emit error\n      // Error events call into user code, which may call Buffer.concat()\n      Buffer.concat = OriginalBufferConcat\n      this[_onError](new ZlibError(err))\n    } finally {\n      if (this[_handle]) {\n        // Core zlib resets `_handle` to null after attempting to close the\n        // native handle. Our no-op handler prevented actual closure, but we\n        // need to restore the `._handle` property.\n        this[_handle]._handle = nativeHandle\n        nativeHandle.close = originalNativeClose\n        this[_handle].close = originalClose\n        // `_processChunk()` adds an 'error' listener. If we don't remove it\n        // after each call, these handlers start piling up.\n        this[_handle].removeAllListeners('error')\n      }\n    }\n\n    let writeReturn\n    if (result) {\n      if (Array.isArray(result) && result.length > 0) {\n        // The first buffer is always `handle._outBuffer`, which would be\n        // re-used for later invocations; so, we always have to copy that one.\n        writeReturn = super.write(Buffer.from(result[0]))\n        for (let i = 1; i < result.length; i++) {\n          writeReturn = super.write(result[i])\n        }\n      } else {\n        writeReturn = super.write(Buffer.from(result))\n      }\n    }\n\n    if (cb)\n      cb()\n    return writeReturn\n  }\n}\n\nclass Zlib extends ZlibBase {\n  constructor (opts, mode) {\n    opts = opts || {}\n\n    opts.flush = opts.flush || constants.Z_NO_FLUSH\n    opts.finishFlush = opts.finishFlush || constants.Z_FINISH\n    super(opts, mode)\n\n    this[_fullFlushFlag] = constants.Z_FULL_FLUSH\n    this[_level] = opts.level\n    this[_strategy] = opts.strategy\n  }\n\n  params (level, strategy) {\n    if (this[_sawError])\n      return\n\n    if (!this[_handle])\n      throw new Error('cannot switch params when binding is closed')\n\n    // no way to test this without also not supporting params at all\n    /* istanbul ignore if */\n    if (!this[_handle].params)\n      throw new Error('not supported in this implementation')\n\n    if (this[_level] !== level || this[_strategy] !== strategy) {\n      this.flush(constants.Z_SYNC_FLUSH)\n      assert(this[_handle], 'zlib binding closed')\n      // .params() calls .flush(), but the latter is always async in the\n      // core zlib. We override .flush() temporarily to intercept that and\n      // flush synchronously.\n      const origFlush = this[_handle].flush\n      this[_handle].flush = (flushFlag, cb) => {\n        this.flush(flushFlag)\n        cb()\n      }\n      try {\n        this[_handle].params(level, strategy)\n      } finally {\n        this[_handle].flush = origFlush\n      }\n      /* istanbul ignore else */\n      if (this[_handle]) {\n        this[_level] = level\n        this[_strategy] = strategy\n      }\n    }\n  }\n}\n\n// minimal 2-byte header\nclass Deflate extends Zlib {\n  constructor (opts) {\n    super(opts, 'Deflate')\n  }\n}\n\nclass Inflate extends Zlib {\n  constructor (opts) {\n    super(opts, 'Inflate')\n  }\n}\n\n// gzip - bigger header, same deflate compression\nclass Gzip extends Zlib {\n  constructor (opts) {\n    super(opts, 'Gzip')\n  }\n}\n\nclass Gunzip extends Zlib {\n  constructor (opts) {\n    super(opts, 'Gunzip')\n  }\n}\n\n// raw - no header\nclass DeflateRaw extends Zlib {\n  constructor (opts) {\n    super(opts, 'DeflateRaw')\n  }\n}\n\nclass InflateRaw extends Zlib {\n  constructor (opts) {\n    super(opts, 'InflateRaw')\n  }\n}\n\n// auto-detect header.\nclass Unzip extends Zlib {\n  constructor (opts) {\n    super(opts, 'Unzip')\n  }\n}\n\nclass Brotli extends ZlibBase {\n  constructor (opts, mode) {\n    opts = opts || {}\n\n    opts.flush = opts.flush || constants.BROTLI_OPERATION_PROCESS\n    opts.finishFlush = opts.finishFlush || constants.BROTLI_OPERATION_FINISH\n\n    super(opts, mode)\n\n    this[_fullFlushFlag] = constants.BROTLI_OPERATION_FLUSH\n  }\n}\n\nclass BrotliCompress extends Brotli {\n  constructor (opts) {\n    super(opts, 'BrotliCompress')\n  }\n}\n\nclass BrotliDecompress extends Brotli {\n  constructor (opts) {\n    super(opts, 'BrotliDecompress')\n  }\n}\n\nexports.Deflate = Deflate\nexports.Inflate = Inflate\nexports.Gzip = Gzip\nexports.Gunzip = Gunzip\nexports.DeflateRaw = DeflateRaw\nexports.InflateRaw = InflateRaw\nexports.Unzip = Unzip\n/* istanbul ignore else */\nif (typeof realZlib.BrotliCompress === 'function') {\n  exports.BrotliCompress = BrotliCompress\n  exports.BrotliDecompress = BrotliDecompress\n} else {\n  exports.BrotliCompress = exports.BrotliDecompress = class {\n    constructor () {\n      throw new Error('Brotli is not supported in this version of Node.js')\n    }\n  }\n}\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvc3dhcm0tanMvbm9kZV9tb2R1bGVzL21pbml6bGliL2luZGV4LmpzIiwibWFwcGluZ3MiOiJBQUFZOztBQUVaLGVBQWUsbUJBQU8sQ0FBQyxzQkFBUTtBQUMvQixlQUFlLG9EQUF3QjtBQUN2QyxpQkFBaUIsbUJBQU8sQ0FBQyxrQkFBTTs7QUFFL0Isa0JBQWtCLGlJQUE2QztBQUMvRCxpQkFBaUIsbUJBQU8sQ0FBQyw4RUFBVTs7QUFFbkM7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsZ0RBQWdELHlCQUF5QjtBQUN6RTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDBDQUEwQztBQUMxQztBQUNBLHdCQUF3QixtQkFBbUI7QUFDM0M7QUFDQTtBQUNBLFFBQVE7QUFDUjtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsUUFBUTtBQUNSO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBLGVBQWU7QUFDZixlQUFlO0FBQ2YsWUFBWTtBQUNaLGNBQWM7QUFDZCxrQkFBa0I7QUFDbEIsa0JBQWtCO0FBQ2xCLGFBQWE7QUFDYjtBQUNBO0FBQ0EsRUFBRSxzQkFBc0I7QUFDeEIsRUFBRSx3QkFBd0I7QUFDMUIsRUFBRTtBQUNGLEVBQUUsc0JBQXNCLEdBQUcsd0JBQXdCO0FBQ25EO0FBQ0E7QUFDQTtBQUNBO0FBQ0EiLCJzb3VyY2VzIjpbIi9Vc2Vycy9wYW56YS9Eb2N1bWVudHMvUGVyc29uYWxQcm9qZWN0cy9wcmVkaWsvbm9kZV9tb2R1bGVzL3N3YXJtLWpzL25vZGVfbW9kdWxlcy9taW5pemxpYi9pbmRleC5qcyJdLCJzb3VyY2VzQ29udGVudCI6WyIndXNlIHN0cmljdCdcblxuY29uc3QgYXNzZXJ0ID0gcmVxdWlyZSgnYXNzZXJ0JylcbmNvbnN0IEJ1ZmZlciA9IHJlcXVpcmUoJ2J1ZmZlcicpLkJ1ZmZlclxuY29uc3QgcmVhbFpsaWIgPSByZXF1aXJlKCd6bGliJylcblxuY29uc3QgY29uc3RhbnRzID0gZXhwb3J0cy5jb25zdGFudHMgPSByZXF1aXJlKCcuL2NvbnN0YW50cy5qcycpXG5jb25zdCBNaW5pcGFzcyA9IHJlcXVpcmUoJ21pbmlwYXNzJylcblxuY29uc3QgT3JpZ2luYWxCdWZmZXJDb25jYXQgPSBCdWZmZXIuY29uY2F0XG5cbmNsYXNzIFpsaWJFcnJvciBleHRlbmRzIEVycm9yIHtcbiAgY29uc3RydWN0b3IgKGVycikge1xuICAgIHN1cGVyKCd6bGliOiAnICsgZXJyLm1lc3NhZ2UpXG4gICAgdGhpcy5jb2RlID0gZXJyLmNvZGVcbiAgICB0aGlzLmVycm5vID0gZXJyLmVycm5vXG4gICAgLyogaXN0YW5idWwgaWdub3JlIGlmICovXG4gICAgaWYgKCF0aGlzLmNvZGUpXG4gICAgICB0aGlzLmNvZGUgPSAnWkxJQl9FUlJPUidcblxuICAgIHRoaXMubWVzc2FnZSA9ICd6bGliOiAnICsgZXJyLm1lc3NhZ2VcbiAgICBFcnJvci5jYXB0dXJlU3RhY2tUcmFjZSh0aGlzLCB0aGlzLmNvbnN0cnVjdG9yKVxuICB9XG5cbiAgZ2V0IG5hbWUgKCkge1xuICAgIHJldHVybiAnWmxpYkVycm9yJ1xuICB9XG59XG5cbi8vIHRoZSBabGliIGNsYXNzIHRoZXkgYWxsIGluaGVyaXQgZnJvbVxuLy8gVGhpcyB0aGluZyBtYW5hZ2VzIHRoZSBxdWV1ZSBvZiByZXF1ZXN0cywgYW5kIHJldHVybnNcbi8vIHRydWUgb3IgZmFsc2UgaWYgdGhlcmUgaXMgYW55dGhpbmcgaW4gdGhlIHF1ZXVlIHdoZW5cbi8vIHlvdSBjYWxsIHRoZSAud3JpdGUoKSBtZXRob2QuXG5jb25zdCBfb3B0cyA9IFN5bWJvbCgnb3B0cycpXG5jb25zdCBfZmx1c2hGbGFnID0gU3ltYm9sKCdmbHVzaEZsYWcnKVxuY29uc3QgX2ZpbmlzaEZsdXNoRmxhZyA9IFN5bWJvbCgnZmluaXNoRmx1c2hGbGFnJylcbmNvbnN0IF9mdWxsRmx1c2hGbGFnID0gU3ltYm9sKCdmdWxsRmx1c2hGbGFnJylcbmNvbnN0IF9oYW5kbGUgPSBTeW1ib2woJ2hhbmRsZScpXG5jb25zdCBfb25FcnJvciA9IFN5bWJvbCgnb25FcnJvcicpXG5jb25zdCBfc2F3RXJyb3IgPSBTeW1ib2woJ3Nhd0Vycm9yJylcbmNvbnN0IF9sZXZlbCA9IFN5bWJvbCgnbGV2ZWwnKVxuY29uc3QgX3N0cmF0ZWd5ID0gU3ltYm9sKCdzdHJhdGVneScpXG5jb25zdCBfZW5kZWQgPSBTeW1ib2woJ2VuZGVkJylcbmNvbnN0IF9kZWZhdWx0RnVsbEZsdXNoID0gU3ltYm9sKCdfZGVmYXVsdEZ1bGxGbHVzaCcpXG5cbmNsYXNzIFpsaWJCYXNlIGV4dGVuZHMgTWluaXBhc3Mge1xuICBjb25zdHJ1Y3RvciAob3B0cywgbW9kZSkge1xuICAgIGlmICghb3B0cyB8fCB0eXBlb2Ygb3B0cyAhPT0gJ29iamVjdCcpXG4gICAgICB0aHJvdyBuZXcgVHlwZUVycm9yKCdpbnZhbGlkIG9wdGlvbnMgZm9yIFpsaWJCYXNlIGNvbnN0cnVjdG9yJylcblxuICAgIHN1cGVyKG9wdHMpXG4gICAgdGhpc1tfZW5kZWRdID0gZmFsc2VcbiAgICB0aGlzW19vcHRzXSA9IG9wdHNcblxuICAgIHRoaXNbX2ZsdXNoRmxhZ10gPSBvcHRzLmZsdXNoXG4gICAgdGhpc1tfZmluaXNoRmx1c2hGbGFnXSA9IG9wdHMuZmluaXNoRmx1c2hcbiAgICAvLyB0aGlzIHdpbGwgdGhyb3cgaWYgYW55IG9wdGlvbnMgYXJlIGludmFsaWQgZm9yIHRoZSBjbGFzcyBzZWxlY3RlZFxuICAgIHRyeSB7XG4gICAgICB0aGlzW19oYW5kbGVdID0gbmV3IHJlYWxabGliW21vZGVdKG9wdHMpXG4gICAgfSBjYXRjaCAoZXIpIHtcbiAgICAgIC8vIG1ha2Ugc3VyZSB0aGF0IGFsbCBlcnJvcnMgZ2V0IGRlY29yYXRlZCBwcm9wZXJseVxuICAgICAgdGhyb3cgbmV3IFpsaWJFcnJvcihlcilcbiAgICB9XG5cbiAgICB0aGlzW19vbkVycm9yXSA9IChlcnIpID0+IHtcbiAgICAgIHRoaXNbX3Nhd0Vycm9yXSA9IHRydWVcbiAgICAgIC8vIHRoZXJlIGlzIG5vIHdheSB0byBjbGVhbmx5IHJlY292ZXIuXG4gICAgICAvLyBjb250aW51aW5nIG9ubHkgb2JzY3VyZXMgcHJvYmxlbXMuXG4gICAgICB0aGlzLmNsb3NlKClcbiAgICAgIHRoaXMuZW1pdCgnZXJyb3InLCBlcnIpXG4gICAgfVxuXG4gICAgdGhpc1tfaGFuZGxlXS5vbignZXJyb3InLCBlciA9PiB0aGlzW19vbkVycm9yXShuZXcgWmxpYkVycm9yKGVyKSkpXG4gICAgdGhpcy5vbmNlKCdlbmQnLCAoKSA9PiB0aGlzLmNsb3NlKVxuICB9XG5cbiAgY2xvc2UgKCkge1xuICAgIGlmICh0aGlzW19oYW5kbGVdKSB7XG4gICAgICB0aGlzW19oYW5kbGVdLmNsb3NlKClcbiAgICAgIHRoaXNbX2hhbmRsZV0gPSBudWxsXG4gICAgICB0aGlzLmVtaXQoJ2Nsb3NlJylcbiAgICB9XG4gIH1cblxuICByZXNldCAoKSB7XG4gICAgaWYgKCF0aGlzW19zYXdFcnJvcl0pIHtcbiAgICAgIGFzc2VydCh0aGlzW19oYW5kbGVdLCAnemxpYiBiaW5kaW5nIGNsb3NlZCcpXG4gICAgICByZXR1cm4gdGhpc1tfaGFuZGxlXS5yZXNldCgpXG4gICAgfVxuICB9XG5cbiAgZmx1c2ggKGZsdXNoRmxhZykge1xuICAgIGlmICh0aGlzLmVuZGVkKVxuICAgICAgcmV0dXJuXG5cbiAgICBpZiAodHlwZW9mIGZsdXNoRmxhZyAhPT0gJ251bWJlcicpXG4gICAgICBmbHVzaEZsYWcgPSB0aGlzW19mdWxsRmx1c2hGbGFnXVxuICAgIHRoaXMud3JpdGUoT2JqZWN0LmFzc2lnbihCdWZmZXIuYWxsb2MoMCksIHsgW19mbHVzaEZsYWddOiBmbHVzaEZsYWcgfSkpXG4gIH1cblxuICBlbmQgKGNodW5rLCBlbmNvZGluZywgY2IpIHtcbiAgICBpZiAoY2h1bmspXG4gICAgICB0aGlzLndyaXRlKGNodW5rLCBlbmNvZGluZylcbiAgICB0aGlzLmZsdXNoKHRoaXNbX2ZpbmlzaEZsdXNoRmxhZ10pXG4gICAgdGhpc1tfZW5kZWRdID0gdHJ1ZVxuICAgIHJldHVybiBzdXBlci5lbmQobnVsbCwgbnVsbCwgY2IpXG4gIH1cblxuICBnZXQgZW5kZWQgKCkge1xuICAgIHJldHVybiB0aGlzW19lbmRlZF1cbiAgfVxuXG4gIHdyaXRlIChjaHVuaywgZW5jb2RpbmcsIGNiKSB7XG4gICAgLy8gcHJvY2VzcyB0aGUgY2h1bmsgdXNpbmcgdGhlIHN5bmMgcHJvY2Vzc1xuICAgIC8vIHRoZW4gc3VwZXIud3JpdGUoKSBhbGwgdGhlIG91dHB1dHRlZCBjaHVua3NcbiAgICBpZiAodHlwZW9mIGVuY29kaW5nID09PSAnZnVuY3Rpb24nKVxuICAgICAgY2IgPSBlbmNvZGluZywgZW5jb2RpbmcgPSAndXRmOCdcblxuICAgIGlmICh0eXBlb2YgY2h1bmsgPT09ICdzdHJpbmcnKVxuICAgICAgY2h1bmsgPSBCdWZmZXIuZnJvbShjaHVuaywgZW5jb2RpbmcpXG5cbiAgICBpZiAodGhpc1tfc2F3RXJyb3JdKVxuICAgICAgcmV0dXJuXG4gICAgYXNzZXJ0KHRoaXNbX2hhbmRsZV0sICd6bGliIGJpbmRpbmcgY2xvc2VkJylcblxuICAgIC8vIF9wcm9jZXNzQ2h1bmsgdHJpZXMgdG8gLmNsb3NlKCkgdGhlIG5hdGl2ZSBoYW5kbGUgYWZ0ZXIgaXQncyBkb25lLCBzbyB3ZVxuICAgIC8vIGludGVyY2VwdCB0aGF0IGJ5IHRlbXBvcmFyaWx5IG1ha2luZyBpdCBhIG5vLW9wLlxuICAgIGNvbnN0IG5hdGl2ZUhhbmRsZSA9IHRoaXNbX2hhbmRsZV0uX2hhbmRsZVxuICAgIGNvbnN0IG9yaWdpbmFsTmF0aXZlQ2xvc2UgPSBuYXRpdmVIYW5kbGUuY2xvc2VcbiAgICBuYXRpdmVIYW5kbGUuY2xvc2UgPSAoKSA9PiB7fVxuICAgIGNvbnN0IG9yaWdpbmFsQ2xvc2UgPSB0aGlzW19oYW5kbGVdLmNsb3NlXG4gICAgdGhpc1tfaGFuZGxlXS5jbG9zZSA9ICgpID0+IHt9XG4gICAgLy8gSXQgYWxzbyBjYWxscyBgQnVmZmVyLmNvbmNhdCgpYCBhdCB0aGUgZW5kLCB3aGljaCBtYXkgYmUgY29udmVuaWVudFxuICAgIC8vIGZvciBzb21lLCBidXQgd2hpY2ggd2UgYXJlIG5vdCBpbnRlcmVzdGVkIGluIGFzIGl0IHNsb3dzIHVzIGRvd24uXG4gICAgQnVmZmVyLmNvbmNhdCA9IChhcmdzKSA9PiBhcmdzXG4gICAgbGV0IHJlc3VsdFxuICAgIHRyeSB7XG4gICAgICBjb25zdCBmbHVzaEZsYWcgPSB0eXBlb2YgY2h1bmtbX2ZsdXNoRmxhZ10gPT09ICdudW1iZXInXG4gICAgICAgID8gY2h1bmtbX2ZsdXNoRmxhZ10gOiB0aGlzW19mbHVzaEZsYWddXG4gICAgICByZXN1bHQgPSB0aGlzW19oYW5kbGVdLl9wcm9jZXNzQ2h1bmsoY2h1bmssIGZsdXNoRmxhZylcbiAgICAgIC8vIGlmIHdlIGRvbid0IHRocm93LCByZXNldCBpdCBiYWNrIGhvdyBpdCB3YXNcbiAgICAgIEJ1ZmZlci5jb25jYXQgPSBPcmlnaW5hbEJ1ZmZlckNvbmNhdFxuICAgIH0gY2F0Y2ggKGVycikge1xuICAgICAgLy8gb3IgaWYgd2UgZG8sIHB1dCBCdWZmZXIuY29uY2F0KCkgYmFjayBiZWZvcmUgd2UgZW1pdCBlcnJvclxuICAgICAgLy8gRXJyb3IgZXZlbnRzIGNhbGwgaW50byB1c2VyIGNvZGUsIHdoaWNoIG1heSBjYWxsIEJ1ZmZlci5jb25jYXQoKVxuICAgICAgQnVmZmVyLmNvbmNhdCA9IE9yaWdpbmFsQnVmZmVyQ29uY2F0XG4gICAgICB0aGlzW19vbkVycm9yXShuZXcgWmxpYkVycm9yKGVycikpXG4gICAgfSBmaW5hbGx5IHtcbiAgICAgIGlmICh0aGlzW19oYW5kbGVdKSB7XG4gICAgICAgIC8vIENvcmUgemxpYiByZXNldHMgYF9oYW5kbGVgIHRvIG51bGwgYWZ0ZXIgYXR0ZW1wdGluZyB0byBjbG9zZSB0aGVcbiAgICAgICAgLy8gbmF0aXZlIGhhbmRsZS4gT3VyIG5vLW9wIGhhbmRsZXIgcHJldmVudGVkIGFjdHVhbCBjbG9zdXJlLCBidXQgd2VcbiAgICAgICAgLy8gbmVlZCB0byByZXN0b3JlIHRoZSBgLl9oYW5kbGVgIHByb3BlcnR5LlxuICAgICAgICB0aGlzW19oYW5kbGVdLl9oYW5kbGUgPSBuYXRpdmVIYW5kbGVcbiAgICAgICAgbmF0aXZlSGFuZGxlLmNsb3NlID0gb3JpZ2luYWxOYXRpdmVDbG9zZVxuICAgICAgICB0aGlzW19oYW5kbGVdLmNsb3NlID0gb3JpZ2luYWxDbG9zZVxuICAgICAgICAvLyBgX3Byb2Nlc3NDaHVuaygpYCBhZGRzIGFuICdlcnJvcicgbGlzdGVuZXIuIElmIHdlIGRvbid0IHJlbW92ZSBpdFxuICAgICAgICAvLyBhZnRlciBlYWNoIGNhbGwsIHRoZXNlIGhhbmRsZXJzIHN0YXJ0IHBpbGluZyB1cC5cbiAgICAgICAgdGhpc1tfaGFuZGxlXS5yZW1vdmVBbGxMaXN0ZW5lcnMoJ2Vycm9yJylcbiAgICAgIH1cbiAgICB9XG5cbiAgICBsZXQgd3JpdGVSZXR1cm5cbiAgICBpZiAocmVzdWx0KSB7XG4gICAgICBpZiAoQXJyYXkuaXNBcnJheShyZXN1bHQpICYmIHJlc3VsdC5sZW5ndGggPiAwKSB7XG4gICAgICAgIC8vIFRoZSBmaXJzdCBidWZmZXIgaXMgYWx3YXlzIGBoYW5kbGUuX291dEJ1ZmZlcmAsIHdoaWNoIHdvdWxkIGJlXG4gICAgICAgIC8vIHJlLXVzZWQgZm9yIGxhdGVyIGludm9jYXRpb25zOyBzbywgd2UgYWx3YXlzIGhhdmUgdG8gY29weSB0aGF0IG9uZS5cbiAgICAgICAgd3JpdGVSZXR1cm4gPSBzdXBlci53cml0ZShCdWZmZXIuZnJvbShyZXN1bHRbMF0pKVxuICAgICAgICBmb3IgKGxldCBpID0gMTsgaSA8IHJlc3VsdC5sZW5ndGg7IGkrKykge1xuICAgICAgICAgIHdyaXRlUmV0dXJuID0gc3VwZXIud3JpdGUocmVzdWx0W2ldKVxuICAgICAgICB9XG4gICAgICB9IGVsc2Uge1xuICAgICAgICB3cml0ZVJldHVybiA9IHN1cGVyLndyaXRlKEJ1ZmZlci5mcm9tKHJlc3VsdCkpXG4gICAgICB9XG4gICAgfVxuXG4gICAgaWYgKGNiKVxuICAgICAgY2IoKVxuICAgIHJldHVybiB3cml0ZVJldHVyblxuICB9XG59XG5cbmNsYXNzIFpsaWIgZXh0ZW5kcyBabGliQmFzZSB7XG4gIGNvbnN0cnVjdG9yIChvcHRzLCBtb2RlKSB7XG4gICAgb3B0cyA9IG9wdHMgfHwge31cblxuICAgIG9wdHMuZmx1c2ggPSBvcHRzLmZsdXNoIHx8IGNvbnN0YW50cy5aX05PX0ZMVVNIXG4gICAgb3B0cy5maW5pc2hGbHVzaCA9IG9wdHMuZmluaXNoRmx1c2ggfHwgY29uc3RhbnRzLlpfRklOSVNIXG4gICAgc3VwZXIob3B0cywgbW9kZSlcblxuICAgIHRoaXNbX2Z1bGxGbHVzaEZsYWddID0gY29uc3RhbnRzLlpfRlVMTF9GTFVTSFxuICAgIHRoaXNbX2xldmVsXSA9IG9wdHMubGV2ZWxcbiAgICB0aGlzW19zdHJhdGVneV0gPSBvcHRzLnN0cmF0ZWd5XG4gIH1cblxuICBwYXJhbXMgKGxldmVsLCBzdHJhdGVneSkge1xuICAgIGlmICh0aGlzW19zYXdFcnJvcl0pXG4gICAgICByZXR1cm5cblxuICAgIGlmICghdGhpc1tfaGFuZGxlXSlcbiAgICAgIHRocm93IG5ldyBFcnJvcignY2Fubm90IHN3aXRjaCBwYXJhbXMgd2hlbiBiaW5kaW5nIGlzIGNsb3NlZCcpXG5cbiAgICAvLyBubyB3YXkgdG8gdGVzdCB0aGlzIHdpdGhvdXQgYWxzbyBub3Qgc3VwcG9ydGluZyBwYXJhbXMgYXQgYWxsXG4gICAgLyogaXN0YW5idWwgaWdub3JlIGlmICovXG4gICAgaWYgKCF0aGlzW19oYW5kbGVdLnBhcmFtcylcbiAgICAgIHRocm93IG5ldyBFcnJvcignbm90IHN1cHBvcnRlZCBpbiB0aGlzIGltcGxlbWVudGF0aW9uJylcblxuICAgIGlmICh0aGlzW19sZXZlbF0gIT09IGxldmVsIHx8IHRoaXNbX3N0cmF0ZWd5XSAhPT0gc3RyYXRlZ3kpIHtcbiAgICAgIHRoaXMuZmx1c2goY29uc3RhbnRzLlpfU1lOQ19GTFVTSClcbiAgICAgIGFzc2VydCh0aGlzW19oYW5kbGVdLCAnemxpYiBiaW5kaW5nIGNsb3NlZCcpXG4gICAgICAvLyAucGFyYW1zKCkgY2FsbHMgLmZsdXNoKCksIGJ1dCB0aGUgbGF0dGVyIGlzIGFsd2F5cyBhc3luYyBpbiB0aGVcbiAgICAgIC8vIGNvcmUgemxpYi4gV2Ugb3ZlcnJpZGUgLmZsdXNoKCkgdGVtcG9yYXJpbHkgdG8gaW50ZXJjZXB0IHRoYXQgYW5kXG4gICAgICAvLyBmbHVzaCBzeW5jaHJvbm91c2x5LlxuICAgICAgY29uc3Qgb3JpZ0ZsdXNoID0gdGhpc1tfaGFuZGxlXS5mbHVzaFxuICAgICAgdGhpc1tfaGFuZGxlXS5mbHVzaCA9IChmbHVzaEZsYWcsIGNiKSA9PiB7XG4gICAgICAgIHRoaXMuZmx1c2goZmx1c2hGbGFnKVxuICAgICAgICBjYigpXG4gICAgICB9XG4gICAgICB0cnkge1xuICAgICAgICB0aGlzW19oYW5kbGVdLnBhcmFtcyhsZXZlbCwgc3RyYXRlZ3kpXG4gICAgICB9IGZpbmFsbHkge1xuICAgICAgICB0aGlzW19oYW5kbGVdLmZsdXNoID0gb3JpZ0ZsdXNoXG4gICAgICB9XG4gICAgICAvKiBpc3RhbmJ1bCBpZ25vcmUgZWxzZSAqL1xuICAgICAgaWYgKHRoaXNbX2hhbmRsZV0pIHtcbiAgICAgICAgdGhpc1tfbGV2ZWxdID0gbGV2ZWxcbiAgICAgICAgdGhpc1tfc3RyYXRlZ3ldID0gc3RyYXRlZ3lcbiAgICAgIH1cbiAgICB9XG4gIH1cbn1cblxuLy8gbWluaW1hbCAyLWJ5dGUgaGVhZGVyXG5jbGFzcyBEZWZsYXRlIGV4dGVuZHMgWmxpYiB7XG4gIGNvbnN0cnVjdG9yIChvcHRzKSB7XG4gICAgc3VwZXIob3B0cywgJ0RlZmxhdGUnKVxuICB9XG59XG5cbmNsYXNzIEluZmxhdGUgZXh0ZW5kcyBabGliIHtcbiAgY29uc3RydWN0b3IgKG9wdHMpIHtcbiAgICBzdXBlcihvcHRzLCAnSW5mbGF0ZScpXG4gIH1cbn1cblxuLy8gZ3ppcCAtIGJpZ2dlciBoZWFkZXIsIHNhbWUgZGVmbGF0ZSBjb21wcmVzc2lvblxuY2xhc3MgR3ppcCBleHRlbmRzIFpsaWIge1xuICBjb25zdHJ1Y3RvciAob3B0cykge1xuICAgIHN1cGVyKG9wdHMsICdHemlwJylcbiAgfVxufVxuXG5jbGFzcyBHdW56aXAgZXh0ZW5kcyBabGliIHtcbiAgY29uc3RydWN0b3IgKG9wdHMpIHtcbiAgICBzdXBlcihvcHRzLCAnR3VuemlwJylcbiAgfVxufVxuXG4vLyByYXcgLSBubyBoZWFkZXJcbmNsYXNzIERlZmxhdGVSYXcgZXh0ZW5kcyBabGliIHtcbiAgY29uc3RydWN0b3IgKG9wdHMpIHtcbiAgICBzdXBlcihvcHRzLCAnRGVmbGF0ZVJhdycpXG4gIH1cbn1cblxuY2xhc3MgSW5mbGF0ZVJhdyBleHRlbmRzIFpsaWIge1xuICBjb25zdHJ1Y3RvciAob3B0cykge1xuICAgIHN1cGVyKG9wdHMsICdJbmZsYXRlUmF3JylcbiAgfVxufVxuXG4vLyBhdXRvLWRldGVjdCBoZWFkZXIuXG5jbGFzcyBVbnppcCBleHRlbmRzIFpsaWIge1xuICBjb25zdHJ1Y3RvciAob3B0cykge1xuICAgIHN1cGVyKG9wdHMsICdVbnppcCcpXG4gIH1cbn1cblxuY2xhc3MgQnJvdGxpIGV4dGVuZHMgWmxpYkJhc2Uge1xuICBjb25zdHJ1Y3RvciAob3B0cywgbW9kZSkge1xuICAgIG9wdHMgPSBvcHRzIHx8IHt9XG5cbiAgICBvcHRzLmZsdXNoID0gb3B0cy5mbHVzaCB8fCBjb25zdGFudHMuQlJPVExJX09QRVJBVElPTl9QUk9DRVNTXG4gICAgb3B0cy5maW5pc2hGbHVzaCA9IG9wdHMuZmluaXNoRmx1c2ggfHwgY29uc3RhbnRzLkJST1RMSV9PUEVSQVRJT05fRklOSVNIXG5cbiAgICBzdXBlcihvcHRzLCBtb2RlKVxuXG4gICAgdGhpc1tfZnVsbEZsdXNoRmxhZ10gPSBjb25zdGFudHMuQlJPVExJX09QRVJBVElPTl9GTFVTSFxuICB9XG59XG5cbmNsYXNzIEJyb3RsaUNvbXByZXNzIGV4dGVuZHMgQnJvdGxpIHtcbiAgY29uc3RydWN0b3IgKG9wdHMpIHtcbiAgICBzdXBlcihvcHRzLCAnQnJvdGxpQ29tcHJlc3MnKVxuICB9XG59XG5cbmNsYXNzIEJyb3RsaURlY29tcHJlc3MgZXh0ZW5kcyBCcm90bGkge1xuICBjb25zdHJ1Y3RvciAob3B0cykge1xuICAgIHN1cGVyKG9wdHMsICdCcm90bGlEZWNvbXByZXNzJylcbiAgfVxufVxuXG5leHBvcnRzLkRlZmxhdGUgPSBEZWZsYXRlXG5leHBvcnRzLkluZmxhdGUgPSBJbmZsYXRlXG5leHBvcnRzLkd6aXAgPSBHemlwXG5leHBvcnRzLkd1bnppcCA9IEd1bnppcFxuZXhwb3J0cy5EZWZsYXRlUmF3ID0gRGVmbGF0ZVJhd1xuZXhwb3J0cy5JbmZsYXRlUmF3ID0gSW5mbGF0ZVJhd1xuZXhwb3J0cy5VbnppcCA9IFVuemlwXG4vKiBpc3RhbmJ1bCBpZ25vcmUgZWxzZSAqL1xuaWYgKHR5cGVvZiByZWFsWmxpYi5Ccm90bGlDb21wcmVzcyA9PT0gJ2Z1bmN0aW9uJykge1xuICBleHBvcnRzLkJyb3RsaUNvbXByZXNzID0gQnJvdGxpQ29tcHJlc3NcbiAgZXhwb3J0cy5Ccm90bGlEZWNvbXByZXNzID0gQnJvdGxpRGVjb21wcmVzc1xufSBlbHNlIHtcbiAgZXhwb3J0cy5Ccm90bGlDb21wcmVzcyA9IGV4cG9ydHMuQnJvdGxpRGVjb21wcmVzcyA9IGNsYXNzIHtcbiAgICBjb25zdHJ1Y3RvciAoKSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoJ0Jyb3RsaSBpcyBub3Qgc3VwcG9ydGVkIGluIHRoaXMgdmVyc2lvbiBvZiBOb2RlLmpzJylcbiAgICB9XG4gIH1cbn1cbiJdLCJuYW1lcyI6W10sImlnbm9yZUxpc3QiOlswXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/swarm-js/node_modules/minizlib/index.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/swarm-js/node_modules/p-cancelable/index.js":
/*!******************************************************************!*\
  !*** ./node_modules/swarm-js/node_modules/p-cancelable/index.js ***!
  \******************************************************************/
/***/ ((module) => {

"use strict";
eval("\n\nclass CancelError extends Error {\n\tconstructor(reason) {\n\t\tsuper(reason || 'Promise was canceled');\n\t\tthis.name = 'CancelError';\n\t}\n\n\tget isCanceled() {\n\t\treturn true;\n\t}\n}\n\nclass PCancelable {\n\tstatic fn(userFn) {\n\t\treturn (...arguments_) => {\n\t\t\treturn new PCancelable((resolve, reject, onCancel) => {\n\t\t\t\targuments_.push(onCancel);\n\t\t\t\t// eslint-disable-next-line promise/prefer-await-to-then\n\t\t\t\tuserFn(...arguments_).then(resolve, reject);\n\t\t\t});\n\t\t};\n\t}\n\n\tconstructor(executor) {\n\t\tthis._cancelHandlers = [];\n\t\tthis._isPending = true;\n\t\tthis._isCanceled = false;\n\t\tthis._rejectOnCancel = true;\n\n\t\tthis._promise = new Promise((resolve, reject) => {\n\t\t\tthis._reject = reject;\n\n\t\t\tconst onResolve = value => {\n\t\t\t\tif (!this._isCanceled || !onCancel.shouldReject) {\n\t\t\t\t\tthis._isPending = false;\n\t\t\t\t\tresolve(value);\n\t\t\t\t}\n\t\t\t};\n\n\t\t\tconst onReject = error => {\n\t\t\t\tthis._isPending = false;\n\t\t\t\treject(error);\n\t\t\t};\n\n\t\t\tconst onCancel = handler => {\n\t\t\t\tif (!this._isPending) {\n\t\t\t\t\tthrow new Error('The `onCancel` handler was attached after the promise settled.');\n\t\t\t\t}\n\n\t\t\t\tthis._cancelHandlers.push(handler);\n\t\t\t};\n\n\t\t\tObject.defineProperties(onCancel, {\n\t\t\t\tshouldReject: {\n\t\t\t\t\tget: () => this._rejectOnCancel,\n\t\t\t\t\tset: boolean => {\n\t\t\t\t\t\tthis._rejectOnCancel = boolean;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t});\n\n\t\t\treturn executor(onResolve, onReject, onCancel);\n\t\t});\n\t}\n\n\tthen(onFulfilled, onRejected) {\n\t\t// eslint-disable-next-line promise/prefer-await-to-then\n\t\treturn this._promise.then(onFulfilled, onRejected);\n\t}\n\n\tcatch(onRejected) {\n\t\treturn this._promise.catch(onRejected);\n\t}\n\n\tfinally(onFinally) {\n\t\treturn this._promise.finally(onFinally);\n\t}\n\n\tcancel(reason) {\n\t\tif (!this._isPending || this._isCanceled) {\n\t\t\treturn;\n\t\t}\n\n\t\tthis._isCanceled = true;\n\n\t\tif (this._cancelHandlers.length > 0) {\n\t\t\ttry {\n\t\t\t\tfor (const handler of this._cancelHandlers) {\n\t\t\t\t\thandler();\n\t\t\t\t}\n\t\t\t} catch (error) {\n\t\t\t\tthis._reject(error);\n\t\t\t\treturn;\n\t\t\t}\n\t\t}\n\n\t\tif (this._rejectOnCancel) {\n\t\t\tthis._reject(new CancelError(reason));\n\t\t}\n\t}\n\n\tget isCanceled() {\n\t\treturn this._isCanceled;\n\t}\n}\n\nObject.setPrototypeOf(PCancelable.prototype, Promise.prototype);\n\nmodule.exports = PCancelable;\nmodule.exports.CancelError = CancelError;\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvc3dhcm0tanMvbm9kZV9tb2R1bGVzL3AtY2FuY2VsYWJsZS9pbmRleC5qcyIsIm1hcHBpbmdzIjoiQUFBYTs7QUFFYjtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsSUFBSTtBQUNKO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsSUFBSTs7QUFFSjtBQUNBLEdBQUc7QUFDSDs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQSwwQkFBMEIiLCJzb3VyY2VzIjpbIi9Vc2Vycy9wYW56YS9Eb2N1bWVudHMvUGVyc29uYWxQcm9qZWN0cy9wcmVkaWsvbm9kZV9tb2R1bGVzL3N3YXJtLWpzL25vZGVfbW9kdWxlcy9wLWNhbmNlbGFibGUvaW5kZXguanMiXSwic291cmNlc0NvbnRlbnQiOlsiJ3VzZSBzdHJpY3QnO1xuXG5jbGFzcyBDYW5jZWxFcnJvciBleHRlbmRzIEVycm9yIHtcblx0Y29uc3RydWN0b3IocmVhc29uKSB7XG5cdFx0c3VwZXIocmVhc29uIHx8ICdQcm9taXNlIHdhcyBjYW5jZWxlZCcpO1xuXHRcdHRoaXMubmFtZSA9ICdDYW5jZWxFcnJvcic7XG5cdH1cblxuXHRnZXQgaXNDYW5jZWxlZCgpIHtcblx0XHRyZXR1cm4gdHJ1ZTtcblx0fVxufVxuXG5jbGFzcyBQQ2FuY2VsYWJsZSB7XG5cdHN0YXRpYyBmbih1c2VyRm4pIHtcblx0XHRyZXR1cm4gKC4uLmFyZ3VtZW50c18pID0+IHtcblx0XHRcdHJldHVybiBuZXcgUENhbmNlbGFibGUoKHJlc29sdmUsIHJlamVjdCwgb25DYW5jZWwpID0+IHtcblx0XHRcdFx0YXJndW1lbnRzXy5wdXNoKG9uQ2FuY2VsKTtcblx0XHRcdFx0Ly8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIHByb21pc2UvcHJlZmVyLWF3YWl0LXRvLXRoZW5cblx0XHRcdFx0dXNlckZuKC4uLmFyZ3VtZW50c18pLnRoZW4ocmVzb2x2ZSwgcmVqZWN0KTtcblx0XHRcdH0pO1xuXHRcdH07XG5cdH1cblxuXHRjb25zdHJ1Y3RvcihleGVjdXRvcikge1xuXHRcdHRoaXMuX2NhbmNlbEhhbmRsZXJzID0gW107XG5cdFx0dGhpcy5faXNQZW5kaW5nID0gdHJ1ZTtcblx0XHR0aGlzLl9pc0NhbmNlbGVkID0gZmFsc2U7XG5cdFx0dGhpcy5fcmVqZWN0T25DYW5jZWwgPSB0cnVlO1xuXG5cdFx0dGhpcy5fcHJvbWlzZSA9IG5ldyBQcm9taXNlKChyZXNvbHZlLCByZWplY3QpID0+IHtcblx0XHRcdHRoaXMuX3JlamVjdCA9IHJlamVjdDtcblxuXHRcdFx0Y29uc3Qgb25SZXNvbHZlID0gdmFsdWUgPT4ge1xuXHRcdFx0XHRpZiAoIXRoaXMuX2lzQ2FuY2VsZWQgfHwgIW9uQ2FuY2VsLnNob3VsZFJlamVjdCkge1xuXHRcdFx0XHRcdHRoaXMuX2lzUGVuZGluZyA9IGZhbHNlO1xuXHRcdFx0XHRcdHJlc29sdmUodmFsdWUpO1xuXHRcdFx0XHR9XG5cdFx0XHR9O1xuXG5cdFx0XHRjb25zdCBvblJlamVjdCA9IGVycm9yID0+IHtcblx0XHRcdFx0dGhpcy5faXNQZW5kaW5nID0gZmFsc2U7XG5cdFx0XHRcdHJlamVjdChlcnJvcik7XG5cdFx0XHR9O1xuXG5cdFx0XHRjb25zdCBvbkNhbmNlbCA9IGhhbmRsZXIgPT4ge1xuXHRcdFx0XHRpZiAoIXRoaXMuX2lzUGVuZGluZykge1xuXHRcdFx0XHRcdHRocm93IG5ldyBFcnJvcignVGhlIGBvbkNhbmNlbGAgaGFuZGxlciB3YXMgYXR0YWNoZWQgYWZ0ZXIgdGhlIHByb21pc2Ugc2V0dGxlZC4nKTtcblx0XHRcdFx0fVxuXG5cdFx0XHRcdHRoaXMuX2NhbmNlbEhhbmRsZXJzLnB1c2goaGFuZGxlcik7XG5cdFx0XHR9O1xuXG5cdFx0XHRPYmplY3QuZGVmaW5lUHJvcGVydGllcyhvbkNhbmNlbCwge1xuXHRcdFx0XHRzaG91bGRSZWplY3Q6IHtcblx0XHRcdFx0XHRnZXQ6ICgpID0+IHRoaXMuX3JlamVjdE9uQ2FuY2VsLFxuXHRcdFx0XHRcdHNldDogYm9vbGVhbiA9PiB7XG5cdFx0XHRcdFx0XHR0aGlzLl9yZWplY3RPbkNhbmNlbCA9IGJvb2xlYW47XG5cdFx0XHRcdFx0fVxuXHRcdFx0XHR9XG5cdFx0XHR9KTtcblxuXHRcdFx0cmV0dXJuIGV4ZWN1dG9yKG9uUmVzb2x2ZSwgb25SZWplY3QsIG9uQ2FuY2VsKTtcblx0XHR9KTtcblx0fVxuXG5cdHRoZW4ob25GdWxmaWxsZWQsIG9uUmVqZWN0ZWQpIHtcblx0XHQvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgcHJvbWlzZS9wcmVmZXItYXdhaXQtdG8tdGhlblxuXHRcdHJldHVybiB0aGlzLl9wcm9taXNlLnRoZW4ob25GdWxmaWxsZWQsIG9uUmVqZWN0ZWQpO1xuXHR9XG5cblx0Y2F0Y2gob25SZWplY3RlZCkge1xuXHRcdHJldHVybiB0aGlzLl9wcm9taXNlLmNhdGNoKG9uUmVqZWN0ZWQpO1xuXHR9XG5cblx0ZmluYWxseShvbkZpbmFsbHkpIHtcblx0XHRyZXR1cm4gdGhpcy5fcHJvbWlzZS5maW5hbGx5KG9uRmluYWxseSk7XG5cdH1cblxuXHRjYW5jZWwocmVhc29uKSB7XG5cdFx0aWYgKCF0aGlzLl9pc1BlbmRpbmcgfHwgdGhpcy5faXNDYW5jZWxlZCkge1xuXHRcdFx0cmV0dXJuO1xuXHRcdH1cblxuXHRcdHRoaXMuX2lzQ2FuY2VsZWQgPSB0cnVlO1xuXG5cdFx0aWYgKHRoaXMuX2NhbmNlbEhhbmRsZXJzLmxlbmd0aCA+IDApIHtcblx0XHRcdHRyeSB7XG5cdFx0XHRcdGZvciAoY29uc3QgaGFuZGxlciBvZiB0aGlzLl9jYW5jZWxIYW5kbGVycykge1xuXHRcdFx0XHRcdGhhbmRsZXIoKTtcblx0XHRcdFx0fVxuXHRcdFx0fSBjYXRjaCAoZXJyb3IpIHtcblx0XHRcdFx0dGhpcy5fcmVqZWN0KGVycm9yKTtcblx0XHRcdFx0cmV0dXJuO1xuXHRcdFx0fVxuXHRcdH1cblxuXHRcdGlmICh0aGlzLl9yZWplY3RPbkNhbmNlbCkge1xuXHRcdFx0dGhpcy5fcmVqZWN0KG5ldyBDYW5jZWxFcnJvcihyZWFzb24pKTtcblx0XHR9XG5cdH1cblxuXHRnZXQgaXNDYW5jZWxlZCgpIHtcblx0XHRyZXR1cm4gdGhpcy5faXNDYW5jZWxlZDtcblx0fVxufVxuXG5PYmplY3Quc2V0UHJvdG90eXBlT2YoUENhbmNlbGFibGUucHJvdG90eXBlLCBQcm9taXNlLnByb3RvdHlwZSk7XG5cbm1vZHVsZS5leHBvcnRzID0gUENhbmNlbGFibGU7XG5tb2R1bGUuZXhwb3J0cy5DYW5jZWxFcnJvciA9IENhbmNlbEVycm9yO1xuIl0sIm5hbWVzIjpbXSwiaWdub3JlTGlzdCI6WzBdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/swarm-js/node_modules/p-cancelable/index.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/swarm-js/node_modules/tar/index.js":
/*!*********************************************************!*\
  !*** ./node_modules/swarm-js/node_modules/tar/index.js ***!
  \*********************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";
eval("\n\n// high-level commands\nexports.c = exports.create = __webpack_require__(/*! ./lib/create.js */ \"(ssr)/./node_modules/swarm-js/node_modules/tar/lib/create.js\")\nexports.r = exports.replace = __webpack_require__(/*! ./lib/replace.js */ \"(ssr)/./node_modules/swarm-js/node_modules/tar/lib/replace.js\")\nexports.t = exports.list = __webpack_require__(/*! ./lib/list.js */ \"(ssr)/./node_modules/swarm-js/node_modules/tar/lib/list.js\")\nexports.u = exports.update = __webpack_require__(/*! ./lib/update.js */ \"(ssr)/./node_modules/swarm-js/node_modules/tar/lib/update.js\")\nexports.x = exports.extract = __webpack_require__(/*! ./lib/extract.js */ \"(ssr)/./node_modules/swarm-js/node_modules/tar/lib/extract.js\")\n\n// classes\nexports.Pack = __webpack_require__(/*! ./lib/pack.js */ \"(ssr)/./node_modules/swarm-js/node_modules/tar/lib/pack.js\")\nexports.Unpack = __webpack_require__(/*! ./lib/unpack.js */ \"(ssr)/./node_modules/swarm-js/node_modules/tar/lib/unpack.js\")\nexports.Parse = __webpack_require__(/*! ./lib/parse.js */ \"(ssr)/./node_modules/swarm-js/node_modules/tar/lib/parse.js\")\nexports.ReadEntry = __webpack_require__(/*! ./lib/read-entry.js */ \"(ssr)/./node_modules/swarm-js/node_modules/tar/lib/read-entry.js\")\nexports.WriteEntry = __webpack_require__(/*! ./lib/write-entry.js */ \"(ssr)/./node_modules/swarm-js/node_modules/tar/lib/write-entry.js\")\nexports.Header = __webpack_require__(/*! ./lib/header.js */ \"(ssr)/./node_modules/swarm-js/node_modules/tar/lib/header.js\")\nexports.Pax = __webpack_require__(/*! ./lib/pax.js */ \"(ssr)/./node_modules/swarm-js/node_modules/tar/lib/pax.js\")\nexports.types = __webpack_require__(/*! ./lib/types.js */ \"(ssr)/./node_modules/swarm-js/node_modules/tar/lib/types.js\")\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvc3dhcm0tanMvbm9kZV9tb2R1bGVzL3Rhci9pbmRleC5qcyIsIm1hcHBpbmdzIjoiQUFBWTs7QUFFWjtBQUNBLFNBQVMsR0FBRywySEFBMkM7QUFDdkQsU0FBUyxHQUFHLDhIQUE2QztBQUN6RCxTQUFTLEdBQUcscUhBQXVDO0FBQ25ELFNBQVMsR0FBRywySEFBMkM7QUFDdkQsU0FBUyxHQUFHLDhIQUE2Qzs7QUFFekQ7QUFDQSxxSEFBdUM7QUFDdkMsMkhBQTJDO0FBQzNDLHdIQUF5QztBQUN6QyxzSUFBa0Q7QUFDbEQseUlBQW9EO0FBQ3BELDJIQUEyQztBQUMzQyxrSEFBcUM7QUFDckMsd0hBQXlDIiwic291cmNlcyI6WyIvVXNlcnMvcGFuemEvRG9jdW1lbnRzL1BlcnNvbmFsUHJvamVjdHMvcHJlZGlrL25vZGVfbW9kdWxlcy9zd2FybS1qcy9ub2RlX21vZHVsZXMvdGFyL2luZGV4LmpzIl0sInNvdXJjZXNDb250ZW50IjpbIid1c2Ugc3RyaWN0J1xuXG4vLyBoaWdoLWxldmVsIGNvbW1hbmRzXG5leHBvcnRzLmMgPSBleHBvcnRzLmNyZWF0ZSA9IHJlcXVpcmUoJy4vbGliL2NyZWF0ZS5qcycpXG5leHBvcnRzLnIgPSBleHBvcnRzLnJlcGxhY2UgPSByZXF1aXJlKCcuL2xpYi9yZXBsYWNlLmpzJylcbmV4cG9ydHMudCA9IGV4cG9ydHMubGlzdCA9IHJlcXVpcmUoJy4vbGliL2xpc3QuanMnKVxuZXhwb3J0cy51ID0gZXhwb3J0cy51cGRhdGUgPSByZXF1aXJlKCcuL2xpYi91cGRhdGUuanMnKVxuZXhwb3J0cy54ID0gZXhwb3J0cy5leHRyYWN0ID0gcmVxdWlyZSgnLi9saWIvZXh0cmFjdC5qcycpXG5cbi8vIGNsYXNzZXNcbmV4cG9ydHMuUGFjayA9IHJlcXVpcmUoJy4vbGliL3BhY2suanMnKVxuZXhwb3J0cy5VbnBhY2sgPSByZXF1aXJlKCcuL2xpYi91bnBhY2suanMnKVxuZXhwb3J0cy5QYXJzZSA9IHJlcXVpcmUoJy4vbGliL3BhcnNlLmpzJylcbmV4cG9ydHMuUmVhZEVudHJ5ID0gcmVxdWlyZSgnLi9saWIvcmVhZC1lbnRyeS5qcycpXG5leHBvcnRzLldyaXRlRW50cnkgPSByZXF1aXJlKCcuL2xpYi93cml0ZS1lbnRyeS5qcycpXG5leHBvcnRzLkhlYWRlciA9IHJlcXVpcmUoJy4vbGliL2hlYWRlci5qcycpXG5leHBvcnRzLlBheCA9IHJlcXVpcmUoJy4vbGliL3BheC5qcycpXG5leHBvcnRzLnR5cGVzID0gcmVxdWlyZSgnLi9saWIvdHlwZXMuanMnKVxuIl0sIm5hbWVzIjpbXSwiaWdub3JlTGlzdCI6WzBdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/swarm-js/node_modules/tar/index.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/swarm-js/node_modules/tar/lib/buffer.js":
/*!**************************************************************!*\
  !*** ./node_modules/swarm-js/node_modules/tar/lib/buffer.js ***!
  \**************************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";
eval("\n\n// Buffer in node 4.x < 4.5.0 doesn't have working Buffer.from\n// or Buffer.alloc, and Buffer in node 10 deprecated the ctor.\n// .M, this is fine .\\^/M..\nlet B = Buffer\n/* istanbul ignore next */\nif (!B.alloc) {\n  B = (__webpack_require__(/*! safe-buffer */ \"(ssr)/./node_modules/safe-buffer/index.js\").Buffer)\n}\nmodule.exports = B\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvc3dhcm0tanMvbm9kZV9tb2R1bGVzL3Rhci9saWIvYnVmZmVyLmpzIiwibWFwcGluZ3MiOiJBQUFZOztBQUVaO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU0sNEZBQTZCO0FBQ25DO0FBQ0EiLCJzb3VyY2VzIjpbIi9Vc2Vycy9wYW56YS9Eb2N1bWVudHMvUGVyc29uYWxQcm9qZWN0cy9wcmVkaWsvbm9kZV9tb2R1bGVzL3N3YXJtLWpzL25vZGVfbW9kdWxlcy90YXIvbGliL2J1ZmZlci5qcyJdLCJzb3VyY2VzQ29udGVudCI6WyIndXNlIHN0cmljdCdcblxuLy8gQnVmZmVyIGluIG5vZGUgNC54IDwgNC41LjAgZG9lc24ndCBoYXZlIHdvcmtpbmcgQnVmZmVyLmZyb21cbi8vIG9yIEJ1ZmZlci5hbGxvYywgYW5kIEJ1ZmZlciBpbiBub2RlIDEwIGRlcHJlY2F0ZWQgdGhlIGN0b3IuXG4vLyAuTSwgdGhpcyBpcyBmaW5lIC5cXF4vTS4uXG5sZXQgQiA9IEJ1ZmZlclxuLyogaXN0YW5idWwgaWdub3JlIG5leHQgKi9cbmlmICghQi5hbGxvYykge1xuICBCID0gcmVxdWlyZSgnc2FmZS1idWZmZXInKS5CdWZmZXJcbn1cbm1vZHVsZS5leHBvcnRzID0gQlxuIl0sIm5hbWVzIjpbXSwiaWdub3JlTGlzdCI6WzBdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/swarm-js/node_modules/tar/lib/buffer.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/swarm-js/node_modules/tar/lib/create.js":
/*!**************************************************************!*\
  !*** ./node_modules/swarm-js/node_modules/tar/lib/create.js ***!
  \**************************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";
eval("\n\n// tar -c\nconst hlo = __webpack_require__(/*! ./high-level-opt.js */ \"(ssr)/./node_modules/swarm-js/node_modules/tar/lib/high-level-opt.js\")\n\nconst Pack = __webpack_require__(/*! ./pack.js */ \"(ssr)/./node_modules/swarm-js/node_modules/tar/lib/pack.js\")\nconst fs = __webpack_require__(/*! fs */ \"fs\")\nconst fsm = __webpack_require__(/*! fs-minipass */ \"(ssr)/./node_modules/swarm-js/node_modules/fs-minipass/index.js\")\nconst t = __webpack_require__(/*! ./list.js */ \"(ssr)/./node_modules/swarm-js/node_modules/tar/lib/list.js\")\nconst path = __webpack_require__(/*! path */ \"path\")\n\nconst c = module.exports = (opt_, files, cb) => {\n  if (typeof files === 'function')\n    cb = files\n\n  if (Array.isArray(opt_))\n    files = opt_, opt_ = {}\n\n  if (!files || !Array.isArray(files) || !files.length)\n    throw new TypeError('no files or directories specified')\n\n  files = Array.from(files)\n\n  const opt = hlo(opt_)\n\n  if (opt.sync && typeof cb === 'function')\n    throw new TypeError('callback not supported for sync tar functions')\n\n  if (!opt.file && typeof cb === 'function')\n    throw new TypeError('callback only supported with file option')\n\n  return opt.file && opt.sync ? createFileSync(opt, files)\n    : opt.file ? createFile(opt, files, cb)\n    : opt.sync ? createSync(opt, files)\n    : create(opt, files)\n}\n\nconst createFileSync = (opt, files) => {\n  const p = new Pack.Sync(opt)\n  const stream = new fsm.WriteStreamSync(opt.file, {\n    mode: opt.mode || 0o666\n  })\n  p.pipe(stream)\n  addFilesSync(p, files)\n}\n\nconst createFile = (opt, files, cb) => {\n  const p = new Pack(opt)\n  const stream = new fsm.WriteStream(opt.file, {\n    mode: opt.mode || 0o666\n  })\n  p.pipe(stream)\n\n  const promise = new Promise((res, rej) => {\n    stream.on('error', rej)\n    stream.on('close', res)\n    p.on('error', rej)\n  })\n\n  addFilesAsync(p, files)\n\n  return cb ? promise.then(cb, cb) : promise\n}\n\nconst addFilesSync = (p, files) => {\n  files.forEach(file => {\n    if (file.charAt(0) === '@')\n      t({\n        file: path.resolve(p.cwd, file.substr(1)),\n        sync: true,\n        noResume: true,\n        onentry: entry => p.add(entry)\n      })\n    else\n      p.add(file)\n  })\n  p.end()\n}\n\nconst addFilesAsync = (p, files) => {\n  while (files.length) {\n    const file = files.shift()\n    if (file.charAt(0) === '@')\n      return t({\n        file: path.resolve(p.cwd, file.substr(1)),\n        noResume: true,\n        onentry: entry => p.add(entry)\n      }).then(_ => addFilesAsync(p, files))\n    else\n      p.add(file)\n  }\n  p.end()\n}\n\nconst createSync = (opt, files) => {\n  const p = new Pack.Sync(opt)\n  addFilesSync(p, files)\n  return p\n}\n\nconst create = (opt, files) => {\n  const p = new Pack(opt)\n  addFilesAsync(p, files)\n  return p\n}\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvc3dhcm0tanMvbm9kZV9tb2R1bGVzL3Rhci9saWIvY3JlYXRlLmpzIiwibWFwcGluZ3MiOiJBQUFZOztBQUVaO0FBQ0EsWUFBWSxtQkFBTyxDQUFDLGlHQUFxQjs7QUFFekMsYUFBYSxtQkFBTyxDQUFDLDZFQUFXO0FBQ2hDLFdBQVcsbUJBQU8sQ0FBQyxjQUFJO0FBQ3ZCLFlBQVksbUJBQU8sQ0FBQyxvRkFBYTtBQUNqQyxVQUFVLG1CQUFPLENBQUMsNkVBQVc7QUFDN0IsYUFBYSxtQkFBTyxDQUFDLGtCQUFNOztBQUUzQjtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7O0FBRUg7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBIiwic291cmNlcyI6WyIvVXNlcnMvcGFuemEvRG9jdW1lbnRzL1BlcnNvbmFsUHJvamVjdHMvcHJlZGlrL25vZGVfbW9kdWxlcy9zd2FybS1qcy9ub2RlX21vZHVsZXMvdGFyL2xpYi9jcmVhdGUuanMiXSwic291cmNlc0NvbnRlbnQiOlsiJ3VzZSBzdHJpY3QnXG5cbi8vIHRhciAtY1xuY29uc3QgaGxvID0gcmVxdWlyZSgnLi9oaWdoLWxldmVsLW9wdC5qcycpXG5cbmNvbnN0IFBhY2sgPSByZXF1aXJlKCcuL3BhY2suanMnKVxuY29uc3QgZnMgPSByZXF1aXJlKCdmcycpXG5jb25zdCBmc20gPSByZXF1aXJlKCdmcy1taW5pcGFzcycpXG5jb25zdCB0ID0gcmVxdWlyZSgnLi9saXN0LmpzJylcbmNvbnN0IHBhdGggPSByZXF1aXJlKCdwYXRoJylcblxuY29uc3QgYyA9IG1vZHVsZS5leHBvcnRzID0gKG9wdF8sIGZpbGVzLCBjYikgPT4ge1xuICBpZiAodHlwZW9mIGZpbGVzID09PSAnZnVuY3Rpb24nKVxuICAgIGNiID0gZmlsZXNcblxuICBpZiAoQXJyYXkuaXNBcnJheShvcHRfKSlcbiAgICBmaWxlcyA9IG9wdF8sIG9wdF8gPSB7fVxuXG4gIGlmICghZmlsZXMgfHwgIUFycmF5LmlzQXJyYXkoZmlsZXMpIHx8ICFmaWxlcy5sZW5ndGgpXG4gICAgdGhyb3cgbmV3IFR5cGVFcnJvcignbm8gZmlsZXMgb3IgZGlyZWN0b3JpZXMgc3BlY2lmaWVkJylcblxuICBmaWxlcyA9IEFycmF5LmZyb20oZmlsZXMpXG5cbiAgY29uc3Qgb3B0ID0gaGxvKG9wdF8pXG5cbiAgaWYgKG9wdC5zeW5jICYmIHR5cGVvZiBjYiA9PT0gJ2Z1bmN0aW9uJylcbiAgICB0aHJvdyBuZXcgVHlwZUVycm9yKCdjYWxsYmFjayBub3Qgc3VwcG9ydGVkIGZvciBzeW5jIHRhciBmdW5jdGlvbnMnKVxuXG4gIGlmICghb3B0LmZpbGUgJiYgdHlwZW9mIGNiID09PSAnZnVuY3Rpb24nKVxuICAgIHRocm93IG5ldyBUeXBlRXJyb3IoJ2NhbGxiYWNrIG9ubHkgc3VwcG9ydGVkIHdpdGggZmlsZSBvcHRpb24nKVxuXG4gIHJldHVybiBvcHQuZmlsZSAmJiBvcHQuc3luYyA/IGNyZWF0ZUZpbGVTeW5jKG9wdCwgZmlsZXMpXG4gICAgOiBvcHQuZmlsZSA/IGNyZWF0ZUZpbGUob3B0LCBmaWxlcywgY2IpXG4gICAgOiBvcHQuc3luYyA/IGNyZWF0ZVN5bmMob3B0LCBmaWxlcylcbiAgICA6IGNyZWF0ZShvcHQsIGZpbGVzKVxufVxuXG5jb25zdCBjcmVhdGVGaWxlU3luYyA9IChvcHQsIGZpbGVzKSA9PiB7XG4gIGNvbnN0IHAgPSBuZXcgUGFjay5TeW5jKG9wdClcbiAgY29uc3Qgc3RyZWFtID0gbmV3IGZzbS5Xcml0ZVN0cmVhbVN5bmMob3B0LmZpbGUsIHtcbiAgICBtb2RlOiBvcHQubW9kZSB8fCAwbzY2NlxuICB9KVxuICBwLnBpcGUoc3RyZWFtKVxuICBhZGRGaWxlc1N5bmMocCwgZmlsZXMpXG59XG5cbmNvbnN0IGNyZWF0ZUZpbGUgPSAob3B0LCBmaWxlcywgY2IpID0+IHtcbiAgY29uc3QgcCA9IG5ldyBQYWNrKG9wdClcbiAgY29uc3Qgc3RyZWFtID0gbmV3IGZzbS5Xcml0ZVN0cmVhbShvcHQuZmlsZSwge1xuICAgIG1vZGU6IG9wdC5tb2RlIHx8IDBvNjY2XG4gIH0pXG4gIHAucGlwZShzdHJlYW0pXG5cbiAgY29uc3QgcHJvbWlzZSA9IG5ldyBQcm9taXNlKChyZXMsIHJlaikgPT4ge1xuICAgIHN0cmVhbS5vbignZXJyb3InLCByZWopXG4gICAgc3RyZWFtLm9uKCdjbG9zZScsIHJlcylcbiAgICBwLm9uKCdlcnJvcicsIHJlailcbiAgfSlcblxuICBhZGRGaWxlc0FzeW5jKHAsIGZpbGVzKVxuXG4gIHJldHVybiBjYiA/IHByb21pc2UudGhlbihjYiwgY2IpIDogcHJvbWlzZVxufVxuXG5jb25zdCBhZGRGaWxlc1N5bmMgPSAocCwgZmlsZXMpID0+IHtcbiAgZmlsZXMuZm9yRWFjaChmaWxlID0+IHtcbiAgICBpZiAoZmlsZS5jaGFyQXQoMCkgPT09ICdAJylcbiAgICAgIHQoe1xuICAgICAgICBmaWxlOiBwYXRoLnJlc29sdmUocC5jd2QsIGZpbGUuc3Vic3RyKDEpKSxcbiAgICAgICAgc3luYzogdHJ1ZSxcbiAgICAgICAgbm9SZXN1bWU6IHRydWUsXG4gICAgICAgIG9uZW50cnk6IGVudHJ5ID0+IHAuYWRkKGVudHJ5KVxuICAgICAgfSlcbiAgICBlbHNlXG4gICAgICBwLmFkZChmaWxlKVxuICB9KVxuICBwLmVuZCgpXG59XG5cbmNvbnN0IGFkZEZpbGVzQXN5bmMgPSAocCwgZmlsZXMpID0+IHtcbiAgd2hpbGUgKGZpbGVzLmxlbmd0aCkge1xuICAgIGNvbnN0IGZpbGUgPSBmaWxlcy5zaGlmdCgpXG4gICAgaWYgKGZpbGUuY2hhckF0KDApID09PSAnQCcpXG4gICAgICByZXR1cm4gdCh7XG4gICAgICAgIGZpbGU6IHBhdGgucmVzb2x2ZShwLmN3ZCwgZmlsZS5zdWJzdHIoMSkpLFxuICAgICAgICBub1Jlc3VtZTogdHJ1ZSxcbiAgICAgICAgb25lbnRyeTogZW50cnkgPT4gcC5hZGQoZW50cnkpXG4gICAgICB9KS50aGVuKF8gPT4gYWRkRmlsZXNBc3luYyhwLCBmaWxlcykpXG4gICAgZWxzZVxuICAgICAgcC5hZGQoZmlsZSlcbiAgfVxuICBwLmVuZCgpXG59XG5cbmNvbnN0IGNyZWF0ZVN5bmMgPSAob3B0LCBmaWxlcykgPT4ge1xuICBjb25zdCBwID0gbmV3IFBhY2suU3luYyhvcHQpXG4gIGFkZEZpbGVzU3luYyhwLCBmaWxlcylcbiAgcmV0dXJuIHBcbn1cblxuY29uc3QgY3JlYXRlID0gKG9wdCwgZmlsZXMpID0+IHtcbiAgY29uc3QgcCA9IG5ldyBQYWNrKG9wdClcbiAgYWRkRmlsZXNBc3luYyhwLCBmaWxlcylcbiAgcmV0dXJuIHBcbn1cbiJdLCJuYW1lcyI6W10sImlnbm9yZUxpc3QiOlswXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/swarm-js/node_modules/tar/lib/create.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/swarm-js/node_modules/tar/lib/extract.js":
/*!***************************************************************!*\
  !*** ./node_modules/swarm-js/node_modules/tar/lib/extract.js ***!
  \***************************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";
eval("\n\n// tar -x\nconst hlo = __webpack_require__(/*! ./high-level-opt.js */ \"(ssr)/./node_modules/swarm-js/node_modules/tar/lib/high-level-opt.js\")\nconst Unpack = __webpack_require__(/*! ./unpack.js */ \"(ssr)/./node_modules/swarm-js/node_modules/tar/lib/unpack.js\")\nconst fs = __webpack_require__(/*! fs */ \"fs\")\nconst fsm = __webpack_require__(/*! fs-minipass */ \"(ssr)/./node_modules/swarm-js/node_modules/fs-minipass/index.js\")\nconst path = __webpack_require__(/*! path */ \"path\")\nconst stripSlash = __webpack_require__(/*! ./strip-trailing-slashes.js */ \"(ssr)/./node_modules/swarm-js/node_modules/tar/lib/strip-trailing-slashes.js\")\n\nconst x = module.exports = (opt_, files, cb) => {\n  if (typeof opt_ === 'function')\n    cb = opt_, files = null, opt_ = {}\n  else if (Array.isArray(opt_))\n    files = opt_, opt_ = {}\n\n  if (typeof files === 'function')\n    cb = files, files = null\n\n  if (!files)\n    files = []\n  else\n    files = Array.from(files)\n\n  const opt = hlo(opt_)\n\n  if (opt.sync && typeof cb === 'function')\n    throw new TypeError('callback not supported for sync tar functions')\n\n  if (!opt.file && typeof cb === 'function')\n    throw new TypeError('callback only supported with file option')\n\n  if (files.length)\n    filesFilter(opt, files)\n\n  return opt.file && opt.sync ? extractFileSync(opt)\n    : opt.file ? extractFile(opt, cb)\n    : opt.sync ? extractSync(opt)\n    : extract(opt)\n}\n\n// construct a filter that limits the file entries listed\n// include child entries if a dir is included\nconst filesFilter = (opt, files) => {\n  const map = new Map(files.map(f => [stripSlash(f), true]))\n  const filter = opt.filter\n\n  const mapHas = (file, r) => {\n    const root = r || path.parse(file).root || '.'\n    const ret = file === root ? false\n      : map.has(file) ? map.get(file)\n      : mapHas(path.dirname(file), root)\n\n    map.set(file, ret)\n    return ret\n  }\n\n  opt.filter = filter\n    ? (file, entry) => filter(file, entry) && mapHas(stripSlash(file))\n    : file => mapHas(stripSlash(file))\n}\n\nconst extractFileSync = opt => {\n  const u = new Unpack.Sync(opt)\n\n  const file = opt.file\n  let threw = true\n  let fd\n  const stat = fs.statSync(file)\n  // This trades a zero-byte read() syscall for a stat\n  // However, it will usually result in less memory allocation\n  const readSize = opt.maxReadSize || 16*1024*1024\n  const stream = new fsm.ReadStreamSync(file, {\n    readSize: readSize,\n    size: stat.size\n  })\n  stream.pipe(u)\n}\n\nconst extractFile = (opt, cb) => {\n  const u = new Unpack(opt)\n  const readSize = opt.maxReadSize || 16*1024*1024\n\n  const file = opt.file\n  const p = new Promise((resolve, reject) => {\n    u.on('error', reject)\n    u.on('close', resolve)\n\n    // This trades a zero-byte read() syscall for a stat\n    // However, it will usually result in less memory allocation\n    fs.stat(file, (er, stat) => {\n      if (er)\n        reject(er)\n      else {\n        const stream = new fsm.ReadStream(file, {\n          readSize: readSize,\n          size: stat.size\n        })\n        stream.on('error', reject)\n        stream.pipe(u)\n      }\n    })\n  })\n  return cb ? p.then(cb, cb) : p\n}\n\nconst extractSync = opt => {\n  return new Unpack.Sync(opt)\n}\n\nconst extract = opt => {\n  return new Unpack(opt)\n}\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvc3dhcm0tanMvbm9kZV9tb2R1bGVzL3Rhci9saWIvZXh0cmFjdC5qcyIsIm1hcHBpbmdzIjoiQUFBWTs7QUFFWjtBQUNBLFlBQVksbUJBQU8sQ0FBQyxpR0FBcUI7QUFDekMsZUFBZSxtQkFBTyxDQUFDLGlGQUFhO0FBQ3BDLFdBQVcsbUJBQU8sQ0FBQyxjQUFJO0FBQ3ZCLFlBQVksbUJBQU8sQ0FBQyxvRkFBYTtBQUNqQyxhQUFhLG1CQUFPLENBQUMsa0JBQU07QUFDM0IsbUJBQW1CLG1CQUFPLENBQUMsaUhBQTZCOztBQUV4RDtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTCxHQUFHO0FBQ0g7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBIiwic291cmNlcyI6WyIvVXNlcnMvcGFuemEvRG9jdW1lbnRzL1BlcnNvbmFsUHJvamVjdHMvcHJlZGlrL25vZGVfbW9kdWxlcy9zd2FybS1qcy9ub2RlX21vZHVsZXMvdGFyL2xpYi9leHRyYWN0LmpzIl0sInNvdXJjZXNDb250ZW50IjpbIid1c2Ugc3RyaWN0J1xuXG4vLyB0YXIgLXhcbmNvbnN0IGhsbyA9IHJlcXVpcmUoJy4vaGlnaC1sZXZlbC1vcHQuanMnKVxuY29uc3QgVW5wYWNrID0gcmVxdWlyZSgnLi91bnBhY2suanMnKVxuY29uc3QgZnMgPSByZXF1aXJlKCdmcycpXG5jb25zdCBmc20gPSByZXF1aXJlKCdmcy1taW5pcGFzcycpXG5jb25zdCBwYXRoID0gcmVxdWlyZSgncGF0aCcpXG5jb25zdCBzdHJpcFNsYXNoID0gcmVxdWlyZSgnLi9zdHJpcC10cmFpbGluZy1zbGFzaGVzLmpzJylcblxuY29uc3QgeCA9IG1vZHVsZS5leHBvcnRzID0gKG9wdF8sIGZpbGVzLCBjYikgPT4ge1xuICBpZiAodHlwZW9mIG9wdF8gPT09ICdmdW5jdGlvbicpXG4gICAgY2IgPSBvcHRfLCBmaWxlcyA9IG51bGwsIG9wdF8gPSB7fVxuICBlbHNlIGlmIChBcnJheS5pc0FycmF5KG9wdF8pKVxuICAgIGZpbGVzID0gb3B0Xywgb3B0XyA9IHt9XG5cbiAgaWYgKHR5cGVvZiBmaWxlcyA9PT0gJ2Z1bmN0aW9uJylcbiAgICBjYiA9IGZpbGVzLCBmaWxlcyA9IG51bGxcblxuICBpZiAoIWZpbGVzKVxuICAgIGZpbGVzID0gW11cbiAgZWxzZVxuICAgIGZpbGVzID0gQXJyYXkuZnJvbShmaWxlcylcblxuICBjb25zdCBvcHQgPSBobG8ob3B0XylcblxuICBpZiAob3B0LnN5bmMgJiYgdHlwZW9mIGNiID09PSAnZnVuY3Rpb24nKVxuICAgIHRocm93IG5ldyBUeXBlRXJyb3IoJ2NhbGxiYWNrIG5vdCBzdXBwb3J0ZWQgZm9yIHN5bmMgdGFyIGZ1bmN0aW9ucycpXG5cbiAgaWYgKCFvcHQuZmlsZSAmJiB0eXBlb2YgY2IgPT09ICdmdW5jdGlvbicpXG4gICAgdGhyb3cgbmV3IFR5cGVFcnJvcignY2FsbGJhY2sgb25seSBzdXBwb3J0ZWQgd2l0aCBmaWxlIG9wdGlvbicpXG5cbiAgaWYgKGZpbGVzLmxlbmd0aClcbiAgICBmaWxlc0ZpbHRlcihvcHQsIGZpbGVzKVxuXG4gIHJldHVybiBvcHQuZmlsZSAmJiBvcHQuc3luYyA/IGV4dHJhY3RGaWxlU3luYyhvcHQpXG4gICAgOiBvcHQuZmlsZSA/IGV4dHJhY3RGaWxlKG9wdCwgY2IpXG4gICAgOiBvcHQuc3luYyA/IGV4dHJhY3RTeW5jKG9wdClcbiAgICA6IGV4dHJhY3Qob3B0KVxufVxuXG4vLyBjb25zdHJ1Y3QgYSBmaWx0ZXIgdGhhdCBsaW1pdHMgdGhlIGZpbGUgZW50cmllcyBsaXN0ZWRcbi8vIGluY2x1ZGUgY2hpbGQgZW50cmllcyBpZiBhIGRpciBpcyBpbmNsdWRlZFxuY29uc3QgZmlsZXNGaWx0ZXIgPSAob3B0LCBmaWxlcykgPT4ge1xuICBjb25zdCBtYXAgPSBuZXcgTWFwKGZpbGVzLm1hcChmID0+IFtzdHJpcFNsYXNoKGYpLCB0cnVlXSkpXG4gIGNvbnN0IGZpbHRlciA9IG9wdC5maWx0ZXJcblxuICBjb25zdCBtYXBIYXMgPSAoZmlsZSwgcikgPT4ge1xuICAgIGNvbnN0IHJvb3QgPSByIHx8IHBhdGgucGFyc2UoZmlsZSkucm9vdCB8fCAnLidcbiAgICBjb25zdCByZXQgPSBmaWxlID09PSByb290ID8gZmFsc2VcbiAgICAgIDogbWFwLmhhcyhmaWxlKSA/IG1hcC5nZXQoZmlsZSlcbiAgICAgIDogbWFwSGFzKHBhdGguZGlybmFtZShmaWxlKSwgcm9vdClcblxuICAgIG1hcC5zZXQoZmlsZSwgcmV0KVxuICAgIHJldHVybiByZXRcbiAgfVxuXG4gIG9wdC5maWx0ZXIgPSBmaWx0ZXJcbiAgICA/IChmaWxlLCBlbnRyeSkgPT4gZmlsdGVyKGZpbGUsIGVudHJ5KSAmJiBtYXBIYXMoc3RyaXBTbGFzaChmaWxlKSlcbiAgICA6IGZpbGUgPT4gbWFwSGFzKHN0cmlwU2xhc2goZmlsZSkpXG59XG5cbmNvbnN0IGV4dHJhY3RGaWxlU3luYyA9IG9wdCA9PiB7XG4gIGNvbnN0IHUgPSBuZXcgVW5wYWNrLlN5bmMob3B0KVxuXG4gIGNvbnN0IGZpbGUgPSBvcHQuZmlsZVxuICBsZXQgdGhyZXcgPSB0cnVlXG4gIGxldCBmZFxuICBjb25zdCBzdGF0ID0gZnMuc3RhdFN5bmMoZmlsZSlcbiAgLy8gVGhpcyB0cmFkZXMgYSB6ZXJvLWJ5dGUgcmVhZCgpIHN5c2NhbGwgZm9yIGEgc3RhdFxuICAvLyBIb3dldmVyLCBpdCB3aWxsIHVzdWFsbHkgcmVzdWx0IGluIGxlc3MgbWVtb3J5IGFsbG9jYXRpb25cbiAgY29uc3QgcmVhZFNpemUgPSBvcHQubWF4UmVhZFNpemUgfHwgMTYqMTAyNCoxMDI0XG4gIGNvbnN0IHN0cmVhbSA9IG5ldyBmc20uUmVhZFN0cmVhbVN5bmMoZmlsZSwge1xuICAgIHJlYWRTaXplOiByZWFkU2l6ZSxcbiAgICBzaXplOiBzdGF0LnNpemVcbiAgfSlcbiAgc3RyZWFtLnBpcGUodSlcbn1cblxuY29uc3QgZXh0cmFjdEZpbGUgPSAob3B0LCBjYikgPT4ge1xuICBjb25zdCB1ID0gbmV3IFVucGFjayhvcHQpXG4gIGNvbnN0IHJlYWRTaXplID0gb3B0Lm1heFJlYWRTaXplIHx8IDE2KjEwMjQqMTAyNFxuXG4gIGNvbnN0IGZpbGUgPSBvcHQuZmlsZVxuICBjb25zdCBwID0gbmV3IFByb21pc2UoKHJlc29sdmUsIHJlamVjdCkgPT4ge1xuICAgIHUub24oJ2Vycm9yJywgcmVqZWN0KVxuICAgIHUub24oJ2Nsb3NlJywgcmVzb2x2ZSlcblxuICAgIC8vIFRoaXMgdHJhZGVzIGEgemVyby1ieXRlIHJlYWQoKSBzeXNjYWxsIGZvciBhIHN0YXRcbiAgICAvLyBIb3dldmVyLCBpdCB3aWxsIHVzdWFsbHkgcmVzdWx0IGluIGxlc3MgbWVtb3J5IGFsbG9jYXRpb25cbiAgICBmcy5zdGF0KGZpbGUsIChlciwgc3RhdCkgPT4ge1xuICAgICAgaWYgKGVyKVxuICAgICAgICByZWplY3QoZXIpXG4gICAgICBlbHNlIHtcbiAgICAgICAgY29uc3Qgc3RyZWFtID0gbmV3IGZzbS5SZWFkU3RyZWFtKGZpbGUsIHtcbiAgICAgICAgICByZWFkU2l6ZTogcmVhZFNpemUsXG4gICAgICAgICAgc2l6ZTogc3RhdC5zaXplXG4gICAgICAgIH0pXG4gICAgICAgIHN0cmVhbS5vbignZXJyb3InLCByZWplY3QpXG4gICAgICAgIHN0cmVhbS5waXBlKHUpXG4gICAgICB9XG4gICAgfSlcbiAgfSlcbiAgcmV0dXJuIGNiID8gcC50aGVuKGNiLCBjYikgOiBwXG59XG5cbmNvbnN0IGV4dHJhY3RTeW5jID0gb3B0ID0+IHtcbiAgcmV0dXJuIG5ldyBVbnBhY2suU3luYyhvcHQpXG59XG5cbmNvbnN0IGV4dHJhY3QgPSBvcHQgPT4ge1xuICByZXR1cm4gbmV3IFVucGFjayhvcHQpXG59XG4iXSwibmFtZXMiOltdLCJpZ25vcmVMaXN0IjpbMF0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/swarm-js/node_modules/tar/lib/extract.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/swarm-js/node_modules/tar/lib/header.js":
/*!**************************************************************!*\
  !*** ./node_modules/swarm-js/node_modules/tar/lib/header.js ***!
  \**************************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";
eval("\n// parse a 512-byte header block to a data object, or vice-versa\n// encode returns `true` if a pax extended header is needed, because\n// the data could not be faithfully encoded in a simple header.\n// (Also, check header.needPax to see if it needs a pax header.)\n\nconst Buffer = __webpack_require__(/*! ./buffer.js */ \"(ssr)/./node_modules/swarm-js/node_modules/tar/lib/buffer.js\")\nconst types = __webpack_require__(/*! ./types.js */ \"(ssr)/./node_modules/swarm-js/node_modules/tar/lib/types.js\")\nconst pathModule = (__webpack_require__(/*! path */ \"path\").posix)\nconst large = __webpack_require__(/*! ./large-numbers.js */ \"(ssr)/./node_modules/swarm-js/node_modules/tar/lib/large-numbers.js\")\n\nconst SLURP = Symbol('slurp')\nconst TYPE = Symbol('type')\n\nclass Header {\n  constructor (data, off, ex, gex) {\n    this.cksumValid = false\n    this.needPax = false\n    this.nullBlock = false\n\n    this.block = null\n    this.path = null\n    this.mode = null\n    this.uid = null\n    this.gid = null\n    this.size = null\n    this.mtime = null\n    this.cksum = null\n    this[TYPE] = '0'\n    this.linkpath = null\n    this.uname = null\n    this.gname = null\n    this.devmaj = 0\n    this.devmin = 0\n    this.atime = null\n    this.ctime = null\n\n    if (Buffer.isBuffer(data))\n      this.decode(data, off || 0, ex, gex)\n    else if (data)\n      this.set(data)\n  }\n\n  decode (buf, off, ex, gex) {\n    if (!off)\n      off = 0\n\n    if (!buf || !(buf.length >= off + 512))\n      throw new Error('need 512 bytes for header')\n\n    this.path = decString(buf, off, 100)\n    this.mode = decNumber(buf, off + 100, 8)\n    this.uid = decNumber(buf, off + 108, 8)\n    this.gid = decNumber(buf, off + 116, 8)\n    this.size = decNumber(buf, off + 124, 12)\n    this.mtime = decDate(buf, off + 136, 12)\n    this.cksum = decNumber(buf, off + 148, 12)\n\n    // if we have extended or global extended headers, apply them now\n    // See https://github.com/npm/node-tar/pull/187\n    this[SLURP](ex)\n    this[SLURP](gex, true)\n\n    // old tar versions marked dirs as a file with a trailing /\n    this[TYPE] = decString(buf, off + 156, 1)\n    if (this[TYPE] === '')\n      this[TYPE] = '0'\n    if (this[TYPE] === '0' && this.path.substr(-1) === '/')\n      this[TYPE] = '5'\n\n    // tar implementations sometimes incorrectly put the stat(dir).size\n    // as the size in the tarball, even though Directory entries are\n    // not able to have any body at all.  In the very rare chance that\n    // it actually DOES have a body, we weren't going to do anything with\n    // it anyway, and it'll just be a warning about an invalid header.\n    if (this[TYPE] === '5')\n      this.size = 0\n\n    this.linkpath = decString(buf, off + 157, 100)\n    if (buf.slice(off + 257, off + 265).toString() === 'ustar\\u000000') {\n      this.uname = decString(buf, off + 265, 32)\n      this.gname = decString(buf, off + 297, 32)\n      this.devmaj = decNumber(buf, off + 329, 8)\n      this.devmin = decNumber(buf, off + 337, 8)\n      if (buf[off + 475] !== 0) {\n        // definitely a prefix, definitely >130 chars.\n        const prefix = decString(buf, off + 345, 155)\n        this.path = prefix + '/' + this.path\n      } else {\n        const prefix = decString(buf, off + 345, 130)\n        if (prefix)\n          this.path = prefix + '/' + this.path\n        this.atime = decDate(buf, off + 476, 12)\n        this.ctime = decDate(buf, off + 488, 12)\n      }\n    }\n\n    let sum = 8 * 0x20\n    for (let i = off; i < off + 148; i++) {\n      sum += buf[i]\n    }\n    for (let i = off + 156; i < off + 512; i++) {\n      sum += buf[i]\n    }\n    this.cksumValid = sum === this.cksum\n    if (this.cksum === null && sum === 8 * 0x20)\n      this.nullBlock = true\n  }\n\n  [SLURP] (ex, global) {\n    for (let k in ex) {\n      // we slurp in everything except for the path attribute in\n      // a global extended header, because that's weird.\n      if (ex[k] !== null && ex[k] !== undefined &&\n          !(global && k === 'path'))\n        this[k] = ex[k]\n    }\n  }\n\n  encode (buf, off) {\n    if (!buf) {\n      buf = this.block = Buffer.alloc(512)\n      off = 0\n    }\n\n    if (!off)\n      off = 0\n\n    if (!(buf.length >= off + 512))\n      throw new Error('need 512 bytes for header')\n\n    const prefixSize = this.ctime || this.atime ? 130 : 155\n    const split = splitPrefix(this.path || '', prefixSize)\n    const path = split[0]\n    const prefix = split[1]\n    this.needPax = split[2]\n\n    this.needPax = encString(buf, off, 100, path) || this.needPax\n    this.needPax = encNumber(buf, off + 100, 8, this.mode) || this.needPax\n    this.needPax = encNumber(buf, off + 108, 8, this.uid) || this.needPax\n    this.needPax = encNumber(buf, off + 116, 8, this.gid) || this.needPax\n    this.needPax = encNumber(buf, off + 124, 12, this.size) || this.needPax\n    this.needPax = encDate(buf, off + 136, 12, this.mtime) || this.needPax\n    buf[off + 156] = this[TYPE].charCodeAt(0)\n    this.needPax = encString(buf, off + 157, 100, this.linkpath) || this.needPax\n    buf.write('ustar\\u000000', off + 257, 8)\n    this.needPax = encString(buf, off + 265, 32, this.uname) || this.needPax\n    this.needPax = encString(buf, off + 297, 32, this.gname) || this.needPax\n    this.needPax = encNumber(buf, off + 329, 8, this.devmaj) || this.needPax\n    this.needPax = encNumber(buf, off + 337, 8, this.devmin) || this.needPax\n    this.needPax = encString(buf, off + 345, prefixSize, prefix) || this.needPax\n    if (buf[off + 475] !== 0)\n      this.needPax = encString(buf, off + 345, 155, prefix) || this.needPax\n    else {\n      this.needPax = encString(buf, off + 345, 130, prefix) || this.needPax\n      this.needPax = encDate(buf, off + 476, 12, this.atime) || this.needPax\n      this.needPax = encDate(buf, off + 488, 12, this.ctime) || this.needPax\n    }\n\n    let sum = 8 * 0x20\n    for (let i = off; i < off + 148; i++) {\n      sum += buf[i]\n    }\n    for (let i = off + 156; i < off + 512; i++) {\n      sum += buf[i]\n    }\n    this.cksum = sum\n    encNumber(buf, off + 148, 8, this.cksum)\n    this.cksumValid = true\n\n    return this.needPax\n  }\n\n  set (data) {\n    for (let i in data) {\n      if (data[i] !== null && data[i] !== undefined)\n        this[i] = data[i]\n    }\n  }\n\n  get type () {\n    return types.name.get(this[TYPE]) || this[TYPE]\n  }\n\n  get typeKey () {\n    return this[TYPE]\n  }\n\n  set type (type) {\n    if (types.code.has(type))\n      this[TYPE] = types.code.get(type)\n    else\n      this[TYPE] = type\n  }\n}\n\nconst splitPrefix = (p, prefixSize) => {\n  const pathSize = 100\n  let pp = p\n  let prefix = ''\n  let ret\n  const root = pathModule.parse(p).root || '.'\n\n  if (Buffer.byteLength(pp) < pathSize)\n    ret = [pp, prefix, false]\n  else {\n    // first set prefix to the dir, and path to the base\n    prefix = pathModule.dirname(pp)\n    pp = pathModule.basename(pp)\n\n    do {\n      // both fit!\n      if (Buffer.byteLength(pp) <= pathSize &&\n          Buffer.byteLength(prefix) <= prefixSize)\n        ret = [pp, prefix, false]\n\n      // prefix fits in prefix, but path doesn't fit in path\n      else if (Buffer.byteLength(pp) > pathSize &&\n          Buffer.byteLength(prefix) <= prefixSize)\n        ret = [pp.substr(0, pathSize - 1), prefix, true]\n\n      else {\n        // make path take a bit from prefix\n        pp = pathModule.join(pathModule.basename(prefix), pp)\n        prefix = pathModule.dirname(prefix)\n      }\n    } while (prefix !== root && !ret)\n\n    // at this point, found no resolution, just truncate\n    if (!ret)\n      ret = [p.substr(0, pathSize - 1), '', true]\n  }\n  return ret\n}\n\nconst decString = (buf, off, size) =>\n  buf.slice(off, off + size).toString('utf8').replace(/\\0.*/, '')\n\nconst decDate = (buf, off, size) =>\n  numToDate(decNumber(buf, off, size))\n\nconst numToDate = num => num === null ? null : new Date(num * 1000)\n\nconst decNumber = (buf, off, size) =>\n  buf[off] & 0x80 ? large.parse(buf.slice(off, off + size))\n    : decSmallNumber(buf, off, size)\n\nconst nanNull = value => isNaN(value) ? null : value\n\nconst decSmallNumber = (buf, off, size) =>\n  nanNull(parseInt(\n    buf.slice(off, off + size)\n      .toString('utf8').replace(/\\0.*$/, '').trim(), 8))\n\n// the maximum encodable as a null-terminated octal, by field size\nconst MAXNUM = {\n  12: 0o77777777777,\n  8 : 0o7777777\n}\n\nconst encNumber = (buf, off, size, number) =>\n  number === null ? false :\n  number > MAXNUM[size] || number < 0\n    ? (large.encode(number, buf.slice(off, off + size)), true)\n    : (encSmallNumber(buf, off, size, number), false)\n\nconst encSmallNumber = (buf, off, size, number) =>\n  buf.write(octalString(number, size), off, size, 'ascii')\n\nconst octalString = (number, size) =>\n  padOctal(Math.floor(number).toString(8), size)\n\nconst padOctal = (string, size) =>\n  (string.length === size - 1 ? string\n  : new Array(size - string.length - 1).join('0') + string + ' ') + '\\0'\n\nconst encDate = (buf, off, size, date) =>\n  date === null ? false :\n  encNumber(buf, off, size, date.getTime() / 1000)\n\n// enough to fill the longest string we've got\nconst NULLS = new Array(156).join('\\0')\n// pad with nulls, return true if it's longer or non-ascii\nconst encString = (buf, off, size, string) =>\n  string === null ? false :\n  (buf.write(string + NULLS, off, size, 'utf8'),\n   string.length !== Buffer.byteLength(string) || string.length > size)\n\nmodule.exports = Header\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvc3dhcm0tanMvbm9kZV9tb2R1bGVzL3Rhci9saWIvaGVhZGVyLmpzIiwibWFwcGluZ3MiOiJBQUFZO0FBQ1o7QUFDQTtBQUNBO0FBQ0E7O0FBRUEsZUFBZSxtQkFBTyxDQUFDLGlGQUFhO0FBQ3BDLGNBQWMsbUJBQU8sQ0FBQywrRUFBWTtBQUNsQyxtQkFBbUIsK0NBQXFCO0FBQ3hDLGNBQWMsbUJBQU8sQ0FBQywrRkFBb0I7O0FBRTFDO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFFBQVE7QUFDUjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLHNCQUFzQixlQUFlO0FBQ3JDO0FBQ0E7QUFDQSw0QkFBNEIsZUFBZTtBQUMzQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0Esc0JBQXNCLGVBQWU7QUFDckM7QUFDQTtBQUNBLDRCQUE0QixlQUFlO0FBQzNDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU07O0FBRU47QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBIiwic291cmNlcyI6WyIvVXNlcnMvcGFuemEvRG9jdW1lbnRzL1BlcnNvbmFsUHJvamVjdHMvcHJlZGlrL25vZGVfbW9kdWxlcy9zd2FybS1qcy9ub2RlX21vZHVsZXMvdGFyL2xpYi9oZWFkZXIuanMiXSwic291cmNlc0NvbnRlbnQiOlsiJ3VzZSBzdHJpY3QnXG4vLyBwYXJzZSBhIDUxMi1ieXRlIGhlYWRlciBibG9jayB0byBhIGRhdGEgb2JqZWN0LCBvciB2aWNlLXZlcnNhXG4vLyBlbmNvZGUgcmV0dXJucyBgdHJ1ZWAgaWYgYSBwYXggZXh0ZW5kZWQgaGVhZGVyIGlzIG5lZWRlZCwgYmVjYXVzZVxuLy8gdGhlIGRhdGEgY291bGQgbm90IGJlIGZhaXRoZnVsbHkgZW5jb2RlZCBpbiBhIHNpbXBsZSBoZWFkZXIuXG4vLyAoQWxzbywgY2hlY2sgaGVhZGVyLm5lZWRQYXggdG8gc2VlIGlmIGl0IG5lZWRzIGEgcGF4IGhlYWRlci4pXG5cbmNvbnN0IEJ1ZmZlciA9IHJlcXVpcmUoJy4vYnVmZmVyLmpzJylcbmNvbnN0IHR5cGVzID0gcmVxdWlyZSgnLi90eXBlcy5qcycpXG5jb25zdCBwYXRoTW9kdWxlID0gcmVxdWlyZSgncGF0aCcpLnBvc2l4XG5jb25zdCBsYXJnZSA9IHJlcXVpcmUoJy4vbGFyZ2UtbnVtYmVycy5qcycpXG5cbmNvbnN0IFNMVVJQID0gU3ltYm9sKCdzbHVycCcpXG5jb25zdCBUWVBFID0gU3ltYm9sKCd0eXBlJylcblxuY2xhc3MgSGVhZGVyIHtcbiAgY29uc3RydWN0b3IgKGRhdGEsIG9mZiwgZXgsIGdleCkge1xuICAgIHRoaXMuY2tzdW1WYWxpZCA9IGZhbHNlXG4gICAgdGhpcy5uZWVkUGF4ID0gZmFsc2VcbiAgICB0aGlzLm51bGxCbG9jayA9IGZhbHNlXG5cbiAgICB0aGlzLmJsb2NrID0gbnVsbFxuICAgIHRoaXMucGF0aCA9IG51bGxcbiAgICB0aGlzLm1vZGUgPSBudWxsXG4gICAgdGhpcy51aWQgPSBudWxsXG4gICAgdGhpcy5naWQgPSBudWxsXG4gICAgdGhpcy5zaXplID0gbnVsbFxuICAgIHRoaXMubXRpbWUgPSBudWxsXG4gICAgdGhpcy5ja3N1bSA9IG51bGxcbiAgICB0aGlzW1RZUEVdID0gJzAnXG4gICAgdGhpcy5saW5rcGF0aCA9IG51bGxcbiAgICB0aGlzLnVuYW1lID0gbnVsbFxuICAgIHRoaXMuZ25hbWUgPSBudWxsXG4gICAgdGhpcy5kZXZtYWogPSAwXG4gICAgdGhpcy5kZXZtaW4gPSAwXG4gICAgdGhpcy5hdGltZSA9IG51bGxcbiAgICB0aGlzLmN0aW1lID0gbnVsbFxuXG4gICAgaWYgKEJ1ZmZlci5pc0J1ZmZlcihkYXRhKSlcbiAgICAgIHRoaXMuZGVjb2RlKGRhdGEsIG9mZiB8fCAwLCBleCwgZ2V4KVxuICAgIGVsc2UgaWYgKGRhdGEpXG4gICAgICB0aGlzLnNldChkYXRhKVxuICB9XG5cbiAgZGVjb2RlIChidWYsIG9mZiwgZXgsIGdleCkge1xuICAgIGlmICghb2ZmKVxuICAgICAgb2ZmID0gMFxuXG4gICAgaWYgKCFidWYgfHwgIShidWYubGVuZ3RoID49IG9mZiArIDUxMikpXG4gICAgICB0aHJvdyBuZXcgRXJyb3IoJ25lZWQgNTEyIGJ5dGVzIGZvciBoZWFkZXInKVxuXG4gICAgdGhpcy5wYXRoID0gZGVjU3RyaW5nKGJ1Ziwgb2ZmLCAxMDApXG4gICAgdGhpcy5tb2RlID0gZGVjTnVtYmVyKGJ1Ziwgb2ZmICsgMTAwLCA4KVxuICAgIHRoaXMudWlkID0gZGVjTnVtYmVyKGJ1Ziwgb2ZmICsgMTA4LCA4KVxuICAgIHRoaXMuZ2lkID0gZGVjTnVtYmVyKGJ1Ziwgb2ZmICsgMTE2LCA4KVxuICAgIHRoaXMuc2l6ZSA9IGRlY051bWJlcihidWYsIG9mZiArIDEyNCwgMTIpXG4gICAgdGhpcy5tdGltZSA9IGRlY0RhdGUoYnVmLCBvZmYgKyAxMzYsIDEyKVxuICAgIHRoaXMuY2tzdW0gPSBkZWNOdW1iZXIoYnVmLCBvZmYgKyAxNDgsIDEyKVxuXG4gICAgLy8gaWYgd2UgaGF2ZSBleHRlbmRlZCBvciBnbG9iYWwgZXh0ZW5kZWQgaGVhZGVycywgYXBwbHkgdGhlbSBub3dcbiAgICAvLyBTZWUgaHR0cHM6Ly9naXRodWIuY29tL25wbS9ub2RlLXRhci9wdWxsLzE4N1xuICAgIHRoaXNbU0xVUlBdKGV4KVxuICAgIHRoaXNbU0xVUlBdKGdleCwgdHJ1ZSlcblxuICAgIC8vIG9sZCB0YXIgdmVyc2lvbnMgbWFya2VkIGRpcnMgYXMgYSBmaWxlIHdpdGggYSB0cmFpbGluZyAvXG4gICAgdGhpc1tUWVBFXSA9IGRlY1N0cmluZyhidWYsIG9mZiArIDE1NiwgMSlcbiAgICBpZiAodGhpc1tUWVBFXSA9PT0gJycpXG4gICAgICB0aGlzW1RZUEVdID0gJzAnXG4gICAgaWYgKHRoaXNbVFlQRV0gPT09ICcwJyAmJiB0aGlzLnBhdGguc3Vic3RyKC0xKSA9PT0gJy8nKVxuICAgICAgdGhpc1tUWVBFXSA9ICc1J1xuXG4gICAgLy8gdGFyIGltcGxlbWVudGF0aW9ucyBzb21ldGltZXMgaW5jb3JyZWN0bHkgcHV0IHRoZSBzdGF0KGRpcikuc2l6ZVxuICAgIC8vIGFzIHRoZSBzaXplIGluIHRoZSB0YXJiYWxsLCBldmVuIHRob3VnaCBEaXJlY3RvcnkgZW50cmllcyBhcmVcbiAgICAvLyBub3QgYWJsZSB0byBoYXZlIGFueSBib2R5IGF0IGFsbC4gIEluIHRoZSB2ZXJ5IHJhcmUgY2hhbmNlIHRoYXRcbiAgICAvLyBpdCBhY3R1YWxseSBET0VTIGhhdmUgYSBib2R5LCB3ZSB3ZXJlbid0IGdvaW5nIHRvIGRvIGFueXRoaW5nIHdpdGhcbiAgICAvLyBpdCBhbnl3YXksIGFuZCBpdCdsbCBqdXN0IGJlIGEgd2FybmluZyBhYm91dCBhbiBpbnZhbGlkIGhlYWRlci5cbiAgICBpZiAodGhpc1tUWVBFXSA9PT0gJzUnKVxuICAgICAgdGhpcy5zaXplID0gMFxuXG4gICAgdGhpcy5saW5rcGF0aCA9IGRlY1N0cmluZyhidWYsIG9mZiArIDE1NywgMTAwKVxuICAgIGlmIChidWYuc2xpY2Uob2ZmICsgMjU3LCBvZmYgKyAyNjUpLnRvU3RyaW5nKCkgPT09ICd1c3RhclxcdTAwMDAwMCcpIHtcbiAgICAgIHRoaXMudW5hbWUgPSBkZWNTdHJpbmcoYnVmLCBvZmYgKyAyNjUsIDMyKVxuICAgICAgdGhpcy5nbmFtZSA9IGRlY1N0cmluZyhidWYsIG9mZiArIDI5NywgMzIpXG4gICAgICB0aGlzLmRldm1haiA9IGRlY051bWJlcihidWYsIG9mZiArIDMyOSwgOClcbiAgICAgIHRoaXMuZGV2bWluID0gZGVjTnVtYmVyKGJ1Ziwgb2ZmICsgMzM3LCA4KVxuICAgICAgaWYgKGJ1ZltvZmYgKyA0NzVdICE9PSAwKSB7XG4gICAgICAgIC8vIGRlZmluaXRlbHkgYSBwcmVmaXgsIGRlZmluaXRlbHkgPjEzMCBjaGFycy5cbiAgICAgICAgY29uc3QgcHJlZml4ID0gZGVjU3RyaW5nKGJ1Ziwgb2ZmICsgMzQ1LCAxNTUpXG4gICAgICAgIHRoaXMucGF0aCA9IHByZWZpeCArICcvJyArIHRoaXMucGF0aFxuICAgICAgfSBlbHNlIHtcbiAgICAgICAgY29uc3QgcHJlZml4ID0gZGVjU3RyaW5nKGJ1Ziwgb2ZmICsgMzQ1LCAxMzApXG4gICAgICAgIGlmIChwcmVmaXgpXG4gICAgICAgICAgdGhpcy5wYXRoID0gcHJlZml4ICsgJy8nICsgdGhpcy5wYXRoXG4gICAgICAgIHRoaXMuYXRpbWUgPSBkZWNEYXRlKGJ1Ziwgb2ZmICsgNDc2LCAxMilcbiAgICAgICAgdGhpcy5jdGltZSA9IGRlY0RhdGUoYnVmLCBvZmYgKyA0ODgsIDEyKVxuICAgICAgfVxuICAgIH1cblxuICAgIGxldCBzdW0gPSA4ICogMHgyMFxuICAgIGZvciAobGV0IGkgPSBvZmY7IGkgPCBvZmYgKyAxNDg7IGkrKykge1xuICAgICAgc3VtICs9IGJ1ZltpXVxuICAgIH1cbiAgICBmb3IgKGxldCBpID0gb2ZmICsgMTU2OyBpIDwgb2ZmICsgNTEyOyBpKyspIHtcbiAgICAgIHN1bSArPSBidWZbaV1cbiAgICB9XG4gICAgdGhpcy5ja3N1bVZhbGlkID0gc3VtID09PSB0aGlzLmNrc3VtXG4gICAgaWYgKHRoaXMuY2tzdW0gPT09IG51bGwgJiYgc3VtID09PSA4ICogMHgyMClcbiAgICAgIHRoaXMubnVsbEJsb2NrID0gdHJ1ZVxuICB9XG5cbiAgW1NMVVJQXSAoZXgsIGdsb2JhbCkge1xuICAgIGZvciAobGV0IGsgaW4gZXgpIHtcbiAgICAgIC8vIHdlIHNsdXJwIGluIGV2ZXJ5dGhpbmcgZXhjZXB0IGZvciB0aGUgcGF0aCBhdHRyaWJ1dGUgaW5cbiAgICAgIC8vIGEgZ2xvYmFsIGV4dGVuZGVkIGhlYWRlciwgYmVjYXVzZSB0aGF0J3Mgd2VpcmQuXG4gICAgICBpZiAoZXhba10gIT09IG51bGwgJiYgZXhba10gIT09IHVuZGVmaW5lZCAmJlxuICAgICAgICAgICEoZ2xvYmFsICYmIGsgPT09ICdwYXRoJykpXG4gICAgICAgIHRoaXNba10gPSBleFtrXVxuICAgIH1cbiAgfVxuXG4gIGVuY29kZSAoYnVmLCBvZmYpIHtcbiAgICBpZiAoIWJ1Zikge1xuICAgICAgYnVmID0gdGhpcy5ibG9jayA9IEJ1ZmZlci5hbGxvYyg1MTIpXG4gICAgICBvZmYgPSAwXG4gICAgfVxuXG4gICAgaWYgKCFvZmYpXG4gICAgICBvZmYgPSAwXG5cbiAgICBpZiAoIShidWYubGVuZ3RoID49IG9mZiArIDUxMikpXG4gICAgICB0aHJvdyBuZXcgRXJyb3IoJ25lZWQgNTEyIGJ5dGVzIGZvciBoZWFkZXInKVxuXG4gICAgY29uc3QgcHJlZml4U2l6ZSA9IHRoaXMuY3RpbWUgfHwgdGhpcy5hdGltZSA/IDEzMCA6IDE1NVxuICAgIGNvbnN0IHNwbGl0ID0gc3BsaXRQcmVmaXgodGhpcy5wYXRoIHx8ICcnLCBwcmVmaXhTaXplKVxuICAgIGNvbnN0IHBhdGggPSBzcGxpdFswXVxuICAgIGNvbnN0IHByZWZpeCA9IHNwbGl0WzFdXG4gICAgdGhpcy5uZWVkUGF4ID0gc3BsaXRbMl1cblxuICAgIHRoaXMubmVlZFBheCA9IGVuY1N0cmluZyhidWYsIG9mZiwgMTAwLCBwYXRoKSB8fCB0aGlzLm5lZWRQYXhcbiAgICB0aGlzLm5lZWRQYXggPSBlbmNOdW1iZXIoYnVmLCBvZmYgKyAxMDAsIDgsIHRoaXMubW9kZSkgfHwgdGhpcy5uZWVkUGF4XG4gICAgdGhpcy5uZWVkUGF4ID0gZW5jTnVtYmVyKGJ1Ziwgb2ZmICsgMTA4LCA4LCB0aGlzLnVpZCkgfHwgdGhpcy5uZWVkUGF4XG4gICAgdGhpcy5uZWVkUGF4ID0gZW5jTnVtYmVyKGJ1Ziwgb2ZmICsgMTE2LCA4LCB0aGlzLmdpZCkgfHwgdGhpcy5uZWVkUGF4XG4gICAgdGhpcy5uZWVkUGF4ID0gZW5jTnVtYmVyKGJ1Ziwgb2ZmICsgMTI0LCAxMiwgdGhpcy5zaXplKSB8fCB0aGlzLm5lZWRQYXhcbiAgICB0aGlzLm5lZWRQYXggPSBlbmNEYXRlKGJ1Ziwgb2ZmICsgMTM2LCAxMiwgdGhpcy5tdGltZSkgfHwgdGhpcy5uZWVkUGF4XG4gICAgYnVmW29mZiArIDE1Nl0gPSB0aGlzW1RZUEVdLmNoYXJDb2RlQXQoMClcbiAgICB0aGlzLm5lZWRQYXggPSBlbmNTdHJpbmcoYnVmLCBvZmYgKyAxNTcsIDEwMCwgdGhpcy5saW5rcGF0aCkgfHwgdGhpcy5uZWVkUGF4XG4gICAgYnVmLndyaXRlKCd1c3RhclxcdTAwMDAwMCcsIG9mZiArIDI1NywgOClcbiAgICB0aGlzLm5lZWRQYXggPSBlbmNTdHJpbmcoYnVmLCBvZmYgKyAyNjUsIDMyLCB0aGlzLnVuYW1lKSB8fCB0aGlzLm5lZWRQYXhcbiAgICB0aGlzLm5lZWRQYXggPSBlbmNTdHJpbmcoYnVmLCBvZmYgKyAyOTcsIDMyLCB0aGlzLmduYW1lKSB8fCB0aGlzLm5lZWRQYXhcbiAgICB0aGlzLm5lZWRQYXggPSBlbmNOdW1iZXIoYnVmLCBvZmYgKyAzMjksIDgsIHRoaXMuZGV2bWFqKSB8fCB0aGlzLm5lZWRQYXhcbiAgICB0aGlzLm5lZWRQYXggPSBlbmNOdW1iZXIoYnVmLCBvZmYgKyAzMzcsIDgsIHRoaXMuZGV2bWluKSB8fCB0aGlzLm5lZWRQYXhcbiAgICB0aGlzLm5lZWRQYXggPSBlbmNTdHJpbmcoYnVmLCBvZmYgKyAzNDUsIHByZWZpeFNpemUsIHByZWZpeCkgfHwgdGhpcy5uZWVkUGF4XG4gICAgaWYgKGJ1ZltvZmYgKyA0NzVdICE9PSAwKVxuICAgICAgdGhpcy5uZWVkUGF4ID0gZW5jU3RyaW5nKGJ1Ziwgb2ZmICsgMzQ1LCAxNTUsIHByZWZpeCkgfHwgdGhpcy5uZWVkUGF4XG4gICAgZWxzZSB7XG4gICAgICB0aGlzLm5lZWRQYXggPSBlbmNTdHJpbmcoYnVmLCBvZmYgKyAzNDUsIDEzMCwgcHJlZml4KSB8fCB0aGlzLm5lZWRQYXhcbiAgICAgIHRoaXMubmVlZFBheCA9IGVuY0RhdGUoYnVmLCBvZmYgKyA0NzYsIDEyLCB0aGlzLmF0aW1lKSB8fCB0aGlzLm5lZWRQYXhcbiAgICAgIHRoaXMubmVlZFBheCA9IGVuY0RhdGUoYnVmLCBvZmYgKyA0ODgsIDEyLCB0aGlzLmN0aW1lKSB8fCB0aGlzLm5lZWRQYXhcbiAgICB9XG5cbiAgICBsZXQgc3VtID0gOCAqIDB4MjBcbiAgICBmb3IgKGxldCBpID0gb2ZmOyBpIDwgb2ZmICsgMTQ4OyBpKyspIHtcbiAgICAgIHN1bSArPSBidWZbaV1cbiAgICB9XG4gICAgZm9yIChsZXQgaSA9IG9mZiArIDE1NjsgaSA8IG9mZiArIDUxMjsgaSsrKSB7XG4gICAgICBzdW0gKz0gYnVmW2ldXG4gICAgfVxuICAgIHRoaXMuY2tzdW0gPSBzdW1cbiAgICBlbmNOdW1iZXIoYnVmLCBvZmYgKyAxNDgsIDgsIHRoaXMuY2tzdW0pXG4gICAgdGhpcy5ja3N1bVZhbGlkID0gdHJ1ZVxuXG4gICAgcmV0dXJuIHRoaXMubmVlZFBheFxuICB9XG5cbiAgc2V0IChkYXRhKSB7XG4gICAgZm9yIChsZXQgaSBpbiBkYXRhKSB7XG4gICAgICBpZiAoZGF0YVtpXSAhPT0gbnVsbCAmJiBkYXRhW2ldICE9PSB1bmRlZmluZWQpXG4gICAgICAgIHRoaXNbaV0gPSBkYXRhW2ldXG4gICAgfVxuICB9XG5cbiAgZ2V0IHR5cGUgKCkge1xuICAgIHJldHVybiB0eXBlcy5uYW1lLmdldCh0aGlzW1RZUEVdKSB8fCB0aGlzW1RZUEVdXG4gIH1cblxuICBnZXQgdHlwZUtleSAoKSB7XG4gICAgcmV0dXJuIHRoaXNbVFlQRV1cbiAgfVxuXG4gIHNldCB0eXBlICh0eXBlKSB7XG4gICAgaWYgKHR5cGVzLmNvZGUuaGFzKHR5cGUpKVxuICAgICAgdGhpc1tUWVBFXSA9IHR5cGVzLmNvZGUuZ2V0KHR5cGUpXG4gICAgZWxzZVxuICAgICAgdGhpc1tUWVBFXSA9IHR5cGVcbiAgfVxufVxuXG5jb25zdCBzcGxpdFByZWZpeCA9IChwLCBwcmVmaXhTaXplKSA9PiB7XG4gIGNvbnN0IHBhdGhTaXplID0gMTAwXG4gIGxldCBwcCA9IHBcbiAgbGV0IHByZWZpeCA9ICcnXG4gIGxldCByZXRcbiAgY29uc3Qgcm9vdCA9IHBhdGhNb2R1bGUucGFyc2UocCkucm9vdCB8fCAnLidcblxuICBpZiAoQnVmZmVyLmJ5dGVMZW5ndGgocHApIDwgcGF0aFNpemUpXG4gICAgcmV0ID0gW3BwLCBwcmVmaXgsIGZhbHNlXVxuICBlbHNlIHtcbiAgICAvLyBmaXJzdCBzZXQgcHJlZml4IHRvIHRoZSBkaXIsIGFuZCBwYXRoIHRvIHRoZSBiYXNlXG4gICAgcHJlZml4ID0gcGF0aE1vZHVsZS5kaXJuYW1lKHBwKVxuICAgIHBwID0gcGF0aE1vZHVsZS5iYXNlbmFtZShwcClcblxuICAgIGRvIHtcbiAgICAgIC8vIGJvdGggZml0IVxuICAgICAgaWYgKEJ1ZmZlci5ieXRlTGVuZ3RoKHBwKSA8PSBwYXRoU2l6ZSAmJlxuICAgICAgICAgIEJ1ZmZlci5ieXRlTGVuZ3RoKHByZWZpeCkgPD0gcHJlZml4U2l6ZSlcbiAgICAgICAgcmV0ID0gW3BwLCBwcmVmaXgsIGZhbHNlXVxuXG4gICAgICAvLyBwcmVmaXggZml0cyBpbiBwcmVmaXgsIGJ1dCBwYXRoIGRvZXNuJ3QgZml0IGluIHBhdGhcbiAgICAgIGVsc2UgaWYgKEJ1ZmZlci5ieXRlTGVuZ3RoKHBwKSA+IHBhdGhTaXplICYmXG4gICAgICAgICAgQnVmZmVyLmJ5dGVMZW5ndGgocHJlZml4KSA8PSBwcmVmaXhTaXplKVxuICAgICAgICByZXQgPSBbcHAuc3Vic3RyKDAsIHBhdGhTaXplIC0gMSksIHByZWZpeCwgdHJ1ZV1cblxuICAgICAgZWxzZSB7XG4gICAgICAgIC8vIG1ha2UgcGF0aCB0YWtlIGEgYml0IGZyb20gcHJlZml4XG4gICAgICAgIHBwID0gcGF0aE1vZHVsZS5qb2luKHBhdGhNb2R1bGUuYmFzZW5hbWUocHJlZml4KSwgcHApXG4gICAgICAgIHByZWZpeCA9IHBhdGhNb2R1bGUuZGlybmFtZShwcmVmaXgpXG4gICAgICB9XG4gICAgfSB3aGlsZSAocHJlZml4ICE9PSByb290ICYmICFyZXQpXG5cbiAgICAvLyBhdCB0aGlzIHBvaW50LCBmb3VuZCBubyByZXNvbHV0aW9uLCBqdXN0IHRydW5jYXRlXG4gICAgaWYgKCFyZXQpXG4gICAgICByZXQgPSBbcC5zdWJzdHIoMCwgcGF0aFNpemUgLSAxKSwgJycsIHRydWVdXG4gIH1cbiAgcmV0dXJuIHJldFxufVxuXG5jb25zdCBkZWNTdHJpbmcgPSAoYnVmLCBvZmYsIHNpemUpID0+XG4gIGJ1Zi5zbGljZShvZmYsIG9mZiArIHNpemUpLnRvU3RyaW5nKCd1dGY4JykucmVwbGFjZSgvXFwwLiovLCAnJylcblxuY29uc3QgZGVjRGF0ZSA9IChidWYsIG9mZiwgc2l6ZSkgPT5cbiAgbnVtVG9EYXRlKGRlY051bWJlcihidWYsIG9mZiwgc2l6ZSkpXG5cbmNvbnN0IG51bVRvRGF0ZSA9IG51bSA9PiBudW0gPT09IG51bGwgPyBudWxsIDogbmV3IERhdGUobnVtICogMTAwMClcblxuY29uc3QgZGVjTnVtYmVyID0gKGJ1Ziwgb2ZmLCBzaXplKSA9PlxuICBidWZbb2ZmXSAmIDB4ODAgPyBsYXJnZS5wYXJzZShidWYuc2xpY2Uob2ZmLCBvZmYgKyBzaXplKSlcbiAgICA6IGRlY1NtYWxsTnVtYmVyKGJ1Ziwgb2ZmLCBzaXplKVxuXG5jb25zdCBuYW5OdWxsID0gdmFsdWUgPT4gaXNOYU4odmFsdWUpID8gbnVsbCA6IHZhbHVlXG5cbmNvbnN0IGRlY1NtYWxsTnVtYmVyID0gKGJ1Ziwgb2ZmLCBzaXplKSA9PlxuICBuYW5OdWxsKHBhcnNlSW50KFxuICAgIGJ1Zi5zbGljZShvZmYsIG9mZiArIHNpemUpXG4gICAgICAudG9TdHJpbmcoJ3V0ZjgnKS5yZXBsYWNlKC9cXDAuKiQvLCAnJykudHJpbSgpLCA4KSlcblxuLy8gdGhlIG1heGltdW0gZW5jb2RhYmxlIGFzIGEgbnVsbC10ZXJtaW5hdGVkIG9jdGFsLCBieSBmaWVsZCBzaXplXG5jb25zdCBNQVhOVU0gPSB7XG4gIDEyOiAwbzc3Nzc3Nzc3Nzc3LFxuICA4IDogMG83Nzc3Nzc3XG59XG5cbmNvbnN0IGVuY051bWJlciA9IChidWYsIG9mZiwgc2l6ZSwgbnVtYmVyKSA9PlxuICBudW1iZXIgPT09IG51bGwgPyBmYWxzZSA6XG4gIG51bWJlciA+IE1BWE5VTVtzaXplXSB8fCBudW1iZXIgPCAwXG4gICAgPyAobGFyZ2UuZW5jb2RlKG51bWJlciwgYnVmLnNsaWNlKG9mZiwgb2ZmICsgc2l6ZSkpLCB0cnVlKVxuICAgIDogKGVuY1NtYWxsTnVtYmVyKGJ1Ziwgb2ZmLCBzaXplLCBudW1iZXIpLCBmYWxzZSlcblxuY29uc3QgZW5jU21hbGxOdW1iZXIgPSAoYnVmLCBvZmYsIHNpemUsIG51bWJlcikgPT5cbiAgYnVmLndyaXRlKG9jdGFsU3RyaW5nKG51bWJlciwgc2l6ZSksIG9mZiwgc2l6ZSwgJ2FzY2lpJylcblxuY29uc3Qgb2N0YWxTdHJpbmcgPSAobnVtYmVyLCBzaXplKSA9PlxuICBwYWRPY3RhbChNYXRoLmZsb29yKG51bWJlcikudG9TdHJpbmcoOCksIHNpemUpXG5cbmNvbnN0IHBhZE9jdGFsID0gKHN0cmluZywgc2l6ZSkgPT5cbiAgKHN0cmluZy5sZW5ndGggPT09IHNpemUgLSAxID8gc3RyaW5nXG4gIDogbmV3IEFycmF5KHNpemUgLSBzdHJpbmcubGVuZ3RoIC0gMSkuam9pbignMCcpICsgc3RyaW5nICsgJyAnKSArICdcXDAnXG5cbmNvbnN0IGVuY0RhdGUgPSAoYnVmLCBvZmYsIHNpemUsIGRhdGUpID0+XG4gIGRhdGUgPT09IG51bGwgPyBmYWxzZSA6XG4gIGVuY051bWJlcihidWYsIG9mZiwgc2l6ZSwgZGF0ZS5nZXRUaW1lKCkgLyAxMDAwKVxuXG4vLyBlbm91Z2ggdG8gZmlsbCB0aGUgbG9uZ2VzdCBzdHJpbmcgd2UndmUgZ290XG5jb25zdCBOVUxMUyA9IG5ldyBBcnJheSgxNTYpLmpvaW4oJ1xcMCcpXG4vLyBwYWQgd2l0aCBudWxscywgcmV0dXJuIHRydWUgaWYgaXQncyBsb25nZXIgb3Igbm9uLWFzY2lpXG5jb25zdCBlbmNTdHJpbmcgPSAoYnVmLCBvZmYsIHNpemUsIHN0cmluZykgPT5cbiAgc3RyaW5nID09PSBudWxsID8gZmFsc2UgOlxuICAoYnVmLndyaXRlKHN0cmluZyArIE5VTExTLCBvZmYsIHNpemUsICd1dGY4JyksXG4gICBzdHJpbmcubGVuZ3RoICE9PSBCdWZmZXIuYnl0ZUxlbmd0aChzdHJpbmcpIHx8IHN0cmluZy5sZW5ndGggPiBzaXplKVxuXG5tb2R1bGUuZXhwb3J0cyA9IEhlYWRlclxuIl0sIm5hbWVzIjpbXSwiaWdub3JlTGlzdCI6WzBdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/swarm-js/node_modules/tar/lib/header.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/swarm-js/node_modules/tar/lib/high-level-opt.js":
/*!**********************************************************************!*\
  !*** ./node_modules/swarm-js/node_modules/tar/lib/high-level-opt.js ***!
  \**********************************************************************/
/***/ ((module) => {

"use strict";
eval("\n\n// turn tar(1) style args like `C` into the more verbose things like `cwd`\n\nconst argmap = new Map([\n  ['C', 'cwd'],\n  ['f', 'file'],\n  ['z', 'gzip'],\n  ['P', 'preservePaths'],\n  ['U', 'unlink'],\n  ['strip-components', 'strip'],\n  ['stripComponents', 'strip'],\n  ['keep-newer', 'newer'],\n  ['keepNewer', 'newer'],\n  ['keep-newer-files', 'newer'],\n  ['keepNewerFiles', 'newer'],\n  ['k', 'keep'],\n  ['keep-existing', 'keep'],\n  ['keepExisting', 'keep'],\n  ['m', 'noMtime'],\n  ['no-mtime', 'noMtime'],\n  ['p', 'preserveOwner'],\n  ['L', 'follow'],\n  ['h', 'follow']\n])\n\nconst parse = module.exports = opt => opt ? Object.keys(opt).map(k => [\n  argmap.has(k) ? argmap.get(k) : k, opt[k]\n]).reduce((set, kv) => (set[kv[0]] = kv[1], set), Object.create(null)) : {}\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvc3dhcm0tanMvbm9kZV9tb2R1bGVzL3Rhci9saWIvaGlnaC1sZXZlbC1vcHQuanMiLCJtYXBwaW5ncyI6IkFBQVk7O0FBRVo7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSIsInNvdXJjZXMiOlsiL1VzZXJzL3BhbnphL0RvY3VtZW50cy9QZXJzb25hbFByb2plY3RzL3ByZWRpay9ub2RlX21vZHVsZXMvc3dhcm0tanMvbm9kZV9tb2R1bGVzL3Rhci9saWIvaGlnaC1sZXZlbC1vcHQuanMiXSwic291cmNlc0NvbnRlbnQiOlsiJ3VzZSBzdHJpY3QnXG5cbi8vIHR1cm4gdGFyKDEpIHN0eWxlIGFyZ3MgbGlrZSBgQ2AgaW50byB0aGUgbW9yZSB2ZXJib3NlIHRoaW5ncyBsaWtlIGBjd2RgXG5cbmNvbnN0IGFyZ21hcCA9IG5ldyBNYXAoW1xuICBbJ0MnLCAnY3dkJ10sXG4gIFsnZicsICdmaWxlJ10sXG4gIFsneicsICdnemlwJ10sXG4gIFsnUCcsICdwcmVzZXJ2ZVBhdGhzJ10sXG4gIFsnVScsICd1bmxpbmsnXSxcbiAgWydzdHJpcC1jb21wb25lbnRzJywgJ3N0cmlwJ10sXG4gIFsnc3RyaXBDb21wb25lbnRzJywgJ3N0cmlwJ10sXG4gIFsna2VlcC1uZXdlcicsICduZXdlciddLFxuICBbJ2tlZXBOZXdlcicsICduZXdlciddLFxuICBbJ2tlZXAtbmV3ZXItZmlsZXMnLCAnbmV3ZXInXSxcbiAgWydrZWVwTmV3ZXJGaWxlcycsICduZXdlciddLFxuICBbJ2snLCAna2VlcCddLFxuICBbJ2tlZXAtZXhpc3RpbmcnLCAna2VlcCddLFxuICBbJ2tlZXBFeGlzdGluZycsICdrZWVwJ10sXG4gIFsnbScsICdub010aW1lJ10sXG4gIFsnbm8tbXRpbWUnLCAnbm9NdGltZSddLFxuICBbJ3AnLCAncHJlc2VydmVPd25lciddLFxuICBbJ0wnLCAnZm9sbG93J10sXG4gIFsnaCcsICdmb2xsb3cnXVxuXSlcblxuY29uc3QgcGFyc2UgPSBtb2R1bGUuZXhwb3J0cyA9IG9wdCA9PiBvcHQgPyBPYmplY3Qua2V5cyhvcHQpLm1hcChrID0+IFtcbiAgYXJnbWFwLmhhcyhrKSA/IGFyZ21hcC5nZXQoaykgOiBrLCBvcHRba11cbl0pLnJlZHVjZSgoc2V0LCBrdikgPT4gKHNldFtrdlswXV0gPSBrdlsxXSwgc2V0KSwgT2JqZWN0LmNyZWF0ZShudWxsKSkgOiB7fVxuIl0sIm5hbWVzIjpbXSwiaWdub3JlTGlzdCI6WzBdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/swarm-js/node_modules/tar/lib/high-level-opt.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/swarm-js/node_modules/tar/lib/large-numbers.js":
/*!*********************************************************************!*\
  !*** ./node_modules/swarm-js/node_modules/tar/lib/large-numbers.js ***!
  \*********************************************************************/
/***/ ((__unused_webpack_module, exports) => {

"use strict";
eval("\n// Tar can encode large and negative numbers using a leading byte of\n// 0xff for negative, and 0x80 for positive.\n\nconst encode = exports.encode = (num, buf) => {\n  if (!Number.isSafeInteger(num))\n    // The number is so large that javascript cannot represent it with integer\n    // precision.\n    throw TypeError('cannot encode number outside of javascript safe integer range')\n  else if (num < 0)\n    encodeNegative(num, buf)\n  else\n    encodePositive(num, buf)\n  return buf\n}\n\nconst encodePositive = (num, buf) => {\n  buf[0] = 0x80\n\n  for (var i = buf.length; i > 1; i--) {\n    buf[i-1] = num & 0xff\n    num = Math.floor(num / 0x100)\n  }\n}\n\nconst encodeNegative = (num, buf) => {\n  buf[0] = 0xff\n  var flipped = false\n  num = num * -1\n  for (var i = buf.length; i > 1; i--) {\n    var byte = num & 0xff\n    num = Math.floor(num / 0x100)\n    if (flipped)\n      buf[i-1] = onesComp(byte)\n    else if (byte === 0)\n      buf[i-1] = 0\n    else {\n      flipped = true\n      buf[i-1] = twosComp(byte)\n    }\n  }\n}\n\nconst parse = exports.parse = (buf) => {\n  var post = buf[buf.length - 1]\n  var pre = buf[0]\n  var value;\n  if (pre === 0x80)\n    value = pos(buf.slice(1, buf.length))\n  else if (pre === 0xff)\n    value = twos(buf)\n  else\n    throw TypeError('invalid base256 encoding')\n\n  if (!Number.isSafeInteger(value))\n    // The number is so large that javascript cannot represent it with integer\n    // precision.\n    throw TypeError('parsed number outside of javascript safe integer range')\n\n  return value\n}\n\nconst twos = (buf) => {\n  var len = buf.length\n  var sum = 0\n  var flipped = false\n  for (var i = len - 1; i > -1; i--) {\n    var byte = buf[i]\n    var f\n    if (flipped)\n      f = onesComp(byte)\n    else if (byte === 0)\n      f = byte\n    else {\n      flipped = true\n      f = twosComp(byte)\n    }\n    if (f !== 0)\n      sum -= f * Math.pow(256, len - i - 1)\n  }\n  return sum\n}\n\nconst pos = (buf) => {\n  var len = buf.length\n  var sum = 0\n  for (var i = len - 1; i > -1; i--) {\n    var byte = buf[i]\n    if (byte !== 0)\n      sum += byte * Math.pow(256, len - i - 1)\n  }\n  return sum\n}\n\nconst onesComp = byte => (0xff ^ byte) & 0xff\n\nconst twosComp = byte => ((0xff ^ byte) + 1) & 0xff\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvc3dhcm0tanMvbm9kZV9tb2R1bGVzL3Rhci9saWIvbGFyZ2UtbnVtYmVycy5qcyIsIm1hcHBpbmdzIjoiQUFBWTtBQUNaO0FBQ0E7O0FBRUEsZUFBZSxjQUFjO0FBQzdCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUEsMkJBQTJCLE9BQU87QUFDbEM7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSwyQkFBMkIsT0FBTztBQUNsQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUEsY0FBYyxhQUFhO0FBQzNCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esd0JBQXdCLFFBQVE7QUFDaEM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLHdCQUF3QixRQUFRO0FBQ2hDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQSIsInNvdXJjZXMiOlsiL1VzZXJzL3BhbnphL0RvY3VtZW50cy9QZXJzb25hbFByb2plY3RzL3ByZWRpay9ub2RlX21vZHVsZXMvc3dhcm0tanMvbm9kZV9tb2R1bGVzL3Rhci9saWIvbGFyZ2UtbnVtYmVycy5qcyJdLCJzb3VyY2VzQ29udGVudCI6WyIndXNlIHN0cmljdCdcbi8vIFRhciBjYW4gZW5jb2RlIGxhcmdlIGFuZCBuZWdhdGl2ZSBudW1iZXJzIHVzaW5nIGEgbGVhZGluZyBieXRlIG9mXG4vLyAweGZmIGZvciBuZWdhdGl2ZSwgYW5kIDB4ODAgZm9yIHBvc2l0aXZlLlxuXG5jb25zdCBlbmNvZGUgPSBleHBvcnRzLmVuY29kZSA9IChudW0sIGJ1ZikgPT4ge1xuICBpZiAoIU51bWJlci5pc1NhZmVJbnRlZ2VyKG51bSkpXG4gICAgLy8gVGhlIG51bWJlciBpcyBzbyBsYXJnZSB0aGF0IGphdmFzY3JpcHQgY2Fubm90IHJlcHJlc2VudCBpdCB3aXRoIGludGVnZXJcbiAgICAvLyBwcmVjaXNpb24uXG4gICAgdGhyb3cgVHlwZUVycm9yKCdjYW5ub3QgZW5jb2RlIG51bWJlciBvdXRzaWRlIG9mIGphdmFzY3JpcHQgc2FmZSBpbnRlZ2VyIHJhbmdlJylcbiAgZWxzZSBpZiAobnVtIDwgMClcbiAgICBlbmNvZGVOZWdhdGl2ZShudW0sIGJ1ZilcbiAgZWxzZVxuICAgIGVuY29kZVBvc2l0aXZlKG51bSwgYnVmKVxuICByZXR1cm4gYnVmXG59XG5cbmNvbnN0IGVuY29kZVBvc2l0aXZlID0gKG51bSwgYnVmKSA9PiB7XG4gIGJ1ZlswXSA9IDB4ODBcblxuICBmb3IgKHZhciBpID0gYnVmLmxlbmd0aDsgaSA+IDE7IGktLSkge1xuICAgIGJ1ZltpLTFdID0gbnVtICYgMHhmZlxuICAgIG51bSA9IE1hdGguZmxvb3IobnVtIC8gMHgxMDApXG4gIH1cbn1cblxuY29uc3QgZW5jb2RlTmVnYXRpdmUgPSAobnVtLCBidWYpID0+IHtcbiAgYnVmWzBdID0gMHhmZlxuICB2YXIgZmxpcHBlZCA9IGZhbHNlXG4gIG51bSA9IG51bSAqIC0xXG4gIGZvciAodmFyIGkgPSBidWYubGVuZ3RoOyBpID4gMTsgaS0tKSB7XG4gICAgdmFyIGJ5dGUgPSBudW0gJiAweGZmXG4gICAgbnVtID0gTWF0aC5mbG9vcihudW0gLyAweDEwMClcbiAgICBpZiAoZmxpcHBlZClcbiAgICAgIGJ1ZltpLTFdID0gb25lc0NvbXAoYnl0ZSlcbiAgICBlbHNlIGlmIChieXRlID09PSAwKVxuICAgICAgYnVmW2ktMV0gPSAwXG4gICAgZWxzZSB7XG4gICAgICBmbGlwcGVkID0gdHJ1ZVxuICAgICAgYnVmW2ktMV0gPSB0d29zQ29tcChieXRlKVxuICAgIH1cbiAgfVxufVxuXG5jb25zdCBwYXJzZSA9IGV4cG9ydHMucGFyc2UgPSAoYnVmKSA9PiB7XG4gIHZhciBwb3N0ID0gYnVmW2J1Zi5sZW5ndGggLSAxXVxuICB2YXIgcHJlID0gYnVmWzBdXG4gIHZhciB2YWx1ZTtcbiAgaWYgKHByZSA9PT0gMHg4MClcbiAgICB2YWx1ZSA9IHBvcyhidWYuc2xpY2UoMSwgYnVmLmxlbmd0aCkpXG4gIGVsc2UgaWYgKHByZSA9PT0gMHhmZilcbiAgICB2YWx1ZSA9IHR3b3MoYnVmKVxuICBlbHNlXG4gICAgdGhyb3cgVHlwZUVycm9yKCdpbnZhbGlkIGJhc2UyNTYgZW5jb2RpbmcnKVxuXG4gIGlmICghTnVtYmVyLmlzU2FmZUludGVnZXIodmFsdWUpKVxuICAgIC8vIFRoZSBudW1iZXIgaXMgc28gbGFyZ2UgdGhhdCBqYXZhc2NyaXB0IGNhbm5vdCByZXByZXNlbnQgaXQgd2l0aCBpbnRlZ2VyXG4gICAgLy8gcHJlY2lzaW9uLlxuICAgIHRocm93IFR5cGVFcnJvcigncGFyc2VkIG51bWJlciBvdXRzaWRlIG9mIGphdmFzY3JpcHQgc2FmZSBpbnRlZ2VyIHJhbmdlJylcblxuICByZXR1cm4gdmFsdWVcbn1cblxuY29uc3QgdHdvcyA9IChidWYpID0+IHtcbiAgdmFyIGxlbiA9IGJ1Zi5sZW5ndGhcbiAgdmFyIHN1bSA9IDBcbiAgdmFyIGZsaXBwZWQgPSBmYWxzZVxuICBmb3IgKHZhciBpID0gbGVuIC0gMTsgaSA+IC0xOyBpLS0pIHtcbiAgICB2YXIgYnl0ZSA9IGJ1ZltpXVxuICAgIHZhciBmXG4gICAgaWYgKGZsaXBwZWQpXG4gICAgICBmID0gb25lc0NvbXAoYnl0ZSlcbiAgICBlbHNlIGlmIChieXRlID09PSAwKVxuICAgICAgZiA9IGJ5dGVcbiAgICBlbHNlIHtcbiAgICAgIGZsaXBwZWQgPSB0cnVlXG4gICAgICBmID0gdHdvc0NvbXAoYnl0ZSlcbiAgICB9XG4gICAgaWYgKGYgIT09IDApXG4gICAgICBzdW0gLT0gZiAqIE1hdGgucG93KDI1NiwgbGVuIC0gaSAtIDEpXG4gIH1cbiAgcmV0dXJuIHN1bVxufVxuXG5jb25zdCBwb3MgPSAoYnVmKSA9PiB7XG4gIHZhciBsZW4gPSBidWYubGVuZ3RoXG4gIHZhciBzdW0gPSAwXG4gIGZvciAodmFyIGkgPSBsZW4gLSAxOyBpID4gLTE7IGktLSkge1xuICAgIHZhciBieXRlID0gYnVmW2ldXG4gICAgaWYgKGJ5dGUgIT09IDApXG4gICAgICBzdW0gKz0gYnl0ZSAqIE1hdGgucG93KDI1NiwgbGVuIC0gaSAtIDEpXG4gIH1cbiAgcmV0dXJuIHN1bVxufVxuXG5jb25zdCBvbmVzQ29tcCA9IGJ5dGUgPT4gKDB4ZmYgXiBieXRlKSAmIDB4ZmZcblxuY29uc3QgdHdvc0NvbXAgPSBieXRlID0+ICgoMHhmZiBeIGJ5dGUpICsgMSkgJiAweGZmXG4iXSwibmFtZXMiOltdLCJpZ25vcmVMaXN0IjpbMF0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/swarm-js/node_modules/tar/lib/large-numbers.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/swarm-js/node_modules/tar/lib/list.js":
/*!************************************************************!*\
  !*** ./node_modules/swarm-js/node_modules/tar/lib/list.js ***!
  \************************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";
eval("\n\nconst Buffer = __webpack_require__(/*! ./buffer.js */ \"(ssr)/./node_modules/swarm-js/node_modules/tar/lib/buffer.js\")\n\n// XXX: This shares a lot in common with extract.js\n// maybe some DRY opportunity here?\n\n// tar -t\nconst hlo = __webpack_require__(/*! ./high-level-opt.js */ \"(ssr)/./node_modules/swarm-js/node_modules/tar/lib/high-level-opt.js\")\nconst Parser = __webpack_require__(/*! ./parse.js */ \"(ssr)/./node_modules/swarm-js/node_modules/tar/lib/parse.js\")\nconst fs = __webpack_require__(/*! fs */ \"fs\")\nconst fsm = __webpack_require__(/*! fs-minipass */ \"(ssr)/./node_modules/swarm-js/node_modules/fs-minipass/index.js\")\nconst path = __webpack_require__(/*! path */ \"path\")\nconst stripSlash = __webpack_require__(/*! ./strip-trailing-slashes.js */ \"(ssr)/./node_modules/swarm-js/node_modules/tar/lib/strip-trailing-slashes.js\")\n\nconst t = module.exports = (opt_, files, cb) => {\n  if (typeof opt_ === 'function')\n    cb = opt_, files = null, opt_ = {}\n  else if (Array.isArray(opt_))\n    files = opt_, opt_ = {}\n\n  if (typeof files === 'function')\n    cb = files, files = null\n\n  if (!files)\n    files = []\n  else\n    files = Array.from(files)\n\n  const opt = hlo(opt_)\n\n  if (opt.sync && typeof cb === 'function')\n    throw new TypeError('callback not supported for sync tar functions')\n\n  if (!opt.file && typeof cb === 'function')\n    throw new TypeError('callback only supported with file option')\n\n  if (files.length)\n    filesFilter(opt, files)\n\n  if (!opt.noResume)\n    onentryFunction(opt)\n\n  return opt.file && opt.sync ? listFileSync(opt)\n    : opt.file ? listFile(opt, cb)\n    : list(opt)\n}\n\nconst onentryFunction = opt => {\n  const onentry = opt.onentry\n  opt.onentry = onentry ? e => {\n    onentry(e)\n    e.resume()\n  } : e => e.resume()\n}\n\n// construct a filter that limits the file entries listed\n// include child entries if a dir is included\nconst filesFilter = (opt, files) => {\n  const map = new Map(files.map(f => [stripSlash(f), true]))\n  const filter = opt.filter\n\n  const mapHas = (file, r) => {\n    const root = r || path.parse(file).root || '.'\n    const ret = file === root ? false\n      : map.has(file) ? map.get(file)\n      : mapHas(path.dirname(file), root)\n\n    map.set(file, ret)\n    return ret\n  }\n\n  opt.filter = filter\n    ? (file, entry) => filter(file, entry) && mapHas(stripSlash(file))\n    : file => mapHas(stripSlash(file))\n}\n\nconst listFileSync = opt => {\n  const p = list(opt)\n  const file = opt.file\n  let threw = true\n  let fd\n  try {\n    const stat = fs.statSync(file)\n    const readSize = opt.maxReadSize || 16*1024*1024\n    if (stat.size < readSize) {\n      p.end(fs.readFileSync(file))\n    } else {\n      let pos = 0\n      const buf = Buffer.allocUnsafe(readSize)\n      fd = fs.openSync(file, 'r')\n      while (pos < stat.size) {\n        let bytesRead = fs.readSync(fd, buf, 0, readSize, pos)\n        pos += bytesRead\n        p.write(buf.slice(0, bytesRead))\n      }\n      p.end()\n    }\n    threw = false\n  } finally {\n    if (threw && fd)\n      try { fs.closeSync(fd) } catch (er) {}\n  }\n}\n\nconst listFile = (opt, cb) => {\n  const parse = new Parser(opt)\n  const readSize = opt.maxReadSize || 16*1024*1024\n\n  const file = opt.file\n  const p = new Promise((resolve, reject) => {\n    parse.on('error', reject)\n    parse.on('end', resolve)\n\n    fs.stat(file, (er, stat) => {\n      if (er)\n        reject(er)\n      else {\n        const stream = new fsm.ReadStream(file, {\n          readSize: readSize,\n          size: stat.size\n        })\n        stream.on('error', reject)\n        stream.pipe(parse)\n      }\n    })\n  })\n  return cb ? p.then(cb, cb) : p\n}\n\nconst list = opt => new Parser(opt)\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvc3dhcm0tanMvbm9kZV9tb2R1bGVzL3Rhci9saWIvbGlzdC5qcyIsIm1hcHBpbmdzIjoiQUFBWTs7QUFFWixlQUFlLG1CQUFPLENBQUMsaUZBQWE7O0FBRXBDO0FBQ0E7O0FBRUE7QUFDQSxZQUFZLG1CQUFPLENBQUMsaUdBQXFCO0FBQ3pDLGVBQWUsbUJBQU8sQ0FBQywrRUFBWTtBQUNuQyxXQUFXLG1CQUFPLENBQUMsY0FBSTtBQUN2QixZQUFZLG1CQUFPLENBQUMsb0ZBQWE7QUFDakMsYUFBYSxtQkFBTyxDQUFDLGtCQUFNO0FBQzNCLG1CQUFtQixtQkFBTyxDQUFDLGlIQUE2Qjs7QUFFeEQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLElBQUk7QUFDSjs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxJQUFJO0FBQ0o7QUFDQSxZQUFZLG1CQUFtQjtBQUMvQjtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0wsR0FBRztBQUNIO0FBQ0E7O0FBRUEiLCJzb3VyY2VzIjpbIi9Vc2Vycy9wYW56YS9Eb2N1bWVudHMvUGVyc29uYWxQcm9qZWN0cy9wcmVkaWsvbm9kZV9tb2R1bGVzL3N3YXJtLWpzL25vZGVfbW9kdWxlcy90YXIvbGliL2xpc3QuanMiXSwic291cmNlc0NvbnRlbnQiOlsiJ3VzZSBzdHJpY3QnXG5cbmNvbnN0IEJ1ZmZlciA9IHJlcXVpcmUoJy4vYnVmZmVyLmpzJylcblxuLy8gWFhYOiBUaGlzIHNoYXJlcyBhIGxvdCBpbiBjb21tb24gd2l0aCBleHRyYWN0LmpzXG4vLyBtYXliZSBzb21lIERSWSBvcHBvcnR1bml0eSBoZXJlP1xuXG4vLyB0YXIgLXRcbmNvbnN0IGhsbyA9IHJlcXVpcmUoJy4vaGlnaC1sZXZlbC1vcHQuanMnKVxuY29uc3QgUGFyc2VyID0gcmVxdWlyZSgnLi9wYXJzZS5qcycpXG5jb25zdCBmcyA9IHJlcXVpcmUoJ2ZzJylcbmNvbnN0IGZzbSA9IHJlcXVpcmUoJ2ZzLW1pbmlwYXNzJylcbmNvbnN0IHBhdGggPSByZXF1aXJlKCdwYXRoJylcbmNvbnN0IHN0cmlwU2xhc2ggPSByZXF1aXJlKCcuL3N0cmlwLXRyYWlsaW5nLXNsYXNoZXMuanMnKVxuXG5jb25zdCB0ID0gbW9kdWxlLmV4cG9ydHMgPSAob3B0XywgZmlsZXMsIGNiKSA9PiB7XG4gIGlmICh0eXBlb2Ygb3B0XyA9PT0gJ2Z1bmN0aW9uJylcbiAgICBjYiA9IG9wdF8sIGZpbGVzID0gbnVsbCwgb3B0XyA9IHt9XG4gIGVsc2UgaWYgKEFycmF5LmlzQXJyYXkob3B0XykpXG4gICAgZmlsZXMgPSBvcHRfLCBvcHRfID0ge31cblxuICBpZiAodHlwZW9mIGZpbGVzID09PSAnZnVuY3Rpb24nKVxuICAgIGNiID0gZmlsZXMsIGZpbGVzID0gbnVsbFxuXG4gIGlmICghZmlsZXMpXG4gICAgZmlsZXMgPSBbXVxuICBlbHNlXG4gICAgZmlsZXMgPSBBcnJheS5mcm9tKGZpbGVzKVxuXG4gIGNvbnN0IG9wdCA9IGhsbyhvcHRfKVxuXG4gIGlmIChvcHQuc3luYyAmJiB0eXBlb2YgY2IgPT09ICdmdW5jdGlvbicpXG4gICAgdGhyb3cgbmV3IFR5cGVFcnJvcignY2FsbGJhY2sgbm90IHN1cHBvcnRlZCBmb3Igc3luYyB0YXIgZnVuY3Rpb25zJylcblxuICBpZiAoIW9wdC5maWxlICYmIHR5cGVvZiBjYiA9PT0gJ2Z1bmN0aW9uJylcbiAgICB0aHJvdyBuZXcgVHlwZUVycm9yKCdjYWxsYmFjayBvbmx5IHN1cHBvcnRlZCB3aXRoIGZpbGUgb3B0aW9uJylcblxuICBpZiAoZmlsZXMubGVuZ3RoKVxuICAgIGZpbGVzRmlsdGVyKG9wdCwgZmlsZXMpXG5cbiAgaWYgKCFvcHQubm9SZXN1bWUpXG4gICAgb25lbnRyeUZ1bmN0aW9uKG9wdClcblxuICByZXR1cm4gb3B0LmZpbGUgJiYgb3B0LnN5bmMgPyBsaXN0RmlsZVN5bmMob3B0KVxuICAgIDogb3B0LmZpbGUgPyBsaXN0RmlsZShvcHQsIGNiKVxuICAgIDogbGlzdChvcHQpXG59XG5cbmNvbnN0IG9uZW50cnlGdW5jdGlvbiA9IG9wdCA9PiB7XG4gIGNvbnN0IG9uZW50cnkgPSBvcHQub25lbnRyeVxuICBvcHQub25lbnRyeSA9IG9uZW50cnkgPyBlID0+IHtcbiAgICBvbmVudHJ5KGUpXG4gICAgZS5yZXN1bWUoKVxuICB9IDogZSA9PiBlLnJlc3VtZSgpXG59XG5cbi8vIGNvbnN0cnVjdCBhIGZpbHRlciB0aGF0IGxpbWl0cyB0aGUgZmlsZSBlbnRyaWVzIGxpc3RlZFxuLy8gaW5jbHVkZSBjaGlsZCBlbnRyaWVzIGlmIGEgZGlyIGlzIGluY2x1ZGVkXG5jb25zdCBmaWxlc0ZpbHRlciA9IChvcHQsIGZpbGVzKSA9PiB7XG4gIGNvbnN0IG1hcCA9IG5ldyBNYXAoZmlsZXMubWFwKGYgPT4gW3N0cmlwU2xhc2goZiksIHRydWVdKSlcbiAgY29uc3QgZmlsdGVyID0gb3B0LmZpbHRlclxuXG4gIGNvbnN0IG1hcEhhcyA9IChmaWxlLCByKSA9PiB7XG4gICAgY29uc3Qgcm9vdCA9IHIgfHwgcGF0aC5wYXJzZShmaWxlKS5yb290IHx8ICcuJ1xuICAgIGNvbnN0IHJldCA9IGZpbGUgPT09IHJvb3QgPyBmYWxzZVxuICAgICAgOiBtYXAuaGFzKGZpbGUpID8gbWFwLmdldChmaWxlKVxuICAgICAgOiBtYXBIYXMocGF0aC5kaXJuYW1lKGZpbGUpLCByb290KVxuXG4gICAgbWFwLnNldChmaWxlLCByZXQpXG4gICAgcmV0dXJuIHJldFxuICB9XG5cbiAgb3B0LmZpbHRlciA9IGZpbHRlclxuICAgID8gKGZpbGUsIGVudHJ5KSA9PiBmaWx0ZXIoZmlsZSwgZW50cnkpICYmIG1hcEhhcyhzdHJpcFNsYXNoKGZpbGUpKVxuICAgIDogZmlsZSA9PiBtYXBIYXMoc3RyaXBTbGFzaChmaWxlKSlcbn1cblxuY29uc3QgbGlzdEZpbGVTeW5jID0gb3B0ID0+IHtcbiAgY29uc3QgcCA9IGxpc3Qob3B0KVxuICBjb25zdCBmaWxlID0gb3B0LmZpbGVcbiAgbGV0IHRocmV3ID0gdHJ1ZVxuICBsZXQgZmRcbiAgdHJ5IHtcbiAgICBjb25zdCBzdGF0ID0gZnMuc3RhdFN5bmMoZmlsZSlcbiAgICBjb25zdCByZWFkU2l6ZSA9IG9wdC5tYXhSZWFkU2l6ZSB8fCAxNioxMDI0KjEwMjRcbiAgICBpZiAoc3RhdC5zaXplIDwgcmVhZFNpemUpIHtcbiAgICAgIHAuZW5kKGZzLnJlYWRGaWxlU3luYyhmaWxlKSlcbiAgICB9IGVsc2Uge1xuICAgICAgbGV0IHBvcyA9IDBcbiAgICAgIGNvbnN0IGJ1ZiA9IEJ1ZmZlci5hbGxvY1Vuc2FmZShyZWFkU2l6ZSlcbiAgICAgIGZkID0gZnMub3BlblN5bmMoZmlsZSwgJ3InKVxuICAgICAgd2hpbGUgKHBvcyA8IHN0YXQuc2l6ZSkge1xuICAgICAgICBsZXQgYnl0ZXNSZWFkID0gZnMucmVhZFN5bmMoZmQsIGJ1ZiwgMCwgcmVhZFNpemUsIHBvcylcbiAgICAgICAgcG9zICs9IGJ5dGVzUmVhZFxuICAgICAgICBwLndyaXRlKGJ1Zi5zbGljZSgwLCBieXRlc1JlYWQpKVxuICAgICAgfVxuICAgICAgcC5lbmQoKVxuICAgIH1cbiAgICB0aHJldyA9IGZhbHNlXG4gIH0gZmluYWxseSB7XG4gICAgaWYgKHRocmV3ICYmIGZkKVxuICAgICAgdHJ5IHsgZnMuY2xvc2VTeW5jKGZkKSB9IGNhdGNoIChlcikge31cbiAgfVxufVxuXG5jb25zdCBsaXN0RmlsZSA9IChvcHQsIGNiKSA9PiB7XG4gIGNvbnN0IHBhcnNlID0gbmV3IFBhcnNlcihvcHQpXG4gIGNvbnN0IHJlYWRTaXplID0gb3B0Lm1heFJlYWRTaXplIHx8IDE2KjEwMjQqMTAyNFxuXG4gIGNvbnN0IGZpbGUgPSBvcHQuZmlsZVxuICBjb25zdCBwID0gbmV3IFByb21pc2UoKHJlc29sdmUsIHJlamVjdCkgPT4ge1xuICAgIHBhcnNlLm9uKCdlcnJvcicsIHJlamVjdClcbiAgICBwYXJzZS5vbignZW5kJywgcmVzb2x2ZSlcblxuICAgIGZzLnN0YXQoZmlsZSwgKGVyLCBzdGF0KSA9PiB7XG4gICAgICBpZiAoZXIpXG4gICAgICAgIHJlamVjdChlcilcbiAgICAgIGVsc2Uge1xuICAgICAgICBjb25zdCBzdHJlYW0gPSBuZXcgZnNtLlJlYWRTdHJlYW0oZmlsZSwge1xuICAgICAgICAgIHJlYWRTaXplOiByZWFkU2l6ZSxcbiAgICAgICAgICBzaXplOiBzdGF0LnNpemVcbiAgICAgICAgfSlcbiAgICAgICAgc3RyZWFtLm9uKCdlcnJvcicsIHJlamVjdClcbiAgICAgICAgc3RyZWFtLnBpcGUocGFyc2UpXG4gICAgICB9XG4gICAgfSlcbiAgfSlcbiAgcmV0dXJuIGNiID8gcC50aGVuKGNiLCBjYikgOiBwXG59XG5cbmNvbnN0IGxpc3QgPSBvcHQgPT4gbmV3IFBhcnNlcihvcHQpXG4iXSwibmFtZXMiOltdLCJpZ25vcmVMaXN0IjpbMF0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/swarm-js/node_modules/tar/lib/list.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/swarm-js/node_modules/tar/lib/mkdir.js":
/*!*************************************************************!*\
  !*** ./node_modules/swarm-js/node_modules/tar/lib/mkdir.js ***!
  \*************************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";
eval("\n// wrapper around mkdirp for tar's needs.\n\n// TODO: This should probably be a class, not functionally\n// passing around state in a gazillion args.\n\nconst mkdirp = __webpack_require__(/*! mkdirp */ \"(ssr)/./node_modules/mkdirp/index.js\")\nconst fs = __webpack_require__(/*! fs */ \"fs\")\nconst path = __webpack_require__(/*! path */ \"path\")\nconst chownr = __webpack_require__(/*! chownr */ \"(ssr)/./node_modules/swarm-js/node_modules/chownr/chownr.js\")\nconst normPath = __webpack_require__(/*! ./normalize-windows-path.js */ \"(ssr)/./node_modules/swarm-js/node_modules/tar/lib/normalize-windows-path.js\")\n\nclass SymlinkError extends Error {\n  constructor (symlink, path) {\n    super('Cannot extract through symbolic link')\n    this.path = path\n    this.symlink = symlink\n  }\n\n  get name () {\n    return 'SylinkError'\n  }\n}\n\nclass CwdError extends Error {\n  constructor (path, code) {\n    super(code + ': Cannot cd into \\'' + path + '\\'')\n    this.path = path\n    this.code = code\n  }\n\n  get name () {\n    return 'CwdError'\n  }\n}\n\nconst cGet = (cache, key) => cache.get(normPath(key))\nconst cSet = (cache, key, val) => cache.set(normPath(key), val)\n\nconst checkCwd = (dir, cb) => {\n  fs.stat(dir, (er, st) => {\n    if (er || !st.isDirectory())\n      er = new CwdError(dir, er && er.code || 'ENOTDIR')\n    cb(er)\n  })\n}\n\nmodule.exports = (dir, opt, cb) => {\n  dir = normPath(dir)\n\n  // if there's any overlap between mask and mode,\n  // then we'll need an explicit chmod\n  const umask = opt.umask\n  const mode = opt.mode | 0o0700\n  const needChmod = (mode & umask) !== 0\n\n  const uid = opt.uid\n  const gid = opt.gid\n  const doChown = typeof uid === 'number' &&\n    typeof gid === 'number' &&\n    ( uid !== opt.processUid || gid !== opt.processGid )\n\n  const preserve = opt.preserve\n  const unlink = opt.unlink\n  const cache = opt.cache\n  const cwd = normPath(opt.cwd)\n\n  const done = (er, created) => {\n    if (er)\n      cb(er)\n    else {\n      cSet(cache, dir, true)\n      if (created && doChown)\n        chownr(created, uid, gid, er => done(er))\n      else if (needChmod)\n        fs.chmod(dir, mode, cb)\n      else\n        cb()\n    }\n  }\n\n  if (cache && cGet(cache, dir) === true)\n    return done()\n\n  if (dir === cwd)\n    return checkCwd(dir, done)\n\n  if (preserve)\n    return mkdirp(dir, mode, done)\n\n  const sub = normPath(path.relative(cwd, dir))\n  const parts = sub.split('/')\n  mkdir_(cwd, parts, mode, cache, unlink, cwd, null, done)\n}\n\nconst mkdir_ = (base, parts, mode, cache, unlink, cwd, created, cb) => {\n  if (!parts.length)\n    return cb(null, created)\n  const p = parts.shift()\n  const part = normPath(path.resolve(base + '/' + p))\n  if (cGet(cache, part))\n    return mkdir_(part, parts, mode, cache, unlink, cwd, created, cb)\n  fs.mkdir(part, mode, onmkdir(part, parts, mode, cache, unlink, cwd, created, cb))\n}\n\nconst onmkdir = (part, parts, mode, cache, unlink, cwd, created, cb) => er => {\n  if (er) {\n    fs.lstat(part, (statEr, st) => {\n      if (statEr) {\n        statEr.path = statEr.path && normPath(statEr.path)\n        cb(statEr)\n      } else if (st.isDirectory())\n        mkdir_(part, parts, mode, cache, unlink, cwd, created, cb)\n      else if (unlink)\n        fs.unlink(part, er => {\n          if (er)\n            return cb(er)\n          fs.mkdir(part, mode, onmkdir(part, parts, mode, cache, unlink, cwd, created, cb))\n        })\n      else if (st.isSymbolicLink())\n        return cb(new SymlinkError(part, part + '/' + parts.join('/')))\n      else\n        cb(er)\n    })\n  } else {\n    created = created || part\n    mkdir_(part, parts, mode, cache, unlink, cwd, created, cb)\n  }\n}\n\nconst checkCwdSync = dir => {\n  let ok = false\n  let code = 'ENOTDIR'\n  try {\n    ok = fs.statSync(dir).isDirectory()\n  } catch (er) {\n    code = er.code\n  } finally {\n    if (!ok)\n      throw new CwdError(dir, code)\n  }\n}\n\nmodule.exports.sync = (dir, opt) => {\n  dir = normPath(dir)\n  // if there's any overlap between mask and mode,\n  // then we'll need an explicit chmod\n  const umask = opt.umask\n  const mode = opt.mode | 0o0700\n  const needChmod = (mode & umask) !== 0\n\n  const uid = opt.uid\n  const gid = opt.gid\n  const doChown = typeof uid === 'number' &&\n    typeof gid === 'number' &&\n    ( uid !== opt.processUid || gid !== opt.processGid )\n\n  const preserve = opt.preserve\n  const unlink = opt.unlink\n  const cache = opt.cache\n  const cwd = normPath(opt.cwd)\n\n  const done = (created) => {\n    cSet(cache, dir, true)\n    if (created && doChown)\n      chownr.sync(created, uid, gid)\n    if (needChmod)\n      fs.chmodSync(dir, mode)\n  }\n\n  if (cache && cGet(cache, dir) === true)\n    return done()\n\n  if (dir === cwd) {\n    checkCwdSync(cwd)\n    return done()\n  }\n\n  if (preserve)\n    return done(mkdirp.sync(dir, mode))\n\n  const sub = normPath(path.relative(cwd, dir))\n  const parts = sub.split('/')\n  let created = null\n  for (let p = parts.shift(), part = cwd;\n    p && (part += '/' + p);\n    p = parts.shift()) {\n    part = normPath(path.resolve(part))\n    if (cGet(cache, part))\n      continue\n\n    try {\n      fs.mkdirSync(part, mode)\n      created = created || part\n      cSet(cache, part, true)\n    } catch (er) {\n      const st = fs.lstatSync(part)\n      if (st.isDirectory()) {\n        cSet(cache, part, true)\n        continue\n      } else if (unlink) {\n        fs.unlinkSync(part)\n        fs.mkdirSync(part, mode)\n        created = created || part\n        cSet(cache, part, true)\n        continue\n      } else if (st.isSymbolicLink())\n        return new SymlinkError(part, part + '/' + parts.join('/'))\n    }\n  }\n\n  return done(created)\n}\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvc3dhcm0tanMvbm9kZV9tb2R1bGVzL3Rhci9saWIvbWtkaXIuanMiLCJtYXBwaW5ncyI6IkFBQVk7QUFDWjs7QUFFQTtBQUNBOztBQUVBLGVBQWUsbUJBQU8sQ0FBQyxvREFBUTtBQUMvQixXQUFXLG1CQUFPLENBQUMsY0FBSTtBQUN2QixhQUFhLG1CQUFPLENBQUMsa0JBQU07QUFDM0IsZUFBZSxtQkFBTyxDQUFDLDJFQUFRO0FBQy9CLGlCQUFpQixtQkFBTyxDQUFDLGlIQUE2Qjs7QUFFdEQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFFBQVE7QUFDUjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0wsSUFBSTtBQUNKO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxJQUFJO0FBQ0o7QUFDQSxJQUFJO0FBQ0o7QUFDQTtBQUNBO0FBQ0E7O0FBRUEsbUJBQW1CO0FBQ25CO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0E7QUFDQSxRQUFRO0FBQ1I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFFBQVE7QUFDUjtBQUNBO0FBQ0E7O0FBRUE7QUFDQSIsInNvdXJjZXMiOlsiL1VzZXJzL3BhbnphL0RvY3VtZW50cy9QZXJzb25hbFByb2plY3RzL3ByZWRpay9ub2RlX21vZHVsZXMvc3dhcm0tanMvbm9kZV9tb2R1bGVzL3Rhci9saWIvbWtkaXIuanMiXSwic291cmNlc0NvbnRlbnQiOlsiJ3VzZSBzdHJpY3QnXG4vLyB3cmFwcGVyIGFyb3VuZCBta2RpcnAgZm9yIHRhcidzIG5lZWRzLlxuXG4vLyBUT0RPOiBUaGlzIHNob3VsZCBwcm9iYWJseSBiZSBhIGNsYXNzLCBub3QgZnVuY3Rpb25hbGx5XG4vLyBwYXNzaW5nIGFyb3VuZCBzdGF0ZSBpbiBhIGdhemlsbGlvbiBhcmdzLlxuXG5jb25zdCBta2RpcnAgPSByZXF1aXJlKCdta2RpcnAnKVxuY29uc3QgZnMgPSByZXF1aXJlKCdmcycpXG5jb25zdCBwYXRoID0gcmVxdWlyZSgncGF0aCcpXG5jb25zdCBjaG93bnIgPSByZXF1aXJlKCdjaG93bnInKVxuY29uc3Qgbm9ybVBhdGggPSByZXF1aXJlKCcuL25vcm1hbGl6ZS13aW5kb3dzLXBhdGguanMnKVxuXG5jbGFzcyBTeW1saW5rRXJyb3IgZXh0ZW5kcyBFcnJvciB7XG4gIGNvbnN0cnVjdG9yIChzeW1saW5rLCBwYXRoKSB7XG4gICAgc3VwZXIoJ0Nhbm5vdCBleHRyYWN0IHRocm91Z2ggc3ltYm9saWMgbGluaycpXG4gICAgdGhpcy5wYXRoID0gcGF0aFxuICAgIHRoaXMuc3ltbGluayA9IHN5bWxpbmtcbiAgfVxuXG4gIGdldCBuYW1lICgpIHtcbiAgICByZXR1cm4gJ1N5bGlua0Vycm9yJ1xuICB9XG59XG5cbmNsYXNzIEN3ZEVycm9yIGV4dGVuZHMgRXJyb3Ige1xuICBjb25zdHJ1Y3RvciAocGF0aCwgY29kZSkge1xuICAgIHN1cGVyKGNvZGUgKyAnOiBDYW5ub3QgY2QgaW50byBcXCcnICsgcGF0aCArICdcXCcnKVxuICAgIHRoaXMucGF0aCA9IHBhdGhcbiAgICB0aGlzLmNvZGUgPSBjb2RlXG4gIH1cblxuICBnZXQgbmFtZSAoKSB7XG4gICAgcmV0dXJuICdDd2RFcnJvcidcbiAgfVxufVxuXG5jb25zdCBjR2V0ID0gKGNhY2hlLCBrZXkpID0+IGNhY2hlLmdldChub3JtUGF0aChrZXkpKVxuY29uc3QgY1NldCA9IChjYWNoZSwga2V5LCB2YWwpID0+IGNhY2hlLnNldChub3JtUGF0aChrZXkpLCB2YWwpXG5cbmNvbnN0IGNoZWNrQ3dkID0gKGRpciwgY2IpID0+IHtcbiAgZnMuc3RhdChkaXIsIChlciwgc3QpID0+IHtcbiAgICBpZiAoZXIgfHwgIXN0LmlzRGlyZWN0b3J5KCkpXG4gICAgICBlciA9IG5ldyBDd2RFcnJvcihkaXIsIGVyICYmIGVyLmNvZGUgfHwgJ0VOT1RESVInKVxuICAgIGNiKGVyKVxuICB9KVxufVxuXG5tb2R1bGUuZXhwb3J0cyA9IChkaXIsIG9wdCwgY2IpID0+IHtcbiAgZGlyID0gbm9ybVBhdGgoZGlyKVxuXG4gIC8vIGlmIHRoZXJlJ3MgYW55IG92ZXJsYXAgYmV0d2VlbiBtYXNrIGFuZCBtb2RlLFxuICAvLyB0aGVuIHdlJ2xsIG5lZWQgYW4gZXhwbGljaXQgY2htb2RcbiAgY29uc3QgdW1hc2sgPSBvcHQudW1hc2tcbiAgY29uc3QgbW9kZSA9IG9wdC5tb2RlIHwgMG8wNzAwXG4gIGNvbnN0IG5lZWRDaG1vZCA9IChtb2RlICYgdW1hc2spICE9PSAwXG5cbiAgY29uc3QgdWlkID0gb3B0LnVpZFxuICBjb25zdCBnaWQgPSBvcHQuZ2lkXG4gIGNvbnN0IGRvQ2hvd24gPSB0eXBlb2YgdWlkID09PSAnbnVtYmVyJyAmJlxuICAgIHR5cGVvZiBnaWQgPT09ICdudW1iZXInICYmXG4gICAgKCB1aWQgIT09IG9wdC5wcm9jZXNzVWlkIHx8IGdpZCAhPT0gb3B0LnByb2Nlc3NHaWQgKVxuXG4gIGNvbnN0IHByZXNlcnZlID0gb3B0LnByZXNlcnZlXG4gIGNvbnN0IHVubGluayA9IG9wdC51bmxpbmtcbiAgY29uc3QgY2FjaGUgPSBvcHQuY2FjaGVcbiAgY29uc3QgY3dkID0gbm9ybVBhdGgob3B0LmN3ZClcblxuICBjb25zdCBkb25lID0gKGVyLCBjcmVhdGVkKSA9PiB7XG4gICAgaWYgKGVyKVxuICAgICAgY2IoZXIpXG4gICAgZWxzZSB7XG4gICAgICBjU2V0KGNhY2hlLCBkaXIsIHRydWUpXG4gICAgICBpZiAoY3JlYXRlZCAmJiBkb0Nob3duKVxuICAgICAgICBjaG93bnIoY3JlYXRlZCwgdWlkLCBnaWQsIGVyID0+IGRvbmUoZXIpKVxuICAgICAgZWxzZSBpZiAobmVlZENobW9kKVxuICAgICAgICBmcy5jaG1vZChkaXIsIG1vZGUsIGNiKVxuICAgICAgZWxzZVxuICAgICAgICBjYigpXG4gICAgfVxuICB9XG5cbiAgaWYgKGNhY2hlICYmIGNHZXQoY2FjaGUsIGRpcikgPT09IHRydWUpXG4gICAgcmV0dXJuIGRvbmUoKVxuXG4gIGlmIChkaXIgPT09IGN3ZClcbiAgICByZXR1cm4gY2hlY2tDd2QoZGlyLCBkb25lKVxuXG4gIGlmIChwcmVzZXJ2ZSlcbiAgICByZXR1cm4gbWtkaXJwKGRpciwgbW9kZSwgZG9uZSlcblxuICBjb25zdCBzdWIgPSBub3JtUGF0aChwYXRoLnJlbGF0aXZlKGN3ZCwgZGlyKSlcbiAgY29uc3QgcGFydHMgPSBzdWIuc3BsaXQoJy8nKVxuICBta2Rpcl8oY3dkLCBwYXJ0cywgbW9kZSwgY2FjaGUsIHVubGluaywgY3dkLCBudWxsLCBkb25lKVxufVxuXG5jb25zdCBta2Rpcl8gPSAoYmFzZSwgcGFydHMsIG1vZGUsIGNhY2hlLCB1bmxpbmssIGN3ZCwgY3JlYXRlZCwgY2IpID0+IHtcbiAgaWYgKCFwYXJ0cy5sZW5ndGgpXG4gICAgcmV0dXJuIGNiKG51bGwsIGNyZWF0ZWQpXG4gIGNvbnN0IHAgPSBwYXJ0cy5zaGlmdCgpXG4gIGNvbnN0IHBhcnQgPSBub3JtUGF0aChwYXRoLnJlc29sdmUoYmFzZSArICcvJyArIHApKVxuICBpZiAoY0dldChjYWNoZSwgcGFydCkpXG4gICAgcmV0dXJuIG1rZGlyXyhwYXJ0LCBwYXJ0cywgbW9kZSwgY2FjaGUsIHVubGluaywgY3dkLCBjcmVhdGVkLCBjYilcbiAgZnMubWtkaXIocGFydCwgbW9kZSwgb25ta2RpcihwYXJ0LCBwYXJ0cywgbW9kZSwgY2FjaGUsIHVubGluaywgY3dkLCBjcmVhdGVkLCBjYikpXG59XG5cbmNvbnN0IG9ubWtkaXIgPSAocGFydCwgcGFydHMsIG1vZGUsIGNhY2hlLCB1bmxpbmssIGN3ZCwgY3JlYXRlZCwgY2IpID0+IGVyID0+IHtcbiAgaWYgKGVyKSB7XG4gICAgZnMubHN0YXQocGFydCwgKHN0YXRFciwgc3QpID0+IHtcbiAgICAgIGlmIChzdGF0RXIpIHtcbiAgICAgICAgc3RhdEVyLnBhdGggPSBzdGF0RXIucGF0aCAmJiBub3JtUGF0aChzdGF0RXIucGF0aClcbiAgICAgICAgY2Ioc3RhdEVyKVxuICAgICAgfSBlbHNlIGlmIChzdC5pc0RpcmVjdG9yeSgpKVxuICAgICAgICBta2Rpcl8ocGFydCwgcGFydHMsIG1vZGUsIGNhY2hlLCB1bmxpbmssIGN3ZCwgY3JlYXRlZCwgY2IpXG4gICAgICBlbHNlIGlmICh1bmxpbmspXG4gICAgICAgIGZzLnVubGluayhwYXJ0LCBlciA9PiB7XG4gICAgICAgICAgaWYgKGVyKVxuICAgICAgICAgICAgcmV0dXJuIGNiKGVyKVxuICAgICAgICAgIGZzLm1rZGlyKHBhcnQsIG1vZGUsIG9ubWtkaXIocGFydCwgcGFydHMsIG1vZGUsIGNhY2hlLCB1bmxpbmssIGN3ZCwgY3JlYXRlZCwgY2IpKVxuICAgICAgICB9KVxuICAgICAgZWxzZSBpZiAoc3QuaXNTeW1ib2xpY0xpbmsoKSlcbiAgICAgICAgcmV0dXJuIGNiKG5ldyBTeW1saW5rRXJyb3IocGFydCwgcGFydCArICcvJyArIHBhcnRzLmpvaW4oJy8nKSkpXG4gICAgICBlbHNlXG4gICAgICAgIGNiKGVyKVxuICAgIH0pXG4gIH0gZWxzZSB7XG4gICAgY3JlYXRlZCA9IGNyZWF0ZWQgfHwgcGFydFxuICAgIG1rZGlyXyhwYXJ0LCBwYXJ0cywgbW9kZSwgY2FjaGUsIHVubGluaywgY3dkLCBjcmVhdGVkLCBjYilcbiAgfVxufVxuXG5jb25zdCBjaGVja0N3ZFN5bmMgPSBkaXIgPT4ge1xuICBsZXQgb2sgPSBmYWxzZVxuICBsZXQgY29kZSA9ICdFTk9URElSJ1xuICB0cnkge1xuICAgIG9rID0gZnMuc3RhdFN5bmMoZGlyKS5pc0RpcmVjdG9yeSgpXG4gIH0gY2F0Y2ggKGVyKSB7XG4gICAgY29kZSA9IGVyLmNvZGVcbiAgfSBmaW5hbGx5IHtcbiAgICBpZiAoIW9rKVxuICAgICAgdGhyb3cgbmV3IEN3ZEVycm9yKGRpciwgY29kZSlcbiAgfVxufVxuXG5tb2R1bGUuZXhwb3J0cy5zeW5jID0gKGRpciwgb3B0KSA9PiB7XG4gIGRpciA9IG5vcm1QYXRoKGRpcilcbiAgLy8gaWYgdGhlcmUncyBhbnkgb3ZlcmxhcCBiZXR3ZWVuIG1hc2sgYW5kIG1vZGUsXG4gIC8vIHRoZW4gd2UnbGwgbmVlZCBhbiBleHBsaWNpdCBjaG1vZFxuICBjb25zdCB1bWFzayA9IG9wdC51bWFza1xuICBjb25zdCBtb2RlID0gb3B0Lm1vZGUgfCAwbzA3MDBcbiAgY29uc3QgbmVlZENobW9kID0gKG1vZGUgJiB1bWFzaykgIT09IDBcblxuICBjb25zdCB1aWQgPSBvcHQudWlkXG4gIGNvbnN0IGdpZCA9IG9wdC5naWRcbiAgY29uc3QgZG9DaG93biA9IHR5cGVvZiB1aWQgPT09ICdudW1iZXInICYmXG4gICAgdHlwZW9mIGdpZCA9PT0gJ251bWJlcicgJiZcbiAgICAoIHVpZCAhPT0gb3B0LnByb2Nlc3NVaWQgfHwgZ2lkICE9PSBvcHQucHJvY2Vzc0dpZCApXG5cbiAgY29uc3QgcHJlc2VydmUgPSBvcHQucHJlc2VydmVcbiAgY29uc3QgdW5saW5rID0gb3B0LnVubGlua1xuICBjb25zdCBjYWNoZSA9IG9wdC5jYWNoZVxuICBjb25zdCBjd2QgPSBub3JtUGF0aChvcHQuY3dkKVxuXG4gIGNvbnN0IGRvbmUgPSAoY3JlYXRlZCkgPT4ge1xuICAgIGNTZXQoY2FjaGUsIGRpciwgdHJ1ZSlcbiAgICBpZiAoY3JlYXRlZCAmJiBkb0Nob3duKVxuICAgICAgY2hvd25yLnN5bmMoY3JlYXRlZCwgdWlkLCBnaWQpXG4gICAgaWYgKG5lZWRDaG1vZClcbiAgICAgIGZzLmNobW9kU3luYyhkaXIsIG1vZGUpXG4gIH1cblxuICBpZiAoY2FjaGUgJiYgY0dldChjYWNoZSwgZGlyKSA9PT0gdHJ1ZSlcbiAgICByZXR1cm4gZG9uZSgpXG5cbiAgaWYgKGRpciA9PT0gY3dkKSB7XG4gICAgY2hlY2tDd2RTeW5jKGN3ZClcbiAgICByZXR1cm4gZG9uZSgpXG4gIH1cblxuICBpZiAocHJlc2VydmUpXG4gICAgcmV0dXJuIGRvbmUobWtkaXJwLnN5bmMoZGlyLCBtb2RlKSlcblxuICBjb25zdCBzdWIgPSBub3JtUGF0aChwYXRoLnJlbGF0aXZlKGN3ZCwgZGlyKSlcbiAgY29uc3QgcGFydHMgPSBzdWIuc3BsaXQoJy8nKVxuICBsZXQgY3JlYXRlZCA9IG51bGxcbiAgZm9yIChsZXQgcCA9IHBhcnRzLnNoaWZ0KCksIHBhcnQgPSBjd2Q7XG4gICAgcCAmJiAocGFydCArPSAnLycgKyBwKTtcbiAgICBwID0gcGFydHMuc2hpZnQoKSkge1xuICAgIHBhcnQgPSBub3JtUGF0aChwYXRoLnJlc29sdmUocGFydCkpXG4gICAgaWYgKGNHZXQoY2FjaGUsIHBhcnQpKVxuICAgICAgY29udGludWVcblxuICAgIHRyeSB7XG4gICAgICBmcy5ta2RpclN5bmMocGFydCwgbW9kZSlcbiAgICAgIGNyZWF0ZWQgPSBjcmVhdGVkIHx8IHBhcnRcbiAgICAgIGNTZXQoY2FjaGUsIHBhcnQsIHRydWUpXG4gICAgfSBjYXRjaCAoZXIpIHtcbiAgICAgIGNvbnN0IHN0ID0gZnMubHN0YXRTeW5jKHBhcnQpXG4gICAgICBpZiAoc3QuaXNEaXJlY3RvcnkoKSkge1xuICAgICAgICBjU2V0KGNhY2hlLCBwYXJ0LCB0cnVlKVxuICAgICAgICBjb250aW51ZVxuICAgICAgfSBlbHNlIGlmICh1bmxpbmspIHtcbiAgICAgICAgZnMudW5saW5rU3luYyhwYXJ0KVxuICAgICAgICBmcy5ta2RpclN5bmMocGFydCwgbW9kZSlcbiAgICAgICAgY3JlYXRlZCA9IGNyZWF0ZWQgfHwgcGFydFxuICAgICAgICBjU2V0KGNhY2hlLCBwYXJ0LCB0cnVlKVxuICAgICAgICBjb250aW51ZVxuICAgICAgfSBlbHNlIGlmIChzdC5pc1N5bWJvbGljTGluaygpKVxuICAgICAgICByZXR1cm4gbmV3IFN5bWxpbmtFcnJvcihwYXJ0LCBwYXJ0ICsgJy8nICsgcGFydHMuam9pbignLycpKVxuICAgIH1cbiAgfVxuXG4gIHJldHVybiBkb25lKGNyZWF0ZWQpXG59XG4iXSwibmFtZXMiOltdLCJpZ25vcmVMaXN0IjpbMF0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/swarm-js/node_modules/tar/lib/mkdir.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/swarm-js/node_modules/tar/lib/mode-fix.js":
/*!****************************************************************!*\
  !*** ./node_modules/swarm-js/node_modules/tar/lib/mode-fix.js ***!
  \****************************************************************/
/***/ ((module) => {

"use strict";
eval("\nmodule.exports = (mode, isDir) => {\n  mode &= 0o7777\n  // if dirs are readable, then they should be listable\n  if (isDir) {\n    if (mode & 0o400)\n      mode |= 0o100\n    if (mode & 0o40)\n      mode |= 0o10\n    if (mode & 0o4)\n      mode |= 0o1\n  }\n  return mode\n}\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvc3dhcm0tanMvbm9kZV9tb2R1bGVzL3Rhci9saWIvbW9kZS1maXguanMiLCJtYXBwaW5ncyI6IkFBQVk7QUFDWjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSIsInNvdXJjZXMiOlsiL1VzZXJzL3BhbnphL0RvY3VtZW50cy9QZXJzb25hbFByb2plY3RzL3ByZWRpay9ub2RlX21vZHVsZXMvc3dhcm0tanMvbm9kZV9tb2R1bGVzL3Rhci9saWIvbW9kZS1maXguanMiXSwic291cmNlc0NvbnRlbnQiOlsiJ3VzZSBzdHJpY3QnXG5tb2R1bGUuZXhwb3J0cyA9IChtb2RlLCBpc0RpcikgPT4ge1xuICBtb2RlICY9IDBvNzc3N1xuICAvLyBpZiBkaXJzIGFyZSByZWFkYWJsZSwgdGhlbiB0aGV5IHNob3VsZCBiZSBsaXN0YWJsZVxuICBpZiAoaXNEaXIpIHtcbiAgICBpZiAobW9kZSAmIDBvNDAwKVxuICAgICAgbW9kZSB8PSAwbzEwMFxuICAgIGlmIChtb2RlICYgMG80MClcbiAgICAgIG1vZGUgfD0gMG8xMFxuICAgIGlmIChtb2RlICYgMG80KVxuICAgICAgbW9kZSB8PSAwbzFcbiAgfVxuICByZXR1cm4gbW9kZVxufVxuIl0sIm5hbWVzIjpbXSwiaWdub3JlTGlzdCI6WzBdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/swarm-js/node_modules/tar/lib/mode-fix.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/swarm-js/node_modules/tar/lib/normalize-windows-path.js":
/*!******************************************************************************!*\
  !*** ./node_modules/swarm-js/node_modules/tar/lib/normalize-windows-path.js ***!
  \******************************************************************************/
/***/ ((module) => {

eval("// on windows, either \\ or / are valid directory separators.\n// on unix, \\ is a valid character in filenames.\n// so, on windows, and only on windows, we replace all \\ chars with /,\n// so that we can use / as our one and only directory separator char.\n\nconst platform = process.env.TESTING_TAR_FAKE_PLATFORM || process.platform\nmodule.exports = platform !== 'win32' ? p => p\n  : p => p && p.replace(/\\\\/g, '/')\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvc3dhcm0tanMvbm9kZV9tb2R1bGVzL3Rhci9saWIvbm9ybWFsaXplLXdpbmRvd3MtcGF0aC5qcyIsIm1hcHBpbmdzIjoiQUFBQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EiLCJzb3VyY2VzIjpbIi9Vc2Vycy9wYW56YS9Eb2N1bWVudHMvUGVyc29uYWxQcm9qZWN0cy9wcmVkaWsvbm9kZV9tb2R1bGVzL3N3YXJtLWpzL25vZGVfbW9kdWxlcy90YXIvbGliL25vcm1hbGl6ZS13aW5kb3dzLXBhdGguanMiXSwic291cmNlc0NvbnRlbnQiOlsiLy8gb24gd2luZG93cywgZWl0aGVyIFxcIG9yIC8gYXJlIHZhbGlkIGRpcmVjdG9yeSBzZXBhcmF0b3JzLlxuLy8gb24gdW5peCwgXFwgaXMgYSB2YWxpZCBjaGFyYWN0ZXIgaW4gZmlsZW5hbWVzLlxuLy8gc28sIG9uIHdpbmRvd3MsIGFuZCBvbmx5IG9uIHdpbmRvd3MsIHdlIHJlcGxhY2UgYWxsIFxcIGNoYXJzIHdpdGggLyxcbi8vIHNvIHRoYXQgd2UgY2FuIHVzZSAvIGFzIG91ciBvbmUgYW5kIG9ubHkgZGlyZWN0b3J5IHNlcGFyYXRvciBjaGFyLlxuXG5jb25zdCBwbGF0Zm9ybSA9IHByb2Nlc3MuZW52LlRFU1RJTkdfVEFSX0ZBS0VfUExBVEZPUk0gfHwgcHJvY2Vzcy5wbGF0Zm9ybVxubW9kdWxlLmV4cG9ydHMgPSBwbGF0Zm9ybSAhPT0gJ3dpbjMyJyA/IHAgPT4gcFxuICA6IHAgPT4gcCAmJiBwLnJlcGxhY2UoL1xcXFwvZywgJy8nKVxuIl0sIm5hbWVzIjpbXSwiaWdub3JlTGlzdCI6WzBdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/swarm-js/node_modules/tar/lib/normalize-windows-path.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/swarm-js/node_modules/tar/lib/pack.js":
/*!************************************************************!*\
  !*** ./node_modules/swarm-js/node_modules/tar/lib/pack.js ***!
  \************************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";
eval("\n\nconst Buffer = __webpack_require__(/*! ./buffer.js */ \"(ssr)/./node_modules/swarm-js/node_modules/tar/lib/buffer.js\")\n\n// A readable tar stream creator\n// Technically, this is a transform stream that you write paths into,\n// and tar format comes out of.\n// The `add()` method is like `write()` but returns this,\n// and end() return `this` as well, so you can\n// do `new Pack(opt).add('files').add('dir').end().pipe(output)\n// You could also do something like:\n// streamOfPaths().pipe(new Pack()).pipe(new fs.WriteStream('out.tar'))\n\nclass PackJob {\n  constructor (path, absolute) {\n    this.path = path || './'\n    this.absolute = absolute\n    this.entry = null\n    this.stat = null\n    this.readdir = null\n    this.pending = false\n    this.ignore = false\n    this.piped = false\n  }\n}\n\nconst MiniPass = __webpack_require__(/*! minipass */ \"(ssr)/./node_modules/swarm-js/node_modules/minipass/index.js\")\nconst zlib = __webpack_require__(/*! minizlib */ \"(ssr)/./node_modules/swarm-js/node_modules/minizlib/index.js\")\nconst ReadEntry = __webpack_require__(/*! ./read-entry.js */ \"(ssr)/./node_modules/swarm-js/node_modules/tar/lib/read-entry.js\")\nconst WriteEntry = __webpack_require__(/*! ./write-entry.js */ \"(ssr)/./node_modules/swarm-js/node_modules/tar/lib/write-entry.js\")\nconst WriteEntrySync = WriteEntry.Sync\nconst WriteEntryTar = WriteEntry.Tar\nconst Yallist = __webpack_require__(/*! yallist */ \"(ssr)/./node_modules/swarm-js/node_modules/yallist/yallist.js\")\nconst EOF = Buffer.alloc(1024)\nconst ONSTAT = Symbol('onStat')\nconst ENDED = Symbol('ended')\nconst QUEUE = Symbol('queue')\nconst CURRENT = Symbol('current')\nconst PROCESS = Symbol('process')\nconst PROCESSING = Symbol('processing')\nconst PROCESSJOB = Symbol('processJob')\nconst JOBS = Symbol('jobs')\nconst JOBDONE = Symbol('jobDone')\nconst ADDFSENTRY = Symbol('addFSEntry')\nconst ADDTARENTRY = Symbol('addTarEntry')\nconst STAT = Symbol('stat')\nconst READDIR = Symbol('readdir')\nconst ONREADDIR = Symbol('onreaddir')\nconst PIPE = Symbol('pipe')\nconst ENTRY = Symbol('entry')\nconst ENTRYOPT = Symbol('entryOpt')\nconst WRITEENTRYCLASS = Symbol('writeEntryClass')\nconst WRITE = Symbol('write')\nconst ONDRAIN = Symbol('ondrain')\n\nconst fs = __webpack_require__(/*! fs */ \"fs\")\nconst path = __webpack_require__(/*! path */ \"path\")\nconst warner = __webpack_require__(/*! ./warn-mixin.js */ \"(ssr)/./node_modules/swarm-js/node_modules/tar/lib/warn-mixin.js\")\nconst normPath = __webpack_require__(/*! ./normalize-windows-path.js */ \"(ssr)/./node_modules/swarm-js/node_modules/tar/lib/normalize-windows-path.js\")\n\nconst Pack = warner(class Pack extends MiniPass {\n  constructor (opt) {\n    super(opt)\n    opt = opt || Object.create(null)\n    this.opt = opt\n    this.cwd = opt.cwd || process.cwd()\n    this.maxReadSize = opt.maxReadSize\n    this.preservePaths = !!opt.preservePaths\n    this.strict = !!opt.strict\n    this.noPax = !!opt.noPax\n    this.prefix = normPath(opt.prefix || '')\n    this.linkCache = opt.linkCache || new Map()\n    this.statCache = opt.statCache || new Map()\n    this.readdirCache = opt.readdirCache || new Map()\n\n    this[WRITEENTRYCLASS] = WriteEntry\n    if (typeof opt.onwarn === 'function')\n      this.on('warn', opt.onwarn)\n\n    this.zip = null\n    if (opt.gzip) {\n      if (typeof opt.gzip !== 'object')\n        opt.gzip = {}\n      this.zip = new zlib.Gzip(opt.gzip)\n      this.zip.on('data', chunk => super.write(chunk))\n      this.zip.on('end', _ => super.end())\n      this.zip.on('drain', _ => this[ONDRAIN]())\n      this.on('resume', _ => this.zip.resume())\n    } else\n      this.on('drain', this[ONDRAIN])\n\n    this.portable = !!opt.portable\n    this.noDirRecurse = !!opt.noDirRecurse\n    this.follow = !!opt.follow\n    this.noMtime = !!opt.noMtime\n    this.mtime = opt.mtime || null\n\n    this.filter = typeof opt.filter === 'function' ? opt.filter : _ => true\n\n    this[QUEUE] = new Yallist\n    this[JOBS] = 0\n    this.jobs = +opt.jobs || 4\n    this[PROCESSING] = false\n    this[ENDED] = false\n  }\n\n  [WRITE] (chunk) {\n    return super.write(chunk)\n  }\n\n  add (path) {\n    this.write(path)\n    return this\n  }\n\n  end (path) {\n    if (path)\n      this.write(path)\n    this[ENDED] = true\n    this[PROCESS]()\n    return this\n  }\n\n  write (path) {\n    if (this[ENDED])\n      throw new Error('write after end')\n\n    if (path instanceof ReadEntry)\n      this[ADDTARENTRY](path)\n    else\n      this[ADDFSENTRY](path)\n    return this.flowing\n  }\n\n  [ADDTARENTRY] (p) {\n    const absolute = normPath(path.resolve(this.cwd, p.path))\n    // in this case, we don't have to wait for the stat\n    if (!this.filter(p.path, p))\n      p.resume()\n    else {\n      const job = new PackJob(p.path, absolute, false)\n      job.entry = new WriteEntryTar(p, this[ENTRYOPT](job))\n      job.entry.on('end', _ => this[JOBDONE](job))\n      this[JOBS] += 1\n      this[QUEUE].push(job)\n    }\n\n    this[PROCESS]()\n  }\n\n  [ADDFSENTRY] (p) {\n    const absolute = normPath(path.resolve(this.cwd, p))\n    this[QUEUE].push(new PackJob(p, absolute))\n    this[PROCESS]()\n  }\n\n  [STAT] (job) {\n    job.pending = true\n    this[JOBS] += 1\n    const stat = this.follow ? 'stat' : 'lstat'\n    fs[stat](job.absolute, (er, stat) => {\n      job.pending = false\n      this[JOBS] -= 1\n      if (er)\n        this.emit('error', er)\n      else\n        this[ONSTAT](job, stat)\n    })\n  }\n\n  [ONSTAT] (job, stat) {\n    this.statCache.set(job.absolute, stat)\n    job.stat = stat\n\n    // now we have the stat, we can filter it.\n    if (!this.filter(job.path, stat))\n      job.ignore = true\n\n    this[PROCESS]()\n  }\n\n  [READDIR] (job) {\n    job.pending = true\n    this[JOBS] += 1\n    fs.readdir(job.absolute, (er, entries) => {\n      job.pending = false\n      this[JOBS] -= 1\n      if (er)\n        return this.emit('error', er)\n      this[ONREADDIR](job, entries)\n    })\n  }\n\n  [ONREADDIR] (job, entries) {\n    this.readdirCache.set(job.absolute, entries)\n    job.readdir = entries\n    this[PROCESS]()\n  }\n\n  [PROCESS] () {\n    if (this[PROCESSING])\n      return\n\n    this[PROCESSING] = true\n    for (let w = this[QUEUE].head;\n         w !== null && this[JOBS] < this.jobs;\n         w = w.next) {\n      this[PROCESSJOB](w.value)\n      if (w.value.ignore) {\n        const p = w.next\n        this[QUEUE].removeNode(w)\n        w.next = p\n      }\n    }\n\n    this[PROCESSING] = false\n\n    if (this[ENDED] && !this[QUEUE].length && this[JOBS] === 0) {\n      if (this.zip)\n        this.zip.end(EOF)\n      else {\n        super.write(EOF)\n        super.end()\n      }\n    }\n  }\n\n  get [CURRENT] () {\n    return this[QUEUE] && this[QUEUE].head && this[QUEUE].head.value\n  }\n\n  [JOBDONE] (job) {\n    this[QUEUE].shift()\n    this[JOBS] -= 1\n    this[PROCESS]()\n  }\n\n  [PROCESSJOB] (job) {\n    if (job.pending)\n      return\n\n    if (job.entry) {\n      if (job === this[CURRENT] && !job.piped)\n        this[PIPE](job)\n      return\n    }\n\n    if (!job.stat) {\n      if (this.statCache.has(job.absolute))\n        this[ONSTAT](job, this.statCache.get(job.absolute))\n      else\n        this[STAT](job)\n    }\n    if (!job.stat)\n      return\n\n    // filtered out!\n    if (job.ignore)\n      return\n\n    if (!this.noDirRecurse && job.stat.isDirectory() && !job.readdir) {\n      if (this.readdirCache.has(job.absolute))\n        this[ONREADDIR](job, this.readdirCache.get(job.absolute))\n      else\n        this[READDIR](job)\n      if (!job.readdir)\n        return\n    }\n\n    // we know it doesn't have an entry, because that got checked above\n    job.entry = this[ENTRY](job)\n    if (!job.entry) {\n      job.ignore = true\n      return\n    }\n\n    if (job === this[CURRENT] && !job.piped)\n      this[PIPE](job)\n  }\n\n  [ENTRYOPT] (job) {\n    return {\n      onwarn: (msg, data) => {\n        this.warn(msg, data)\n      },\n      noPax: this.noPax,\n      cwd: this.cwd,\n      absolute: job.absolute,\n      preservePaths: this.preservePaths,\n      maxReadSize: this.maxReadSize,\n      strict: this.strict,\n      portable: this.portable,\n      linkCache: this.linkCache,\n      statCache: this.statCache,\n      noMtime: this.noMtime,\n      mtime: this.mtime,\n      prefix: this.prefix,\n    }\n  }\n\n  [ENTRY] (job) {\n    this[JOBS] += 1\n    try {\n      return new this[WRITEENTRYCLASS](job.path, this[ENTRYOPT](job))\n        .on('end', () => this[JOBDONE](job))\n        .on('error', er => this.emit('error', er))\n    } catch (er) {\n      this.emit('error', er)\n    }\n  }\n\n  [ONDRAIN] () {\n    if (this[CURRENT] && this[CURRENT].entry)\n      this[CURRENT].entry.resume()\n  }\n\n  // like .pipe() but using super, because our write() is special\n  [PIPE] (job) {\n    job.piped = true\n\n    if (job.readdir)\n      job.readdir.forEach(entry => {\n        const p = job.path\n        const base = p === './' ? '' : p.replace(/\\/*$/, '/')\n        this[ADDFSENTRY](base + entry)\n      })\n\n    const source = job.entry\n    const zip = this.zip\n\n    if (zip)\n      source.on('data', chunk => {\n        if (!zip.write(chunk))\n          source.pause()\n      })\n    else\n      source.on('data', chunk => {\n        if (!super.write(chunk))\n          source.pause()\n      })\n  }\n\n  pause () {\n    if (this.zip)\n      this.zip.pause()\n    return super.pause()\n  }\n})\n\nclass PackSync extends Pack {\n  constructor (opt) {\n    super(opt)\n    this[WRITEENTRYCLASS] = WriteEntrySync\n  }\n\n  // pause/resume are no-ops in sync streams.\n  pause () {}\n  resume () {}\n\n  [STAT] (job) {\n    const stat = this.follow ? 'statSync' : 'lstatSync'\n    this[ONSTAT](job, fs[stat](job.absolute))\n  }\n\n  [READDIR] (job, stat) {\n    this[ONREADDIR](job, fs.readdirSync(job.absolute))\n  }\n\n  // gotta get it all in this tick\n  [PIPE] (job) {\n    const source = job.entry\n    const zip = this.zip\n\n    if (job.readdir)\n      job.readdir.forEach(entry => {\n        const p = job.path\n        const base = p === './' ? '' : p.replace(/\\/*$/, '/')\n        this[ADDFSENTRY](base + entry)\n      })\n\n    if (zip)\n      source.on('data', chunk => {\n        zip.write(chunk)\n      })\n    else\n      source.on('data', chunk => {\n        super[WRITE](chunk)\n      })\n  }\n}\n\nPack.Sync = PackSync\n\nmodule.exports = Pack\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvc3dhcm0tanMvbm9kZV9tb2R1bGVzL3Rhci9saWIvcGFjay5qcyIsIm1hcHBpbmdzIjoiQUFBWTs7QUFFWixlQUFlLG1CQUFPLENBQUMsaUZBQWE7O0FBRXBDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBLGlCQUFpQixtQkFBTyxDQUFDLDhFQUFVO0FBQ25DLGFBQWEsbUJBQU8sQ0FBQyw4RUFBVTtBQUMvQixrQkFBa0IsbUJBQU8sQ0FBQyx5RkFBaUI7QUFDM0MsbUJBQW1CLG1CQUFPLENBQUMsMkZBQWtCO0FBQzdDO0FBQ0E7QUFDQSxnQkFBZ0IsbUJBQU8sQ0FBQyw4RUFBUztBQUNqQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUEsV0FBVyxtQkFBTyxDQUFDLGNBQUk7QUFDdkIsYUFBYSxtQkFBTyxDQUFDLGtCQUFNO0FBQzNCLGVBQWUsbUJBQU8sQ0FBQyx5RkFBaUI7QUFDeEMsaUJBQWlCLG1CQUFPLENBQUMsaUhBQTZCOztBQUV0RDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87O0FBRVA7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQzs7QUFFRDtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87O0FBRVA7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBOztBQUVBOztBQUVBIiwic291cmNlcyI6WyIvVXNlcnMvcGFuemEvRG9jdW1lbnRzL1BlcnNvbmFsUHJvamVjdHMvcHJlZGlrL25vZGVfbW9kdWxlcy9zd2FybS1qcy9ub2RlX21vZHVsZXMvdGFyL2xpYi9wYWNrLmpzIl0sInNvdXJjZXNDb250ZW50IjpbIid1c2Ugc3RyaWN0J1xuXG5jb25zdCBCdWZmZXIgPSByZXF1aXJlKCcuL2J1ZmZlci5qcycpXG5cbi8vIEEgcmVhZGFibGUgdGFyIHN0cmVhbSBjcmVhdG9yXG4vLyBUZWNobmljYWxseSwgdGhpcyBpcyBhIHRyYW5zZm9ybSBzdHJlYW0gdGhhdCB5b3Ugd3JpdGUgcGF0aHMgaW50byxcbi8vIGFuZCB0YXIgZm9ybWF0IGNvbWVzIG91dCBvZi5cbi8vIFRoZSBgYWRkKClgIG1ldGhvZCBpcyBsaWtlIGB3cml0ZSgpYCBidXQgcmV0dXJucyB0aGlzLFxuLy8gYW5kIGVuZCgpIHJldHVybiBgdGhpc2AgYXMgd2VsbCwgc28geW91IGNhblxuLy8gZG8gYG5ldyBQYWNrKG9wdCkuYWRkKCdmaWxlcycpLmFkZCgnZGlyJykuZW5kKCkucGlwZShvdXRwdXQpXG4vLyBZb3UgY291bGQgYWxzbyBkbyBzb21ldGhpbmcgbGlrZTpcbi8vIHN0cmVhbU9mUGF0aHMoKS5waXBlKG5ldyBQYWNrKCkpLnBpcGUobmV3IGZzLldyaXRlU3RyZWFtKCdvdXQudGFyJykpXG5cbmNsYXNzIFBhY2tKb2Ige1xuICBjb25zdHJ1Y3RvciAocGF0aCwgYWJzb2x1dGUpIHtcbiAgICB0aGlzLnBhdGggPSBwYXRoIHx8ICcuLydcbiAgICB0aGlzLmFic29sdXRlID0gYWJzb2x1dGVcbiAgICB0aGlzLmVudHJ5ID0gbnVsbFxuICAgIHRoaXMuc3RhdCA9IG51bGxcbiAgICB0aGlzLnJlYWRkaXIgPSBudWxsXG4gICAgdGhpcy5wZW5kaW5nID0gZmFsc2VcbiAgICB0aGlzLmlnbm9yZSA9IGZhbHNlXG4gICAgdGhpcy5waXBlZCA9IGZhbHNlXG4gIH1cbn1cblxuY29uc3QgTWluaVBhc3MgPSByZXF1aXJlKCdtaW5pcGFzcycpXG5jb25zdCB6bGliID0gcmVxdWlyZSgnbWluaXpsaWInKVxuY29uc3QgUmVhZEVudHJ5ID0gcmVxdWlyZSgnLi9yZWFkLWVudHJ5LmpzJylcbmNvbnN0IFdyaXRlRW50cnkgPSByZXF1aXJlKCcuL3dyaXRlLWVudHJ5LmpzJylcbmNvbnN0IFdyaXRlRW50cnlTeW5jID0gV3JpdGVFbnRyeS5TeW5jXG5jb25zdCBXcml0ZUVudHJ5VGFyID0gV3JpdGVFbnRyeS5UYXJcbmNvbnN0IFlhbGxpc3QgPSByZXF1aXJlKCd5YWxsaXN0JylcbmNvbnN0IEVPRiA9IEJ1ZmZlci5hbGxvYygxMDI0KVxuY29uc3QgT05TVEFUID0gU3ltYm9sKCdvblN0YXQnKVxuY29uc3QgRU5ERUQgPSBTeW1ib2woJ2VuZGVkJylcbmNvbnN0IFFVRVVFID0gU3ltYm9sKCdxdWV1ZScpXG5jb25zdCBDVVJSRU5UID0gU3ltYm9sKCdjdXJyZW50JylcbmNvbnN0IFBST0NFU1MgPSBTeW1ib2woJ3Byb2Nlc3MnKVxuY29uc3QgUFJPQ0VTU0lORyA9IFN5bWJvbCgncHJvY2Vzc2luZycpXG5jb25zdCBQUk9DRVNTSk9CID0gU3ltYm9sKCdwcm9jZXNzSm9iJylcbmNvbnN0IEpPQlMgPSBTeW1ib2woJ2pvYnMnKVxuY29uc3QgSk9CRE9ORSA9IFN5bWJvbCgnam9iRG9uZScpXG5jb25zdCBBRERGU0VOVFJZID0gU3ltYm9sKCdhZGRGU0VudHJ5JylcbmNvbnN0IEFERFRBUkVOVFJZID0gU3ltYm9sKCdhZGRUYXJFbnRyeScpXG5jb25zdCBTVEFUID0gU3ltYm9sKCdzdGF0JylcbmNvbnN0IFJFQURESVIgPSBTeW1ib2woJ3JlYWRkaXInKVxuY29uc3QgT05SRUFERElSID0gU3ltYm9sKCdvbnJlYWRkaXInKVxuY29uc3QgUElQRSA9IFN5bWJvbCgncGlwZScpXG5jb25zdCBFTlRSWSA9IFN5bWJvbCgnZW50cnknKVxuY29uc3QgRU5UUllPUFQgPSBTeW1ib2woJ2VudHJ5T3B0JylcbmNvbnN0IFdSSVRFRU5UUllDTEFTUyA9IFN5bWJvbCgnd3JpdGVFbnRyeUNsYXNzJylcbmNvbnN0IFdSSVRFID0gU3ltYm9sKCd3cml0ZScpXG5jb25zdCBPTkRSQUlOID0gU3ltYm9sKCdvbmRyYWluJylcblxuY29uc3QgZnMgPSByZXF1aXJlKCdmcycpXG5jb25zdCBwYXRoID0gcmVxdWlyZSgncGF0aCcpXG5jb25zdCB3YXJuZXIgPSByZXF1aXJlKCcuL3dhcm4tbWl4aW4uanMnKVxuY29uc3Qgbm9ybVBhdGggPSByZXF1aXJlKCcuL25vcm1hbGl6ZS13aW5kb3dzLXBhdGguanMnKVxuXG5jb25zdCBQYWNrID0gd2FybmVyKGNsYXNzIFBhY2sgZXh0ZW5kcyBNaW5pUGFzcyB7XG4gIGNvbnN0cnVjdG9yIChvcHQpIHtcbiAgICBzdXBlcihvcHQpXG4gICAgb3B0ID0gb3B0IHx8IE9iamVjdC5jcmVhdGUobnVsbClcbiAgICB0aGlzLm9wdCA9IG9wdFxuICAgIHRoaXMuY3dkID0gb3B0LmN3ZCB8fCBwcm9jZXNzLmN3ZCgpXG4gICAgdGhpcy5tYXhSZWFkU2l6ZSA9IG9wdC5tYXhSZWFkU2l6ZVxuICAgIHRoaXMucHJlc2VydmVQYXRocyA9ICEhb3B0LnByZXNlcnZlUGF0aHNcbiAgICB0aGlzLnN0cmljdCA9ICEhb3B0LnN0cmljdFxuICAgIHRoaXMubm9QYXggPSAhIW9wdC5ub1BheFxuICAgIHRoaXMucHJlZml4ID0gbm9ybVBhdGgob3B0LnByZWZpeCB8fCAnJylcbiAgICB0aGlzLmxpbmtDYWNoZSA9IG9wdC5saW5rQ2FjaGUgfHwgbmV3IE1hcCgpXG4gICAgdGhpcy5zdGF0Q2FjaGUgPSBvcHQuc3RhdENhY2hlIHx8IG5ldyBNYXAoKVxuICAgIHRoaXMucmVhZGRpckNhY2hlID0gb3B0LnJlYWRkaXJDYWNoZSB8fCBuZXcgTWFwKClcblxuICAgIHRoaXNbV1JJVEVFTlRSWUNMQVNTXSA9IFdyaXRlRW50cnlcbiAgICBpZiAodHlwZW9mIG9wdC5vbndhcm4gPT09ICdmdW5jdGlvbicpXG4gICAgICB0aGlzLm9uKCd3YXJuJywgb3B0Lm9ud2FybilcblxuICAgIHRoaXMuemlwID0gbnVsbFxuICAgIGlmIChvcHQuZ3ppcCkge1xuICAgICAgaWYgKHR5cGVvZiBvcHQuZ3ppcCAhPT0gJ29iamVjdCcpXG4gICAgICAgIG9wdC5nemlwID0ge31cbiAgICAgIHRoaXMuemlwID0gbmV3IHpsaWIuR3ppcChvcHQuZ3ppcClcbiAgICAgIHRoaXMuemlwLm9uKCdkYXRhJywgY2h1bmsgPT4gc3VwZXIud3JpdGUoY2h1bmspKVxuICAgICAgdGhpcy56aXAub24oJ2VuZCcsIF8gPT4gc3VwZXIuZW5kKCkpXG4gICAgICB0aGlzLnppcC5vbignZHJhaW4nLCBfID0+IHRoaXNbT05EUkFJTl0oKSlcbiAgICAgIHRoaXMub24oJ3Jlc3VtZScsIF8gPT4gdGhpcy56aXAucmVzdW1lKCkpXG4gICAgfSBlbHNlXG4gICAgICB0aGlzLm9uKCdkcmFpbicsIHRoaXNbT05EUkFJTl0pXG5cbiAgICB0aGlzLnBvcnRhYmxlID0gISFvcHQucG9ydGFibGVcbiAgICB0aGlzLm5vRGlyUmVjdXJzZSA9ICEhb3B0Lm5vRGlyUmVjdXJzZVxuICAgIHRoaXMuZm9sbG93ID0gISFvcHQuZm9sbG93XG4gICAgdGhpcy5ub010aW1lID0gISFvcHQubm9NdGltZVxuICAgIHRoaXMubXRpbWUgPSBvcHQubXRpbWUgfHwgbnVsbFxuXG4gICAgdGhpcy5maWx0ZXIgPSB0eXBlb2Ygb3B0LmZpbHRlciA9PT0gJ2Z1bmN0aW9uJyA/IG9wdC5maWx0ZXIgOiBfID0+IHRydWVcblxuICAgIHRoaXNbUVVFVUVdID0gbmV3IFlhbGxpc3RcbiAgICB0aGlzW0pPQlNdID0gMFxuICAgIHRoaXMuam9icyA9ICtvcHQuam9icyB8fCA0XG4gICAgdGhpc1tQUk9DRVNTSU5HXSA9IGZhbHNlXG4gICAgdGhpc1tFTkRFRF0gPSBmYWxzZVxuICB9XG5cbiAgW1dSSVRFXSAoY2h1bmspIHtcbiAgICByZXR1cm4gc3VwZXIud3JpdGUoY2h1bmspXG4gIH1cblxuICBhZGQgKHBhdGgpIHtcbiAgICB0aGlzLndyaXRlKHBhdGgpXG4gICAgcmV0dXJuIHRoaXNcbiAgfVxuXG4gIGVuZCAocGF0aCkge1xuICAgIGlmIChwYXRoKVxuICAgICAgdGhpcy53cml0ZShwYXRoKVxuICAgIHRoaXNbRU5ERURdID0gdHJ1ZVxuICAgIHRoaXNbUFJPQ0VTU10oKVxuICAgIHJldHVybiB0aGlzXG4gIH1cblxuICB3cml0ZSAocGF0aCkge1xuICAgIGlmICh0aGlzW0VOREVEXSlcbiAgICAgIHRocm93IG5ldyBFcnJvcignd3JpdGUgYWZ0ZXIgZW5kJylcblxuICAgIGlmIChwYXRoIGluc3RhbmNlb2YgUmVhZEVudHJ5KVxuICAgICAgdGhpc1tBRERUQVJFTlRSWV0ocGF0aClcbiAgICBlbHNlXG4gICAgICB0aGlzW0FEREZTRU5UUlldKHBhdGgpXG4gICAgcmV0dXJuIHRoaXMuZmxvd2luZ1xuICB9XG5cbiAgW0FERFRBUkVOVFJZXSAocCkge1xuICAgIGNvbnN0IGFic29sdXRlID0gbm9ybVBhdGgocGF0aC5yZXNvbHZlKHRoaXMuY3dkLCBwLnBhdGgpKVxuICAgIC8vIGluIHRoaXMgY2FzZSwgd2UgZG9uJ3QgaGF2ZSB0byB3YWl0IGZvciB0aGUgc3RhdFxuICAgIGlmICghdGhpcy5maWx0ZXIocC5wYXRoLCBwKSlcbiAgICAgIHAucmVzdW1lKClcbiAgICBlbHNlIHtcbiAgICAgIGNvbnN0IGpvYiA9IG5ldyBQYWNrSm9iKHAucGF0aCwgYWJzb2x1dGUsIGZhbHNlKVxuICAgICAgam9iLmVudHJ5ID0gbmV3IFdyaXRlRW50cnlUYXIocCwgdGhpc1tFTlRSWU9QVF0oam9iKSlcbiAgICAgIGpvYi5lbnRyeS5vbignZW5kJywgXyA9PiB0aGlzW0pPQkRPTkVdKGpvYikpXG4gICAgICB0aGlzW0pPQlNdICs9IDFcbiAgICAgIHRoaXNbUVVFVUVdLnB1c2goam9iKVxuICAgIH1cblxuICAgIHRoaXNbUFJPQ0VTU10oKVxuICB9XG5cbiAgW0FEREZTRU5UUlldIChwKSB7XG4gICAgY29uc3QgYWJzb2x1dGUgPSBub3JtUGF0aChwYXRoLnJlc29sdmUodGhpcy5jd2QsIHApKVxuICAgIHRoaXNbUVVFVUVdLnB1c2gobmV3IFBhY2tKb2IocCwgYWJzb2x1dGUpKVxuICAgIHRoaXNbUFJPQ0VTU10oKVxuICB9XG5cbiAgW1NUQVRdIChqb2IpIHtcbiAgICBqb2IucGVuZGluZyA9IHRydWVcbiAgICB0aGlzW0pPQlNdICs9IDFcbiAgICBjb25zdCBzdGF0ID0gdGhpcy5mb2xsb3cgPyAnc3RhdCcgOiAnbHN0YXQnXG4gICAgZnNbc3RhdF0oam9iLmFic29sdXRlLCAoZXIsIHN0YXQpID0+IHtcbiAgICAgIGpvYi5wZW5kaW5nID0gZmFsc2VcbiAgICAgIHRoaXNbSk9CU10gLT0gMVxuICAgICAgaWYgKGVyKVxuICAgICAgICB0aGlzLmVtaXQoJ2Vycm9yJywgZXIpXG4gICAgICBlbHNlXG4gICAgICAgIHRoaXNbT05TVEFUXShqb2IsIHN0YXQpXG4gICAgfSlcbiAgfVxuXG4gIFtPTlNUQVRdIChqb2IsIHN0YXQpIHtcbiAgICB0aGlzLnN0YXRDYWNoZS5zZXQoam9iLmFic29sdXRlLCBzdGF0KVxuICAgIGpvYi5zdGF0ID0gc3RhdFxuXG4gICAgLy8gbm93IHdlIGhhdmUgdGhlIHN0YXQsIHdlIGNhbiBmaWx0ZXIgaXQuXG4gICAgaWYgKCF0aGlzLmZpbHRlcihqb2IucGF0aCwgc3RhdCkpXG4gICAgICBqb2IuaWdub3JlID0gdHJ1ZVxuXG4gICAgdGhpc1tQUk9DRVNTXSgpXG4gIH1cblxuICBbUkVBRERJUl0gKGpvYikge1xuICAgIGpvYi5wZW5kaW5nID0gdHJ1ZVxuICAgIHRoaXNbSk9CU10gKz0gMVxuICAgIGZzLnJlYWRkaXIoam9iLmFic29sdXRlLCAoZXIsIGVudHJpZXMpID0+IHtcbiAgICAgIGpvYi5wZW5kaW5nID0gZmFsc2VcbiAgICAgIHRoaXNbSk9CU10gLT0gMVxuICAgICAgaWYgKGVyKVxuICAgICAgICByZXR1cm4gdGhpcy5lbWl0KCdlcnJvcicsIGVyKVxuICAgICAgdGhpc1tPTlJFQURESVJdKGpvYiwgZW50cmllcylcbiAgICB9KVxuICB9XG5cbiAgW09OUkVBRERJUl0gKGpvYiwgZW50cmllcykge1xuICAgIHRoaXMucmVhZGRpckNhY2hlLnNldChqb2IuYWJzb2x1dGUsIGVudHJpZXMpXG4gICAgam9iLnJlYWRkaXIgPSBlbnRyaWVzXG4gICAgdGhpc1tQUk9DRVNTXSgpXG4gIH1cblxuICBbUFJPQ0VTU10gKCkge1xuICAgIGlmICh0aGlzW1BST0NFU1NJTkddKVxuICAgICAgcmV0dXJuXG5cbiAgICB0aGlzW1BST0NFU1NJTkddID0gdHJ1ZVxuICAgIGZvciAobGV0IHcgPSB0aGlzW1FVRVVFXS5oZWFkO1xuICAgICAgICAgdyAhPT0gbnVsbCAmJiB0aGlzW0pPQlNdIDwgdGhpcy5qb2JzO1xuICAgICAgICAgdyA9IHcubmV4dCkge1xuICAgICAgdGhpc1tQUk9DRVNTSk9CXSh3LnZhbHVlKVxuICAgICAgaWYgKHcudmFsdWUuaWdub3JlKSB7XG4gICAgICAgIGNvbnN0IHAgPSB3Lm5leHRcbiAgICAgICAgdGhpc1tRVUVVRV0ucmVtb3ZlTm9kZSh3KVxuICAgICAgICB3Lm5leHQgPSBwXG4gICAgICB9XG4gICAgfVxuXG4gICAgdGhpc1tQUk9DRVNTSU5HXSA9IGZhbHNlXG5cbiAgICBpZiAodGhpc1tFTkRFRF0gJiYgIXRoaXNbUVVFVUVdLmxlbmd0aCAmJiB0aGlzW0pPQlNdID09PSAwKSB7XG4gICAgICBpZiAodGhpcy56aXApXG4gICAgICAgIHRoaXMuemlwLmVuZChFT0YpXG4gICAgICBlbHNlIHtcbiAgICAgICAgc3VwZXIud3JpdGUoRU9GKVxuICAgICAgICBzdXBlci5lbmQoKVxuICAgICAgfVxuICAgIH1cbiAgfVxuXG4gIGdldCBbQ1VSUkVOVF0gKCkge1xuICAgIHJldHVybiB0aGlzW1FVRVVFXSAmJiB0aGlzW1FVRVVFXS5oZWFkICYmIHRoaXNbUVVFVUVdLmhlYWQudmFsdWVcbiAgfVxuXG4gIFtKT0JET05FXSAoam9iKSB7XG4gICAgdGhpc1tRVUVVRV0uc2hpZnQoKVxuICAgIHRoaXNbSk9CU10gLT0gMVxuICAgIHRoaXNbUFJPQ0VTU10oKVxuICB9XG5cbiAgW1BST0NFU1NKT0JdIChqb2IpIHtcbiAgICBpZiAoam9iLnBlbmRpbmcpXG4gICAgICByZXR1cm5cblxuICAgIGlmIChqb2IuZW50cnkpIHtcbiAgICAgIGlmIChqb2IgPT09IHRoaXNbQ1VSUkVOVF0gJiYgIWpvYi5waXBlZClcbiAgICAgICAgdGhpc1tQSVBFXShqb2IpXG4gICAgICByZXR1cm5cbiAgICB9XG5cbiAgICBpZiAoIWpvYi5zdGF0KSB7XG4gICAgICBpZiAodGhpcy5zdGF0Q2FjaGUuaGFzKGpvYi5hYnNvbHV0ZSkpXG4gICAgICAgIHRoaXNbT05TVEFUXShqb2IsIHRoaXMuc3RhdENhY2hlLmdldChqb2IuYWJzb2x1dGUpKVxuICAgICAgZWxzZVxuICAgICAgICB0aGlzW1NUQVRdKGpvYilcbiAgICB9XG4gICAgaWYgKCFqb2Iuc3RhdClcbiAgICAgIHJldHVyblxuXG4gICAgLy8gZmlsdGVyZWQgb3V0IVxuICAgIGlmIChqb2IuaWdub3JlKVxuICAgICAgcmV0dXJuXG5cbiAgICBpZiAoIXRoaXMubm9EaXJSZWN1cnNlICYmIGpvYi5zdGF0LmlzRGlyZWN0b3J5KCkgJiYgIWpvYi5yZWFkZGlyKSB7XG4gICAgICBpZiAodGhpcy5yZWFkZGlyQ2FjaGUuaGFzKGpvYi5hYnNvbHV0ZSkpXG4gICAgICAgIHRoaXNbT05SRUFERElSXShqb2IsIHRoaXMucmVhZGRpckNhY2hlLmdldChqb2IuYWJzb2x1dGUpKVxuICAgICAgZWxzZVxuICAgICAgICB0aGlzW1JFQURESVJdKGpvYilcbiAgICAgIGlmICgham9iLnJlYWRkaXIpXG4gICAgICAgIHJldHVyblxuICAgIH1cblxuICAgIC8vIHdlIGtub3cgaXQgZG9lc24ndCBoYXZlIGFuIGVudHJ5LCBiZWNhdXNlIHRoYXQgZ290IGNoZWNrZWQgYWJvdmVcbiAgICBqb2IuZW50cnkgPSB0aGlzW0VOVFJZXShqb2IpXG4gICAgaWYgKCFqb2IuZW50cnkpIHtcbiAgICAgIGpvYi5pZ25vcmUgPSB0cnVlXG4gICAgICByZXR1cm5cbiAgICB9XG5cbiAgICBpZiAoam9iID09PSB0aGlzW0NVUlJFTlRdICYmICFqb2IucGlwZWQpXG4gICAgICB0aGlzW1BJUEVdKGpvYilcbiAgfVxuXG4gIFtFTlRSWU9QVF0gKGpvYikge1xuICAgIHJldHVybiB7XG4gICAgICBvbndhcm46IChtc2csIGRhdGEpID0+IHtcbiAgICAgICAgdGhpcy53YXJuKG1zZywgZGF0YSlcbiAgICAgIH0sXG4gICAgICBub1BheDogdGhpcy5ub1BheCxcbiAgICAgIGN3ZDogdGhpcy5jd2QsXG4gICAgICBhYnNvbHV0ZTogam9iLmFic29sdXRlLFxuICAgICAgcHJlc2VydmVQYXRoczogdGhpcy5wcmVzZXJ2ZVBhdGhzLFxuICAgICAgbWF4UmVhZFNpemU6IHRoaXMubWF4UmVhZFNpemUsXG4gICAgICBzdHJpY3Q6IHRoaXMuc3RyaWN0LFxuICAgICAgcG9ydGFibGU6IHRoaXMucG9ydGFibGUsXG4gICAgICBsaW5rQ2FjaGU6IHRoaXMubGlua0NhY2hlLFxuICAgICAgc3RhdENhY2hlOiB0aGlzLnN0YXRDYWNoZSxcbiAgICAgIG5vTXRpbWU6IHRoaXMubm9NdGltZSxcbiAgICAgIG10aW1lOiB0aGlzLm10aW1lLFxuICAgICAgcHJlZml4OiB0aGlzLnByZWZpeCxcbiAgICB9XG4gIH1cblxuICBbRU5UUlldIChqb2IpIHtcbiAgICB0aGlzW0pPQlNdICs9IDFcbiAgICB0cnkge1xuICAgICAgcmV0dXJuIG5ldyB0aGlzW1dSSVRFRU5UUllDTEFTU10oam9iLnBhdGgsIHRoaXNbRU5UUllPUFRdKGpvYikpXG4gICAgICAgIC5vbignZW5kJywgKCkgPT4gdGhpc1tKT0JET05FXShqb2IpKVxuICAgICAgICAub24oJ2Vycm9yJywgZXIgPT4gdGhpcy5lbWl0KCdlcnJvcicsIGVyKSlcbiAgICB9IGNhdGNoIChlcikge1xuICAgICAgdGhpcy5lbWl0KCdlcnJvcicsIGVyKVxuICAgIH1cbiAgfVxuXG4gIFtPTkRSQUlOXSAoKSB7XG4gICAgaWYgKHRoaXNbQ1VSUkVOVF0gJiYgdGhpc1tDVVJSRU5UXS5lbnRyeSlcbiAgICAgIHRoaXNbQ1VSUkVOVF0uZW50cnkucmVzdW1lKClcbiAgfVxuXG4gIC8vIGxpa2UgLnBpcGUoKSBidXQgdXNpbmcgc3VwZXIsIGJlY2F1c2Ugb3VyIHdyaXRlKCkgaXMgc3BlY2lhbFxuICBbUElQRV0gKGpvYikge1xuICAgIGpvYi5waXBlZCA9IHRydWVcblxuICAgIGlmIChqb2IucmVhZGRpcilcbiAgICAgIGpvYi5yZWFkZGlyLmZvckVhY2goZW50cnkgPT4ge1xuICAgICAgICBjb25zdCBwID0gam9iLnBhdGhcbiAgICAgICAgY29uc3QgYmFzZSA9IHAgPT09ICcuLycgPyAnJyA6IHAucmVwbGFjZSgvXFwvKiQvLCAnLycpXG4gICAgICAgIHRoaXNbQURERlNFTlRSWV0oYmFzZSArIGVudHJ5KVxuICAgICAgfSlcblxuICAgIGNvbnN0IHNvdXJjZSA9IGpvYi5lbnRyeVxuICAgIGNvbnN0IHppcCA9IHRoaXMuemlwXG5cbiAgICBpZiAoemlwKVxuICAgICAgc291cmNlLm9uKCdkYXRhJywgY2h1bmsgPT4ge1xuICAgICAgICBpZiAoIXppcC53cml0ZShjaHVuaykpXG4gICAgICAgICAgc291cmNlLnBhdXNlKClcbiAgICAgIH0pXG4gICAgZWxzZVxuICAgICAgc291cmNlLm9uKCdkYXRhJywgY2h1bmsgPT4ge1xuICAgICAgICBpZiAoIXN1cGVyLndyaXRlKGNodW5rKSlcbiAgICAgICAgICBzb3VyY2UucGF1c2UoKVxuICAgICAgfSlcbiAgfVxuXG4gIHBhdXNlICgpIHtcbiAgICBpZiAodGhpcy56aXApXG4gICAgICB0aGlzLnppcC5wYXVzZSgpXG4gICAgcmV0dXJuIHN1cGVyLnBhdXNlKClcbiAgfVxufSlcblxuY2xhc3MgUGFja1N5bmMgZXh0ZW5kcyBQYWNrIHtcbiAgY29uc3RydWN0b3IgKG9wdCkge1xuICAgIHN1cGVyKG9wdClcbiAgICB0aGlzW1dSSVRFRU5UUllDTEFTU10gPSBXcml0ZUVudHJ5U3luY1xuICB9XG5cbiAgLy8gcGF1c2UvcmVzdW1lIGFyZSBuby1vcHMgaW4gc3luYyBzdHJlYW1zLlxuICBwYXVzZSAoKSB7fVxuICByZXN1bWUgKCkge31cblxuICBbU1RBVF0gKGpvYikge1xuICAgIGNvbnN0IHN0YXQgPSB0aGlzLmZvbGxvdyA/ICdzdGF0U3luYycgOiAnbHN0YXRTeW5jJ1xuICAgIHRoaXNbT05TVEFUXShqb2IsIGZzW3N0YXRdKGpvYi5hYnNvbHV0ZSkpXG4gIH1cblxuICBbUkVBRERJUl0gKGpvYiwgc3RhdCkge1xuICAgIHRoaXNbT05SRUFERElSXShqb2IsIGZzLnJlYWRkaXJTeW5jKGpvYi5hYnNvbHV0ZSkpXG4gIH1cblxuICAvLyBnb3R0YSBnZXQgaXQgYWxsIGluIHRoaXMgdGlja1xuICBbUElQRV0gKGpvYikge1xuICAgIGNvbnN0IHNvdXJjZSA9IGpvYi5lbnRyeVxuICAgIGNvbnN0IHppcCA9IHRoaXMuemlwXG5cbiAgICBpZiAoam9iLnJlYWRkaXIpXG4gICAgICBqb2IucmVhZGRpci5mb3JFYWNoKGVudHJ5ID0+IHtcbiAgICAgICAgY29uc3QgcCA9IGpvYi5wYXRoXG4gICAgICAgIGNvbnN0IGJhc2UgPSBwID09PSAnLi8nID8gJycgOiBwLnJlcGxhY2UoL1xcLyokLywgJy8nKVxuICAgICAgICB0aGlzW0FEREZTRU5UUlldKGJhc2UgKyBlbnRyeSlcbiAgICAgIH0pXG5cbiAgICBpZiAoemlwKVxuICAgICAgc291cmNlLm9uKCdkYXRhJywgY2h1bmsgPT4ge1xuICAgICAgICB6aXAud3JpdGUoY2h1bmspXG4gICAgICB9KVxuICAgIGVsc2VcbiAgICAgIHNvdXJjZS5vbignZGF0YScsIGNodW5rID0+IHtcbiAgICAgICAgc3VwZXJbV1JJVEVdKGNodW5rKVxuICAgICAgfSlcbiAgfVxufVxuXG5QYWNrLlN5bmMgPSBQYWNrU3luY1xuXG5tb2R1bGUuZXhwb3J0cyA9IFBhY2tcbiJdLCJuYW1lcyI6W10sImlnbm9yZUxpc3QiOlswXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/swarm-js/node_modules/tar/lib/pack.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/swarm-js/node_modules/tar/lib/parse.js":
/*!*************************************************************!*\
  !*** ./node_modules/swarm-js/node_modules/tar/lib/parse.js ***!
  \*************************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";
eval("\n\n// this[BUFFER] is the remainder of a chunk if we're waiting for\n// the full 512 bytes of a header to come in.  We will Buffer.concat()\n// it to the next write(), which is a mem copy, but a small one.\n//\n// this[QUEUE] is a Yallist of entries that haven't been emitted\n// yet this can only get filled up if the user keeps write()ing after\n// a write() returns false, or does a write() with more than one entry\n//\n// We don't buffer chunks, we always parse them and either create an\n// entry, or push it into the active entry.  The ReadEntry class knows\n// to throw data away if .ignore=true\n//\n// Shift entry off the buffer when it emits 'end', and emit 'entry' for\n// the next one in the list.\n//\n// At any time, we're pushing body chunks into the entry at WRITEENTRY,\n// and waiting for 'end' on the entry at READENTRY\n//\n// ignored entries get .resume() called on them straight away\n\nconst warner = __webpack_require__(/*! ./warn-mixin.js */ \"(ssr)/./node_modules/swarm-js/node_modules/tar/lib/warn-mixin.js\")\nconst path = __webpack_require__(/*! path */ \"path\")\nconst Header = __webpack_require__(/*! ./header.js */ \"(ssr)/./node_modules/swarm-js/node_modules/tar/lib/header.js\")\nconst EE = __webpack_require__(/*! events */ \"events\")\nconst Yallist = __webpack_require__(/*! yallist */ \"(ssr)/./node_modules/swarm-js/node_modules/yallist/yallist.js\")\nconst maxMetaEntrySize = 1024 * 1024\nconst Entry = __webpack_require__(/*! ./read-entry.js */ \"(ssr)/./node_modules/swarm-js/node_modules/tar/lib/read-entry.js\")\nconst Pax = __webpack_require__(/*! ./pax.js */ \"(ssr)/./node_modules/swarm-js/node_modules/tar/lib/pax.js\")\nconst zlib = __webpack_require__(/*! minizlib */ \"(ssr)/./node_modules/swarm-js/node_modules/minizlib/index.js\")\nconst Buffer = __webpack_require__(/*! ./buffer.js */ \"(ssr)/./node_modules/swarm-js/node_modules/tar/lib/buffer.js\")\n\nconst gzipHeader = Buffer.from([0x1f, 0x8b])\nconst STATE = Symbol('state')\nconst WRITEENTRY = Symbol('writeEntry')\nconst READENTRY = Symbol('readEntry')\nconst NEXTENTRY = Symbol('nextEntry')\nconst PROCESSENTRY = Symbol('processEntry')\nconst EX = Symbol('extendedHeader')\nconst GEX = Symbol('globalExtendedHeader')\nconst META = Symbol('meta')\nconst EMITMETA = Symbol('emitMeta')\nconst BUFFER = Symbol('buffer')\nconst QUEUE = Symbol('queue')\nconst ENDED = Symbol('ended')\nconst EMITTEDEND = Symbol('emittedEnd')\nconst EMIT = Symbol('emit')\nconst UNZIP = Symbol('unzip')\nconst CONSUMECHUNK = Symbol('consumeChunk')\nconst CONSUMECHUNKSUB = Symbol('consumeChunkSub')\nconst CONSUMEBODY = Symbol('consumeBody')\nconst CONSUMEMETA = Symbol('consumeMeta')\nconst CONSUMEHEADER = Symbol('consumeHeader')\nconst CONSUMING = Symbol('consuming')\nconst BUFFERCONCAT = Symbol('bufferConcat')\nconst MAYBEEND = Symbol('maybeEnd')\nconst WRITING = Symbol('writing')\nconst ABORTED = Symbol('aborted')\nconst DONE = Symbol('onDone')\n\nconst noop = _ => true\n\nmodule.exports = warner(class Parser extends EE {\n  constructor (opt) {\n    opt = opt || {}\n    super(opt)\n\n    if (opt.ondone)\n      this.on(DONE, opt.ondone)\n    else\n      this.on(DONE, _ => {\n        this.emit('prefinish')\n        this.emit('finish')\n        this.emit('end')\n        this.emit('close')\n      })\n\n    this.strict = !!opt.strict\n    this.maxMetaEntrySize = opt.maxMetaEntrySize || maxMetaEntrySize\n    this.filter = typeof opt.filter === 'function' ? opt.filter : noop\n\n    // have to set this so that streams are ok piping into it\n    this.writable = true\n    this.readable = false\n\n    this[QUEUE] = new Yallist()\n    this[BUFFER] = null\n    this[READENTRY] = null\n    this[WRITEENTRY] = null\n    this[STATE] = 'begin'\n    this[META] = ''\n    this[EX] = null\n    this[GEX] = null\n    this[ENDED] = false\n    this[UNZIP] = null\n    this[ABORTED] = false\n    if (typeof opt.onwarn === 'function')\n      this.on('warn', opt.onwarn)\n    if (typeof opt.onentry === 'function')\n      this.on('entry', opt.onentry)\n  }\n\n  [CONSUMEHEADER] (chunk, position) {\n    let header\n    try {\n      header = new Header(chunk, position, this[EX], this[GEX])\n    } catch (er) {\n      return this.warn('invalid entry', er)\n    }\n\n    if (header.nullBlock)\n      this[EMIT]('nullBlock')\n    else if (!header.cksumValid)\n      this.warn('invalid entry', header)\n    else if (!header.path)\n      this.warn('invalid: path is required', header)\n    else {\n      const type = header.type\n      if (/^(Symbolic)?Link$/.test(type) && !header.linkpath)\n        this.warn('invalid: linkpath required', header)\n      else if (!/^(Symbolic)?Link$/.test(type) && header.linkpath)\n        this.warn('invalid: linkpath forbidden', header)\n      else {\n        const entry = this[WRITEENTRY] = new Entry(header, this[EX], this[GEX])\n\n        if (entry.meta) {\n          if (entry.size > this.maxMetaEntrySize) {\n            entry.ignore = true\n            this[EMIT]('ignoredEntry', entry)\n            this[STATE] = 'ignore'\n          } else if (entry.size > 0) {\n            this[META] = ''\n            entry.on('data', c => this[META] += c)\n            this[STATE] = 'meta'\n          }\n        } else {\n\n          this[EX] = null\n          entry.ignore = entry.ignore || !this.filter(entry.path, entry)\n          if (entry.ignore) {\n            this[EMIT]('ignoredEntry', entry)\n            this[STATE] = entry.remain ? 'ignore' : 'begin'\n          } else {\n            if (entry.remain)\n              this[STATE] = 'body'\n            else {\n              this[STATE] = 'begin'\n              entry.end()\n            }\n\n            if (!this[READENTRY]) {\n              this[QUEUE].push(entry)\n              this[NEXTENTRY]()\n            } else\n              this[QUEUE].push(entry)\n          }\n        }\n      }\n    }\n  }\n\n  [PROCESSENTRY] (entry) {\n    let go = true\n\n    if (!entry) {\n      this[READENTRY] = null\n      go = false\n    } else if (Array.isArray(entry))\n      this.emit.apply(this, entry)\n    else {\n      this[READENTRY] = entry\n      this.emit('entry', entry)\n      if (!entry.emittedEnd) {\n        entry.on('end', _ => this[NEXTENTRY]())\n        go = false\n      }\n    }\n\n    return go\n  }\n\n  [NEXTENTRY] () {\n    do {} while (this[PROCESSENTRY](this[QUEUE].shift()))\n\n    if (!this[QUEUE].length) {\n      // At this point, there's nothing in the queue, but we may have an\n      // entry which is being consumed (readEntry).\n      // If we don't, then we definitely can handle more data.\n      // If we do, and either it's flowing, or it has never had any data\n      // written to it, then it needs more.\n      // The only other possibility is that it has returned false from a\n      // write() call, so we wait for the next drain to continue.\n      const re = this[READENTRY]\n      const drainNow = !re || re.flowing || re.size === re.remain\n      if (drainNow) {\n        if (!this[WRITING])\n          this.emit('drain')\n      } else\n        re.once('drain', _ => this.emit('drain'))\n     }\n  }\n\n  [CONSUMEBODY] (chunk, position) {\n    // write up to but no  more than writeEntry.blockRemain\n    const entry = this[WRITEENTRY]\n    const br = entry.blockRemain\n    const c = (br >= chunk.length && position === 0) ? chunk\n      : chunk.slice(position, position + br)\n\n    entry.write(c)\n\n    if (!entry.blockRemain) {\n      this[STATE] = 'begin'\n      this[WRITEENTRY] = null\n      entry.end()\n    }\n\n    return c.length\n  }\n\n  [CONSUMEMETA] (chunk, position) {\n    const entry = this[WRITEENTRY]\n    const ret = this[CONSUMEBODY](chunk, position)\n\n    // if we finished, then the entry is reset\n    if (!this[WRITEENTRY])\n      this[EMITMETA](entry)\n\n    return ret\n  }\n\n  [EMIT] (ev, data, extra) {\n    if (!this[QUEUE].length && !this[READENTRY])\n      this.emit(ev, data, extra)\n    else\n      this[QUEUE].push([ev, data, extra])\n  }\n\n  [EMITMETA] (entry) {\n    this[EMIT]('meta', this[META])\n    switch (entry.type) {\n      case 'ExtendedHeader':\n      case 'OldExtendedHeader':\n        this[EX] = Pax.parse(this[META], this[EX], false)\n        break\n\n      case 'GlobalExtendedHeader':\n        this[GEX] = Pax.parse(this[META], this[GEX], true)\n        break\n\n      case 'NextFileHasLongPath':\n      case 'OldGnuLongPath':\n        this[EX] = this[EX] || Object.create(null)\n        this[EX].path = this[META].replace(/\\0.*/, '')\n        break\n\n      case 'NextFileHasLongLinkpath':\n        this[EX] = this[EX] || Object.create(null)\n        this[EX].linkpath = this[META].replace(/\\0.*/, '')\n        break\n\n      /* istanbul ignore next */\n      default: throw new Error('unknown meta: ' + entry.type)\n    }\n  }\n\n  abort (msg, error) {\n    this[ABORTED] = true\n    this.warn(msg, error)\n    this.emit('abort', error)\n    this.emit('error', error)\n  }\n\n  write (chunk) {\n    if (this[ABORTED])\n      return\n\n    // first write, might be gzipped\n    if (this[UNZIP] === null && chunk) {\n      if (this[BUFFER]) {\n        chunk = Buffer.concat([this[BUFFER], chunk])\n        this[BUFFER] = null\n      }\n      if (chunk.length < gzipHeader.length) {\n        this[BUFFER] = chunk\n        return true\n      }\n      for (let i = 0; this[UNZIP] === null && i < gzipHeader.length; i++) {\n        if (chunk[i] !== gzipHeader[i])\n          this[UNZIP] = false\n      }\n      if (this[UNZIP] === null) {\n        const ended = this[ENDED]\n        this[ENDED] = false\n        this[UNZIP] = new zlib.Unzip()\n        this[UNZIP].on('data', chunk => this[CONSUMECHUNK](chunk))\n        this[UNZIP].on('error', er =>\n          this.abort(er.message, er))\n        this[UNZIP].on('end', _ => {\n          this[ENDED] = true\n          this[CONSUMECHUNK]()\n        })\n        this[WRITING] = true\n        const ret = this[UNZIP][ended ? 'end' : 'write' ](chunk)\n        this[WRITING] = false\n        return ret\n      }\n    }\n\n    this[WRITING] = true\n    if (this[UNZIP])\n      this[UNZIP].write(chunk)\n    else\n      this[CONSUMECHUNK](chunk)\n    this[WRITING] = false\n\n    // return false if there's a queue, or if the current entry isn't flowing\n    const ret =\n      this[QUEUE].length ? false :\n      this[READENTRY] ? this[READENTRY].flowing :\n      true\n\n    // if we have no queue, then that means a clogged READENTRY\n    if (!ret && !this[QUEUE].length)\n      this[READENTRY].once('drain', _ => this.emit('drain'))\n\n    return ret\n  }\n\n  [BUFFERCONCAT] (c) {\n    if (c && !this[ABORTED])\n      this[BUFFER] = this[BUFFER] ? Buffer.concat([this[BUFFER], c]) : c\n  }\n\n  [MAYBEEND] () {\n    if (this[ENDED] &&\n        !this[EMITTEDEND] &&\n        !this[ABORTED] &&\n        !this[CONSUMING]) {\n      this[EMITTEDEND] = true\n      const entry = this[WRITEENTRY]\n      if (entry && entry.blockRemain) {\n        const have = this[BUFFER] ? this[BUFFER].length : 0\n        this.warn('Truncated input (needed ' + entry.blockRemain +\n                  ' more bytes, only ' + have + ' available)', entry)\n        if (this[BUFFER])\n          entry.write(this[BUFFER])\n        entry.end()\n      }\n      this[EMIT](DONE)\n    }\n  }\n\n  [CONSUMECHUNK] (chunk) {\n    if (this[CONSUMING]) {\n      this[BUFFERCONCAT](chunk)\n    } else if (!chunk && !this[BUFFER]) {\n      this[MAYBEEND]()\n    } else {\n      this[CONSUMING] = true\n      if (this[BUFFER]) {\n        this[BUFFERCONCAT](chunk)\n        const c = this[BUFFER]\n        this[BUFFER] = null\n        this[CONSUMECHUNKSUB](c)\n      } else {\n        this[CONSUMECHUNKSUB](chunk)\n      }\n\n      while (this[BUFFER] && this[BUFFER].length >= 512 && !this[ABORTED]) {\n        const c = this[BUFFER]\n        this[BUFFER] = null\n        this[CONSUMECHUNKSUB](c)\n      }\n      this[CONSUMING] = false\n    }\n\n    if (!this[BUFFER] || this[ENDED])\n      this[MAYBEEND]()\n  }\n\n  [CONSUMECHUNKSUB] (chunk) {\n    // we know that we are in CONSUMING mode, so anything written goes into\n    // the buffer.  Advance the position and put any remainder in the buffer.\n    let position = 0\n    let length = chunk.length\n    while (position + 512 <= length && !this[ABORTED]) {\n      switch (this[STATE]) {\n        case 'begin':\n          this[CONSUMEHEADER](chunk, position)\n          position += 512\n          break\n\n        case 'ignore':\n        case 'body':\n          position += this[CONSUMEBODY](chunk, position)\n          break\n\n        case 'meta':\n          position += this[CONSUMEMETA](chunk, position)\n          break\n\n        /* istanbul ignore next */\n        default:\n          throw new Error('invalid state: ' + this[STATE])\n      }\n    }\n\n    if (position < length) {\n      if (this[BUFFER])\n        this[BUFFER] = Buffer.concat([chunk.slice(position), this[BUFFER]])\n      else\n        this[BUFFER] = chunk.slice(position)\n    }\n  }\n\n  end (chunk) {\n    if (!this[ABORTED]) {\n      if (this[UNZIP])\n        this[UNZIP].end(chunk)\n      else {\n        this[ENDED] = true\n        this.write(chunk)\n      }\n    }\n  }\n})\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvc3dhcm0tanMvbm9kZV9tb2R1bGVzL3Rhci9saWIvcGFyc2UuanMiLCJtYXBwaW5ncyI6IkFBQVk7O0FBRVo7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUEsZUFBZSxtQkFBTyxDQUFDLHlGQUFpQjtBQUN4QyxhQUFhLG1CQUFPLENBQUMsa0JBQU07QUFDM0IsZUFBZSxtQkFBTyxDQUFDLGlGQUFhO0FBQ3BDLFdBQVcsbUJBQU8sQ0FBQyxzQkFBUTtBQUMzQixnQkFBZ0IsbUJBQU8sQ0FBQyw4RUFBUztBQUNqQztBQUNBLGNBQWMsbUJBQU8sQ0FBQyx5RkFBaUI7QUFDdkMsWUFBWSxtQkFBTyxDQUFDLDJFQUFVO0FBQzlCLGFBQWEsbUJBQU8sQ0FBQyw4RUFBVTtBQUMvQixlQUFlLG1CQUFPLENBQUMsaUZBQWE7O0FBRXBDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTzs7QUFFUDtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsWUFBWTtBQUNaO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsVUFBVTs7QUFFVjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsWUFBWTtBQUNaO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxjQUFjO0FBQ2Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0EsVUFBVTs7QUFFVjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFFBQVE7QUFDUjtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxzQkFBc0IsK0NBQStDO0FBQ3JFO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFFBQVE7QUFDUjtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQyIsInNvdXJjZXMiOlsiL1VzZXJzL3BhbnphL0RvY3VtZW50cy9QZXJzb25hbFByb2plY3RzL3ByZWRpay9ub2RlX21vZHVsZXMvc3dhcm0tanMvbm9kZV9tb2R1bGVzL3Rhci9saWIvcGFyc2UuanMiXSwic291cmNlc0NvbnRlbnQiOlsiJ3VzZSBzdHJpY3QnXG5cbi8vIHRoaXNbQlVGRkVSXSBpcyB0aGUgcmVtYWluZGVyIG9mIGEgY2h1bmsgaWYgd2UncmUgd2FpdGluZyBmb3Jcbi8vIHRoZSBmdWxsIDUxMiBieXRlcyBvZiBhIGhlYWRlciB0byBjb21lIGluLiAgV2Ugd2lsbCBCdWZmZXIuY29uY2F0KClcbi8vIGl0IHRvIHRoZSBuZXh0IHdyaXRlKCksIHdoaWNoIGlzIGEgbWVtIGNvcHksIGJ1dCBhIHNtYWxsIG9uZS5cbi8vXG4vLyB0aGlzW1FVRVVFXSBpcyBhIFlhbGxpc3Qgb2YgZW50cmllcyB0aGF0IGhhdmVuJ3QgYmVlbiBlbWl0dGVkXG4vLyB5ZXQgdGhpcyBjYW4gb25seSBnZXQgZmlsbGVkIHVwIGlmIHRoZSB1c2VyIGtlZXBzIHdyaXRlKClpbmcgYWZ0ZXJcbi8vIGEgd3JpdGUoKSByZXR1cm5zIGZhbHNlLCBvciBkb2VzIGEgd3JpdGUoKSB3aXRoIG1vcmUgdGhhbiBvbmUgZW50cnlcbi8vXG4vLyBXZSBkb24ndCBidWZmZXIgY2h1bmtzLCB3ZSBhbHdheXMgcGFyc2UgdGhlbSBhbmQgZWl0aGVyIGNyZWF0ZSBhblxuLy8gZW50cnksIG9yIHB1c2ggaXQgaW50byB0aGUgYWN0aXZlIGVudHJ5LiAgVGhlIFJlYWRFbnRyeSBjbGFzcyBrbm93c1xuLy8gdG8gdGhyb3cgZGF0YSBhd2F5IGlmIC5pZ25vcmU9dHJ1ZVxuLy9cbi8vIFNoaWZ0IGVudHJ5IG9mZiB0aGUgYnVmZmVyIHdoZW4gaXQgZW1pdHMgJ2VuZCcsIGFuZCBlbWl0ICdlbnRyeScgZm9yXG4vLyB0aGUgbmV4dCBvbmUgaW4gdGhlIGxpc3QuXG4vL1xuLy8gQXQgYW55IHRpbWUsIHdlJ3JlIHB1c2hpbmcgYm9keSBjaHVua3MgaW50byB0aGUgZW50cnkgYXQgV1JJVEVFTlRSWSxcbi8vIGFuZCB3YWl0aW5nIGZvciAnZW5kJyBvbiB0aGUgZW50cnkgYXQgUkVBREVOVFJZXG4vL1xuLy8gaWdub3JlZCBlbnRyaWVzIGdldCAucmVzdW1lKCkgY2FsbGVkIG9uIHRoZW0gc3RyYWlnaHQgYXdheVxuXG5jb25zdCB3YXJuZXIgPSByZXF1aXJlKCcuL3dhcm4tbWl4aW4uanMnKVxuY29uc3QgcGF0aCA9IHJlcXVpcmUoJ3BhdGgnKVxuY29uc3QgSGVhZGVyID0gcmVxdWlyZSgnLi9oZWFkZXIuanMnKVxuY29uc3QgRUUgPSByZXF1aXJlKCdldmVudHMnKVxuY29uc3QgWWFsbGlzdCA9IHJlcXVpcmUoJ3lhbGxpc3QnKVxuY29uc3QgbWF4TWV0YUVudHJ5U2l6ZSA9IDEwMjQgKiAxMDI0XG5jb25zdCBFbnRyeSA9IHJlcXVpcmUoJy4vcmVhZC1lbnRyeS5qcycpXG5jb25zdCBQYXggPSByZXF1aXJlKCcuL3BheC5qcycpXG5jb25zdCB6bGliID0gcmVxdWlyZSgnbWluaXpsaWInKVxuY29uc3QgQnVmZmVyID0gcmVxdWlyZSgnLi9idWZmZXIuanMnKVxuXG5jb25zdCBnemlwSGVhZGVyID0gQnVmZmVyLmZyb20oWzB4MWYsIDB4OGJdKVxuY29uc3QgU1RBVEUgPSBTeW1ib2woJ3N0YXRlJylcbmNvbnN0IFdSSVRFRU5UUlkgPSBTeW1ib2woJ3dyaXRlRW50cnknKVxuY29uc3QgUkVBREVOVFJZID0gU3ltYm9sKCdyZWFkRW50cnknKVxuY29uc3QgTkVYVEVOVFJZID0gU3ltYm9sKCduZXh0RW50cnknKVxuY29uc3QgUFJPQ0VTU0VOVFJZID0gU3ltYm9sKCdwcm9jZXNzRW50cnknKVxuY29uc3QgRVggPSBTeW1ib2woJ2V4dGVuZGVkSGVhZGVyJylcbmNvbnN0IEdFWCA9IFN5bWJvbCgnZ2xvYmFsRXh0ZW5kZWRIZWFkZXInKVxuY29uc3QgTUVUQSA9IFN5bWJvbCgnbWV0YScpXG5jb25zdCBFTUlUTUVUQSA9IFN5bWJvbCgnZW1pdE1ldGEnKVxuY29uc3QgQlVGRkVSID0gU3ltYm9sKCdidWZmZXInKVxuY29uc3QgUVVFVUUgPSBTeW1ib2woJ3F1ZXVlJylcbmNvbnN0IEVOREVEID0gU3ltYm9sKCdlbmRlZCcpXG5jb25zdCBFTUlUVEVERU5EID0gU3ltYm9sKCdlbWl0dGVkRW5kJylcbmNvbnN0IEVNSVQgPSBTeW1ib2woJ2VtaXQnKVxuY29uc3QgVU5aSVAgPSBTeW1ib2woJ3VuemlwJylcbmNvbnN0IENPTlNVTUVDSFVOSyA9IFN5bWJvbCgnY29uc3VtZUNodW5rJylcbmNvbnN0IENPTlNVTUVDSFVOS1NVQiA9IFN5bWJvbCgnY29uc3VtZUNodW5rU3ViJylcbmNvbnN0IENPTlNVTUVCT0RZID0gU3ltYm9sKCdjb25zdW1lQm9keScpXG5jb25zdCBDT05TVU1FTUVUQSA9IFN5bWJvbCgnY29uc3VtZU1ldGEnKVxuY29uc3QgQ09OU1VNRUhFQURFUiA9IFN5bWJvbCgnY29uc3VtZUhlYWRlcicpXG5jb25zdCBDT05TVU1JTkcgPSBTeW1ib2woJ2NvbnN1bWluZycpXG5jb25zdCBCVUZGRVJDT05DQVQgPSBTeW1ib2woJ2J1ZmZlckNvbmNhdCcpXG5jb25zdCBNQVlCRUVORCA9IFN5bWJvbCgnbWF5YmVFbmQnKVxuY29uc3QgV1JJVElORyA9IFN5bWJvbCgnd3JpdGluZycpXG5jb25zdCBBQk9SVEVEID0gU3ltYm9sKCdhYm9ydGVkJylcbmNvbnN0IERPTkUgPSBTeW1ib2woJ29uRG9uZScpXG5cbmNvbnN0IG5vb3AgPSBfID0+IHRydWVcblxubW9kdWxlLmV4cG9ydHMgPSB3YXJuZXIoY2xhc3MgUGFyc2VyIGV4dGVuZHMgRUUge1xuICBjb25zdHJ1Y3RvciAob3B0KSB7XG4gICAgb3B0ID0gb3B0IHx8IHt9XG4gICAgc3VwZXIob3B0KVxuXG4gICAgaWYgKG9wdC5vbmRvbmUpXG4gICAgICB0aGlzLm9uKERPTkUsIG9wdC5vbmRvbmUpXG4gICAgZWxzZVxuICAgICAgdGhpcy5vbihET05FLCBfID0+IHtcbiAgICAgICAgdGhpcy5lbWl0KCdwcmVmaW5pc2gnKVxuICAgICAgICB0aGlzLmVtaXQoJ2ZpbmlzaCcpXG4gICAgICAgIHRoaXMuZW1pdCgnZW5kJylcbiAgICAgICAgdGhpcy5lbWl0KCdjbG9zZScpXG4gICAgICB9KVxuXG4gICAgdGhpcy5zdHJpY3QgPSAhIW9wdC5zdHJpY3RcbiAgICB0aGlzLm1heE1ldGFFbnRyeVNpemUgPSBvcHQubWF4TWV0YUVudHJ5U2l6ZSB8fCBtYXhNZXRhRW50cnlTaXplXG4gICAgdGhpcy5maWx0ZXIgPSB0eXBlb2Ygb3B0LmZpbHRlciA9PT0gJ2Z1bmN0aW9uJyA/IG9wdC5maWx0ZXIgOiBub29wXG5cbiAgICAvLyBoYXZlIHRvIHNldCB0aGlzIHNvIHRoYXQgc3RyZWFtcyBhcmUgb2sgcGlwaW5nIGludG8gaXRcbiAgICB0aGlzLndyaXRhYmxlID0gdHJ1ZVxuICAgIHRoaXMucmVhZGFibGUgPSBmYWxzZVxuXG4gICAgdGhpc1tRVUVVRV0gPSBuZXcgWWFsbGlzdCgpXG4gICAgdGhpc1tCVUZGRVJdID0gbnVsbFxuICAgIHRoaXNbUkVBREVOVFJZXSA9IG51bGxcbiAgICB0aGlzW1dSSVRFRU5UUlldID0gbnVsbFxuICAgIHRoaXNbU1RBVEVdID0gJ2JlZ2luJ1xuICAgIHRoaXNbTUVUQV0gPSAnJ1xuICAgIHRoaXNbRVhdID0gbnVsbFxuICAgIHRoaXNbR0VYXSA9IG51bGxcbiAgICB0aGlzW0VOREVEXSA9IGZhbHNlXG4gICAgdGhpc1tVTlpJUF0gPSBudWxsXG4gICAgdGhpc1tBQk9SVEVEXSA9IGZhbHNlXG4gICAgaWYgKHR5cGVvZiBvcHQub253YXJuID09PSAnZnVuY3Rpb24nKVxuICAgICAgdGhpcy5vbignd2FybicsIG9wdC5vbndhcm4pXG4gICAgaWYgKHR5cGVvZiBvcHQub25lbnRyeSA9PT0gJ2Z1bmN0aW9uJylcbiAgICAgIHRoaXMub24oJ2VudHJ5Jywgb3B0Lm9uZW50cnkpXG4gIH1cblxuICBbQ09OU1VNRUhFQURFUl0gKGNodW5rLCBwb3NpdGlvbikge1xuICAgIGxldCBoZWFkZXJcbiAgICB0cnkge1xuICAgICAgaGVhZGVyID0gbmV3IEhlYWRlcihjaHVuaywgcG9zaXRpb24sIHRoaXNbRVhdLCB0aGlzW0dFWF0pXG4gICAgfSBjYXRjaCAoZXIpIHtcbiAgICAgIHJldHVybiB0aGlzLndhcm4oJ2ludmFsaWQgZW50cnknLCBlcilcbiAgICB9XG5cbiAgICBpZiAoaGVhZGVyLm51bGxCbG9jaylcbiAgICAgIHRoaXNbRU1JVF0oJ251bGxCbG9jaycpXG4gICAgZWxzZSBpZiAoIWhlYWRlci5ja3N1bVZhbGlkKVxuICAgICAgdGhpcy53YXJuKCdpbnZhbGlkIGVudHJ5JywgaGVhZGVyKVxuICAgIGVsc2UgaWYgKCFoZWFkZXIucGF0aClcbiAgICAgIHRoaXMud2FybignaW52YWxpZDogcGF0aCBpcyByZXF1aXJlZCcsIGhlYWRlcilcbiAgICBlbHNlIHtcbiAgICAgIGNvbnN0IHR5cGUgPSBoZWFkZXIudHlwZVxuICAgICAgaWYgKC9eKFN5bWJvbGljKT9MaW5rJC8udGVzdCh0eXBlKSAmJiAhaGVhZGVyLmxpbmtwYXRoKVxuICAgICAgICB0aGlzLndhcm4oJ2ludmFsaWQ6IGxpbmtwYXRoIHJlcXVpcmVkJywgaGVhZGVyKVxuICAgICAgZWxzZSBpZiAoIS9eKFN5bWJvbGljKT9MaW5rJC8udGVzdCh0eXBlKSAmJiBoZWFkZXIubGlua3BhdGgpXG4gICAgICAgIHRoaXMud2FybignaW52YWxpZDogbGlua3BhdGggZm9yYmlkZGVuJywgaGVhZGVyKVxuICAgICAgZWxzZSB7XG4gICAgICAgIGNvbnN0IGVudHJ5ID0gdGhpc1tXUklURUVOVFJZXSA9IG5ldyBFbnRyeShoZWFkZXIsIHRoaXNbRVhdLCB0aGlzW0dFWF0pXG5cbiAgICAgICAgaWYgKGVudHJ5Lm1ldGEpIHtcbiAgICAgICAgICBpZiAoZW50cnkuc2l6ZSA+IHRoaXMubWF4TWV0YUVudHJ5U2l6ZSkge1xuICAgICAgICAgICAgZW50cnkuaWdub3JlID0gdHJ1ZVxuICAgICAgICAgICAgdGhpc1tFTUlUXSgnaWdub3JlZEVudHJ5JywgZW50cnkpXG4gICAgICAgICAgICB0aGlzW1NUQVRFXSA9ICdpZ25vcmUnXG4gICAgICAgICAgfSBlbHNlIGlmIChlbnRyeS5zaXplID4gMCkge1xuICAgICAgICAgICAgdGhpc1tNRVRBXSA9ICcnXG4gICAgICAgICAgICBlbnRyeS5vbignZGF0YScsIGMgPT4gdGhpc1tNRVRBXSArPSBjKVxuICAgICAgICAgICAgdGhpc1tTVEFURV0gPSAnbWV0YSdcbiAgICAgICAgICB9XG4gICAgICAgIH0gZWxzZSB7XG5cbiAgICAgICAgICB0aGlzW0VYXSA9IG51bGxcbiAgICAgICAgICBlbnRyeS5pZ25vcmUgPSBlbnRyeS5pZ25vcmUgfHwgIXRoaXMuZmlsdGVyKGVudHJ5LnBhdGgsIGVudHJ5KVxuICAgICAgICAgIGlmIChlbnRyeS5pZ25vcmUpIHtcbiAgICAgICAgICAgIHRoaXNbRU1JVF0oJ2lnbm9yZWRFbnRyeScsIGVudHJ5KVxuICAgICAgICAgICAgdGhpc1tTVEFURV0gPSBlbnRyeS5yZW1haW4gPyAnaWdub3JlJyA6ICdiZWdpbidcbiAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgaWYgKGVudHJ5LnJlbWFpbilcbiAgICAgICAgICAgICAgdGhpc1tTVEFURV0gPSAnYm9keSdcbiAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICB0aGlzW1NUQVRFXSA9ICdiZWdpbidcbiAgICAgICAgICAgICAgZW50cnkuZW5kKClcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgaWYgKCF0aGlzW1JFQURFTlRSWV0pIHtcbiAgICAgICAgICAgICAgdGhpc1tRVUVVRV0ucHVzaChlbnRyeSlcbiAgICAgICAgICAgICAgdGhpc1tORVhURU5UUlldKClcbiAgICAgICAgICAgIH0gZWxzZVxuICAgICAgICAgICAgICB0aGlzW1FVRVVFXS5wdXNoKGVudHJ5KVxuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cbiAgfVxuXG4gIFtQUk9DRVNTRU5UUlldIChlbnRyeSkge1xuICAgIGxldCBnbyA9IHRydWVcblxuICAgIGlmICghZW50cnkpIHtcbiAgICAgIHRoaXNbUkVBREVOVFJZXSA9IG51bGxcbiAgICAgIGdvID0gZmFsc2VcbiAgICB9IGVsc2UgaWYgKEFycmF5LmlzQXJyYXkoZW50cnkpKVxuICAgICAgdGhpcy5lbWl0LmFwcGx5KHRoaXMsIGVudHJ5KVxuICAgIGVsc2Uge1xuICAgICAgdGhpc1tSRUFERU5UUlldID0gZW50cnlcbiAgICAgIHRoaXMuZW1pdCgnZW50cnknLCBlbnRyeSlcbiAgICAgIGlmICghZW50cnkuZW1pdHRlZEVuZCkge1xuICAgICAgICBlbnRyeS5vbignZW5kJywgXyA9PiB0aGlzW05FWFRFTlRSWV0oKSlcbiAgICAgICAgZ28gPSBmYWxzZVxuICAgICAgfVxuICAgIH1cblxuICAgIHJldHVybiBnb1xuICB9XG5cbiAgW05FWFRFTlRSWV0gKCkge1xuICAgIGRvIHt9IHdoaWxlICh0aGlzW1BST0NFU1NFTlRSWV0odGhpc1tRVUVVRV0uc2hpZnQoKSkpXG5cbiAgICBpZiAoIXRoaXNbUVVFVUVdLmxlbmd0aCkge1xuICAgICAgLy8gQXQgdGhpcyBwb2ludCwgdGhlcmUncyBub3RoaW5nIGluIHRoZSBxdWV1ZSwgYnV0IHdlIG1heSBoYXZlIGFuXG4gICAgICAvLyBlbnRyeSB3aGljaCBpcyBiZWluZyBjb25zdW1lZCAocmVhZEVudHJ5KS5cbiAgICAgIC8vIElmIHdlIGRvbid0LCB0aGVuIHdlIGRlZmluaXRlbHkgY2FuIGhhbmRsZSBtb3JlIGRhdGEuXG4gICAgICAvLyBJZiB3ZSBkbywgYW5kIGVpdGhlciBpdCdzIGZsb3dpbmcsIG9yIGl0IGhhcyBuZXZlciBoYWQgYW55IGRhdGFcbiAgICAgIC8vIHdyaXR0ZW4gdG8gaXQsIHRoZW4gaXQgbmVlZHMgbW9yZS5cbiAgICAgIC8vIFRoZSBvbmx5IG90aGVyIHBvc3NpYmlsaXR5IGlzIHRoYXQgaXQgaGFzIHJldHVybmVkIGZhbHNlIGZyb20gYVxuICAgICAgLy8gd3JpdGUoKSBjYWxsLCBzbyB3ZSB3YWl0IGZvciB0aGUgbmV4dCBkcmFpbiB0byBjb250aW51ZS5cbiAgICAgIGNvbnN0IHJlID0gdGhpc1tSRUFERU5UUlldXG4gICAgICBjb25zdCBkcmFpbk5vdyA9ICFyZSB8fCByZS5mbG93aW5nIHx8IHJlLnNpemUgPT09IHJlLnJlbWFpblxuICAgICAgaWYgKGRyYWluTm93KSB7XG4gICAgICAgIGlmICghdGhpc1tXUklUSU5HXSlcbiAgICAgICAgICB0aGlzLmVtaXQoJ2RyYWluJylcbiAgICAgIH0gZWxzZVxuICAgICAgICByZS5vbmNlKCdkcmFpbicsIF8gPT4gdGhpcy5lbWl0KCdkcmFpbicpKVxuICAgICB9XG4gIH1cblxuICBbQ09OU1VNRUJPRFldIChjaHVuaywgcG9zaXRpb24pIHtcbiAgICAvLyB3cml0ZSB1cCB0byBidXQgbm8gIG1vcmUgdGhhbiB3cml0ZUVudHJ5LmJsb2NrUmVtYWluXG4gICAgY29uc3QgZW50cnkgPSB0aGlzW1dSSVRFRU5UUlldXG4gICAgY29uc3QgYnIgPSBlbnRyeS5ibG9ja1JlbWFpblxuICAgIGNvbnN0IGMgPSAoYnIgPj0gY2h1bmsubGVuZ3RoICYmIHBvc2l0aW9uID09PSAwKSA/IGNodW5rXG4gICAgICA6IGNodW5rLnNsaWNlKHBvc2l0aW9uLCBwb3NpdGlvbiArIGJyKVxuXG4gICAgZW50cnkud3JpdGUoYylcblxuICAgIGlmICghZW50cnkuYmxvY2tSZW1haW4pIHtcbiAgICAgIHRoaXNbU1RBVEVdID0gJ2JlZ2luJ1xuICAgICAgdGhpc1tXUklURUVOVFJZXSA9IG51bGxcbiAgICAgIGVudHJ5LmVuZCgpXG4gICAgfVxuXG4gICAgcmV0dXJuIGMubGVuZ3RoXG4gIH1cblxuICBbQ09OU1VNRU1FVEFdIChjaHVuaywgcG9zaXRpb24pIHtcbiAgICBjb25zdCBlbnRyeSA9IHRoaXNbV1JJVEVFTlRSWV1cbiAgICBjb25zdCByZXQgPSB0aGlzW0NPTlNVTUVCT0RZXShjaHVuaywgcG9zaXRpb24pXG5cbiAgICAvLyBpZiB3ZSBmaW5pc2hlZCwgdGhlbiB0aGUgZW50cnkgaXMgcmVzZXRcbiAgICBpZiAoIXRoaXNbV1JJVEVFTlRSWV0pXG4gICAgICB0aGlzW0VNSVRNRVRBXShlbnRyeSlcblxuICAgIHJldHVybiByZXRcbiAgfVxuXG4gIFtFTUlUXSAoZXYsIGRhdGEsIGV4dHJhKSB7XG4gICAgaWYgKCF0aGlzW1FVRVVFXS5sZW5ndGggJiYgIXRoaXNbUkVBREVOVFJZXSlcbiAgICAgIHRoaXMuZW1pdChldiwgZGF0YSwgZXh0cmEpXG4gICAgZWxzZVxuICAgICAgdGhpc1tRVUVVRV0ucHVzaChbZXYsIGRhdGEsIGV4dHJhXSlcbiAgfVxuXG4gIFtFTUlUTUVUQV0gKGVudHJ5KSB7XG4gICAgdGhpc1tFTUlUXSgnbWV0YScsIHRoaXNbTUVUQV0pXG4gICAgc3dpdGNoIChlbnRyeS50eXBlKSB7XG4gICAgICBjYXNlICdFeHRlbmRlZEhlYWRlcic6XG4gICAgICBjYXNlICdPbGRFeHRlbmRlZEhlYWRlcic6XG4gICAgICAgIHRoaXNbRVhdID0gUGF4LnBhcnNlKHRoaXNbTUVUQV0sIHRoaXNbRVhdLCBmYWxzZSlcbiAgICAgICAgYnJlYWtcblxuICAgICAgY2FzZSAnR2xvYmFsRXh0ZW5kZWRIZWFkZXInOlxuICAgICAgICB0aGlzW0dFWF0gPSBQYXgucGFyc2UodGhpc1tNRVRBXSwgdGhpc1tHRVhdLCB0cnVlKVxuICAgICAgICBicmVha1xuXG4gICAgICBjYXNlICdOZXh0RmlsZUhhc0xvbmdQYXRoJzpcbiAgICAgIGNhc2UgJ09sZEdudUxvbmdQYXRoJzpcbiAgICAgICAgdGhpc1tFWF0gPSB0aGlzW0VYXSB8fCBPYmplY3QuY3JlYXRlKG51bGwpXG4gICAgICAgIHRoaXNbRVhdLnBhdGggPSB0aGlzW01FVEFdLnJlcGxhY2UoL1xcMC4qLywgJycpXG4gICAgICAgIGJyZWFrXG5cbiAgICAgIGNhc2UgJ05leHRGaWxlSGFzTG9uZ0xpbmtwYXRoJzpcbiAgICAgICAgdGhpc1tFWF0gPSB0aGlzW0VYXSB8fCBPYmplY3QuY3JlYXRlKG51bGwpXG4gICAgICAgIHRoaXNbRVhdLmxpbmtwYXRoID0gdGhpc1tNRVRBXS5yZXBsYWNlKC9cXDAuKi8sICcnKVxuICAgICAgICBicmVha1xuXG4gICAgICAvKiBpc3RhbmJ1bCBpZ25vcmUgbmV4dCAqL1xuICAgICAgZGVmYXVsdDogdGhyb3cgbmV3IEVycm9yKCd1bmtub3duIG1ldGE6ICcgKyBlbnRyeS50eXBlKVxuICAgIH1cbiAgfVxuXG4gIGFib3J0IChtc2csIGVycm9yKSB7XG4gICAgdGhpc1tBQk9SVEVEXSA9IHRydWVcbiAgICB0aGlzLndhcm4obXNnLCBlcnJvcilcbiAgICB0aGlzLmVtaXQoJ2Fib3J0JywgZXJyb3IpXG4gICAgdGhpcy5lbWl0KCdlcnJvcicsIGVycm9yKVxuICB9XG5cbiAgd3JpdGUgKGNodW5rKSB7XG4gICAgaWYgKHRoaXNbQUJPUlRFRF0pXG4gICAgICByZXR1cm5cblxuICAgIC8vIGZpcnN0IHdyaXRlLCBtaWdodCBiZSBnemlwcGVkXG4gICAgaWYgKHRoaXNbVU5aSVBdID09PSBudWxsICYmIGNodW5rKSB7XG4gICAgICBpZiAodGhpc1tCVUZGRVJdKSB7XG4gICAgICAgIGNodW5rID0gQnVmZmVyLmNvbmNhdChbdGhpc1tCVUZGRVJdLCBjaHVua10pXG4gICAgICAgIHRoaXNbQlVGRkVSXSA9IG51bGxcbiAgICAgIH1cbiAgICAgIGlmIChjaHVuay5sZW5ndGggPCBnemlwSGVhZGVyLmxlbmd0aCkge1xuICAgICAgICB0aGlzW0JVRkZFUl0gPSBjaHVua1xuICAgICAgICByZXR1cm4gdHJ1ZVxuICAgICAgfVxuICAgICAgZm9yIChsZXQgaSA9IDA7IHRoaXNbVU5aSVBdID09PSBudWxsICYmIGkgPCBnemlwSGVhZGVyLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgIGlmIChjaHVua1tpXSAhPT0gZ3ppcEhlYWRlcltpXSlcbiAgICAgICAgICB0aGlzW1VOWklQXSA9IGZhbHNlXG4gICAgICB9XG4gICAgICBpZiAodGhpc1tVTlpJUF0gPT09IG51bGwpIHtcbiAgICAgICAgY29uc3QgZW5kZWQgPSB0aGlzW0VOREVEXVxuICAgICAgICB0aGlzW0VOREVEXSA9IGZhbHNlXG4gICAgICAgIHRoaXNbVU5aSVBdID0gbmV3IHpsaWIuVW56aXAoKVxuICAgICAgICB0aGlzW1VOWklQXS5vbignZGF0YScsIGNodW5rID0+IHRoaXNbQ09OU1VNRUNIVU5LXShjaHVuaykpXG4gICAgICAgIHRoaXNbVU5aSVBdLm9uKCdlcnJvcicsIGVyID0+XG4gICAgICAgICAgdGhpcy5hYm9ydChlci5tZXNzYWdlLCBlcikpXG4gICAgICAgIHRoaXNbVU5aSVBdLm9uKCdlbmQnLCBfID0+IHtcbiAgICAgICAgICB0aGlzW0VOREVEXSA9IHRydWVcbiAgICAgICAgICB0aGlzW0NPTlNVTUVDSFVOS10oKVxuICAgICAgICB9KVxuICAgICAgICB0aGlzW1dSSVRJTkddID0gdHJ1ZVxuICAgICAgICBjb25zdCByZXQgPSB0aGlzW1VOWklQXVtlbmRlZCA/ICdlbmQnIDogJ3dyaXRlJyBdKGNodW5rKVxuICAgICAgICB0aGlzW1dSSVRJTkddID0gZmFsc2VcbiAgICAgICAgcmV0dXJuIHJldFxuICAgICAgfVxuICAgIH1cblxuICAgIHRoaXNbV1JJVElOR10gPSB0cnVlXG4gICAgaWYgKHRoaXNbVU5aSVBdKVxuICAgICAgdGhpc1tVTlpJUF0ud3JpdGUoY2h1bmspXG4gICAgZWxzZVxuICAgICAgdGhpc1tDT05TVU1FQ0hVTktdKGNodW5rKVxuICAgIHRoaXNbV1JJVElOR10gPSBmYWxzZVxuXG4gICAgLy8gcmV0dXJuIGZhbHNlIGlmIHRoZXJlJ3MgYSBxdWV1ZSwgb3IgaWYgdGhlIGN1cnJlbnQgZW50cnkgaXNuJ3QgZmxvd2luZ1xuICAgIGNvbnN0IHJldCA9XG4gICAgICB0aGlzW1FVRVVFXS5sZW5ndGggPyBmYWxzZSA6XG4gICAgICB0aGlzW1JFQURFTlRSWV0gPyB0aGlzW1JFQURFTlRSWV0uZmxvd2luZyA6XG4gICAgICB0cnVlXG5cbiAgICAvLyBpZiB3ZSBoYXZlIG5vIHF1ZXVlLCB0aGVuIHRoYXQgbWVhbnMgYSBjbG9nZ2VkIFJFQURFTlRSWVxuICAgIGlmICghcmV0ICYmICF0aGlzW1FVRVVFXS5sZW5ndGgpXG4gICAgICB0aGlzW1JFQURFTlRSWV0ub25jZSgnZHJhaW4nLCBfID0+IHRoaXMuZW1pdCgnZHJhaW4nKSlcblxuICAgIHJldHVybiByZXRcbiAgfVxuXG4gIFtCVUZGRVJDT05DQVRdIChjKSB7XG4gICAgaWYgKGMgJiYgIXRoaXNbQUJPUlRFRF0pXG4gICAgICB0aGlzW0JVRkZFUl0gPSB0aGlzW0JVRkZFUl0gPyBCdWZmZXIuY29uY2F0KFt0aGlzW0JVRkZFUl0sIGNdKSA6IGNcbiAgfVxuXG4gIFtNQVlCRUVORF0gKCkge1xuICAgIGlmICh0aGlzW0VOREVEXSAmJlxuICAgICAgICAhdGhpc1tFTUlUVEVERU5EXSAmJlxuICAgICAgICAhdGhpc1tBQk9SVEVEXSAmJlxuICAgICAgICAhdGhpc1tDT05TVU1JTkddKSB7XG4gICAgICB0aGlzW0VNSVRURURFTkRdID0gdHJ1ZVxuICAgICAgY29uc3QgZW50cnkgPSB0aGlzW1dSSVRFRU5UUlldXG4gICAgICBpZiAoZW50cnkgJiYgZW50cnkuYmxvY2tSZW1haW4pIHtcbiAgICAgICAgY29uc3QgaGF2ZSA9IHRoaXNbQlVGRkVSXSA/IHRoaXNbQlVGRkVSXS5sZW5ndGggOiAwXG4gICAgICAgIHRoaXMud2FybignVHJ1bmNhdGVkIGlucHV0IChuZWVkZWQgJyArIGVudHJ5LmJsb2NrUmVtYWluICtcbiAgICAgICAgICAgICAgICAgICcgbW9yZSBieXRlcywgb25seSAnICsgaGF2ZSArICcgYXZhaWxhYmxlKScsIGVudHJ5KVxuICAgICAgICBpZiAodGhpc1tCVUZGRVJdKVxuICAgICAgICAgIGVudHJ5LndyaXRlKHRoaXNbQlVGRkVSXSlcbiAgICAgICAgZW50cnkuZW5kKClcbiAgICAgIH1cbiAgICAgIHRoaXNbRU1JVF0oRE9ORSlcbiAgICB9XG4gIH1cblxuICBbQ09OU1VNRUNIVU5LXSAoY2h1bmspIHtcbiAgICBpZiAodGhpc1tDT05TVU1JTkddKSB7XG4gICAgICB0aGlzW0JVRkZFUkNPTkNBVF0oY2h1bmspXG4gICAgfSBlbHNlIGlmICghY2h1bmsgJiYgIXRoaXNbQlVGRkVSXSkge1xuICAgICAgdGhpc1tNQVlCRUVORF0oKVxuICAgIH0gZWxzZSB7XG4gICAgICB0aGlzW0NPTlNVTUlOR10gPSB0cnVlXG4gICAgICBpZiAodGhpc1tCVUZGRVJdKSB7XG4gICAgICAgIHRoaXNbQlVGRkVSQ09OQ0FUXShjaHVuaylcbiAgICAgICAgY29uc3QgYyA9IHRoaXNbQlVGRkVSXVxuICAgICAgICB0aGlzW0JVRkZFUl0gPSBudWxsXG4gICAgICAgIHRoaXNbQ09OU1VNRUNIVU5LU1VCXShjKVxuICAgICAgfSBlbHNlIHtcbiAgICAgICAgdGhpc1tDT05TVU1FQ0hVTktTVUJdKGNodW5rKVxuICAgICAgfVxuXG4gICAgICB3aGlsZSAodGhpc1tCVUZGRVJdICYmIHRoaXNbQlVGRkVSXS5sZW5ndGggPj0gNTEyICYmICF0aGlzW0FCT1JURURdKSB7XG4gICAgICAgIGNvbnN0IGMgPSB0aGlzW0JVRkZFUl1cbiAgICAgICAgdGhpc1tCVUZGRVJdID0gbnVsbFxuICAgICAgICB0aGlzW0NPTlNVTUVDSFVOS1NVQl0oYylcbiAgICAgIH1cbiAgICAgIHRoaXNbQ09OU1VNSU5HXSA9IGZhbHNlXG4gICAgfVxuXG4gICAgaWYgKCF0aGlzW0JVRkZFUl0gfHwgdGhpc1tFTkRFRF0pXG4gICAgICB0aGlzW01BWUJFRU5EXSgpXG4gIH1cblxuICBbQ09OU1VNRUNIVU5LU1VCXSAoY2h1bmspIHtcbiAgICAvLyB3ZSBrbm93IHRoYXQgd2UgYXJlIGluIENPTlNVTUlORyBtb2RlLCBzbyBhbnl0aGluZyB3cml0dGVuIGdvZXMgaW50b1xuICAgIC8vIHRoZSBidWZmZXIuICBBZHZhbmNlIHRoZSBwb3NpdGlvbiBhbmQgcHV0IGFueSByZW1haW5kZXIgaW4gdGhlIGJ1ZmZlci5cbiAgICBsZXQgcG9zaXRpb24gPSAwXG4gICAgbGV0IGxlbmd0aCA9IGNodW5rLmxlbmd0aFxuICAgIHdoaWxlIChwb3NpdGlvbiArIDUxMiA8PSBsZW5ndGggJiYgIXRoaXNbQUJPUlRFRF0pIHtcbiAgICAgIHN3aXRjaCAodGhpc1tTVEFURV0pIHtcbiAgICAgICAgY2FzZSAnYmVnaW4nOlxuICAgICAgICAgIHRoaXNbQ09OU1VNRUhFQURFUl0oY2h1bmssIHBvc2l0aW9uKVxuICAgICAgICAgIHBvc2l0aW9uICs9IDUxMlxuICAgICAgICAgIGJyZWFrXG5cbiAgICAgICAgY2FzZSAnaWdub3JlJzpcbiAgICAgICAgY2FzZSAnYm9keSc6XG4gICAgICAgICAgcG9zaXRpb24gKz0gdGhpc1tDT05TVU1FQk9EWV0oY2h1bmssIHBvc2l0aW9uKVxuICAgICAgICAgIGJyZWFrXG5cbiAgICAgICAgY2FzZSAnbWV0YSc6XG4gICAgICAgICAgcG9zaXRpb24gKz0gdGhpc1tDT05TVU1FTUVUQV0oY2h1bmssIHBvc2l0aW9uKVxuICAgICAgICAgIGJyZWFrXG5cbiAgICAgICAgLyogaXN0YW5idWwgaWdub3JlIG5leHQgKi9cbiAgICAgICAgZGVmYXVsdDpcbiAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ2ludmFsaWQgc3RhdGU6ICcgKyB0aGlzW1NUQVRFXSlcbiAgICAgIH1cbiAgICB9XG5cbiAgICBpZiAocG9zaXRpb24gPCBsZW5ndGgpIHtcbiAgICAgIGlmICh0aGlzW0JVRkZFUl0pXG4gICAgICAgIHRoaXNbQlVGRkVSXSA9IEJ1ZmZlci5jb25jYXQoW2NodW5rLnNsaWNlKHBvc2l0aW9uKSwgdGhpc1tCVUZGRVJdXSlcbiAgICAgIGVsc2VcbiAgICAgICAgdGhpc1tCVUZGRVJdID0gY2h1bmsuc2xpY2UocG9zaXRpb24pXG4gICAgfVxuICB9XG5cbiAgZW5kIChjaHVuaykge1xuICAgIGlmICghdGhpc1tBQk9SVEVEXSkge1xuICAgICAgaWYgKHRoaXNbVU5aSVBdKVxuICAgICAgICB0aGlzW1VOWklQXS5lbmQoY2h1bmspXG4gICAgICBlbHNlIHtcbiAgICAgICAgdGhpc1tFTkRFRF0gPSB0cnVlXG4gICAgICAgIHRoaXMud3JpdGUoY2h1bmspXG4gICAgICB9XG4gICAgfVxuICB9XG59KVxuIl0sIm5hbWVzIjpbXSwiaWdub3JlTGlzdCI6WzBdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/swarm-js/node_modules/tar/lib/parse.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/swarm-js/node_modules/tar/lib/path-reservations.js":
/*!*************************************************************************!*\
  !*** ./node_modules/swarm-js/node_modules/tar/lib/path-reservations.js ***!
  \*************************************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

eval("// A path exclusive reservation system\n// reserve([list, of, paths], fn)\n// When the fn is first in line for all its paths, it\n// is called with a cb that clears the reservation.\n//\n// Used by async unpack to avoid clobbering paths in use,\n// while still allowing maximal safe parallelization.\n\nconst assert = __webpack_require__(/*! assert */ \"assert\")\nconst normPath = __webpack_require__(/*! ./normalize-windows-path.js */ \"(ssr)/./node_modules/swarm-js/node_modules/tar/lib/normalize-windows-path.js\")\nconst stripSlashes = __webpack_require__(/*! ./strip-trailing-slashes.js */ \"(ssr)/./node_modules/swarm-js/node_modules/tar/lib/strip-trailing-slashes.js\")\nconst { join } = __webpack_require__(/*! path */ \"path\")\n\nconst platform = process.env.TESTING_TAR_FAKE_PLATFORM || process.platform\nconst isWindows = platform === 'win32'\n\nmodule.exports = () => {\n  // path => [function or Set]\n  // A Set object means a directory reservation\n  // A fn is a direct reservation on that path\n  const queues = new Map()\n\n  // fn => {paths:[path,...], dirs:[path, ...]}\n  const reservations = new Map()\n\n  // return a set of parent dirs for a given path\n  // '/a/b/c/d' -> ['/', '/a', '/a/b', '/a/b/c', '/a/b/c/d']\n  const getDirs = path => {\n    const dirs = path.split('/').slice(0, -1).reduce((set, path) => {\n      if (set.length)\n        path = normPath(join(set[set.length - 1], path))\n      set.push(path || '/')\n      return set\n    }, [])\n    return dirs\n  }\n\n  // functions currently running\n  const running = new Set()\n\n  // return the queues for each path the function cares about\n  // fn => {paths, dirs}\n  const getQueues = fn => {\n    const res = reservations.get(fn)\n    /* istanbul ignore if - unpossible */\n    if (!res)\n      throw new Error('function does not have any path reservations')\n    return {\n      paths: res.paths.map(path => queues.get(path)),\n      dirs: [...res.dirs].map(path => queues.get(path)),\n    }\n  }\n\n  // check if fn is first in line for all its paths, and is\n  // included in the first set for all its dir queues\n  const check = fn => {\n    const {paths, dirs} = getQueues(fn)\n    return paths.every(q => q[0] === fn) &&\n      dirs.every(q => q[0] instanceof Set && q[0].has(fn))\n  }\n\n  // run the function if it's first in line and not already running\n  const run = fn => {\n    if (running.has(fn) || !check(fn))\n      return false\n    running.add(fn)\n    fn(() => clear(fn))\n    return true\n  }\n\n  const clear = fn => {\n    if (!running.has(fn))\n      return false\n\n    const { paths, dirs } = reservations.get(fn)\n    const next = new Set()\n\n    paths.forEach(path => {\n      const q = queues.get(path)\n      assert.equal(q[0], fn)\n      if (q.length === 1)\n        queues.delete(path)\n      else {\n        q.shift()\n        if (typeof q[0] === 'function')\n          next.add(q[0])\n        else\n          q[0].forEach(fn => next.add(fn))\n      }\n    })\n\n    dirs.forEach(dir => {\n      const q = queues.get(dir)\n      assert(q[0] instanceof Set)\n      if (q[0].size === 1 && q.length === 1) {\n        queues.delete(dir)\n      } else if (q[0].size === 1) {\n        q.shift()\n\n        // must be a function or else the Set would've been reused\n        next.add(q[0])\n      } else\n        q[0].delete(fn)\n    })\n    running.delete(fn)\n\n    next.forEach(fn => run(fn))\n    return true\n  }\n\n  const reserve = (paths, fn) => {\n    // collide on matches across case and unicode normalization\n    // On windows, thanks to the magic of 8.3 shortnames, it is fundamentally\n    // impossible to determine whether two paths refer to the same thing on\n    // disk, without asking the kernel for a shortname.\n    // So, we just pretend that every path matches every other path here,\n    // effectively removing all parallelization on windows.\n    paths = isWindows ? ['win32 parallelization disabled'] : paths.map(p => {\n      return stripSlashes(normPath(join(p)))\n        .normalize('NFKD')\n        .toLowerCase()\n    })\n\n    const dirs = new Set(\n      paths.map(path => getDirs(path)).reduce((a, b) => a.concat(b))\n    )\n    reservations.set(fn, {dirs, paths})\n    paths.forEach(path => {\n      const q = queues.get(path)\n      if (!q)\n        queues.set(path, [fn])\n      else\n        q.push(fn)\n    })\n    dirs.forEach(dir => {\n      const q = queues.get(dir)\n      if (!q)\n        queues.set(dir, [new Set([fn])])\n      else if (q[q.length-1] instanceof Set)\n        q[q.length-1].add(fn)\n      else\n        q.push(new Set([fn]))\n    })\n\n    return run(fn)\n  }\n\n  return { check, reserve }\n}\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvc3dhcm0tanMvbm9kZV9tb2R1bGVzL3Rhci9saWIvcGF0aC1yZXNlcnZhdGlvbnMuanMiLCJtYXBwaW5ncyI6IkFBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUEsZUFBZSxtQkFBTyxDQUFDLHNCQUFRO0FBQy9CLGlCQUFpQixtQkFBTyxDQUFDLGlIQUE2QjtBQUN0RCxxQkFBcUIsbUJBQU8sQ0FBQyxpSEFBNkI7QUFDMUQsUUFBUSxPQUFPLEVBQUUsbUJBQU8sQ0FBQyxrQkFBTTs7QUFFL0I7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBLFlBQVk7QUFDWjs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBLFlBQVk7QUFDWjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxXQUFXLGFBQWE7QUFDeEI7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBLFlBQVksY0FBYztBQUMxQjs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLOztBQUVMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxRQUFRO0FBQ1I7O0FBRUE7QUFDQTtBQUNBLFFBQVE7QUFDUjtBQUNBLEtBQUs7QUFDTDs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7O0FBRUw7QUFDQTtBQUNBO0FBQ0EsMEJBQTBCLFlBQVk7QUFDdEM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLOztBQUVMO0FBQ0E7O0FBRUEsV0FBVztBQUNYIiwic291cmNlcyI6WyIvVXNlcnMvcGFuemEvRG9jdW1lbnRzL1BlcnNvbmFsUHJvamVjdHMvcHJlZGlrL25vZGVfbW9kdWxlcy9zd2FybS1qcy9ub2RlX21vZHVsZXMvdGFyL2xpYi9wYXRoLXJlc2VydmF0aW9ucy5qcyJdLCJzb3VyY2VzQ29udGVudCI6WyIvLyBBIHBhdGggZXhjbHVzaXZlIHJlc2VydmF0aW9uIHN5c3RlbVxuLy8gcmVzZXJ2ZShbbGlzdCwgb2YsIHBhdGhzXSwgZm4pXG4vLyBXaGVuIHRoZSBmbiBpcyBmaXJzdCBpbiBsaW5lIGZvciBhbGwgaXRzIHBhdGhzLCBpdFxuLy8gaXMgY2FsbGVkIHdpdGggYSBjYiB0aGF0IGNsZWFycyB0aGUgcmVzZXJ2YXRpb24uXG4vL1xuLy8gVXNlZCBieSBhc3luYyB1bnBhY2sgdG8gYXZvaWQgY2xvYmJlcmluZyBwYXRocyBpbiB1c2UsXG4vLyB3aGlsZSBzdGlsbCBhbGxvd2luZyBtYXhpbWFsIHNhZmUgcGFyYWxsZWxpemF0aW9uLlxuXG5jb25zdCBhc3NlcnQgPSByZXF1aXJlKCdhc3NlcnQnKVxuY29uc3Qgbm9ybVBhdGggPSByZXF1aXJlKCcuL25vcm1hbGl6ZS13aW5kb3dzLXBhdGguanMnKVxuY29uc3Qgc3RyaXBTbGFzaGVzID0gcmVxdWlyZSgnLi9zdHJpcC10cmFpbGluZy1zbGFzaGVzLmpzJylcbmNvbnN0IHsgam9pbiB9ID0gcmVxdWlyZSgncGF0aCcpXG5cbmNvbnN0IHBsYXRmb3JtID0gcHJvY2Vzcy5lbnYuVEVTVElOR19UQVJfRkFLRV9QTEFURk9STSB8fCBwcm9jZXNzLnBsYXRmb3JtXG5jb25zdCBpc1dpbmRvd3MgPSBwbGF0Zm9ybSA9PT0gJ3dpbjMyJ1xuXG5tb2R1bGUuZXhwb3J0cyA9ICgpID0+IHtcbiAgLy8gcGF0aCA9PiBbZnVuY3Rpb24gb3IgU2V0XVxuICAvLyBBIFNldCBvYmplY3QgbWVhbnMgYSBkaXJlY3RvcnkgcmVzZXJ2YXRpb25cbiAgLy8gQSBmbiBpcyBhIGRpcmVjdCByZXNlcnZhdGlvbiBvbiB0aGF0IHBhdGhcbiAgY29uc3QgcXVldWVzID0gbmV3IE1hcCgpXG5cbiAgLy8gZm4gPT4ge3BhdGhzOltwYXRoLC4uLl0sIGRpcnM6W3BhdGgsIC4uLl19XG4gIGNvbnN0IHJlc2VydmF0aW9ucyA9IG5ldyBNYXAoKVxuXG4gIC8vIHJldHVybiBhIHNldCBvZiBwYXJlbnQgZGlycyBmb3IgYSBnaXZlbiBwYXRoXG4gIC8vICcvYS9iL2MvZCcgLT4gWycvJywgJy9hJywgJy9hL2InLCAnL2EvYi9jJywgJy9hL2IvYy9kJ11cbiAgY29uc3QgZ2V0RGlycyA9IHBhdGggPT4ge1xuICAgIGNvbnN0IGRpcnMgPSBwYXRoLnNwbGl0KCcvJykuc2xpY2UoMCwgLTEpLnJlZHVjZSgoc2V0LCBwYXRoKSA9PiB7XG4gICAgICBpZiAoc2V0Lmxlbmd0aClcbiAgICAgICAgcGF0aCA9IG5vcm1QYXRoKGpvaW4oc2V0W3NldC5sZW5ndGggLSAxXSwgcGF0aCkpXG4gICAgICBzZXQucHVzaChwYXRoIHx8ICcvJylcbiAgICAgIHJldHVybiBzZXRcbiAgICB9LCBbXSlcbiAgICByZXR1cm4gZGlyc1xuICB9XG5cbiAgLy8gZnVuY3Rpb25zIGN1cnJlbnRseSBydW5uaW5nXG4gIGNvbnN0IHJ1bm5pbmcgPSBuZXcgU2V0KClcblxuICAvLyByZXR1cm4gdGhlIHF1ZXVlcyBmb3IgZWFjaCBwYXRoIHRoZSBmdW5jdGlvbiBjYXJlcyBhYm91dFxuICAvLyBmbiA9PiB7cGF0aHMsIGRpcnN9XG4gIGNvbnN0IGdldFF1ZXVlcyA9IGZuID0+IHtcbiAgICBjb25zdCByZXMgPSByZXNlcnZhdGlvbnMuZ2V0KGZuKVxuICAgIC8qIGlzdGFuYnVsIGlnbm9yZSBpZiAtIHVucG9zc2libGUgKi9cbiAgICBpZiAoIXJlcylcbiAgICAgIHRocm93IG5ldyBFcnJvcignZnVuY3Rpb24gZG9lcyBub3QgaGF2ZSBhbnkgcGF0aCByZXNlcnZhdGlvbnMnKVxuICAgIHJldHVybiB7XG4gICAgICBwYXRoczogcmVzLnBhdGhzLm1hcChwYXRoID0+IHF1ZXVlcy5nZXQocGF0aCkpLFxuICAgICAgZGlyczogWy4uLnJlcy5kaXJzXS5tYXAocGF0aCA9PiBxdWV1ZXMuZ2V0KHBhdGgpKSxcbiAgICB9XG4gIH1cblxuICAvLyBjaGVjayBpZiBmbiBpcyBmaXJzdCBpbiBsaW5lIGZvciBhbGwgaXRzIHBhdGhzLCBhbmQgaXNcbiAgLy8gaW5jbHVkZWQgaW4gdGhlIGZpcnN0IHNldCBmb3IgYWxsIGl0cyBkaXIgcXVldWVzXG4gIGNvbnN0IGNoZWNrID0gZm4gPT4ge1xuICAgIGNvbnN0IHtwYXRocywgZGlyc30gPSBnZXRRdWV1ZXMoZm4pXG4gICAgcmV0dXJuIHBhdGhzLmV2ZXJ5KHEgPT4gcVswXSA9PT0gZm4pICYmXG4gICAgICBkaXJzLmV2ZXJ5KHEgPT4gcVswXSBpbnN0YW5jZW9mIFNldCAmJiBxWzBdLmhhcyhmbikpXG4gIH1cblxuICAvLyBydW4gdGhlIGZ1bmN0aW9uIGlmIGl0J3MgZmlyc3QgaW4gbGluZSBhbmQgbm90IGFscmVhZHkgcnVubmluZ1xuICBjb25zdCBydW4gPSBmbiA9PiB7XG4gICAgaWYgKHJ1bm5pbmcuaGFzKGZuKSB8fCAhY2hlY2soZm4pKVxuICAgICAgcmV0dXJuIGZhbHNlXG4gICAgcnVubmluZy5hZGQoZm4pXG4gICAgZm4oKCkgPT4gY2xlYXIoZm4pKVxuICAgIHJldHVybiB0cnVlXG4gIH1cblxuICBjb25zdCBjbGVhciA9IGZuID0+IHtcbiAgICBpZiAoIXJ1bm5pbmcuaGFzKGZuKSlcbiAgICAgIHJldHVybiBmYWxzZVxuXG4gICAgY29uc3QgeyBwYXRocywgZGlycyB9ID0gcmVzZXJ2YXRpb25zLmdldChmbilcbiAgICBjb25zdCBuZXh0ID0gbmV3IFNldCgpXG5cbiAgICBwYXRocy5mb3JFYWNoKHBhdGggPT4ge1xuICAgICAgY29uc3QgcSA9IHF1ZXVlcy5nZXQocGF0aClcbiAgICAgIGFzc2VydC5lcXVhbChxWzBdLCBmbilcbiAgICAgIGlmIChxLmxlbmd0aCA9PT0gMSlcbiAgICAgICAgcXVldWVzLmRlbGV0ZShwYXRoKVxuICAgICAgZWxzZSB7XG4gICAgICAgIHEuc2hpZnQoKVxuICAgICAgICBpZiAodHlwZW9mIHFbMF0gPT09ICdmdW5jdGlvbicpXG4gICAgICAgICAgbmV4dC5hZGQocVswXSlcbiAgICAgICAgZWxzZVxuICAgICAgICAgIHFbMF0uZm9yRWFjaChmbiA9PiBuZXh0LmFkZChmbikpXG4gICAgICB9XG4gICAgfSlcblxuICAgIGRpcnMuZm9yRWFjaChkaXIgPT4ge1xuICAgICAgY29uc3QgcSA9IHF1ZXVlcy5nZXQoZGlyKVxuICAgICAgYXNzZXJ0KHFbMF0gaW5zdGFuY2VvZiBTZXQpXG4gICAgICBpZiAocVswXS5zaXplID09PSAxICYmIHEubGVuZ3RoID09PSAxKSB7XG4gICAgICAgIHF1ZXVlcy5kZWxldGUoZGlyKVxuICAgICAgfSBlbHNlIGlmIChxWzBdLnNpemUgPT09IDEpIHtcbiAgICAgICAgcS5zaGlmdCgpXG5cbiAgICAgICAgLy8gbXVzdCBiZSBhIGZ1bmN0aW9uIG9yIGVsc2UgdGhlIFNldCB3b3VsZCd2ZSBiZWVuIHJldXNlZFxuICAgICAgICBuZXh0LmFkZChxWzBdKVxuICAgICAgfSBlbHNlXG4gICAgICAgIHFbMF0uZGVsZXRlKGZuKVxuICAgIH0pXG4gICAgcnVubmluZy5kZWxldGUoZm4pXG5cbiAgICBuZXh0LmZvckVhY2goZm4gPT4gcnVuKGZuKSlcbiAgICByZXR1cm4gdHJ1ZVxuICB9XG5cbiAgY29uc3QgcmVzZXJ2ZSA9IChwYXRocywgZm4pID0+IHtcbiAgICAvLyBjb2xsaWRlIG9uIG1hdGNoZXMgYWNyb3NzIGNhc2UgYW5kIHVuaWNvZGUgbm9ybWFsaXphdGlvblxuICAgIC8vIE9uIHdpbmRvd3MsIHRoYW5rcyB0byB0aGUgbWFnaWMgb2YgOC4zIHNob3J0bmFtZXMsIGl0IGlzIGZ1bmRhbWVudGFsbHlcbiAgICAvLyBpbXBvc3NpYmxlIHRvIGRldGVybWluZSB3aGV0aGVyIHR3byBwYXRocyByZWZlciB0byB0aGUgc2FtZSB0aGluZyBvblxuICAgIC8vIGRpc2ssIHdpdGhvdXQgYXNraW5nIHRoZSBrZXJuZWwgZm9yIGEgc2hvcnRuYW1lLlxuICAgIC8vIFNvLCB3ZSBqdXN0IHByZXRlbmQgdGhhdCBldmVyeSBwYXRoIG1hdGNoZXMgZXZlcnkgb3RoZXIgcGF0aCBoZXJlLFxuICAgIC8vIGVmZmVjdGl2ZWx5IHJlbW92aW5nIGFsbCBwYXJhbGxlbGl6YXRpb24gb24gd2luZG93cy5cbiAgICBwYXRocyA9IGlzV2luZG93cyA/IFsnd2luMzIgcGFyYWxsZWxpemF0aW9uIGRpc2FibGVkJ10gOiBwYXRocy5tYXAocCA9PiB7XG4gICAgICByZXR1cm4gc3RyaXBTbGFzaGVzKG5vcm1QYXRoKGpvaW4ocCkpKVxuICAgICAgICAubm9ybWFsaXplKCdORktEJylcbiAgICAgICAgLnRvTG93ZXJDYXNlKClcbiAgICB9KVxuXG4gICAgY29uc3QgZGlycyA9IG5ldyBTZXQoXG4gICAgICBwYXRocy5tYXAocGF0aCA9PiBnZXREaXJzKHBhdGgpKS5yZWR1Y2UoKGEsIGIpID0+IGEuY29uY2F0KGIpKVxuICAgIClcbiAgICByZXNlcnZhdGlvbnMuc2V0KGZuLCB7ZGlycywgcGF0aHN9KVxuICAgIHBhdGhzLmZvckVhY2gocGF0aCA9PiB7XG4gICAgICBjb25zdCBxID0gcXVldWVzLmdldChwYXRoKVxuICAgICAgaWYgKCFxKVxuICAgICAgICBxdWV1ZXMuc2V0KHBhdGgsIFtmbl0pXG4gICAgICBlbHNlXG4gICAgICAgIHEucHVzaChmbilcbiAgICB9KVxuICAgIGRpcnMuZm9yRWFjaChkaXIgPT4ge1xuICAgICAgY29uc3QgcSA9IHF1ZXVlcy5nZXQoZGlyKVxuICAgICAgaWYgKCFxKVxuICAgICAgICBxdWV1ZXMuc2V0KGRpciwgW25ldyBTZXQoW2ZuXSldKVxuICAgICAgZWxzZSBpZiAocVtxLmxlbmd0aC0xXSBpbnN0YW5jZW9mIFNldClcbiAgICAgICAgcVtxLmxlbmd0aC0xXS5hZGQoZm4pXG4gICAgICBlbHNlXG4gICAgICAgIHEucHVzaChuZXcgU2V0KFtmbl0pKVxuICAgIH0pXG5cbiAgICByZXR1cm4gcnVuKGZuKVxuICB9XG5cbiAgcmV0dXJuIHsgY2hlY2ssIHJlc2VydmUgfVxufVxuIl0sIm5hbWVzIjpbXSwiaWdub3JlTGlzdCI6WzBdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/swarm-js/node_modules/tar/lib/path-reservations.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/swarm-js/node_modules/tar/lib/pax.js":
/*!***********************************************************!*\
  !*** ./node_modules/swarm-js/node_modules/tar/lib/pax.js ***!
  \***********************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";
eval("\nconst Buffer = __webpack_require__(/*! ./buffer.js */ \"(ssr)/./node_modules/swarm-js/node_modules/tar/lib/buffer.js\")\nconst Header = __webpack_require__(/*! ./header.js */ \"(ssr)/./node_modules/swarm-js/node_modules/tar/lib/header.js\")\nconst path = __webpack_require__(/*! path */ \"path\")\n\nclass Pax {\n  constructor (obj, global) {\n    this.atime = obj.atime || null\n    this.charset = obj.charset || null\n    this.comment = obj.comment || null\n    this.ctime = obj.ctime || null\n    this.gid = obj.gid || null\n    this.gname = obj.gname || null\n    this.linkpath = obj.linkpath || null\n    this.mtime = obj.mtime || null\n    this.path = obj.path || null\n    this.size = obj.size || null\n    this.uid = obj.uid || null\n    this.uname = obj.uname || null\n    this.dev = obj.dev || null\n    this.ino = obj.ino || null\n    this.nlink = obj.nlink || null\n    this.global = global || false\n  }\n\n  encode () {\n    const body = this.encodeBody()\n    if (body === '')\n      return null\n\n    const bodyLen = Buffer.byteLength(body)\n    // round up to 512 bytes\n    // add 512 for header\n    const bufLen = 512 * Math.ceil(1 + bodyLen / 512)\n    const buf = Buffer.allocUnsafe(bufLen)\n\n    // 0-fill the header section, it might not hit every field\n    for (let i = 0; i < 512; i++) {\n      buf[i] = 0\n    }\n\n    new Header({\n      // XXX split the path\n      // then the path should be PaxHeader + basename, but less than 99,\n      // prepend with the dirname\n      path: ('PaxHeader/' + path.basename(this.path)).slice(0, 99),\n      mode: this.mode || 0o644,\n      uid: this.uid || null,\n      gid: this.gid || null,\n      size: bodyLen,\n      mtime: this.mtime || null,\n      type: this.global ? 'GlobalExtendedHeader' : 'ExtendedHeader',\n      linkpath: '',\n      uname: this.uname || '',\n      gname: this.gname || '',\n      devmaj: 0,\n      devmin: 0,\n      atime: this.atime || null,\n      ctime: this.ctime || null\n    }).encode(buf)\n\n    buf.write(body, 512, bodyLen, 'utf8')\n\n    // null pad after the body\n    for (let i = bodyLen + 512; i < buf.length; i++) {\n      buf[i] = 0\n    }\n\n    return buf\n  }\n\n  encodeBody () {\n    return (\n      this.encodeField('path') +\n      this.encodeField('ctime') +\n      this.encodeField('atime') +\n      this.encodeField('dev') +\n      this.encodeField('ino') +\n      this.encodeField('nlink') +\n      this.encodeField('charset') +\n      this.encodeField('comment') +\n      this.encodeField('gid') +\n      this.encodeField('gname') +\n      this.encodeField('linkpath') +\n      this.encodeField('mtime') +\n      this.encodeField('size') +\n      this.encodeField('uid') +\n      this.encodeField('uname')\n    )\n  }\n\n  encodeField (field) {\n    if (this[field] === null || this[field] === undefined)\n      return ''\n    const v = this[field] instanceof Date ? this[field].getTime() / 1000\n      : this[field]\n    const s = ' ' +\n      (field === 'dev' || field === 'ino' || field === 'nlink'\n       ? 'SCHILY.' : '') +\n      field + '=' + v + '\\n'\n    const byteLen = Buffer.byteLength(s)\n    // the digits includes the length of the digits in ascii base-10\n    // so if it's 9 characters, then adding 1 for the 9 makes it 10\n    // which makes it 11 chars.\n    let digits = Math.floor(Math.log(byteLen) / Math.log(10)) + 1\n    if (byteLen + digits >= Math.pow(10, digits))\n      digits += 1\n    const len = digits + byteLen\n    return len + s\n  }\n}\n\nPax.parse = (string, ex, g) => new Pax(merge(parseKV(string), ex), g)\n\nconst merge = (a, b) =>\n  b ? Object.keys(a).reduce((s, k) => (s[k] = a[k], s), b) : a\n\nconst parseKV = string =>\n  string\n    .replace(/\\n$/, '')\n    .split('\\n')\n    .reduce(parseKVLine, Object.create(null))\n\nconst parseKVLine = (set, line) => {\n  const n = parseInt(line, 10)\n\n  // XXX Values with \\n in them will fail this.\n  // Refactor to not be a naive line-by-line parse.\n  if (n !== Buffer.byteLength(line) + 1)\n    return set\n\n  line = line.substr((n + ' ').length)\n  const kv = line.split('=')\n  const k = kv.shift().replace(/^SCHILY\\.(dev|ino|nlink)/, '$1')\n  if (!k)\n    return set\n\n  const v = kv.join('=')\n  set[k] = /^([A-Z]+\\.)?([mac]|birth|creation)time$/.test(k)\n    ?  new Date(v * 1000)\n    : /^[0-9]+$/.test(v) ? +v\n    : v\n  return set\n}\n\nmodule.exports = Pax\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvc3dhcm0tanMvbm9kZV9tb2R1bGVzL3Rhci9saWIvcGF4LmpzIiwibWFwcGluZ3MiOiJBQUFZO0FBQ1osZUFBZSxtQkFBTyxDQUFDLGlGQUFhO0FBQ3BDLGVBQWUsbUJBQU8sQ0FBQyxpRkFBYTtBQUNwQyxhQUFhLG1CQUFPLENBQUMsa0JBQU07O0FBRTNCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxvQkFBb0IsU0FBUztBQUM3QjtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7O0FBRUw7O0FBRUE7QUFDQSxnQ0FBZ0MsZ0JBQWdCO0FBQ2hEO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUEiLCJzb3VyY2VzIjpbIi9Vc2Vycy9wYW56YS9Eb2N1bWVudHMvUGVyc29uYWxQcm9qZWN0cy9wcmVkaWsvbm9kZV9tb2R1bGVzL3N3YXJtLWpzL25vZGVfbW9kdWxlcy90YXIvbGliL3BheC5qcyJdLCJzb3VyY2VzQ29udGVudCI6WyIndXNlIHN0cmljdCdcbmNvbnN0IEJ1ZmZlciA9IHJlcXVpcmUoJy4vYnVmZmVyLmpzJylcbmNvbnN0IEhlYWRlciA9IHJlcXVpcmUoJy4vaGVhZGVyLmpzJylcbmNvbnN0IHBhdGggPSByZXF1aXJlKCdwYXRoJylcblxuY2xhc3MgUGF4IHtcbiAgY29uc3RydWN0b3IgKG9iaiwgZ2xvYmFsKSB7XG4gICAgdGhpcy5hdGltZSA9IG9iai5hdGltZSB8fCBudWxsXG4gICAgdGhpcy5jaGFyc2V0ID0gb2JqLmNoYXJzZXQgfHwgbnVsbFxuICAgIHRoaXMuY29tbWVudCA9IG9iai5jb21tZW50IHx8IG51bGxcbiAgICB0aGlzLmN0aW1lID0gb2JqLmN0aW1lIHx8IG51bGxcbiAgICB0aGlzLmdpZCA9IG9iai5naWQgfHwgbnVsbFxuICAgIHRoaXMuZ25hbWUgPSBvYmouZ25hbWUgfHwgbnVsbFxuICAgIHRoaXMubGlua3BhdGggPSBvYmoubGlua3BhdGggfHwgbnVsbFxuICAgIHRoaXMubXRpbWUgPSBvYmoubXRpbWUgfHwgbnVsbFxuICAgIHRoaXMucGF0aCA9IG9iai5wYXRoIHx8IG51bGxcbiAgICB0aGlzLnNpemUgPSBvYmouc2l6ZSB8fCBudWxsXG4gICAgdGhpcy51aWQgPSBvYmoudWlkIHx8IG51bGxcbiAgICB0aGlzLnVuYW1lID0gb2JqLnVuYW1lIHx8IG51bGxcbiAgICB0aGlzLmRldiA9IG9iai5kZXYgfHwgbnVsbFxuICAgIHRoaXMuaW5vID0gb2JqLmlubyB8fCBudWxsXG4gICAgdGhpcy5ubGluayA9IG9iai5ubGluayB8fCBudWxsXG4gICAgdGhpcy5nbG9iYWwgPSBnbG9iYWwgfHwgZmFsc2VcbiAgfVxuXG4gIGVuY29kZSAoKSB7XG4gICAgY29uc3QgYm9keSA9IHRoaXMuZW5jb2RlQm9keSgpXG4gICAgaWYgKGJvZHkgPT09ICcnKVxuICAgICAgcmV0dXJuIG51bGxcblxuICAgIGNvbnN0IGJvZHlMZW4gPSBCdWZmZXIuYnl0ZUxlbmd0aChib2R5KVxuICAgIC8vIHJvdW5kIHVwIHRvIDUxMiBieXRlc1xuICAgIC8vIGFkZCA1MTIgZm9yIGhlYWRlclxuICAgIGNvbnN0IGJ1ZkxlbiA9IDUxMiAqIE1hdGguY2VpbCgxICsgYm9keUxlbiAvIDUxMilcbiAgICBjb25zdCBidWYgPSBCdWZmZXIuYWxsb2NVbnNhZmUoYnVmTGVuKVxuXG4gICAgLy8gMC1maWxsIHRoZSBoZWFkZXIgc2VjdGlvbiwgaXQgbWlnaHQgbm90IGhpdCBldmVyeSBmaWVsZFxuICAgIGZvciAobGV0IGkgPSAwOyBpIDwgNTEyOyBpKyspIHtcbiAgICAgIGJ1ZltpXSA9IDBcbiAgICB9XG5cbiAgICBuZXcgSGVhZGVyKHtcbiAgICAgIC8vIFhYWCBzcGxpdCB0aGUgcGF0aFxuICAgICAgLy8gdGhlbiB0aGUgcGF0aCBzaG91bGQgYmUgUGF4SGVhZGVyICsgYmFzZW5hbWUsIGJ1dCBsZXNzIHRoYW4gOTksXG4gICAgICAvLyBwcmVwZW5kIHdpdGggdGhlIGRpcm5hbWVcbiAgICAgIHBhdGg6ICgnUGF4SGVhZGVyLycgKyBwYXRoLmJhc2VuYW1lKHRoaXMucGF0aCkpLnNsaWNlKDAsIDk5KSxcbiAgICAgIG1vZGU6IHRoaXMubW9kZSB8fCAwbzY0NCxcbiAgICAgIHVpZDogdGhpcy51aWQgfHwgbnVsbCxcbiAgICAgIGdpZDogdGhpcy5naWQgfHwgbnVsbCxcbiAgICAgIHNpemU6IGJvZHlMZW4sXG4gICAgICBtdGltZTogdGhpcy5tdGltZSB8fCBudWxsLFxuICAgICAgdHlwZTogdGhpcy5nbG9iYWwgPyAnR2xvYmFsRXh0ZW5kZWRIZWFkZXInIDogJ0V4dGVuZGVkSGVhZGVyJyxcbiAgICAgIGxpbmtwYXRoOiAnJyxcbiAgICAgIHVuYW1lOiB0aGlzLnVuYW1lIHx8ICcnLFxuICAgICAgZ25hbWU6IHRoaXMuZ25hbWUgfHwgJycsXG4gICAgICBkZXZtYWo6IDAsXG4gICAgICBkZXZtaW46IDAsXG4gICAgICBhdGltZTogdGhpcy5hdGltZSB8fCBudWxsLFxuICAgICAgY3RpbWU6IHRoaXMuY3RpbWUgfHwgbnVsbFxuICAgIH0pLmVuY29kZShidWYpXG5cbiAgICBidWYud3JpdGUoYm9keSwgNTEyLCBib2R5TGVuLCAndXRmOCcpXG5cbiAgICAvLyBudWxsIHBhZCBhZnRlciB0aGUgYm9keVxuICAgIGZvciAobGV0IGkgPSBib2R5TGVuICsgNTEyOyBpIDwgYnVmLmxlbmd0aDsgaSsrKSB7XG4gICAgICBidWZbaV0gPSAwXG4gICAgfVxuXG4gICAgcmV0dXJuIGJ1ZlxuICB9XG5cbiAgZW5jb2RlQm9keSAoKSB7XG4gICAgcmV0dXJuIChcbiAgICAgIHRoaXMuZW5jb2RlRmllbGQoJ3BhdGgnKSArXG4gICAgICB0aGlzLmVuY29kZUZpZWxkKCdjdGltZScpICtcbiAgICAgIHRoaXMuZW5jb2RlRmllbGQoJ2F0aW1lJykgK1xuICAgICAgdGhpcy5lbmNvZGVGaWVsZCgnZGV2JykgK1xuICAgICAgdGhpcy5lbmNvZGVGaWVsZCgnaW5vJykgK1xuICAgICAgdGhpcy5lbmNvZGVGaWVsZCgnbmxpbmsnKSArXG4gICAgICB0aGlzLmVuY29kZUZpZWxkKCdjaGFyc2V0JykgK1xuICAgICAgdGhpcy5lbmNvZGVGaWVsZCgnY29tbWVudCcpICtcbiAgICAgIHRoaXMuZW5jb2RlRmllbGQoJ2dpZCcpICtcbiAgICAgIHRoaXMuZW5jb2RlRmllbGQoJ2duYW1lJykgK1xuICAgICAgdGhpcy5lbmNvZGVGaWVsZCgnbGlua3BhdGgnKSArXG4gICAgICB0aGlzLmVuY29kZUZpZWxkKCdtdGltZScpICtcbiAgICAgIHRoaXMuZW5jb2RlRmllbGQoJ3NpemUnKSArXG4gICAgICB0aGlzLmVuY29kZUZpZWxkKCd1aWQnKSArXG4gICAgICB0aGlzLmVuY29kZUZpZWxkKCd1bmFtZScpXG4gICAgKVxuICB9XG5cbiAgZW5jb2RlRmllbGQgKGZpZWxkKSB7XG4gICAgaWYgKHRoaXNbZmllbGRdID09PSBudWxsIHx8IHRoaXNbZmllbGRdID09PSB1bmRlZmluZWQpXG4gICAgICByZXR1cm4gJydcbiAgICBjb25zdCB2ID0gdGhpc1tmaWVsZF0gaW5zdGFuY2VvZiBEYXRlID8gdGhpc1tmaWVsZF0uZ2V0VGltZSgpIC8gMTAwMFxuICAgICAgOiB0aGlzW2ZpZWxkXVxuICAgIGNvbnN0IHMgPSAnICcgK1xuICAgICAgKGZpZWxkID09PSAnZGV2JyB8fCBmaWVsZCA9PT0gJ2lubycgfHwgZmllbGQgPT09ICdubGluaydcbiAgICAgICA/ICdTQ0hJTFkuJyA6ICcnKSArXG4gICAgICBmaWVsZCArICc9JyArIHYgKyAnXFxuJ1xuICAgIGNvbnN0IGJ5dGVMZW4gPSBCdWZmZXIuYnl0ZUxlbmd0aChzKVxuICAgIC8vIHRoZSBkaWdpdHMgaW5jbHVkZXMgdGhlIGxlbmd0aCBvZiB0aGUgZGlnaXRzIGluIGFzY2lpIGJhc2UtMTBcbiAgICAvLyBzbyBpZiBpdCdzIDkgY2hhcmFjdGVycywgdGhlbiBhZGRpbmcgMSBmb3IgdGhlIDkgbWFrZXMgaXQgMTBcbiAgICAvLyB3aGljaCBtYWtlcyBpdCAxMSBjaGFycy5cbiAgICBsZXQgZGlnaXRzID0gTWF0aC5mbG9vcihNYXRoLmxvZyhieXRlTGVuKSAvIE1hdGgubG9nKDEwKSkgKyAxXG4gICAgaWYgKGJ5dGVMZW4gKyBkaWdpdHMgPj0gTWF0aC5wb3coMTAsIGRpZ2l0cykpXG4gICAgICBkaWdpdHMgKz0gMVxuICAgIGNvbnN0IGxlbiA9IGRpZ2l0cyArIGJ5dGVMZW5cbiAgICByZXR1cm4gbGVuICsgc1xuICB9XG59XG5cblBheC5wYXJzZSA9IChzdHJpbmcsIGV4LCBnKSA9PiBuZXcgUGF4KG1lcmdlKHBhcnNlS1Yoc3RyaW5nKSwgZXgpLCBnKVxuXG5jb25zdCBtZXJnZSA9IChhLCBiKSA9PlxuICBiID8gT2JqZWN0LmtleXMoYSkucmVkdWNlKChzLCBrKSA9PiAoc1trXSA9IGFba10sIHMpLCBiKSA6IGFcblxuY29uc3QgcGFyc2VLViA9IHN0cmluZyA9PlxuICBzdHJpbmdcbiAgICAucmVwbGFjZSgvXFxuJC8sICcnKVxuICAgIC5zcGxpdCgnXFxuJylcbiAgICAucmVkdWNlKHBhcnNlS1ZMaW5lLCBPYmplY3QuY3JlYXRlKG51bGwpKVxuXG5jb25zdCBwYXJzZUtWTGluZSA9IChzZXQsIGxpbmUpID0+IHtcbiAgY29uc3QgbiA9IHBhcnNlSW50KGxpbmUsIDEwKVxuXG4gIC8vIFhYWCBWYWx1ZXMgd2l0aCBcXG4gaW4gdGhlbSB3aWxsIGZhaWwgdGhpcy5cbiAgLy8gUmVmYWN0b3IgdG8gbm90IGJlIGEgbmFpdmUgbGluZS1ieS1saW5lIHBhcnNlLlxuICBpZiAobiAhPT0gQnVmZmVyLmJ5dGVMZW5ndGgobGluZSkgKyAxKVxuICAgIHJldHVybiBzZXRcblxuICBsaW5lID0gbGluZS5zdWJzdHIoKG4gKyAnICcpLmxlbmd0aClcbiAgY29uc3Qga3YgPSBsaW5lLnNwbGl0KCc9JylcbiAgY29uc3QgayA9IGt2LnNoaWZ0KCkucmVwbGFjZSgvXlNDSElMWVxcLihkZXZ8aW5vfG5saW5rKS8sICckMScpXG4gIGlmICghaylcbiAgICByZXR1cm4gc2V0XG5cbiAgY29uc3QgdiA9IGt2LmpvaW4oJz0nKVxuICBzZXRba10gPSAvXihbQS1aXStcXC4pPyhbbWFjXXxiaXJ0aHxjcmVhdGlvbil0aW1lJC8udGVzdChrKVxuICAgID8gIG5ldyBEYXRlKHYgKiAxMDAwKVxuICAgIDogL15bMC05XSskLy50ZXN0KHYpID8gK3ZcbiAgICA6IHZcbiAgcmV0dXJuIHNldFxufVxuXG5tb2R1bGUuZXhwb3J0cyA9IFBheFxuIl0sIm5hbWVzIjpbXSwiaWdub3JlTGlzdCI6WzBdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/swarm-js/node_modules/tar/lib/pax.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/swarm-js/node_modules/tar/lib/read-entry.js":
/*!******************************************************************!*\
  !*** ./node_modules/swarm-js/node_modules/tar/lib/read-entry.js ***!
  \******************************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";
eval("\nconst types = __webpack_require__(/*! ./types.js */ \"(ssr)/./node_modules/swarm-js/node_modules/tar/lib/types.js\")\nconst MiniPass = __webpack_require__(/*! minipass */ \"(ssr)/./node_modules/swarm-js/node_modules/minipass/index.js\")\nconst normPath = __webpack_require__(/*! ./normalize-windows-path.js */ \"(ssr)/./node_modules/swarm-js/node_modules/tar/lib/normalize-windows-path.js\")\n\nconst SLURP = Symbol('slurp')\nmodule.exports = class ReadEntry extends MiniPass {\n  constructor (header, ex, gex) {\n    super()\n    // read entries always start life paused.  this is to avoid the\n    // situation where Minipass's auto-ending empty streams results\n    // in an entry ending before we're ready for it.\n    this.pause()\n    this.extended = ex\n    this.globalExtended = gex\n    this.header = header\n    this.startBlockSize = 512 * Math.ceil(header.size / 512)\n    this.blockRemain = this.startBlockSize\n    this.remain = header.size\n    this.type = header.type\n    this.meta = false\n    this.ignore = false\n    switch (this.type) {\n      case 'File':\n      case 'OldFile':\n      case 'Link':\n      case 'SymbolicLink':\n      case 'CharacterDevice':\n      case 'BlockDevice':\n      case 'Directory':\n      case 'FIFO':\n      case 'ContiguousFile':\n      case 'GNUDumpDir':\n        break\n\n      case 'NextFileHasLongLinkpath':\n      case 'NextFileHasLongPath':\n      case 'OldGnuLongPath':\n      case 'GlobalExtendedHeader':\n      case 'ExtendedHeader':\n      case 'OldExtendedHeader':\n        this.meta = true\n        break\n\n      // NOTE: gnutar and bsdtar treat unrecognized types as 'File'\n      // it may be worth doing the same, but with a warning.\n      default:\n        this.ignore = true\n    }\n\n    this.path = normPath(header.path)\n    this.mode = header.mode\n    if (this.mode)\n      this.mode = this.mode & 0o7777\n    this.uid = header.uid\n    this.gid = header.gid\n    this.uname = header.uname\n    this.gname = header.gname\n    this.size = header.size\n    this.mtime = header.mtime\n    this.atime = header.atime\n    this.ctime = header.ctime\n    this.linkpath = normPath(header.linkpath)\n    this.uname = header.uname\n    this.gname = header.gname\n\n    if (ex) this[SLURP](ex)\n    if (gex) this[SLURP](gex, true)\n  }\n\n  write (data) {\n    const writeLen = data.length\n    if (writeLen > this.blockRemain)\n      throw new Error('writing more to entry than is appropriate')\n\n    const r = this.remain\n    const br = this.blockRemain\n    this.remain = Math.max(0, r - writeLen)\n    this.blockRemain = Math.max(0, br - writeLen)\n    if (this.ignore)\n      return true\n\n    if (r >= writeLen)\n      return super.write(data)\n\n    // r < writeLen\n    return super.write(data.slice(0, r))\n  }\n\n  [SLURP] (ex, global) {\n    for (let k in ex) {\n      // we slurp in everything except for the path attribute in\n      // a global extended header, because that's weird.\n      if (ex[k] !== null && ex[k] !== undefined &&\n          !(global && k === 'path'))\n        this[k] = k === 'path' || k === 'linkpath' ? normPath(ex[k]) : ex[k]\n    }\n  }\n}\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvc3dhcm0tanMvbm9kZV9tb2R1bGVzL3Rhci9saWIvcmVhZC1lbnRyeS5qcyIsIm1hcHBpbmdzIjoiQUFBWTtBQUNaLGNBQWMsbUJBQU8sQ0FBQywrRUFBWTtBQUNsQyxpQkFBaUIsbUJBQU8sQ0FBQyw4RUFBVTtBQUNuQyxpQkFBaUIsbUJBQU8sQ0FBQyxpSEFBNkI7O0FBRXREO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBIiwic291cmNlcyI6WyIvVXNlcnMvcGFuemEvRG9jdW1lbnRzL1BlcnNvbmFsUHJvamVjdHMvcHJlZGlrL25vZGVfbW9kdWxlcy9zd2FybS1qcy9ub2RlX21vZHVsZXMvdGFyL2xpYi9yZWFkLWVudHJ5LmpzIl0sInNvdXJjZXNDb250ZW50IjpbIid1c2Ugc3RyaWN0J1xuY29uc3QgdHlwZXMgPSByZXF1aXJlKCcuL3R5cGVzLmpzJylcbmNvbnN0IE1pbmlQYXNzID0gcmVxdWlyZSgnbWluaXBhc3MnKVxuY29uc3Qgbm9ybVBhdGggPSByZXF1aXJlKCcuL25vcm1hbGl6ZS13aW5kb3dzLXBhdGguanMnKVxuXG5jb25zdCBTTFVSUCA9IFN5bWJvbCgnc2x1cnAnKVxubW9kdWxlLmV4cG9ydHMgPSBjbGFzcyBSZWFkRW50cnkgZXh0ZW5kcyBNaW5pUGFzcyB7XG4gIGNvbnN0cnVjdG9yIChoZWFkZXIsIGV4LCBnZXgpIHtcbiAgICBzdXBlcigpXG4gICAgLy8gcmVhZCBlbnRyaWVzIGFsd2F5cyBzdGFydCBsaWZlIHBhdXNlZC4gIHRoaXMgaXMgdG8gYXZvaWQgdGhlXG4gICAgLy8gc2l0dWF0aW9uIHdoZXJlIE1pbmlwYXNzJ3MgYXV0by1lbmRpbmcgZW1wdHkgc3RyZWFtcyByZXN1bHRzXG4gICAgLy8gaW4gYW4gZW50cnkgZW5kaW5nIGJlZm9yZSB3ZSdyZSByZWFkeSBmb3IgaXQuXG4gICAgdGhpcy5wYXVzZSgpXG4gICAgdGhpcy5leHRlbmRlZCA9IGV4XG4gICAgdGhpcy5nbG9iYWxFeHRlbmRlZCA9IGdleFxuICAgIHRoaXMuaGVhZGVyID0gaGVhZGVyXG4gICAgdGhpcy5zdGFydEJsb2NrU2l6ZSA9IDUxMiAqIE1hdGguY2VpbChoZWFkZXIuc2l6ZSAvIDUxMilcbiAgICB0aGlzLmJsb2NrUmVtYWluID0gdGhpcy5zdGFydEJsb2NrU2l6ZVxuICAgIHRoaXMucmVtYWluID0gaGVhZGVyLnNpemVcbiAgICB0aGlzLnR5cGUgPSBoZWFkZXIudHlwZVxuICAgIHRoaXMubWV0YSA9IGZhbHNlXG4gICAgdGhpcy5pZ25vcmUgPSBmYWxzZVxuICAgIHN3aXRjaCAodGhpcy50eXBlKSB7XG4gICAgICBjYXNlICdGaWxlJzpcbiAgICAgIGNhc2UgJ09sZEZpbGUnOlxuICAgICAgY2FzZSAnTGluayc6XG4gICAgICBjYXNlICdTeW1ib2xpY0xpbmsnOlxuICAgICAgY2FzZSAnQ2hhcmFjdGVyRGV2aWNlJzpcbiAgICAgIGNhc2UgJ0Jsb2NrRGV2aWNlJzpcbiAgICAgIGNhc2UgJ0RpcmVjdG9yeSc6XG4gICAgICBjYXNlICdGSUZPJzpcbiAgICAgIGNhc2UgJ0NvbnRpZ3VvdXNGaWxlJzpcbiAgICAgIGNhc2UgJ0dOVUR1bXBEaXInOlxuICAgICAgICBicmVha1xuXG4gICAgICBjYXNlICdOZXh0RmlsZUhhc0xvbmdMaW5rcGF0aCc6XG4gICAgICBjYXNlICdOZXh0RmlsZUhhc0xvbmdQYXRoJzpcbiAgICAgIGNhc2UgJ09sZEdudUxvbmdQYXRoJzpcbiAgICAgIGNhc2UgJ0dsb2JhbEV4dGVuZGVkSGVhZGVyJzpcbiAgICAgIGNhc2UgJ0V4dGVuZGVkSGVhZGVyJzpcbiAgICAgIGNhc2UgJ09sZEV4dGVuZGVkSGVhZGVyJzpcbiAgICAgICAgdGhpcy5tZXRhID0gdHJ1ZVxuICAgICAgICBicmVha1xuXG4gICAgICAvLyBOT1RFOiBnbnV0YXIgYW5kIGJzZHRhciB0cmVhdCB1bnJlY29nbml6ZWQgdHlwZXMgYXMgJ0ZpbGUnXG4gICAgICAvLyBpdCBtYXkgYmUgd29ydGggZG9pbmcgdGhlIHNhbWUsIGJ1dCB3aXRoIGEgd2FybmluZy5cbiAgICAgIGRlZmF1bHQ6XG4gICAgICAgIHRoaXMuaWdub3JlID0gdHJ1ZVxuICAgIH1cblxuICAgIHRoaXMucGF0aCA9IG5vcm1QYXRoKGhlYWRlci5wYXRoKVxuICAgIHRoaXMubW9kZSA9IGhlYWRlci5tb2RlXG4gICAgaWYgKHRoaXMubW9kZSlcbiAgICAgIHRoaXMubW9kZSA9IHRoaXMubW9kZSAmIDBvNzc3N1xuICAgIHRoaXMudWlkID0gaGVhZGVyLnVpZFxuICAgIHRoaXMuZ2lkID0gaGVhZGVyLmdpZFxuICAgIHRoaXMudW5hbWUgPSBoZWFkZXIudW5hbWVcbiAgICB0aGlzLmduYW1lID0gaGVhZGVyLmduYW1lXG4gICAgdGhpcy5zaXplID0gaGVhZGVyLnNpemVcbiAgICB0aGlzLm10aW1lID0gaGVhZGVyLm10aW1lXG4gICAgdGhpcy5hdGltZSA9IGhlYWRlci5hdGltZVxuICAgIHRoaXMuY3RpbWUgPSBoZWFkZXIuY3RpbWVcbiAgICB0aGlzLmxpbmtwYXRoID0gbm9ybVBhdGgoaGVhZGVyLmxpbmtwYXRoKVxuICAgIHRoaXMudW5hbWUgPSBoZWFkZXIudW5hbWVcbiAgICB0aGlzLmduYW1lID0gaGVhZGVyLmduYW1lXG5cbiAgICBpZiAoZXgpIHRoaXNbU0xVUlBdKGV4KVxuICAgIGlmIChnZXgpIHRoaXNbU0xVUlBdKGdleCwgdHJ1ZSlcbiAgfVxuXG4gIHdyaXRlIChkYXRhKSB7XG4gICAgY29uc3Qgd3JpdGVMZW4gPSBkYXRhLmxlbmd0aFxuICAgIGlmICh3cml0ZUxlbiA+IHRoaXMuYmxvY2tSZW1haW4pXG4gICAgICB0aHJvdyBuZXcgRXJyb3IoJ3dyaXRpbmcgbW9yZSB0byBlbnRyeSB0aGFuIGlzIGFwcHJvcHJpYXRlJylcblxuICAgIGNvbnN0IHIgPSB0aGlzLnJlbWFpblxuICAgIGNvbnN0IGJyID0gdGhpcy5ibG9ja1JlbWFpblxuICAgIHRoaXMucmVtYWluID0gTWF0aC5tYXgoMCwgciAtIHdyaXRlTGVuKVxuICAgIHRoaXMuYmxvY2tSZW1haW4gPSBNYXRoLm1heCgwLCBiciAtIHdyaXRlTGVuKVxuICAgIGlmICh0aGlzLmlnbm9yZSlcbiAgICAgIHJldHVybiB0cnVlXG5cbiAgICBpZiAociA+PSB3cml0ZUxlbilcbiAgICAgIHJldHVybiBzdXBlci53cml0ZShkYXRhKVxuXG4gICAgLy8gciA8IHdyaXRlTGVuXG4gICAgcmV0dXJuIHN1cGVyLndyaXRlKGRhdGEuc2xpY2UoMCwgcikpXG4gIH1cblxuICBbU0xVUlBdIChleCwgZ2xvYmFsKSB7XG4gICAgZm9yIChsZXQgayBpbiBleCkge1xuICAgICAgLy8gd2Ugc2x1cnAgaW4gZXZlcnl0aGluZyBleGNlcHQgZm9yIHRoZSBwYXRoIGF0dHJpYnV0ZSBpblxuICAgICAgLy8gYSBnbG9iYWwgZXh0ZW5kZWQgaGVhZGVyLCBiZWNhdXNlIHRoYXQncyB3ZWlyZC5cbiAgICAgIGlmIChleFtrXSAhPT0gbnVsbCAmJiBleFtrXSAhPT0gdW5kZWZpbmVkICYmXG4gICAgICAgICAgIShnbG9iYWwgJiYgayA9PT0gJ3BhdGgnKSlcbiAgICAgICAgdGhpc1trXSA9IGsgPT09ICdwYXRoJyB8fCBrID09PSAnbGlua3BhdGgnID8gbm9ybVBhdGgoZXhba10pIDogZXhba11cbiAgICB9XG4gIH1cbn1cbiJdLCJuYW1lcyI6W10sImlnbm9yZUxpc3QiOlswXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/swarm-js/node_modules/tar/lib/read-entry.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/swarm-js/node_modules/tar/lib/replace.js":
/*!***************************************************************!*\
  !*** ./node_modules/swarm-js/node_modules/tar/lib/replace.js ***!
  \***************************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";
eval("\nconst Buffer = __webpack_require__(/*! ./buffer.js */ \"(ssr)/./node_modules/swarm-js/node_modules/tar/lib/buffer.js\")\n\n// tar -r\nconst hlo = __webpack_require__(/*! ./high-level-opt.js */ \"(ssr)/./node_modules/swarm-js/node_modules/tar/lib/high-level-opt.js\")\nconst Pack = __webpack_require__(/*! ./pack.js */ \"(ssr)/./node_modules/swarm-js/node_modules/tar/lib/pack.js\")\nconst Parse = __webpack_require__(/*! ./parse.js */ \"(ssr)/./node_modules/swarm-js/node_modules/tar/lib/parse.js\")\nconst fs = __webpack_require__(/*! fs */ \"fs\")\nconst fsm = __webpack_require__(/*! fs-minipass */ \"(ssr)/./node_modules/swarm-js/node_modules/fs-minipass/index.js\")\nconst t = __webpack_require__(/*! ./list.js */ \"(ssr)/./node_modules/swarm-js/node_modules/tar/lib/list.js\")\nconst path = __webpack_require__(/*! path */ \"path\")\n\n// starting at the head of the file, read a Header\n// If the checksum is invalid, that's our position to start writing\n// If it is, jump forward by the specified size (round up to 512)\n// and try again.\n// Write the new Pack stream starting there.\n\nconst Header = __webpack_require__(/*! ./header.js */ \"(ssr)/./node_modules/swarm-js/node_modules/tar/lib/header.js\")\n\nconst r = module.exports = (opt_, files, cb) => {\n  const opt = hlo(opt_)\n\n  if (!opt.file)\n    throw new TypeError('file is required')\n\n  if (opt.gzip)\n    throw new TypeError('cannot append to compressed archives')\n\n  if (!files || !Array.isArray(files) || !files.length)\n    throw new TypeError('no files or directories specified')\n\n  files = Array.from(files)\n\n  return opt.sync ? replaceSync(opt, files)\n    : replace(opt, files, cb)\n}\n\nconst replaceSync = (opt, files) => {\n  const p = new Pack.Sync(opt)\n\n  let threw = true\n  let fd\n  let position\n\n  try {\n    try {\n      fd = fs.openSync(opt.file, 'r+')\n    } catch (er) {\n      if (er.code === 'ENOENT')\n        fd = fs.openSync(opt.file, 'w+')\n      else\n        throw er\n    }\n\n    const st = fs.fstatSync(fd)\n    const headBuf = Buffer.alloc(512)\n\n    POSITION: for (position = 0; position < st.size; position += 512) {\n      for (let bufPos = 0, bytes = 0; bufPos < 512; bufPos += bytes) {\n        bytes = fs.readSync(\n          fd, headBuf, bufPos, headBuf.length - bufPos, position + bufPos\n        )\n\n        if (position === 0 && headBuf[0] === 0x1f && headBuf[1] === 0x8b)\n          throw new Error('cannot append to compressed archives')\n\n        if (!bytes)\n          break POSITION\n      }\n\n      let h = new Header(headBuf)\n      if (!h.cksumValid)\n        break\n      let entryBlockSize = 512 * Math.ceil(h.size / 512)\n      if (position + entryBlockSize + 512 > st.size)\n        break\n      // the 512 for the header we just parsed will be added as well\n      // also jump ahead all the blocks for the body\n      position += entryBlockSize\n      if (opt.mtimeCache)\n        opt.mtimeCache.set(h.path, h.mtime)\n    }\n    threw = false\n\n    streamSync(opt, p, position, fd, files)\n  } finally {\n    if (threw)\n      try { fs.closeSync(fd) } catch (er) {}\n  }\n}\n\nconst streamSync = (opt, p, position, fd, files) => {\n  const stream = new fsm.WriteStreamSync(opt.file, {\n    fd: fd,\n    start: position\n  })\n  p.pipe(stream)\n  addFilesSync(p, files)\n}\n\nconst replace = (opt, files, cb) => {\n  files = Array.from(files)\n  const p = new Pack(opt)\n\n  const getPos = (fd, size, cb_) => {\n    const cb = (er, pos) => {\n      if (er)\n        fs.close(fd, _ => cb_(er))\n      else\n        cb_(null, pos)\n    }\n\n    let position = 0\n    if (size === 0)\n      return cb(null, 0)\n\n    let bufPos = 0\n    const headBuf = Buffer.alloc(512)\n    const onread = (er, bytes) => {\n      if (er)\n        return cb(er)\n      bufPos += bytes\n      if (bufPos < 512 && bytes)\n        return fs.read(\n          fd, headBuf, bufPos, headBuf.length - bufPos,\n          position + bufPos, onread\n        )\n\n      if (position === 0 && headBuf[0] === 0x1f && headBuf[1] === 0x8b)\n        return cb(new Error('cannot append to compressed archives'))\n\n      // truncated header\n      if (bufPos < 512)\n        return cb(null, position)\n\n      const h = new Header(headBuf)\n      if (!h.cksumValid)\n        return cb(null, position)\n\n      const entryBlockSize = 512 * Math.ceil(h.size / 512)\n      if (position + entryBlockSize + 512 > size)\n        return cb(null, position)\n\n      position += entryBlockSize + 512\n      if (position >= size)\n        return cb(null, position)\n\n      if (opt.mtimeCache)\n        opt.mtimeCache.set(h.path, h.mtime)\n      bufPos = 0\n      fs.read(fd, headBuf, 0, 512, position, onread)\n    }\n    fs.read(fd, headBuf, 0, 512, position, onread)\n  }\n\n  const promise = new Promise((resolve, reject) => {\n    p.on('error', reject)\n    let flag = 'r+'\n    const onopen = (er, fd) => {\n      if (er && er.code === 'ENOENT' && flag === 'r+') {\n        flag = 'w+'\n        return fs.open(opt.file, flag, onopen)\n      }\n\n      if (er)\n        return reject(er)\n\n      fs.fstat(fd, (er, st) => {\n        if (er)\n          return fs.close(fd, () => reject(er))\n\n        getPos(fd, st.size, (er, position) => {\n          if (er)\n            return reject(er)\n          const stream = new fsm.WriteStream(opt.file, {\n            fd: fd,\n            start: position\n          })\n          p.pipe(stream)\n          stream.on('error', reject)\n          stream.on('close', resolve)\n          addFilesAsync(p, files)\n        })\n      })\n    }\n    fs.open(opt.file, flag, onopen)\n  })\n\n  return cb ? promise.then(cb, cb) : promise\n}\n\nconst addFilesSync = (p, files) => {\n  files.forEach(file => {\n    if (file.charAt(0) === '@')\n      t({\n        file: path.resolve(p.cwd, file.substr(1)),\n        sync: true,\n        noResume: true,\n        onentry: entry => p.add(entry)\n      })\n    else\n      p.add(file)\n  })\n  p.end()\n}\n\nconst addFilesAsync = (p, files) => {\n  while (files.length) {\n    const file = files.shift()\n    if (file.charAt(0) === '@')\n      return t({\n        file: path.resolve(p.cwd, file.substr(1)),\n        noResume: true,\n        onentry: entry => p.add(entry)\n      }).then(_ => addFilesAsync(p, files))\n    else\n      p.add(file)\n  }\n  p.end()\n}\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvc3dhcm0tanMvbm9kZV9tb2R1bGVzL3Rhci9saWIvcmVwbGFjZS5qcyIsIm1hcHBpbmdzIjoiQUFBWTtBQUNaLGVBQWUsbUJBQU8sQ0FBQyxpRkFBYTs7QUFFcEM7QUFDQSxZQUFZLG1CQUFPLENBQUMsaUdBQXFCO0FBQ3pDLGFBQWEsbUJBQU8sQ0FBQyw2RUFBVztBQUNoQyxjQUFjLG1CQUFPLENBQUMsK0VBQVk7QUFDbEMsV0FBVyxtQkFBTyxDQUFDLGNBQUk7QUFDdkIsWUFBWSxtQkFBTyxDQUFDLG9GQUFhO0FBQ2pDLFVBQVUsbUJBQU8sQ0FBQyw2RUFBVztBQUM3QixhQUFhLG1CQUFPLENBQUMsa0JBQU07O0FBRTNCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUEsZUFBZSxtQkFBTyxDQUFDLGlGQUFhOztBQUVwQztBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBLGlDQUFpQyxvQkFBb0I7QUFDckQsc0NBQXNDLGNBQWM7QUFDcEQ7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0EsSUFBSTtBQUNKO0FBQ0EsWUFBWSxtQkFBbUI7QUFDL0I7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsV0FBVztBQUNYO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNULE9BQU87QUFDUDtBQUNBO0FBQ0EsR0FBRzs7QUFFSDtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQSIsInNvdXJjZXMiOlsiL1VzZXJzL3BhbnphL0RvY3VtZW50cy9QZXJzb25hbFByb2plY3RzL3ByZWRpay9ub2RlX21vZHVsZXMvc3dhcm0tanMvbm9kZV9tb2R1bGVzL3Rhci9saWIvcmVwbGFjZS5qcyJdLCJzb3VyY2VzQ29udGVudCI6WyIndXNlIHN0cmljdCdcbmNvbnN0IEJ1ZmZlciA9IHJlcXVpcmUoJy4vYnVmZmVyLmpzJylcblxuLy8gdGFyIC1yXG5jb25zdCBobG8gPSByZXF1aXJlKCcuL2hpZ2gtbGV2ZWwtb3B0LmpzJylcbmNvbnN0IFBhY2sgPSByZXF1aXJlKCcuL3BhY2suanMnKVxuY29uc3QgUGFyc2UgPSByZXF1aXJlKCcuL3BhcnNlLmpzJylcbmNvbnN0IGZzID0gcmVxdWlyZSgnZnMnKVxuY29uc3QgZnNtID0gcmVxdWlyZSgnZnMtbWluaXBhc3MnKVxuY29uc3QgdCA9IHJlcXVpcmUoJy4vbGlzdC5qcycpXG5jb25zdCBwYXRoID0gcmVxdWlyZSgncGF0aCcpXG5cbi8vIHN0YXJ0aW5nIGF0IHRoZSBoZWFkIG9mIHRoZSBmaWxlLCByZWFkIGEgSGVhZGVyXG4vLyBJZiB0aGUgY2hlY2tzdW0gaXMgaW52YWxpZCwgdGhhdCdzIG91ciBwb3NpdGlvbiB0byBzdGFydCB3cml0aW5nXG4vLyBJZiBpdCBpcywganVtcCBmb3J3YXJkIGJ5IHRoZSBzcGVjaWZpZWQgc2l6ZSAocm91bmQgdXAgdG8gNTEyKVxuLy8gYW5kIHRyeSBhZ2Fpbi5cbi8vIFdyaXRlIHRoZSBuZXcgUGFjayBzdHJlYW0gc3RhcnRpbmcgdGhlcmUuXG5cbmNvbnN0IEhlYWRlciA9IHJlcXVpcmUoJy4vaGVhZGVyLmpzJylcblxuY29uc3QgciA9IG1vZHVsZS5leHBvcnRzID0gKG9wdF8sIGZpbGVzLCBjYikgPT4ge1xuICBjb25zdCBvcHQgPSBobG8ob3B0XylcblxuICBpZiAoIW9wdC5maWxlKVxuICAgIHRocm93IG5ldyBUeXBlRXJyb3IoJ2ZpbGUgaXMgcmVxdWlyZWQnKVxuXG4gIGlmIChvcHQuZ3ppcClcbiAgICB0aHJvdyBuZXcgVHlwZUVycm9yKCdjYW5ub3QgYXBwZW5kIHRvIGNvbXByZXNzZWQgYXJjaGl2ZXMnKVxuXG4gIGlmICghZmlsZXMgfHwgIUFycmF5LmlzQXJyYXkoZmlsZXMpIHx8ICFmaWxlcy5sZW5ndGgpXG4gICAgdGhyb3cgbmV3IFR5cGVFcnJvcignbm8gZmlsZXMgb3IgZGlyZWN0b3JpZXMgc3BlY2lmaWVkJylcblxuICBmaWxlcyA9IEFycmF5LmZyb20oZmlsZXMpXG5cbiAgcmV0dXJuIG9wdC5zeW5jID8gcmVwbGFjZVN5bmMob3B0LCBmaWxlcylcbiAgICA6IHJlcGxhY2Uob3B0LCBmaWxlcywgY2IpXG59XG5cbmNvbnN0IHJlcGxhY2VTeW5jID0gKG9wdCwgZmlsZXMpID0+IHtcbiAgY29uc3QgcCA9IG5ldyBQYWNrLlN5bmMob3B0KVxuXG4gIGxldCB0aHJldyA9IHRydWVcbiAgbGV0IGZkXG4gIGxldCBwb3NpdGlvblxuXG4gIHRyeSB7XG4gICAgdHJ5IHtcbiAgICAgIGZkID0gZnMub3BlblN5bmMob3B0LmZpbGUsICdyKycpXG4gICAgfSBjYXRjaCAoZXIpIHtcbiAgICAgIGlmIChlci5jb2RlID09PSAnRU5PRU5UJylcbiAgICAgICAgZmQgPSBmcy5vcGVuU3luYyhvcHQuZmlsZSwgJ3crJylcbiAgICAgIGVsc2VcbiAgICAgICAgdGhyb3cgZXJcbiAgICB9XG5cbiAgICBjb25zdCBzdCA9IGZzLmZzdGF0U3luYyhmZClcbiAgICBjb25zdCBoZWFkQnVmID0gQnVmZmVyLmFsbG9jKDUxMilcblxuICAgIFBPU0lUSU9OOiBmb3IgKHBvc2l0aW9uID0gMDsgcG9zaXRpb24gPCBzdC5zaXplOyBwb3NpdGlvbiArPSA1MTIpIHtcbiAgICAgIGZvciAobGV0IGJ1ZlBvcyA9IDAsIGJ5dGVzID0gMDsgYnVmUG9zIDwgNTEyOyBidWZQb3MgKz0gYnl0ZXMpIHtcbiAgICAgICAgYnl0ZXMgPSBmcy5yZWFkU3luYyhcbiAgICAgICAgICBmZCwgaGVhZEJ1ZiwgYnVmUG9zLCBoZWFkQnVmLmxlbmd0aCAtIGJ1ZlBvcywgcG9zaXRpb24gKyBidWZQb3NcbiAgICAgICAgKVxuXG4gICAgICAgIGlmIChwb3NpdGlvbiA9PT0gMCAmJiBoZWFkQnVmWzBdID09PSAweDFmICYmIGhlYWRCdWZbMV0gPT09IDB4OGIpXG4gICAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdjYW5ub3QgYXBwZW5kIHRvIGNvbXByZXNzZWQgYXJjaGl2ZXMnKVxuXG4gICAgICAgIGlmICghYnl0ZXMpXG4gICAgICAgICAgYnJlYWsgUE9TSVRJT05cbiAgICAgIH1cblxuICAgICAgbGV0IGggPSBuZXcgSGVhZGVyKGhlYWRCdWYpXG4gICAgICBpZiAoIWguY2tzdW1WYWxpZClcbiAgICAgICAgYnJlYWtcbiAgICAgIGxldCBlbnRyeUJsb2NrU2l6ZSA9IDUxMiAqIE1hdGguY2VpbChoLnNpemUgLyA1MTIpXG4gICAgICBpZiAocG9zaXRpb24gKyBlbnRyeUJsb2NrU2l6ZSArIDUxMiA+IHN0LnNpemUpXG4gICAgICAgIGJyZWFrXG4gICAgICAvLyB0aGUgNTEyIGZvciB0aGUgaGVhZGVyIHdlIGp1c3QgcGFyc2VkIHdpbGwgYmUgYWRkZWQgYXMgd2VsbFxuICAgICAgLy8gYWxzbyBqdW1wIGFoZWFkIGFsbCB0aGUgYmxvY2tzIGZvciB0aGUgYm9keVxuICAgICAgcG9zaXRpb24gKz0gZW50cnlCbG9ja1NpemVcbiAgICAgIGlmIChvcHQubXRpbWVDYWNoZSlcbiAgICAgICAgb3B0Lm10aW1lQ2FjaGUuc2V0KGgucGF0aCwgaC5tdGltZSlcbiAgICB9XG4gICAgdGhyZXcgPSBmYWxzZVxuXG4gICAgc3RyZWFtU3luYyhvcHQsIHAsIHBvc2l0aW9uLCBmZCwgZmlsZXMpXG4gIH0gZmluYWxseSB7XG4gICAgaWYgKHRocmV3KVxuICAgICAgdHJ5IHsgZnMuY2xvc2VTeW5jKGZkKSB9IGNhdGNoIChlcikge31cbiAgfVxufVxuXG5jb25zdCBzdHJlYW1TeW5jID0gKG9wdCwgcCwgcG9zaXRpb24sIGZkLCBmaWxlcykgPT4ge1xuICBjb25zdCBzdHJlYW0gPSBuZXcgZnNtLldyaXRlU3RyZWFtU3luYyhvcHQuZmlsZSwge1xuICAgIGZkOiBmZCxcbiAgICBzdGFydDogcG9zaXRpb25cbiAgfSlcbiAgcC5waXBlKHN0cmVhbSlcbiAgYWRkRmlsZXNTeW5jKHAsIGZpbGVzKVxufVxuXG5jb25zdCByZXBsYWNlID0gKG9wdCwgZmlsZXMsIGNiKSA9PiB7XG4gIGZpbGVzID0gQXJyYXkuZnJvbShmaWxlcylcbiAgY29uc3QgcCA9IG5ldyBQYWNrKG9wdClcblxuICBjb25zdCBnZXRQb3MgPSAoZmQsIHNpemUsIGNiXykgPT4ge1xuICAgIGNvbnN0IGNiID0gKGVyLCBwb3MpID0+IHtcbiAgICAgIGlmIChlcilcbiAgICAgICAgZnMuY2xvc2UoZmQsIF8gPT4gY2JfKGVyKSlcbiAgICAgIGVsc2VcbiAgICAgICAgY2JfKG51bGwsIHBvcylcbiAgICB9XG5cbiAgICBsZXQgcG9zaXRpb24gPSAwXG4gICAgaWYgKHNpemUgPT09IDApXG4gICAgICByZXR1cm4gY2IobnVsbCwgMClcblxuICAgIGxldCBidWZQb3MgPSAwXG4gICAgY29uc3QgaGVhZEJ1ZiA9IEJ1ZmZlci5hbGxvYyg1MTIpXG4gICAgY29uc3Qgb25yZWFkID0gKGVyLCBieXRlcykgPT4ge1xuICAgICAgaWYgKGVyKVxuICAgICAgICByZXR1cm4gY2IoZXIpXG4gICAgICBidWZQb3MgKz0gYnl0ZXNcbiAgICAgIGlmIChidWZQb3MgPCA1MTIgJiYgYnl0ZXMpXG4gICAgICAgIHJldHVybiBmcy5yZWFkKFxuICAgICAgICAgIGZkLCBoZWFkQnVmLCBidWZQb3MsIGhlYWRCdWYubGVuZ3RoIC0gYnVmUG9zLFxuICAgICAgICAgIHBvc2l0aW9uICsgYnVmUG9zLCBvbnJlYWRcbiAgICAgICAgKVxuXG4gICAgICBpZiAocG9zaXRpb24gPT09IDAgJiYgaGVhZEJ1ZlswXSA9PT0gMHgxZiAmJiBoZWFkQnVmWzFdID09PSAweDhiKVxuICAgICAgICByZXR1cm4gY2IobmV3IEVycm9yKCdjYW5ub3QgYXBwZW5kIHRvIGNvbXByZXNzZWQgYXJjaGl2ZXMnKSlcblxuICAgICAgLy8gdHJ1bmNhdGVkIGhlYWRlclxuICAgICAgaWYgKGJ1ZlBvcyA8IDUxMilcbiAgICAgICAgcmV0dXJuIGNiKG51bGwsIHBvc2l0aW9uKVxuXG4gICAgICBjb25zdCBoID0gbmV3IEhlYWRlcihoZWFkQnVmKVxuICAgICAgaWYgKCFoLmNrc3VtVmFsaWQpXG4gICAgICAgIHJldHVybiBjYihudWxsLCBwb3NpdGlvbilcblxuICAgICAgY29uc3QgZW50cnlCbG9ja1NpemUgPSA1MTIgKiBNYXRoLmNlaWwoaC5zaXplIC8gNTEyKVxuICAgICAgaWYgKHBvc2l0aW9uICsgZW50cnlCbG9ja1NpemUgKyA1MTIgPiBzaXplKVxuICAgICAgICByZXR1cm4gY2IobnVsbCwgcG9zaXRpb24pXG5cbiAgICAgIHBvc2l0aW9uICs9IGVudHJ5QmxvY2tTaXplICsgNTEyXG4gICAgICBpZiAocG9zaXRpb24gPj0gc2l6ZSlcbiAgICAgICAgcmV0dXJuIGNiKG51bGwsIHBvc2l0aW9uKVxuXG4gICAgICBpZiAob3B0Lm10aW1lQ2FjaGUpXG4gICAgICAgIG9wdC5tdGltZUNhY2hlLnNldChoLnBhdGgsIGgubXRpbWUpXG4gICAgICBidWZQb3MgPSAwXG4gICAgICBmcy5yZWFkKGZkLCBoZWFkQnVmLCAwLCA1MTIsIHBvc2l0aW9uLCBvbnJlYWQpXG4gICAgfVxuICAgIGZzLnJlYWQoZmQsIGhlYWRCdWYsIDAsIDUxMiwgcG9zaXRpb24sIG9ucmVhZClcbiAgfVxuXG4gIGNvbnN0IHByb21pc2UgPSBuZXcgUHJvbWlzZSgocmVzb2x2ZSwgcmVqZWN0KSA9PiB7XG4gICAgcC5vbignZXJyb3InLCByZWplY3QpXG4gICAgbGV0IGZsYWcgPSAncisnXG4gICAgY29uc3Qgb25vcGVuID0gKGVyLCBmZCkgPT4ge1xuICAgICAgaWYgKGVyICYmIGVyLmNvZGUgPT09ICdFTk9FTlQnICYmIGZsYWcgPT09ICdyKycpIHtcbiAgICAgICAgZmxhZyA9ICd3KydcbiAgICAgICAgcmV0dXJuIGZzLm9wZW4ob3B0LmZpbGUsIGZsYWcsIG9ub3BlbilcbiAgICAgIH1cblxuICAgICAgaWYgKGVyKVxuICAgICAgICByZXR1cm4gcmVqZWN0KGVyKVxuXG4gICAgICBmcy5mc3RhdChmZCwgKGVyLCBzdCkgPT4ge1xuICAgICAgICBpZiAoZXIpXG4gICAgICAgICAgcmV0dXJuIGZzLmNsb3NlKGZkLCAoKSA9PiByZWplY3QoZXIpKVxuXG4gICAgICAgIGdldFBvcyhmZCwgc3Quc2l6ZSwgKGVyLCBwb3NpdGlvbikgPT4ge1xuICAgICAgICAgIGlmIChlcilcbiAgICAgICAgICAgIHJldHVybiByZWplY3QoZXIpXG4gICAgICAgICAgY29uc3Qgc3RyZWFtID0gbmV3IGZzbS5Xcml0ZVN0cmVhbShvcHQuZmlsZSwge1xuICAgICAgICAgICAgZmQ6IGZkLFxuICAgICAgICAgICAgc3RhcnQ6IHBvc2l0aW9uXG4gICAgICAgICAgfSlcbiAgICAgICAgICBwLnBpcGUoc3RyZWFtKVxuICAgICAgICAgIHN0cmVhbS5vbignZXJyb3InLCByZWplY3QpXG4gICAgICAgICAgc3RyZWFtLm9uKCdjbG9zZScsIHJlc29sdmUpXG4gICAgICAgICAgYWRkRmlsZXNBc3luYyhwLCBmaWxlcylcbiAgICAgICAgfSlcbiAgICAgIH0pXG4gICAgfVxuICAgIGZzLm9wZW4ob3B0LmZpbGUsIGZsYWcsIG9ub3BlbilcbiAgfSlcblxuICByZXR1cm4gY2IgPyBwcm9taXNlLnRoZW4oY2IsIGNiKSA6IHByb21pc2Vcbn1cblxuY29uc3QgYWRkRmlsZXNTeW5jID0gKHAsIGZpbGVzKSA9PiB7XG4gIGZpbGVzLmZvckVhY2goZmlsZSA9PiB7XG4gICAgaWYgKGZpbGUuY2hhckF0KDApID09PSAnQCcpXG4gICAgICB0KHtcbiAgICAgICAgZmlsZTogcGF0aC5yZXNvbHZlKHAuY3dkLCBmaWxlLnN1YnN0cigxKSksXG4gICAgICAgIHN5bmM6IHRydWUsXG4gICAgICAgIG5vUmVzdW1lOiB0cnVlLFxuICAgICAgICBvbmVudHJ5OiBlbnRyeSA9PiBwLmFkZChlbnRyeSlcbiAgICAgIH0pXG4gICAgZWxzZVxuICAgICAgcC5hZGQoZmlsZSlcbiAgfSlcbiAgcC5lbmQoKVxufVxuXG5jb25zdCBhZGRGaWxlc0FzeW5jID0gKHAsIGZpbGVzKSA9PiB7XG4gIHdoaWxlIChmaWxlcy5sZW5ndGgpIHtcbiAgICBjb25zdCBmaWxlID0gZmlsZXMuc2hpZnQoKVxuICAgIGlmIChmaWxlLmNoYXJBdCgwKSA9PT0gJ0AnKVxuICAgICAgcmV0dXJuIHQoe1xuICAgICAgICBmaWxlOiBwYXRoLnJlc29sdmUocC5jd2QsIGZpbGUuc3Vic3RyKDEpKSxcbiAgICAgICAgbm9SZXN1bWU6IHRydWUsXG4gICAgICAgIG9uZW50cnk6IGVudHJ5ID0+IHAuYWRkKGVudHJ5KVxuICAgICAgfSkudGhlbihfID0+IGFkZEZpbGVzQXN5bmMocCwgZmlsZXMpKVxuICAgIGVsc2VcbiAgICAgIHAuYWRkKGZpbGUpXG4gIH1cbiAgcC5lbmQoKVxufVxuIl0sIm5hbWVzIjpbXSwiaWdub3JlTGlzdCI6WzBdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/swarm-js/node_modules/tar/lib/replace.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/swarm-js/node_modules/tar/lib/strip-absolute-path.js":
/*!***************************************************************************!*\
  !*** ./node_modules/swarm-js/node_modules/tar/lib/strip-absolute-path.js ***!
  \***************************************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

eval("// unix absolute paths are also absolute on win32, so we use this for both\nconst { isAbsolute, parse } = (__webpack_require__(/*! path */ \"path\").win32)\n\n// returns [root, stripped]\n// Note that windows will think that //x/y/z/a has a \"root\" of //x/y, and in\n// those cases, we want to sanitize it to x/y/z/a, not z/a, so we strip /\n// explicitly if it's the first character.\n// drive-specific relative paths on Windows get their root stripped off even\n// though they are not absolute, so `c:../foo` becomes ['c:', '../foo']\nmodule.exports = path => {\n  let r = ''\n\n  let parsed = parse(path)\n  while (isAbsolute(path) || parsed.root) {\n    // windows will think that //x/y/z has a \"root\" of //x/y/\n    // but strip the //?/C:/ off of //?/C:/path\n    const root = path.charAt(0) === '/' && path.slice(0, 4) !== '//?/' ? '/'\n      : parsed.root\n    path = path.substr(root.length)\n    r += root\n    parsed = parse(path)\n  }\n  return [r, path]\n}\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvc3dhcm0tanMvbm9kZV9tb2R1bGVzL3Rhci9saWIvc3RyaXAtYWJzb2x1dGUtcGF0aC5qcyIsIm1hcHBpbmdzIjoiQUFBQTtBQUNBLFFBQVEsb0JBQW9CLEVBQUUsK0NBQXFCOztBQUVuRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSIsInNvdXJjZXMiOlsiL1VzZXJzL3BhbnphL0RvY3VtZW50cy9QZXJzb25hbFByb2plY3RzL3ByZWRpay9ub2RlX21vZHVsZXMvc3dhcm0tanMvbm9kZV9tb2R1bGVzL3Rhci9saWIvc3RyaXAtYWJzb2x1dGUtcGF0aC5qcyJdLCJzb3VyY2VzQ29udGVudCI6WyIvLyB1bml4IGFic29sdXRlIHBhdGhzIGFyZSBhbHNvIGFic29sdXRlIG9uIHdpbjMyLCBzbyB3ZSB1c2UgdGhpcyBmb3IgYm90aFxuY29uc3QgeyBpc0Fic29sdXRlLCBwYXJzZSB9ID0gcmVxdWlyZSgncGF0aCcpLndpbjMyXG5cbi8vIHJldHVybnMgW3Jvb3QsIHN0cmlwcGVkXVxuLy8gTm90ZSB0aGF0IHdpbmRvd3Mgd2lsbCB0aGluayB0aGF0IC8veC95L3ovYSBoYXMgYSBcInJvb3RcIiBvZiAvL3gveSwgYW5kIGluXG4vLyB0aG9zZSBjYXNlcywgd2Ugd2FudCB0byBzYW5pdGl6ZSBpdCB0byB4L3kvei9hLCBub3Qgei9hLCBzbyB3ZSBzdHJpcCAvXG4vLyBleHBsaWNpdGx5IGlmIGl0J3MgdGhlIGZpcnN0IGNoYXJhY3Rlci5cbi8vIGRyaXZlLXNwZWNpZmljIHJlbGF0aXZlIHBhdGhzIG9uIFdpbmRvd3MgZ2V0IHRoZWlyIHJvb3Qgc3RyaXBwZWQgb2ZmIGV2ZW5cbi8vIHRob3VnaCB0aGV5IGFyZSBub3QgYWJzb2x1dGUsIHNvIGBjOi4uL2Zvb2AgYmVjb21lcyBbJ2M6JywgJy4uL2ZvbyddXG5tb2R1bGUuZXhwb3J0cyA9IHBhdGggPT4ge1xuICBsZXQgciA9ICcnXG5cbiAgbGV0IHBhcnNlZCA9IHBhcnNlKHBhdGgpXG4gIHdoaWxlIChpc0Fic29sdXRlKHBhdGgpIHx8IHBhcnNlZC5yb290KSB7XG4gICAgLy8gd2luZG93cyB3aWxsIHRoaW5rIHRoYXQgLy94L3kveiBoYXMgYSBcInJvb3RcIiBvZiAvL3gveS9cbiAgICAvLyBidXQgc3RyaXAgdGhlIC8vPy9DOi8gb2ZmIG9mIC8vPy9DOi9wYXRoXG4gICAgY29uc3Qgcm9vdCA9IHBhdGguY2hhckF0KDApID09PSAnLycgJiYgcGF0aC5zbGljZSgwLCA0KSAhPT0gJy8vPy8nID8gJy8nXG4gICAgICA6IHBhcnNlZC5yb290XG4gICAgcGF0aCA9IHBhdGguc3Vic3RyKHJvb3QubGVuZ3RoKVxuICAgIHIgKz0gcm9vdFxuICAgIHBhcnNlZCA9IHBhcnNlKHBhdGgpXG4gIH1cbiAgcmV0dXJuIFtyLCBwYXRoXVxufVxuIl0sIm5hbWVzIjpbXSwiaWdub3JlTGlzdCI6WzBdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/swarm-js/node_modules/tar/lib/strip-absolute-path.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/swarm-js/node_modules/tar/lib/strip-trailing-slashes.js":
/*!******************************************************************************!*\
  !*** ./node_modules/swarm-js/node_modules/tar/lib/strip-trailing-slashes.js ***!
  \******************************************************************************/
/***/ ((module) => {

eval("// this is the only approach that was significantly faster than using\n// str.replace(/\\/+$/, '') for strings ending with a lot of / chars and\n// containing multiple / chars.\nconst batchStrings = [\n  '/'.repeat(1024),\n  '/'.repeat(512),\n  '/'.repeat(256),\n  '/'.repeat(128),\n  '/'.repeat(64),\n  '/'.repeat(32),\n  '/'.repeat(16),\n  '/'.repeat(8),\n  '/'.repeat(4),\n  '/'.repeat(2),\n  '/',\n]\n\nmodule.exports = str => {\n  for (const s of batchStrings) {\n    while (str.length >= s.length && str.slice(-1 * s.length) === s)\n      str = str.slice(0, -1 * s.length)\n  }\n  return str\n}\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvc3dhcm0tanMvbm9kZV9tb2R1bGVzL3Rhci9saWIvc3RyaXAtdHJhaWxpbmctc2xhc2hlcy5qcyIsIm1hcHBpbmdzIjoiQUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSIsInNvdXJjZXMiOlsiL1VzZXJzL3BhbnphL0RvY3VtZW50cy9QZXJzb25hbFByb2plY3RzL3ByZWRpay9ub2RlX21vZHVsZXMvc3dhcm0tanMvbm9kZV9tb2R1bGVzL3Rhci9saWIvc3RyaXAtdHJhaWxpbmctc2xhc2hlcy5qcyJdLCJzb3VyY2VzQ29udGVudCI6WyIvLyB0aGlzIGlzIHRoZSBvbmx5IGFwcHJvYWNoIHRoYXQgd2FzIHNpZ25pZmljYW50bHkgZmFzdGVyIHRoYW4gdXNpbmdcbi8vIHN0ci5yZXBsYWNlKC9cXC8rJC8sICcnKSBmb3Igc3RyaW5ncyBlbmRpbmcgd2l0aCBhIGxvdCBvZiAvIGNoYXJzIGFuZFxuLy8gY29udGFpbmluZyBtdWx0aXBsZSAvIGNoYXJzLlxuY29uc3QgYmF0Y2hTdHJpbmdzID0gW1xuICAnLycucmVwZWF0KDEwMjQpLFxuICAnLycucmVwZWF0KDUxMiksXG4gICcvJy5yZXBlYXQoMjU2KSxcbiAgJy8nLnJlcGVhdCgxMjgpLFxuICAnLycucmVwZWF0KDY0KSxcbiAgJy8nLnJlcGVhdCgzMiksXG4gICcvJy5yZXBlYXQoMTYpLFxuICAnLycucmVwZWF0KDgpLFxuICAnLycucmVwZWF0KDQpLFxuICAnLycucmVwZWF0KDIpLFxuICAnLycsXG5dXG5cbm1vZHVsZS5leHBvcnRzID0gc3RyID0+IHtcbiAgZm9yIChjb25zdCBzIG9mIGJhdGNoU3RyaW5ncykge1xuICAgIHdoaWxlIChzdHIubGVuZ3RoID49IHMubGVuZ3RoICYmIHN0ci5zbGljZSgtMSAqIHMubGVuZ3RoKSA9PT0gcylcbiAgICAgIHN0ciA9IHN0ci5zbGljZSgwLCAtMSAqIHMubGVuZ3RoKVxuICB9XG4gIHJldHVybiBzdHJcbn1cbiJdLCJuYW1lcyI6W10sImlnbm9yZUxpc3QiOlswXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/swarm-js/node_modules/tar/lib/strip-trailing-slashes.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/swarm-js/node_modules/tar/lib/types.js":
/*!*************************************************************!*\
  !*** ./node_modules/swarm-js/node_modules/tar/lib/types.js ***!
  \*************************************************************/
/***/ ((__unused_webpack_module, exports) => {

"use strict";
eval("\n// map types from key to human-friendly name\nexports.name = new Map([\n  ['0', 'File'],\n  // same as File\n  ['', 'OldFile'],\n  ['1', 'Link'],\n  ['2', 'SymbolicLink'],\n  // Devices and FIFOs aren't fully supported\n  // they are parsed, but skipped when unpacking\n  ['3', 'CharacterDevice'],\n  ['4', 'BlockDevice'],\n  ['5', 'Directory'],\n  ['6', 'FIFO'],\n  // same as File\n  ['7', 'ContiguousFile'],\n  // pax headers\n  ['g', 'GlobalExtendedHeader'],\n  ['x', 'ExtendedHeader'],\n  // vendor-specific stuff\n  // skip\n  ['A', 'SolarisACL'],\n  // like 5, but with data, which should be skipped\n  ['D', 'GNUDumpDir'],\n  // metadata only, skip\n  ['I', 'Inode'],\n  // data = link path of next file\n  ['K', 'NextFileHasLongLinkpath'],\n  // data = path of next file\n  ['L', 'NextFileHasLongPath'],\n  // skip\n  ['M', 'ContinuationFile'],\n  // like L\n  ['N', 'OldGnuLongPath'],\n  // skip\n  ['S', 'SparseFile'],\n  // skip\n  ['V', 'TapeVolumeHeader'],\n  // like x\n  ['X', 'OldExtendedHeader']\n])\n\n// map the other direction\nexports.code = new Map(Array.from(exports.name).map(kv => [kv[1], kv[0]]))\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvc3dhcm0tanMvbm9kZV9tb2R1bGVzL3Rhci9saWIvdHlwZXMuanMiLCJtYXBwaW5ncyI6IkFBQVk7QUFDWjtBQUNBLFlBQVk7QUFDWjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0EsWUFBWSIsInNvdXJjZXMiOlsiL1VzZXJzL3BhbnphL0RvY3VtZW50cy9QZXJzb25hbFByb2plY3RzL3ByZWRpay9ub2RlX21vZHVsZXMvc3dhcm0tanMvbm9kZV9tb2R1bGVzL3Rhci9saWIvdHlwZXMuanMiXSwic291cmNlc0NvbnRlbnQiOlsiJ3VzZSBzdHJpY3QnXG4vLyBtYXAgdHlwZXMgZnJvbSBrZXkgdG8gaHVtYW4tZnJpZW5kbHkgbmFtZVxuZXhwb3J0cy5uYW1lID0gbmV3IE1hcChbXG4gIFsnMCcsICdGaWxlJ10sXG4gIC8vIHNhbWUgYXMgRmlsZVxuICBbJycsICdPbGRGaWxlJ10sXG4gIFsnMScsICdMaW5rJ10sXG4gIFsnMicsICdTeW1ib2xpY0xpbmsnXSxcbiAgLy8gRGV2aWNlcyBhbmQgRklGT3MgYXJlbid0IGZ1bGx5IHN1cHBvcnRlZFxuICAvLyB0aGV5IGFyZSBwYXJzZWQsIGJ1dCBza2lwcGVkIHdoZW4gdW5wYWNraW5nXG4gIFsnMycsICdDaGFyYWN0ZXJEZXZpY2UnXSxcbiAgWyc0JywgJ0Jsb2NrRGV2aWNlJ10sXG4gIFsnNScsICdEaXJlY3RvcnknXSxcbiAgWyc2JywgJ0ZJRk8nXSxcbiAgLy8gc2FtZSBhcyBGaWxlXG4gIFsnNycsICdDb250aWd1b3VzRmlsZSddLFxuICAvLyBwYXggaGVhZGVyc1xuICBbJ2cnLCAnR2xvYmFsRXh0ZW5kZWRIZWFkZXInXSxcbiAgWyd4JywgJ0V4dGVuZGVkSGVhZGVyJ10sXG4gIC8vIHZlbmRvci1zcGVjaWZpYyBzdHVmZlxuICAvLyBza2lwXG4gIFsnQScsICdTb2xhcmlzQUNMJ10sXG4gIC8vIGxpa2UgNSwgYnV0IHdpdGggZGF0YSwgd2hpY2ggc2hvdWxkIGJlIHNraXBwZWRcbiAgWydEJywgJ0dOVUR1bXBEaXInXSxcbiAgLy8gbWV0YWRhdGEgb25seSwgc2tpcFxuICBbJ0knLCAnSW5vZGUnXSxcbiAgLy8gZGF0YSA9IGxpbmsgcGF0aCBvZiBuZXh0IGZpbGVcbiAgWydLJywgJ05leHRGaWxlSGFzTG9uZ0xpbmtwYXRoJ10sXG4gIC8vIGRhdGEgPSBwYXRoIG9mIG5leHQgZmlsZVxuICBbJ0wnLCAnTmV4dEZpbGVIYXNMb25nUGF0aCddLFxuICAvLyBza2lwXG4gIFsnTScsICdDb250aW51YXRpb25GaWxlJ10sXG4gIC8vIGxpa2UgTFxuICBbJ04nLCAnT2xkR251TG9uZ1BhdGgnXSxcbiAgLy8gc2tpcFxuICBbJ1MnLCAnU3BhcnNlRmlsZSddLFxuICAvLyBza2lwXG4gIFsnVicsICdUYXBlVm9sdW1lSGVhZGVyJ10sXG4gIC8vIGxpa2UgeFxuICBbJ1gnLCAnT2xkRXh0ZW5kZWRIZWFkZXInXVxuXSlcblxuLy8gbWFwIHRoZSBvdGhlciBkaXJlY3Rpb25cbmV4cG9ydHMuY29kZSA9IG5ldyBNYXAoQXJyYXkuZnJvbShleHBvcnRzLm5hbWUpLm1hcChrdiA9PiBba3ZbMV0sIGt2WzBdXSkpXG4iXSwibmFtZXMiOltdLCJpZ25vcmVMaXN0IjpbMF0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/swarm-js/node_modules/tar/lib/types.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/swarm-js/node_modules/tar/lib/unpack.js":
/*!**************************************************************!*\
  !*** ./node_modules/swarm-js/node_modules/tar/lib/unpack.js ***!
  \**************************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";
eval("\n\n// the PEND/UNPEND stuff tracks whether we're ready to emit end/close yet.\n// but the path reservations are required to avoid race conditions where\n// parallelized unpack ops may mess with one another, due to dependencies\n// (like a Link depending on its target) or destructive operations (like\n// clobbering an fs object to create one of a different type.)\n\nconst assert = __webpack_require__(/*! assert */ \"assert\")\nconst EE = (__webpack_require__(/*! events */ \"events\").EventEmitter)\nconst Parser = __webpack_require__(/*! ./parse.js */ \"(ssr)/./node_modules/swarm-js/node_modules/tar/lib/parse.js\")\nconst fs = __webpack_require__(/*! fs */ \"fs\")\nconst fsm = __webpack_require__(/*! fs-minipass */ \"(ssr)/./node_modules/swarm-js/node_modules/fs-minipass/index.js\")\nconst path = __webpack_require__(/*! path */ \"path\")\nconst mkdir = __webpack_require__(/*! ./mkdir.js */ \"(ssr)/./node_modules/swarm-js/node_modules/tar/lib/mkdir.js\")\nconst mkdirSync = mkdir.sync\nconst wc = __webpack_require__(/*! ./winchars.js */ \"(ssr)/./node_modules/swarm-js/node_modules/tar/lib/winchars.js\")\nconst stripAbsolutePath = __webpack_require__(/*! ./strip-absolute-path.js */ \"(ssr)/./node_modules/swarm-js/node_modules/tar/lib/strip-absolute-path.js\")\nconst pathReservations = __webpack_require__(/*! ./path-reservations.js */ \"(ssr)/./node_modules/swarm-js/node_modules/tar/lib/path-reservations.js\")\nconst normPath = __webpack_require__(/*! ./normalize-windows-path.js */ \"(ssr)/./node_modules/swarm-js/node_modules/tar/lib/normalize-windows-path.js\")\nconst stripSlash = __webpack_require__(/*! ./strip-trailing-slashes.js */ \"(ssr)/./node_modules/swarm-js/node_modules/tar/lib/strip-trailing-slashes.js\")\n\nconst ONENTRY = Symbol('onEntry')\nconst CHECKFS = Symbol('checkFs')\nconst CHECKFS2 = Symbol('checkFs2')\nconst PRUNECACHE = Symbol('pruneCache')\nconst ISREUSABLE = Symbol('isReusable')\nconst MAKEFS = Symbol('makeFs')\nconst FILE = Symbol('file')\nconst DIRECTORY = Symbol('directory')\nconst LINK = Symbol('link')\nconst SYMLINK = Symbol('symlink')\nconst HARDLINK = Symbol('hardlink')\nconst UNSUPPORTED = Symbol('unsupported')\nconst UNKNOWN = Symbol('unknown')\nconst CHECKPATH = Symbol('checkPath')\nconst MKDIR = Symbol('mkdir')\nconst ONERROR = Symbol('onError')\nconst PENDING = Symbol('pending')\nconst PEND = Symbol('pend')\nconst UNPEND = Symbol('unpend')\nconst ENDED = Symbol('ended')\nconst MAYBECLOSE = Symbol('maybeClose')\nconst SKIP = Symbol('skip')\nconst DOCHOWN = Symbol('doChown')\nconst UID = Symbol('uid')\nconst GID = Symbol('gid')\nconst CHECKED_CWD = Symbol('checkedCwd')\nconst crypto = __webpack_require__(/*! crypto */ \"crypto\")\nconst platform = process.env.TESTING_TAR_FAKE_PLATFORM || process.platform\nconst isWindows = platform === 'win32'\n\n// Unlinks on Windows are not atomic.\n//\n// This means that if you have a file entry, followed by another\n// file entry with an identical name, and you cannot re-use the file\n// (because it's a hardlink, or because unlink:true is set, or it's\n// Windows, which does not have useful nlink values), then the unlink\n// will be committed to the disk AFTER the new file has been written\n// over the old one, deleting the new file.\n//\n// To work around this, on Windows systems, we rename the file and then\n// delete the renamed file.  It's a sloppy kludge, but frankly, I do not\n// know of a better way to do this, given windows' non-atomic unlink\n// semantics.\n//\n// See: https://github.com/npm/node-tar/issues/183\n/* istanbul ignore next */\nconst unlinkFile = (path, cb) => {\n  if (!isWindows)\n    return fs.unlink(path, cb)\n\n  const name = path + '.DELETE.' + crypto.randomBytes(16).toString('hex')\n  fs.rename(path, name, er => {\n    if (er)\n      return cb(er)\n    fs.unlink(name, cb)\n  })\n}\n\n/* istanbul ignore next */\nconst unlinkFileSync = path => {\n  if (!isWindows)\n    return fs.unlinkSync(path)\n\n  const name = path + '.DELETE.' + crypto.randomBytes(16).toString('hex')\n  fs.renameSync(path, name)\n  fs.unlinkSync(name)\n}\n\n// this.gid, entry.gid, this.processUid\nconst uint32 = (a, b, c) =>\n  a === a >>> 0 ? a\n  : b === b >>> 0 ? b\n  : c\n\n// clear the cache if it's a case-insensitive unicode-squashing match.\n// we can't know if the current file system is case-sensitive or supports\n// unicode fully, so we check for similarity on the maximally compatible\n// representation.  Err on the side of pruning, since all it's doing is\n// preventing lstats, and it's not the end of the world if we get a false\n// positive.\n// Note that on windows, we always drop the entire cache whenever a\n// symbolic link is encountered, because 8.3 filenames are impossible\n// to reason about, and collisions are hazards rather than just failures.\nconst cacheKeyNormalize = path => stripSlash(normPath(path))\n  .normalize('NFKD')\n  .toLowerCase()\n\nconst pruneCache = (cache, abs) => {\n  abs = cacheKeyNormalize(abs)\n  for (const path of cache.keys()) {\n    const pnorm = cacheKeyNormalize(path)\n    if (pnorm === abs || pnorm.indexOf(abs + '/') === 0)\n      cache.delete(path)\n  }\n}\n\nconst dropCache = cache => {\n  for (const key of cache.keys())\n    cache.delete(key)\n}\n\nclass Unpack extends Parser {\n  constructor (opt) {\n    if (!opt)\n      opt = {}\n\n    opt.ondone = _ => {\n      this[ENDED] = true\n      this[MAYBECLOSE]()\n    }\n\n    super(opt)\n\n    this[CHECKED_CWD] = false\n\n    this.reservations = pathReservations()\n\n    this.transform = typeof opt.transform === 'function' ? opt.transform : null\n\n    this.writable = true\n    this.readable = false\n\n    this[PENDING] = 0\n    this[ENDED] = false\n\n    this.dirCache = opt.dirCache || new Map()\n\n    if (typeof opt.uid === 'number' || typeof opt.gid === 'number') {\n      // need both or neither\n      if (typeof opt.uid !== 'number' || typeof opt.gid !== 'number')\n        throw new TypeError('cannot set owner without number uid and gid')\n      if (opt.preserveOwner)\n        throw new TypeError(\n          'cannot preserve owner in archive and also set owner explicitly')\n      this.uid = opt.uid\n      this.gid = opt.gid\n      this.setOwner = true\n    } else {\n      this.uid = null\n      this.gid = null\n      this.setOwner = false\n    }\n\n    // default true for root\n    if (opt.preserveOwner === undefined && typeof opt.uid !== 'number')\n      this.preserveOwner = process.getuid && process.getuid() === 0\n    else\n      this.preserveOwner = !!opt.preserveOwner\n\n    this.processUid = (this.preserveOwner || this.setOwner) && process.getuid ?\n      process.getuid() : null\n    this.processGid = (this.preserveOwner || this.setOwner) && process.getgid ?\n      process.getgid() : null\n\n    // mostly just for testing, but useful in some cases.\n    // Forcibly trigger a chown on every entry, no matter what\n    this.forceChown = opt.forceChown === true\n\n    // turn ><?| in filenames into 0xf000-higher encoded forms\n    this.win32 = !!opt.win32 || isWindows\n\n    // do not unpack over files that are newer than what's in the archive\n    this.newer = !!opt.newer\n\n    // do not unpack over ANY files\n    this.keep = !!opt.keep\n\n    // do not set mtime/atime of extracted entries\n    this.noMtime = !!opt.noMtime\n\n    // allow .., absolute path entries, and unpacking through symlinks\n    // without this, warn and skip .., relativize absolutes, and error\n    // on symlinks in extraction path\n    this.preservePaths = !!opt.preservePaths\n\n    // unlink files and links before writing. This breaks existing hard\n    // links, and removes symlink directories rather than erroring\n    this.unlink = !!opt.unlink\n\n    this.cwd = normPath(path.resolve(opt.cwd || process.cwd()))\n    this.strip = +opt.strip || 0\n    this.processUmask = process.umask()\n    this.umask = typeof opt.umask === 'number' ? opt.umask : this.processUmask\n    // default mode for dirs created as parents\n    this.dmode = opt.dmode || (0o0777 & (~this.umask))\n    this.fmode = opt.fmode || (0o0666 & (~this.umask))\n    this.on('entry', entry => this[ONENTRY](entry))\n  }\n\n  [MAYBECLOSE] () {\n    if (this[ENDED] && this[PENDING] === 0) {\n      this.emit('prefinish')\n      this.emit('finish')\n      this.emit('end')\n      this.emit('close')\n    }\n  }\n\n  [CHECKPATH] (entry) {\n    if (this.strip) {\n      const parts = normPath(entry.path).split('/')\n      if (parts.length < this.strip)\n        return false\n      entry.path = parts.slice(this.strip).join('/')\n\n      if (entry.type === 'Link') {\n        const linkparts = normPath(entry.linkpath).split('/')\n        if (linkparts.length >= this.strip)\n          entry.linkpath = linkparts.slice(this.strip).join('/')\n        else\n          return false\n      }\n    }\n\n    if (!this.preservePaths) {\n      const p = normPath(entry.path)\n      const parts = p.split('/')\n      if (parts.includes('..') || isWindows && /^[a-z]:\\.\\.$/i.test(parts[0])) {\n        this.warn(`path contains '..'`, p)\n        return false\n      }\n\n      // strip off the root\n      const s = stripAbsolutePath(p)\n      if (s[0]) {\n        entry.path = s[1]\n        this.warn(`stripping ${s[0]} from absolute path`, p)\n      }\n    }\n\n    if (path.isAbsolute(entry.path))\n      entry.absolute = normPath(path.resolve(entry.path))\n    else\n      entry.absolute = normPath(path.resolve(this.cwd, entry.path))\n\n    // if we somehow ended up with a path that escapes the cwd, and we are\n    // not in preservePaths mode, then something is fishy!  This should have\n    // been prevented above, so ignore this for coverage.\n    /* istanbul ignore if - defense in depth */\n    if (!this.preservePaths &&\n        entry.absolute.indexOf(this.cwd + '/') !== 0 &&\n        entry.absolute !== this.cwd) {\n      this.warn('TAR_ENTRY_ERROR', 'path escaped extraction target', {\n        entry,\n        path: normPath(entry.path),\n        resolvedPath: entry.absolute,\n        cwd: this.cwd,\n      })\n      return false\n    }\n\n    // an archive can set properties on the extraction directory, but it\n    // may not replace the cwd with a different kind of thing entirely.\n    if (entry.absolute === this.cwd &&\n        entry.type !== 'Directory' &&\n        entry.type !== 'GNUDumpDir')\n      return false\n\n    // only encode : chars that aren't drive letter indicators\n    if (this.win32) {\n      const { root: aRoot } = path.win32.parse(entry.absolute)\n      entry.absolute = aRoot + wc.encode(entry.absolute.substr(aRoot.length))\n      const { root: pRoot } = path.win32.parse(entry.path)\n      entry.path = pRoot + wc.encode(entry.path.substr(pRoot.length))\n    }\n\n    return true\n  }\n\n  [ONENTRY] (entry) {\n    if (!this[CHECKPATH](entry))\n      return entry.resume()\n\n    assert.equal(typeof entry.absolute, 'string')\n\n    switch (entry.type) {\n      case 'Directory':\n      case 'GNUDumpDir':\n        if (entry.mode)\n          entry.mode = entry.mode | 0o700\n\n      case 'File':\n      case 'OldFile':\n      case 'ContiguousFile':\n      case 'Link':\n      case 'SymbolicLink':\n        return this[CHECKFS](entry)\n\n      case 'CharacterDevice':\n      case 'BlockDevice':\n      case 'FIFO':\n        return this[UNSUPPORTED](entry)\n    }\n  }\n\n  [ONERROR] (er, entry) {\n    // Cwd has to exist, or else nothing works. That's serious.\n    // Other errors are warnings, which raise the error in strict\n    // mode, but otherwise continue on.\n    if (er.name === 'CwdError')\n      this.emit('error', er)\n    else {\n      this.warn(er.message, er)\n      this[UNPEND]()\n      entry.resume()\n    }\n  }\n\n  [MKDIR] (dir, mode, cb) {\n    mkdir(normPath(dir), {\n      uid: this.uid,\n      gid: this.gid,\n      processUid: this.processUid,\n      processGid: this.processGid,\n      umask: this.processUmask,\n      preserve: this.preservePaths,\n      unlink: this.unlink,\n      cache: this.dirCache,\n      cwd: this.cwd,\n      mode: mode\n    }, cb)\n  }\n\n  [DOCHOWN] (entry) {\n    // in preserve owner mode, chown if the entry doesn't match process\n    // in set owner mode, chown if setting doesn't match process\n    return this.forceChown ||\n      this.preserveOwner &&\n      ( typeof entry.uid === 'number' && entry.uid !== this.processUid ||\n        typeof entry.gid === 'number' && entry.gid !== this.processGid )\n      ||\n      ( typeof this.uid === 'number' && this.uid !== this.processUid ||\n        typeof this.gid === 'number' && this.gid !== this.processGid )\n  }\n\n  [UID] (entry) {\n    return uint32(this.uid, entry.uid, this.processUid)\n  }\n\n  [GID] (entry) {\n    return uint32(this.gid, entry.gid, this.processGid)\n  }\n\n  [FILE] (entry, fullyDone) {\n    const mode = entry.mode & 0o7777 || this.fmode\n    const stream = new fsm.WriteStream(entry.absolute, {\n      mode: mode,\n      autoClose: false\n    })\n    stream.on('error', er => {\n      if (stream.fd)\n        fs.close(stream.fd, () => {})\n\n      // flush all the data out so that we aren't left hanging\n      // if the error wasn't actually fatal.  otherwise the parse\n      // is blocked, and we never proceed.\n      /* istanbul ignore next */\n      stream.write = () => true\n      this[ONERROR](er, entry)\n      fullyDone()\n    })\n\n    let actions = 1\n    const done = er => {\n      if (er) {\n        /* istanbul ignore else - we should always have a fd by now */\n        if (stream.fd)\n          fs.close(stream.fd, () => {})\n\n        this[ONERROR](er, entry)\n        fullyDone()\n        return\n      }\n\n      if (--actions === 0) {\n        fs.close(stream.fd, er => {\n          fullyDone()\n          /* istanbul ignore next */\n          er ? this[ONERROR](er, entry) : this[UNPEND]()\n        })\n      }\n    }\n\n    stream.on('finish', _ => {\n      // if futimes fails, try utimes\n      // if utimes fails, fail with the original error\n      // same for fchown/chown\n      const abs = entry.absolute\n      const fd = stream.fd\n\n      if (entry.mtime && !this.noMtime) {\n        actions++\n        const atime = entry.atime || new Date()\n        const mtime = entry.mtime\n        fs.futimes(fd, atime, mtime, er =>\n          er ? fs.utimes(abs, atime, mtime, er2 => done(er2 && er))\n          : done())\n      }\n\n      if (this[DOCHOWN](entry)) {\n        actions++\n        const uid = this[UID](entry)\n        const gid = this[GID](entry)\n        fs.fchown(fd, uid, gid, er =>\n          er ? fs.chown(abs, uid, gid, er2 => done(er2 && er))\n          : done())\n      }\n\n      done()\n    })\n\n    const tx = this.transform ? this.transform(entry) || entry : entry\n    if (tx !== entry) {\n      tx.on('error', er => this[ONERROR](er, entry))\n      entry.pipe(tx)\n    }\n    tx.pipe(stream)\n  }\n\n  [DIRECTORY] (entry, fullyDone) {\n    const mode = entry.mode & 0o7777 || this.dmode\n    this[MKDIR](entry.absolute, mode, er => {\n      if (er) {\n        fullyDone()\n        return this[ONERROR](er, entry)\n      }\n\n      let actions = 1\n      const done = _ => {\n        if (--actions === 0) {\n          fullyDone()\n          this[UNPEND]()\n          entry.resume()\n        }\n      }\n\n      if (entry.mtime && !this.noMtime) {\n        actions++\n        fs.utimes(entry.absolute, entry.atime || new Date(), entry.mtime, done)\n      }\n\n      if (this[DOCHOWN](entry)) {\n        actions++\n        fs.chown(entry.absolute, this[UID](entry), this[GID](entry), done)\n      }\n\n      done()\n    })\n  }\n\n  [UNSUPPORTED] (entry) {\n    this.warn('unsupported entry type: ' + entry.type, entry)\n    entry.resume()\n  }\n\n  [SYMLINK] (entry, done) {\n    this[LINK](entry, entry.linkpath, 'symlink', done)\n  }\n\n  [HARDLINK] (entry, done) {\n    const linkpath = normPath(path.resolve(this.cwd, entry.linkpath))\n    this[LINK](entry, linkpath, 'link', done)\n  }\n\n  [PEND] () {\n    this[PENDING]++\n  }\n\n  [UNPEND] () {\n    this[PENDING]--\n    this[MAYBECLOSE]()\n  }\n\n  [SKIP] (entry) {\n    this[UNPEND]()\n    entry.resume()\n  }\n\n  // Check if we can reuse an existing filesystem entry safely and\n  // overwrite it, rather than unlinking and recreating\n  // Windows doesn't report a useful nlink, so we just never reuse entries\n  [ISREUSABLE] (entry, st) {\n    return entry.type === 'File' &&\n      !this.unlink &&\n      st.isFile() &&\n      st.nlink <= 1 &&\n      !isWindows\n  }\n\n  // check if a thing is there, and if so, try to clobber it\n  [CHECKFS] (entry) {\n    this[PEND]()\n    const paths = [entry.path]\n    if (entry.linkpath)\n      paths.push(entry.linkpath)\n    this.reservations.reserve(paths, done => this[CHECKFS2](entry, done))\n  }\n\n  [PRUNECACHE] (entry) {\n    // if we are not creating a directory, and the path is in the dirCache,\n    // then that means we are about to delete the directory we created\n    // previously, and it is no longer going to be a directory, and neither\n    // is any of its children.\n    // If a symbolic link is encountered, all bets are off.  There is no\n    // reasonable way to sanitize the cache in such a way we will be able to\n    // avoid having filesystem collisions.  If this happens with a non-symlink\n    // entry, it'll just fail to unpack, but a symlink to a directory, using an\n    // 8.3 shortname or certain unicode attacks, can evade detection and lead\n    // to arbitrary writes to anywhere on the system.\n    if (entry.type === 'SymbolicLink')\n      dropCache(this.dirCache)\n    else if (entry.type !== 'Directory')\n      pruneCache(this.dirCache, entry.absolute)\n  }\n\n  [CHECKFS2] (entry, fullyDone) {\n    this[PRUNECACHE](entry)\n\n    const done = er => {\n      this[PRUNECACHE](entry)\n      fullyDone(er)\n    }\n\n    const checkCwd = () => {\n      this[MKDIR](this.cwd, this.dmode, er => {\n        if (er) {\n          this[ONERROR](er, entry)\n          done()\n          return\n        }\n        this[CHECKED_CWD] = true\n        start()\n      })\n    }\n\n    const start = () => {\n      if (entry.absolute !== this.cwd) {\n        const parent = normPath(path.dirname(entry.absolute))\n        if (parent !== this.cwd) {\n          return this[MKDIR](parent, this.dmode, er => {\n            if (er) {\n              this[ONERROR](er, entry)\n              done()\n              return\n            }\n            afterMakeParent()\n          })\n        }\n      }\n      afterMakeParent()\n    }\n\n    const afterMakeParent = () => {\n      fs.lstat(entry.absolute, (lstatEr, st) => {\n        if (st && (this.keep || this.newer && st.mtime > entry.mtime)) {\n          this[SKIP](entry)\n          done()\n          return\n        }\n        if (lstatEr || this[ISREUSABLE](entry, st))\n          return this[MAKEFS](null, entry, done)\n\n        if (st.isDirectory()) {\n          if (entry.type === 'Directory') {\n            const needChmod = !this.noChmod &&\n              entry.mode &&\n              (st.mode & 0o7777) !== entry.mode\n            const afterChmod = er => this[MAKEFS](er, entry, done)\n            if (!needChmod)\n              return afterChmod()\n            return fs.chmod(entry.absolute, entry.mode, afterChmod)\n          }\n          // Not a dir entry, have to remove it.\n          // NB: the only way to end up with an entry that is the cwd\n          // itself, in such a way that == does not detect, is a\n          // tricky windows absolute path with UNC or 8.3 parts (and\n          // preservePaths:true, or else it will have been stripped).\n          // In that case, the user has opted out of path protections\n          // explicitly, so if they blow away the cwd, c'est la vie.\n          if (entry.absolute !== this.cwd) {\n            return fs.rmdir(entry.absolute, er =>\n              this[MAKEFS](er, entry, done))\n          }\n        }\n\n        // not a dir, and not reusable\n        // don't remove if the cwd, we want that error\n        if (entry.absolute === this.cwd)\n          return this[MAKEFS](null, entry, done)\n\n        unlinkFile(entry.absolute, er =>\n          this[MAKEFS](er, entry, done))\n      })\n    }\n\n    if (this[CHECKED_CWD])\n      start()\n    else\n      checkCwd()\n  }\n\n  [MAKEFS] (er, entry, done) {\n    if (er)\n      return this[ONERROR](er, entry)\n\n    switch (entry.type) {\n      case 'File':\n      case 'OldFile':\n      case 'ContiguousFile':\n        return this[FILE](entry, done)\n\n      case 'Link':\n        return this[HARDLINK](entry, done)\n\n      case 'SymbolicLink':\n        return this[SYMLINK](entry, done)\n\n      case 'Directory':\n      case 'GNUDumpDir':\n        return this[DIRECTORY](entry, done)\n    }\n  }\n\n  [LINK] (entry, linkpath, link, done) {\n    // XXX: get the type ('symlink' or 'junction') for windows\n    fs[link](linkpath, entry.absolute, er => {\n      if (er)\n        return this[ONERROR](er, entry)\n      done()\n      this[UNPEND]()\n      entry.resume()\n    })\n  }\n}\n\nconst callSync = fn => {\n  try {\n    return [null, fn()]\n  } catch (er) {\n    return [er, null]\n  }\n}\nclass UnpackSync extends Unpack {\n  [MAKEFS] (er, entry) {\n    return super[MAKEFS](er, entry, /* istanbul ignore next */ () => {})\n  }\n\n  [CHECKFS] (entry) {\n    this[PRUNECACHE](entry)\n\n    if (!this[CHECKED_CWD]) {\n      const er = this[MKDIR](this.cwd, this.dmode)\n      if (er)\n        return this[ONERROR](er, entry)\n      this[CHECKED_CWD] = true\n    }\n\n    // don't bother to make the parent if the current entry is the cwd,\n    // we've already checked it.\n    if (entry.absolute !== this.cwd) {\n      const parent = normPath(path.dirname(entry.absolute))\n      if (parent !== this.cwd) {\n        const mkParent = this[MKDIR](parent, this.dmode)\n        if (mkParent)\n          return this[ONERROR](mkParent, entry)\n      }\n    }\n\n    const [lstatEr, st] = callSync(() => fs.lstatSync(entry.absolute))\n    if (st && (this.keep || this.newer && st.mtime > entry.mtime))\n      return this[SKIP](entry)\n\n    if (lstatEr || this[ISREUSABLE](entry, st))\n      return this[MAKEFS](null, entry)\n\n    if (st.isDirectory()) {\n      if (entry.type === 'Directory') {\n        const needChmod = !this.noChmod &&\n          entry.mode &&\n          (st.mode & 0o7777) !== entry.mode\n        const [er] = needChmod ? callSync(() => {\n          fs.chmodSync(entry.absolute, entry.mode)\n        }) : []\n        return this[MAKEFS](er, entry)\n      }\n      // not a dir entry, have to remove it\n      const [er] = callSync(() => fs.rmdirSync(entry.absolute))\n      this[MAKEFS](er, entry)\n    }\n\n    // not a dir, and not reusable.\n    // don't remove if it's the cwd, since we want that error.\n    const [er] = entry.absolute === this.cwd ? []\n      : callSync(() => unlinkFileSync(entry.absolute))\n    this[MAKEFS](er, entry)\n  }\n\n  [FILE] (entry, done) {\n    const mode = entry.mode & 0o7777 || this.fmode\n\n    const oner = er => {\n      let closeError\n      try {\n        fs.closeSync(fd)\n      } catch (e) {\n        closeError = e\n      }\n      if (er || closeError)\n        this[ONERROR](er || closeError, entry)\n      done()\n    }\n\n    let stream\n    let fd\n    try {\n      fd = fs.openSync(entry.absolute, 'w', mode)\n    } catch (er) {\n      return oner(er)\n    }\n    const tx = this.transform ? this.transform(entry) || entry : entry\n    if (tx !== entry) {\n      tx.on('error', er => this[ONERROR](er, entry))\n      entry.pipe(tx)\n    }\n\n    tx.on('data', chunk => {\n      try {\n        fs.writeSync(fd, chunk, 0, chunk.length)\n      } catch (er) {\n        oner(er)\n      }\n    })\n\n    tx.on('end', _ => {\n      let er = null\n      // try both, falling futimes back to utimes\n      // if either fails, handle the first error\n      if (entry.mtime && !this.noMtime) {\n        const atime = entry.atime || new Date()\n        const mtime = entry.mtime\n        try {\n          fs.futimesSync(fd, atime, mtime)\n        } catch (futimeser) {\n          try {\n            fs.utimesSync(entry.absolute, atime, mtime)\n          } catch (utimeser) {\n            er = futimeser\n          }\n        }\n      }\n\n      if (this[DOCHOWN](entry)) {\n        const uid = this[UID](entry)\n        const gid = this[GID](entry)\n\n        try {\n          fs.fchownSync(fd, uid, gid)\n        } catch (fchowner) {\n          try {\n            fs.chownSync(entry.absolute, uid, gid)\n          } catch (chowner) {\n            er = er || fchowner\n          }\n        }\n      }\n\n      oner(er)\n    })\n  }\n\n  [DIRECTORY] (entry, done) {\n    const mode = entry.mode & 0o7777 || this.dmode\n    const er = this[MKDIR](entry.absolute, mode)\n    if (er) {\n      this[ONERROR](er, entry)\n      done()\n      return\n    }\n    if (entry.mtime && !this.noMtime) {\n      try {\n        fs.utimesSync(entry.absolute, entry.atime || new Date(), entry.mtime)\n      } catch (er) {}\n    }\n    if (this[DOCHOWN](entry)) {\n      try {\n        fs.chownSync(entry.absolute, this[UID](entry), this[GID](entry))\n      } catch (er) {}\n    }\n    done()\n    entry.resume()\n  }\n\n  [MKDIR] (dir, mode) {\n    try {\n      return mkdir.sync(normPath(dir), {\n        uid: this.uid,\n        gid: this.gid,\n        processUid: this.processUid,\n        processGid: this.processGid,\n        umask: this.processUmask,\n        preserve: this.preservePaths,\n        unlink: this.unlink,\n        cache: this.dirCache,\n        cwd: this.cwd,\n        mode: mode\n      })\n    } catch (er) {\n      return er\n    }\n  }\n\n  [LINK] (entry, linkpath, link, done) {\n    try {\n      fs[link + 'Sync'](linkpath, entry.absolute)\n      done()\n      entry.resume()\n    } catch (er) {\n      return this[ONERROR](er, entry)\n    }\n  }\n}\n\nUnpack.Sync = UnpackSync\nmodule.exports = Unpack\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvc3dhcm0tanMvbm9kZV9tb2R1bGVzL3Rhci9saWIvdW5wYWNrLmpzIiwibWFwcGluZ3MiOiJBQUFZOztBQUVaO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUEsZUFBZSxtQkFBTyxDQUFDLHNCQUFRO0FBQy9CLFdBQVcsMERBQThCO0FBQ3pDLGVBQWUsbUJBQU8sQ0FBQywrRUFBWTtBQUNuQyxXQUFXLG1CQUFPLENBQUMsY0FBSTtBQUN2QixZQUFZLG1CQUFPLENBQUMsb0ZBQWE7QUFDakMsYUFBYSxtQkFBTyxDQUFDLGtCQUFNO0FBQzNCLGNBQWMsbUJBQU8sQ0FBQywrRUFBWTtBQUNsQztBQUNBLFdBQVcsbUJBQU8sQ0FBQyxxRkFBZTtBQUNsQywwQkFBMEIsbUJBQU8sQ0FBQywyR0FBMEI7QUFDNUQseUJBQXlCLG1CQUFPLENBQUMsdUdBQXdCO0FBQ3pELGlCQUFpQixtQkFBTyxDQUFDLGlIQUE2QjtBQUN0RCxtQkFBbUIsbUJBQU8sQ0FBQyxpSEFBNkI7O0FBRXhEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxlQUFlLG1CQUFPLENBQUMsc0JBQVE7QUFDL0I7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsK0JBQStCLE1BQU07QUFDckM7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLGNBQWMsY0FBYztBQUM1QjtBQUNBLGNBQWMsY0FBYztBQUM1QjtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQSxvQ0FBb0M7O0FBRXBDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSzs7QUFFTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esc0NBQXNDOztBQUV0QztBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLEtBQUs7O0FBRUw7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLEtBQUs7QUFDTDs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFdBQVc7QUFDWDtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLE9BQU87QUFDUDs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxJQUFJO0FBQ0o7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHVFQUF1RTtBQUN2RTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxRQUFRO0FBQ1I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLFFBQVE7QUFDUjtBQUNBO0FBQ0EsS0FBSzs7QUFFTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxVQUFVO0FBQ1Y7QUFDQTtBQUNBLFlBQVk7QUFDWjtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLFVBQVU7QUFDVjtBQUNBO0FBQ0EsWUFBWTtBQUNaO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0EsS0FBSztBQUNMOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxRQUFRO0FBQ1I7QUFDQTtBQUNBO0FBQ0E7QUFDQSxRQUFRO0FBQ1I7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1AsTUFBTTtBQUNOO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0EiLCJzb3VyY2VzIjpbIi9Vc2Vycy9wYW56YS9Eb2N1bWVudHMvUGVyc29uYWxQcm9qZWN0cy9wcmVkaWsvbm9kZV9tb2R1bGVzL3N3YXJtLWpzL25vZGVfbW9kdWxlcy90YXIvbGliL3VucGFjay5qcyJdLCJzb3VyY2VzQ29udGVudCI6WyIndXNlIHN0cmljdCdcblxuLy8gdGhlIFBFTkQvVU5QRU5EIHN0dWZmIHRyYWNrcyB3aGV0aGVyIHdlJ3JlIHJlYWR5IHRvIGVtaXQgZW5kL2Nsb3NlIHlldC5cbi8vIGJ1dCB0aGUgcGF0aCByZXNlcnZhdGlvbnMgYXJlIHJlcXVpcmVkIHRvIGF2b2lkIHJhY2UgY29uZGl0aW9ucyB3aGVyZVxuLy8gcGFyYWxsZWxpemVkIHVucGFjayBvcHMgbWF5IG1lc3Mgd2l0aCBvbmUgYW5vdGhlciwgZHVlIHRvIGRlcGVuZGVuY2llc1xuLy8gKGxpa2UgYSBMaW5rIGRlcGVuZGluZyBvbiBpdHMgdGFyZ2V0KSBvciBkZXN0cnVjdGl2ZSBvcGVyYXRpb25zIChsaWtlXG4vLyBjbG9iYmVyaW5nIGFuIGZzIG9iamVjdCB0byBjcmVhdGUgb25lIG9mIGEgZGlmZmVyZW50IHR5cGUuKVxuXG5jb25zdCBhc3NlcnQgPSByZXF1aXJlKCdhc3NlcnQnKVxuY29uc3QgRUUgPSByZXF1aXJlKCdldmVudHMnKS5FdmVudEVtaXR0ZXJcbmNvbnN0IFBhcnNlciA9IHJlcXVpcmUoJy4vcGFyc2UuanMnKVxuY29uc3QgZnMgPSByZXF1aXJlKCdmcycpXG5jb25zdCBmc20gPSByZXF1aXJlKCdmcy1taW5pcGFzcycpXG5jb25zdCBwYXRoID0gcmVxdWlyZSgncGF0aCcpXG5jb25zdCBta2RpciA9IHJlcXVpcmUoJy4vbWtkaXIuanMnKVxuY29uc3QgbWtkaXJTeW5jID0gbWtkaXIuc3luY1xuY29uc3Qgd2MgPSByZXF1aXJlKCcuL3dpbmNoYXJzLmpzJylcbmNvbnN0IHN0cmlwQWJzb2x1dGVQYXRoID0gcmVxdWlyZSgnLi9zdHJpcC1hYnNvbHV0ZS1wYXRoLmpzJylcbmNvbnN0IHBhdGhSZXNlcnZhdGlvbnMgPSByZXF1aXJlKCcuL3BhdGgtcmVzZXJ2YXRpb25zLmpzJylcbmNvbnN0IG5vcm1QYXRoID0gcmVxdWlyZSgnLi9ub3JtYWxpemUtd2luZG93cy1wYXRoLmpzJylcbmNvbnN0IHN0cmlwU2xhc2ggPSByZXF1aXJlKCcuL3N0cmlwLXRyYWlsaW5nLXNsYXNoZXMuanMnKVxuXG5jb25zdCBPTkVOVFJZID0gU3ltYm9sKCdvbkVudHJ5JylcbmNvbnN0IENIRUNLRlMgPSBTeW1ib2woJ2NoZWNrRnMnKVxuY29uc3QgQ0hFQ0tGUzIgPSBTeW1ib2woJ2NoZWNrRnMyJylcbmNvbnN0IFBSVU5FQ0FDSEUgPSBTeW1ib2woJ3BydW5lQ2FjaGUnKVxuY29uc3QgSVNSRVVTQUJMRSA9IFN5bWJvbCgnaXNSZXVzYWJsZScpXG5jb25zdCBNQUtFRlMgPSBTeW1ib2woJ21ha2VGcycpXG5jb25zdCBGSUxFID0gU3ltYm9sKCdmaWxlJylcbmNvbnN0IERJUkVDVE9SWSA9IFN5bWJvbCgnZGlyZWN0b3J5JylcbmNvbnN0IExJTksgPSBTeW1ib2woJ2xpbmsnKVxuY29uc3QgU1lNTElOSyA9IFN5bWJvbCgnc3ltbGluaycpXG5jb25zdCBIQVJETElOSyA9IFN5bWJvbCgnaGFyZGxpbmsnKVxuY29uc3QgVU5TVVBQT1JURUQgPSBTeW1ib2woJ3Vuc3VwcG9ydGVkJylcbmNvbnN0IFVOS05PV04gPSBTeW1ib2woJ3Vua25vd24nKVxuY29uc3QgQ0hFQ0tQQVRIID0gU3ltYm9sKCdjaGVja1BhdGgnKVxuY29uc3QgTUtESVIgPSBTeW1ib2woJ21rZGlyJylcbmNvbnN0IE9ORVJST1IgPSBTeW1ib2woJ29uRXJyb3InKVxuY29uc3QgUEVORElORyA9IFN5bWJvbCgncGVuZGluZycpXG5jb25zdCBQRU5EID0gU3ltYm9sKCdwZW5kJylcbmNvbnN0IFVOUEVORCA9IFN5bWJvbCgndW5wZW5kJylcbmNvbnN0IEVOREVEID0gU3ltYm9sKCdlbmRlZCcpXG5jb25zdCBNQVlCRUNMT1NFID0gU3ltYm9sKCdtYXliZUNsb3NlJylcbmNvbnN0IFNLSVAgPSBTeW1ib2woJ3NraXAnKVxuY29uc3QgRE9DSE9XTiA9IFN5bWJvbCgnZG9DaG93bicpXG5jb25zdCBVSUQgPSBTeW1ib2woJ3VpZCcpXG5jb25zdCBHSUQgPSBTeW1ib2woJ2dpZCcpXG5jb25zdCBDSEVDS0VEX0NXRCA9IFN5bWJvbCgnY2hlY2tlZEN3ZCcpXG5jb25zdCBjcnlwdG8gPSByZXF1aXJlKCdjcnlwdG8nKVxuY29uc3QgcGxhdGZvcm0gPSBwcm9jZXNzLmVudi5URVNUSU5HX1RBUl9GQUtFX1BMQVRGT1JNIHx8IHByb2Nlc3MucGxhdGZvcm1cbmNvbnN0IGlzV2luZG93cyA9IHBsYXRmb3JtID09PSAnd2luMzInXG5cbi8vIFVubGlua3Mgb24gV2luZG93cyBhcmUgbm90IGF0b21pYy5cbi8vXG4vLyBUaGlzIG1lYW5zIHRoYXQgaWYgeW91IGhhdmUgYSBmaWxlIGVudHJ5LCBmb2xsb3dlZCBieSBhbm90aGVyXG4vLyBmaWxlIGVudHJ5IHdpdGggYW4gaWRlbnRpY2FsIG5hbWUsIGFuZCB5b3UgY2Fubm90IHJlLXVzZSB0aGUgZmlsZVxuLy8gKGJlY2F1c2UgaXQncyBhIGhhcmRsaW5rLCBvciBiZWNhdXNlIHVubGluazp0cnVlIGlzIHNldCwgb3IgaXQnc1xuLy8gV2luZG93cywgd2hpY2ggZG9lcyBub3QgaGF2ZSB1c2VmdWwgbmxpbmsgdmFsdWVzKSwgdGhlbiB0aGUgdW5saW5rXG4vLyB3aWxsIGJlIGNvbW1pdHRlZCB0byB0aGUgZGlzayBBRlRFUiB0aGUgbmV3IGZpbGUgaGFzIGJlZW4gd3JpdHRlblxuLy8gb3ZlciB0aGUgb2xkIG9uZSwgZGVsZXRpbmcgdGhlIG5ldyBmaWxlLlxuLy9cbi8vIFRvIHdvcmsgYXJvdW5kIHRoaXMsIG9uIFdpbmRvd3Mgc3lzdGVtcywgd2UgcmVuYW1lIHRoZSBmaWxlIGFuZCB0aGVuXG4vLyBkZWxldGUgdGhlIHJlbmFtZWQgZmlsZS4gIEl0J3MgYSBzbG9wcHkga2x1ZGdlLCBidXQgZnJhbmtseSwgSSBkbyBub3Rcbi8vIGtub3cgb2YgYSBiZXR0ZXIgd2F5IHRvIGRvIHRoaXMsIGdpdmVuIHdpbmRvd3MnIG5vbi1hdG9taWMgdW5saW5rXG4vLyBzZW1hbnRpY3MuXG4vL1xuLy8gU2VlOiBodHRwczovL2dpdGh1Yi5jb20vbnBtL25vZGUtdGFyL2lzc3Vlcy8xODNcbi8qIGlzdGFuYnVsIGlnbm9yZSBuZXh0ICovXG5jb25zdCB1bmxpbmtGaWxlID0gKHBhdGgsIGNiKSA9PiB7XG4gIGlmICghaXNXaW5kb3dzKVxuICAgIHJldHVybiBmcy51bmxpbmsocGF0aCwgY2IpXG5cbiAgY29uc3QgbmFtZSA9IHBhdGggKyAnLkRFTEVURS4nICsgY3J5cHRvLnJhbmRvbUJ5dGVzKDE2KS50b1N0cmluZygnaGV4JylcbiAgZnMucmVuYW1lKHBhdGgsIG5hbWUsIGVyID0+IHtcbiAgICBpZiAoZXIpXG4gICAgICByZXR1cm4gY2IoZXIpXG4gICAgZnMudW5saW5rKG5hbWUsIGNiKVxuICB9KVxufVxuXG4vKiBpc3RhbmJ1bCBpZ25vcmUgbmV4dCAqL1xuY29uc3QgdW5saW5rRmlsZVN5bmMgPSBwYXRoID0+IHtcbiAgaWYgKCFpc1dpbmRvd3MpXG4gICAgcmV0dXJuIGZzLnVubGlua1N5bmMocGF0aClcblxuICBjb25zdCBuYW1lID0gcGF0aCArICcuREVMRVRFLicgKyBjcnlwdG8ucmFuZG9tQnl0ZXMoMTYpLnRvU3RyaW5nKCdoZXgnKVxuICBmcy5yZW5hbWVTeW5jKHBhdGgsIG5hbWUpXG4gIGZzLnVubGlua1N5bmMobmFtZSlcbn1cblxuLy8gdGhpcy5naWQsIGVudHJ5LmdpZCwgdGhpcy5wcm9jZXNzVWlkXG5jb25zdCB1aW50MzIgPSAoYSwgYiwgYykgPT5cbiAgYSA9PT0gYSA+Pj4gMCA/IGFcbiAgOiBiID09PSBiID4+PiAwID8gYlxuICA6IGNcblxuLy8gY2xlYXIgdGhlIGNhY2hlIGlmIGl0J3MgYSBjYXNlLWluc2Vuc2l0aXZlIHVuaWNvZGUtc3F1YXNoaW5nIG1hdGNoLlxuLy8gd2UgY2FuJ3Qga25vdyBpZiB0aGUgY3VycmVudCBmaWxlIHN5c3RlbSBpcyBjYXNlLXNlbnNpdGl2ZSBvciBzdXBwb3J0c1xuLy8gdW5pY29kZSBmdWxseSwgc28gd2UgY2hlY2sgZm9yIHNpbWlsYXJpdHkgb24gdGhlIG1heGltYWxseSBjb21wYXRpYmxlXG4vLyByZXByZXNlbnRhdGlvbi4gIEVyciBvbiB0aGUgc2lkZSBvZiBwcnVuaW5nLCBzaW5jZSBhbGwgaXQncyBkb2luZyBpc1xuLy8gcHJldmVudGluZyBsc3RhdHMsIGFuZCBpdCdzIG5vdCB0aGUgZW5kIG9mIHRoZSB3b3JsZCBpZiB3ZSBnZXQgYSBmYWxzZVxuLy8gcG9zaXRpdmUuXG4vLyBOb3RlIHRoYXQgb24gd2luZG93cywgd2UgYWx3YXlzIGRyb3AgdGhlIGVudGlyZSBjYWNoZSB3aGVuZXZlciBhXG4vLyBzeW1ib2xpYyBsaW5rIGlzIGVuY291bnRlcmVkLCBiZWNhdXNlIDguMyBmaWxlbmFtZXMgYXJlIGltcG9zc2libGVcbi8vIHRvIHJlYXNvbiBhYm91dCwgYW5kIGNvbGxpc2lvbnMgYXJlIGhhemFyZHMgcmF0aGVyIHRoYW4ganVzdCBmYWlsdXJlcy5cbmNvbnN0IGNhY2hlS2V5Tm9ybWFsaXplID0gcGF0aCA9PiBzdHJpcFNsYXNoKG5vcm1QYXRoKHBhdGgpKVxuICAubm9ybWFsaXplKCdORktEJylcbiAgLnRvTG93ZXJDYXNlKClcblxuY29uc3QgcHJ1bmVDYWNoZSA9IChjYWNoZSwgYWJzKSA9PiB7XG4gIGFicyA9IGNhY2hlS2V5Tm9ybWFsaXplKGFicylcbiAgZm9yIChjb25zdCBwYXRoIG9mIGNhY2hlLmtleXMoKSkge1xuICAgIGNvbnN0IHBub3JtID0gY2FjaGVLZXlOb3JtYWxpemUocGF0aClcbiAgICBpZiAocG5vcm0gPT09IGFicyB8fCBwbm9ybS5pbmRleE9mKGFicyArICcvJykgPT09IDApXG4gICAgICBjYWNoZS5kZWxldGUocGF0aClcbiAgfVxufVxuXG5jb25zdCBkcm9wQ2FjaGUgPSBjYWNoZSA9PiB7XG4gIGZvciAoY29uc3Qga2V5IG9mIGNhY2hlLmtleXMoKSlcbiAgICBjYWNoZS5kZWxldGUoa2V5KVxufVxuXG5jbGFzcyBVbnBhY2sgZXh0ZW5kcyBQYXJzZXIge1xuICBjb25zdHJ1Y3RvciAob3B0KSB7XG4gICAgaWYgKCFvcHQpXG4gICAgICBvcHQgPSB7fVxuXG4gICAgb3B0Lm9uZG9uZSA9IF8gPT4ge1xuICAgICAgdGhpc1tFTkRFRF0gPSB0cnVlXG4gICAgICB0aGlzW01BWUJFQ0xPU0VdKClcbiAgICB9XG5cbiAgICBzdXBlcihvcHQpXG5cbiAgICB0aGlzW0NIRUNLRURfQ1dEXSA9IGZhbHNlXG5cbiAgICB0aGlzLnJlc2VydmF0aW9ucyA9IHBhdGhSZXNlcnZhdGlvbnMoKVxuXG4gICAgdGhpcy50cmFuc2Zvcm0gPSB0eXBlb2Ygb3B0LnRyYW5zZm9ybSA9PT0gJ2Z1bmN0aW9uJyA/IG9wdC50cmFuc2Zvcm0gOiBudWxsXG5cbiAgICB0aGlzLndyaXRhYmxlID0gdHJ1ZVxuICAgIHRoaXMucmVhZGFibGUgPSBmYWxzZVxuXG4gICAgdGhpc1tQRU5ESU5HXSA9IDBcbiAgICB0aGlzW0VOREVEXSA9IGZhbHNlXG5cbiAgICB0aGlzLmRpckNhY2hlID0gb3B0LmRpckNhY2hlIHx8IG5ldyBNYXAoKVxuXG4gICAgaWYgKHR5cGVvZiBvcHQudWlkID09PSAnbnVtYmVyJyB8fCB0eXBlb2Ygb3B0LmdpZCA9PT0gJ251bWJlcicpIHtcbiAgICAgIC8vIG5lZWQgYm90aCBvciBuZWl0aGVyXG4gICAgICBpZiAodHlwZW9mIG9wdC51aWQgIT09ICdudW1iZXInIHx8IHR5cGVvZiBvcHQuZ2lkICE9PSAnbnVtYmVyJylcbiAgICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvcignY2Fubm90IHNldCBvd25lciB3aXRob3V0IG51bWJlciB1aWQgYW5kIGdpZCcpXG4gICAgICBpZiAob3B0LnByZXNlcnZlT3duZXIpXG4gICAgICAgIHRocm93IG5ldyBUeXBlRXJyb3IoXG4gICAgICAgICAgJ2Nhbm5vdCBwcmVzZXJ2ZSBvd25lciBpbiBhcmNoaXZlIGFuZCBhbHNvIHNldCBvd25lciBleHBsaWNpdGx5JylcbiAgICAgIHRoaXMudWlkID0gb3B0LnVpZFxuICAgICAgdGhpcy5naWQgPSBvcHQuZ2lkXG4gICAgICB0aGlzLnNldE93bmVyID0gdHJ1ZVxuICAgIH0gZWxzZSB7XG4gICAgICB0aGlzLnVpZCA9IG51bGxcbiAgICAgIHRoaXMuZ2lkID0gbnVsbFxuICAgICAgdGhpcy5zZXRPd25lciA9IGZhbHNlXG4gICAgfVxuXG4gICAgLy8gZGVmYXVsdCB0cnVlIGZvciByb290XG4gICAgaWYgKG9wdC5wcmVzZXJ2ZU93bmVyID09PSB1bmRlZmluZWQgJiYgdHlwZW9mIG9wdC51aWQgIT09ICdudW1iZXInKVxuICAgICAgdGhpcy5wcmVzZXJ2ZU93bmVyID0gcHJvY2Vzcy5nZXR1aWQgJiYgcHJvY2Vzcy5nZXR1aWQoKSA9PT0gMFxuICAgIGVsc2VcbiAgICAgIHRoaXMucHJlc2VydmVPd25lciA9ICEhb3B0LnByZXNlcnZlT3duZXJcblxuICAgIHRoaXMucHJvY2Vzc1VpZCA9ICh0aGlzLnByZXNlcnZlT3duZXIgfHwgdGhpcy5zZXRPd25lcikgJiYgcHJvY2Vzcy5nZXR1aWQgP1xuICAgICAgcHJvY2Vzcy5nZXR1aWQoKSA6IG51bGxcbiAgICB0aGlzLnByb2Nlc3NHaWQgPSAodGhpcy5wcmVzZXJ2ZU93bmVyIHx8IHRoaXMuc2V0T3duZXIpICYmIHByb2Nlc3MuZ2V0Z2lkID9cbiAgICAgIHByb2Nlc3MuZ2V0Z2lkKCkgOiBudWxsXG5cbiAgICAvLyBtb3N0bHkganVzdCBmb3IgdGVzdGluZywgYnV0IHVzZWZ1bCBpbiBzb21lIGNhc2VzLlxuICAgIC8vIEZvcmNpYmx5IHRyaWdnZXIgYSBjaG93biBvbiBldmVyeSBlbnRyeSwgbm8gbWF0dGVyIHdoYXRcbiAgICB0aGlzLmZvcmNlQ2hvd24gPSBvcHQuZm9yY2VDaG93biA9PT0gdHJ1ZVxuXG4gICAgLy8gdHVybiA+PD98IGluIGZpbGVuYW1lcyBpbnRvIDB4ZjAwMC1oaWdoZXIgZW5jb2RlZCBmb3Jtc1xuICAgIHRoaXMud2luMzIgPSAhIW9wdC53aW4zMiB8fCBpc1dpbmRvd3NcblxuICAgIC8vIGRvIG5vdCB1bnBhY2sgb3ZlciBmaWxlcyB0aGF0IGFyZSBuZXdlciB0aGFuIHdoYXQncyBpbiB0aGUgYXJjaGl2ZVxuICAgIHRoaXMubmV3ZXIgPSAhIW9wdC5uZXdlclxuXG4gICAgLy8gZG8gbm90IHVucGFjayBvdmVyIEFOWSBmaWxlc1xuICAgIHRoaXMua2VlcCA9ICEhb3B0LmtlZXBcblxuICAgIC8vIGRvIG5vdCBzZXQgbXRpbWUvYXRpbWUgb2YgZXh0cmFjdGVkIGVudHJpZXNcbiAgICB0aGlzLm5vTXRpbWUgPSAhIW9wdC5ub010aW1lXG5cbiAgICAvLyBhbGxvdyAuLiwgYWJzb2x1dGUgcGF0aCBlbnRyaWVzLCBhbmQgdW5wYWNraW5nIHRocm91Z2ggc3ltbGlua3NcbiAgICAvLyB3aXRob3V0IHRoaXMsIHdhcm4gYW5kIHNraXAgLi4sIHJlbGF0aXZpemUgYWJzb2x1dGVzLCBhbmQgZXJyb3JcbiAgICAvLyBvbiBzeW1saW5rcyBpbiBleHRyYWN0aW9uIHBhdGhcbiAgICB0aGlzLnByZXNlcnZlUGF0aHMgPSAhIW9wdC5wcmVzZXJ2ZVBhdGhzXG5cbiAgICAvLyB1bmxpbmsgZmlsZXMgYW5kIGxpbmtzIGJlZm9yZSB3cml0aW5nLiBUaGlzIGJyZWFrcyBleGlzdGluZyBoYXJkXG4gICAgLy8gbGlua3MsIGFuZCByZW1vdmVzIHN5bWxpbmsgZGlyZWN0b3JpZXMgcmF0aGVyIHRoYW4gZXJyb3JpbmdcbiAgICB0aGlzLnVubGluayA9ICEhb3B0LnVubGlua1xuXG4gICAgdGhpcy5jd2QgPSBub3JtUGF0aChwYXRoLnJlc29sdmUob3B0LmN3ZCB8fCBwcm9jZXNzLmN3ZCgpKSlcbiAgICB0aGlzLnN0cmlwID0gK29wdC5zdHJpcCB8fCAwXG4gICAgdGhpcy5wcm9jZXNzVW1hc2sgPSBwcm9jZXNzLnVtYXNrKClcbiAgICB0aGlzLnVtYXNrID0gdHlwZW9mIG9wdC51bWFzayA9PT0gJ251bWJlcicgPyBvcHQudW1hc2sgOiB0aGlzLnByb2Nlc3NVbWFza1xuICAgIC8vIGRlZmF1bHQgbW9kZSBmb3IgZGlycyBjcmVhdGVkIGFzIHBhcmVudHNcbiAgICB0aGlzLmRtb2RlID0gb3B0LmRtb2RlIHx8ICgwbzA3NzcgJiAofnRoaXMudW1hc2spKVxuICAgIHRoaXMuZm1vZGUgPSBvcHQuZm1vZGUgfHwgKDBvMDY2NiAmICh+dGhpcy51bWFzaykpXG4gICAgdGhpcy5vbignZW50cnknLCBlbnRyeSA9PiB0aGlzW09ORU5UUlldKGVudHJ5KSlcbiAgfVxuXG4gIFtNQVlCRUNMT1NFXSAoKSB7XG4gICAgaWYgKHRoaXNbRU5ERURdICYmIHRoaXNbUEVORElOR10gPT09IDApIHtcbiAgICAgIHRoaXMuZW1pdCgncHJlZmluaXNoJylcbiAgICAgIHRoaXMuZW1pdCgnZmluaXNoJylcbiAgICAgIHRoaXMuZW1pdCgnZW5kJylcbiAgICAgIHRoaXMuZW1pdCgnY2xvc2UnKVxuICAgIH1cbiAgfVxuXG4gIFtDSEVDS1BBVEhdIChlbnRyeSkge1xuICAgIGlmICh0aGlzLnN0cmlwKSB7XG4gICAgICBjb25zdCBwYXJ0cyA9IG5vcm1QYXRoKGVudHJ5LnBhdGgpLnNwbGl0KCcvJylcbiAgICAgIGlmIChwYXJ0cy5sZW5ndGggPCB0aGlzLnN0cmlwKVxuICAgICAgICByZXR1cm4gZmFsc2VcbiAgICAgIGVudHJ5LnBhdGggPSBwYXJ0cy5zbGljZSh0aGlzLnN0cmlwKS5qb2luKCcvJylcblxuICAgICAgaWYgKGVudHJ5LnR5cGUgPT09ICdMaW5rJykge1xuICAgICAgICBjb25zdCBsaW5rcGFydHMgPSBub3JtUGF0aChlbnRyeS5saW5rcGF0aCkuc3BsaXQoJy8nKVxuICAgICAgICBpZiAobGlua3BhcnRzLmxlbmd0aCA+PSB0aGlzLnN0cmlwKVxuICAgICAgICAgIGVudHJ5LmxpbmtwYXRoID0gbGlua3BhcnRzLnNsaWNlKHRoaXMuc3RyaXApLmpvaW4oJy8nKVxuICAgICAgICBlbHNlXG4gICAgICAgICAgcmV0dXJuIGZhbHNlXG4gICAgICB9XG4gICAgfVxuXG4gICAgaWYgKCF0aGlzLnByZXNlcnZlUGF0aHMpIHtcbiAgICAgIGNvbnN0IHAgPSBub3JtUGF0aChlbnRyeS5wYXRoKVxuICAgICAgY29uc3QgcGFydHMgPSBwLnNwbGl0KCcvJylcbiAgICAgIGlmIChwYXJ0cy5pbmNsdWRlcygnLi4nKSB8fCBpc1dpbmRvd3MgJiYgL15bYS16XTpcXC5cXC4kL2kudGVzdChwYXJ0c1swXSkpIHtcbiAgICAgICAgdGhpcy53YXJuKGBwYXRoIGNvbnRhaW5zICcuLidgLCBwKVxuICAgICAgICByZXR1cm4gZmFsc2VcbiAgICAgIH1cblxuICAgICAgLy8gc3RyaXAgb2ZmIHRoZSByb290XG4gICAgICBjb25zdCBzID0gc3RyaXBBYnNvbHV0ZVBhdGgocClcbiAgICAgIGlmIChzWzBdKSB7XG4gICAgICAgIGVudHJ5LnBhdGggPSBzWzFdXG4gICAgICAgIHRoaXMud2Fybihgc3RyaXBwaW5nICR7c1swXX0gZnJvbSBhYnNvbHV0ZSBwYXRoYCwgcClcbiAgICAgIH1cbiAgICB9XG5cbiAgICBpZiAocGF0aC5pc0Fic29sdXRlKGVudHJ5LnBhdGgpKVxuICAgICAgZW50cnkuYWJzb2x1dGUgPSBub3JtUGF0aChwYXRoLnJlc29sdmUoZW50cnkucGF0aCkpXG4gICAgZWxzZVxuICAgICAgZW50cnkuYWJzb2x1dGUgPSBub3JtUGF0aChwYXRoLnJlc29sdmUodGhpcy5jd2QsIGVudHJ5LnBhdGgpKVxuXG4gICAgLy8gaWYgd2Ugc29tZWhvdyBlbmRlZCB1cCB3aXRoIGEgcGF0aCB0aGF0IGVzY2FwZXMgdGhlIGN3ZCwgYW5kIHdlIGFyZVxuICAgIC8vIG5vdCBpbiBwcmVzZXJ2ZVBhdGhzIG1vZGUsIHRoZW4gc29tZXRoaW5nIGlzIGZpc2h5ISAgVGhpcyBzaG91bGQgaGF2ZVxuICAgIC8vIGJlZW4gcHJldmVudGVkIGFib3ZlLCBzbyBpZ25vcmUgdGhpcyBmb3IgY292ZXJhZ2UuXG4gICAgLyogaXN0YW5idWwgaWdub3JlIGlmIC0gZGVmZW5zZSBpbiBkZXB0aCAqL1xuICAgIGlmICghdGhpcy5wcmVzZXJ2ZVBhdGhzICYmXG4gICAgICAgIGVudHJ5LmFic29sdXRlLmluZGV4T2YodGhpcy5jd2QgKyAnLycpICE9PSAwICYmXG4gICAgICAgIGVudHJ5LmFic29sdXRlICE9PSB0aGlzLmN3ZCkge1xuICAgICAgdGhpcy53YXJuKCdUQVJfRU5UUllfRVJST1InLCAncGF0aCBlc2NhcGVkIGV4dHJhY3Rpb24gdGFyZ2V0Jywge1xuICAgICAgICBlbnRyeSxcbiAgICAgICAgcGF0aDogbm9ybVBhdGgoZW50cnkucGF0aCksXG4gICAgICAgIHJlc29sdmVkUGF0aDogZW50cnkuYWJzb2x1dGUsXG4gICAgICAgIGN3ZDogdGhpcy5jd2QsXG4gICAgICB9KVxuICAgICAgcmV0dXJuIGZhbHNlXG4gICAgfVxuXG4gICAgLy8gYW4gYXJjaGl2ZSBjYW4gc2V0IHByb3BlcnRpZXMgb24gdGhlIGV4dHJhY3Rpb24gZGlyZWN0b3J5LCBidXQgaXRcbiAgICAvLyBtYXkgbm90IHJlcGxhY2UgdGhlIGN3ZCB3aXRoIGEgZGlmZmVyZW50IGtpbmQgb2YgdGhpbmcgZW50aXJlbHkuXG4gICAgaWYgKGVudHJ5LmFic29sdXRlID09PSB0aGlzLmN3ZCAmJlxuICAgICAgICBlbnRyeS50eXBlICE9PSAnRGlyZWN0b3J5JyAmJlxuICAgICAgICBlbnRyeS50eXBlICE9PSAnR05VRHVtcERpcicpXG4gICAgICByZXR1cm4gZmFsc2VcblxuICAgIC8vIG9ubHkgZW5jb2RlIDogY2hhcnMgdGhhdCBhcmVuJ3QgZHJpdmUgbGV0dGVyIGluZGljYXRvcnNcbiAgICBpZiAodGhpcy53aW4zMikge1xuICAgICAgY29uc3QgeyByb290OiBhUm9vdCB9ID0gcGF0aC53aW4zMi5wYXJzZShlbnRyeS5hYnNvbHV0ZSlcbiAgICAgIGVudHJ5LmFic29sdXRlID0gYVJvb3QgKyB3Yy5lbmNvZGUoZW50cnkuYWJzb2x1dGUuc3Vic3RyKGFSb290Lmxlbmd0aCkpXG4gICAgICBjb25zdCB7IHJvb3Q6IHBSb290IH0gPSBwYXRoLndpbjMyLnBhcnNlKGVudHJ5LnBhdGgpXG4gICAgICBlbnRyeS5wYXRoID0gcFJvb3QgKyB3Yy5lbmNvZGUoZW50cnkucGF0aC5zdWJzdHIocFJvb3QubGVuZ3RoKSlcbiAgICB9XG5cbiAgICByZXR1cm4gdHJ1ZVxuICB9XG5cbiAgW09ORU5UUlldIChlbnRyeSkge1xuICAgIGlmICghdGhpc1tDSEVDS1BBVEhdKGVudHJ5KSlcbiAgICAgIHJldHVybiBlbnRyeS5yZXN1bWUoKVxuXG4gICAgYXNzZXJ0LmVxdWFsKHR5cGVvZiBlbnRyeS5hYnNvbHV0ZSwgJ3N0cmluZycpXG5cbiAgICBzd2l0Y2ggKGVudHJ5LnR5cGUpIHtcbiAgICAgIGNhc2UgJ0RpcmVjdG9yeSc6XG4gICAgICBjYXNlICdHTlVEdW1wRGlyJzpcbiAgICAgICAgaWYgKGVudHJ5Lm1vZGUpXG4gICAgICAgICAgZW50cnkubW9kZSA9IGVudHJ5Lm1vZGUgfCAwbzcwMFxuXG4gICAgICBjYXNlICdGaWxlJzpcbiAgICAgIGNhc2UgJ09sZEZpbGUnOlxuICAgICAgY2FzZSAnQ29udGlndW91c0ZpbGUnOlxuICAgICAgY2FzZSAnTGluayc6XG4gICAgICBjYXNlICdTeW1ib2xpY0xpbmsnOlxuICAgICAgICByZXR1cm4gdGhpc1tDSEVDS0ZTXShlbnRyeSlcblxuICAgICAgY2FzZSAnQ2hhcmFjdGVyRGV2aWNlJzpcbiAgICAgIGNhc2UgJ0Jsb2NrRGV2aWNlJzpcbiAgICAgIGNhc2UgJ0ZJRk8nOlxuICAgICAgICByZXR1cm4gdGhpc1tVTlNVUFBPUlRFRF0oZW50cnkpXG4gICAgfVxuICB9XG5cbiAgW09ORVJST1JdIChlciwgZW50cnkpIHtcbiAgICAvLyBDd2QgaGFzIHRvIGV4aXN0LCBvciBlbHNlIG5vdGhpbmcgd29ya3MuIFRoYXQncyBzZXJpb3VzLlxuICAgIC8vIE90aGVyIGVycm9ycyBhcmUgd2FybmluZ3MsIHdoaWNoIHJhaXNlIHRoZSBlcnJvciBpbiBzdHJpY3RcbiAgICAvLyBtb2RlLCBidXQgb3RoZXJ3aXNlIGNvbnRpbnVlIG9uLlxuICAgIGlmIChlci5uYW1lID09PSAnQ3dkRXJyb3InKVxuICAgICAgdGhpcy5lbWl0KCdlcnJvcicsIGVyKVxuICAgIGVsc2Uge1xuICAgICAgdGhpcy53YXJuKGVyLm1lc3NhZ2UsIGVyKVxuICAgICAgdGhpc1tVTlBFTkRdKClcbiAgICAgIGVudHJ5LnJlc3VtZSgpXG4gICAgfVxuICB9XG5cbiAgW01LRElSXSAoZGlyLCBtb2RlLCBjYikge1xuICAgIG1rZGlyKG5vcm1QYXRoKGRpciksIHtcbiAgICAgIHVpZDogdGhpcy51aWQsXG4gICAgICBnaWQ6IHRoaXMuZ2lkLFxuICAgICAgcHJvY2Vzc1VpZDogdGhpcy5wcm9jZXNzVWlkLFxuICAgICAgcHJvY2Vzc0dpZDogdGhpcy5wcm9jZXNzR2lkLFxuICAgICAgdW1hc2s6IHRoaXMucHJvY2Vzc1VtYXNrLFxuICAgICAgcHJlc2VydmU6IHRoaXMucHJlc2VydmVQYXRocyxcbiAgICAgIHVubGluazogdGhpcy51bmxpbmssXG4gICAgICBjYWNoZTogdGhpcy5kaXJDYWNoZSxcbiAgICAgIGN3ZDogdGhpcy5jd2QsXG4gICAgICBtb2RlOiBtb2RlXG4gICAgfSwgY2IpXG4gIH1cblxuICBbRE9DSE9XTl0gKGVudHJ5KSB7XG4gICAgLy8gaW4gcHJlc2VydmUgb3duZXIgbW9kZSwgY2hvd24gaWYgdGhlIGVudHJ5IGRvZXNuJ3QgbWF0Y2ggcHJvY2Vzc1xuICAgIC8vIGluIHNldCBvd25lciBtb2RlLCBjaG93biBpZiBzZXR0aW5nIGRvZXNuJ3QgbWF0Y2ggcHJvY2Vzc1xuICAgIHJldHVybiB0aGlzLmZvcmNlQ2hvd24gfHxcbiAgICAgIHRoaXMucHJlc2VydmVPd25lciAmJlxuICAgICAgKCB0eXBlb2YgZW50cnkudWlkID09PSAnbnVtYmVyJyAmJiBlbnRyeS51aWQgIT09IHRoaXMucHJvY2Vzc1VpZCB8fFxuICAgICAgICB0eXBlb2YgZW50cnkuZ2lkID09PSAnbnVtYmVyJyAmJiBlbnRyeS5naWQgIT09IHRoaXMucHJvY2Vzc0dpZCApXG4gICAgICB8fFxuICAgICAgKCB0eXBlb2YgdGhpcy51aWQgPT09ICdudW1iZXInICYmIHRoaXMudWlkICE9PSB0aGlzLnByb2Nlc3NVaWQgfHxcbiAgICAgICAgdHlwZW9mIHRoaXMuZ2lkID09PSAnbnVtYmVyJyAmJiB0aGlzLmdpZCAhPT0gdGhpcy5wcm9jZXNzR2lkIClcbiAgfVxuXG4gIFtVSURdIChlbnRyeSkge1xuICAgIHJldHVybiB1aW50MzIodGhpcy51aWQsIGVudHJ5LnVpZCwgdGhpcy5wcm9jZXNzVWlkKVxuICB9XG5cbiAgW0dJRF0gKGVudHJ5KSB7XG4gICAgcmV0dXJuIHVpbnQzMih0aGlzLmdpZCwgZW50cnkuZ2lkLCB0aGlzLnByb2Nlc3NHaWQpXG4gIH1cblxuICBbRklMRV0gKGVudHJ5LCBmdWxseURvbmUpIHtcbiAgICBjb25zdCBtb2RlID0gZW50cnkubW9kZSAmIDBvNzc3NyB8fCB0aGlzLmZtb2RlXG4gICAgY29uc3Qgc3RyZWFtID0gbmV3IGZzbS5Xcml0ZVN0cmVhbShlbnRyeS5hYnNvbHV0ZSwge1xuICAgICAgbW9kZTogbW9kZSxcbiAgICAgIGF1dG9DbG9zZTogZmFsc2VcbiAgICB9KVxuICAgIHN0cmVhbS5vbignZXJyb3InLCBlciA9PiB7XG4gICAgICBpZiAoc3RyZWFtLmZkKVxuICAgICAgICBmcy5jbG9zZShzdHJlYW0uZmQsICgpID0+IHt9KVxuXG4gICAgICAvLyBmbHVzaCBhbGwgdGhlIGRhdGEgb3V0IHNvIHRoYXQgd2UgYXJlbid0IGxlZnQgaGFuZ2luZ1xuICAgICAgLy8gaWYgdGhlIGVycm9yIHdhc24ndCBhY3R1YWxseSBmYXRhbC4gIG90aGVyd2lzZSB0aGUgcGFyc2VcbiAgICAgIC8vIGlzIGJsb2NrZWQsIGFuZCB3ZSBuZXZlciBwcm9jZWVkLlxuICAgICAgLyogaXN0YW5idWwgaWdub3JlIG5leHQgKi9cbiAgICAgIHN0cmVhbS53cml0ZSA9ICgpID0+IHRydWVcbiAgICAgIHRoaXNbT05FUlJPUl0oZXIsIGVudHJ5KVxuICAgICAgZnVsbHlEb25lKClcbiAgICB9KVxuXG4gICAgbGV0IGFjdGlvbnMgPSAxXG4gICAgY29uc3QgZG9uZSA9IGVyID0+IHtcbiAgICAgIGlmIChlcikge1xuICAgICAgICAvKiBpc3RhbmJ1bCBpZ25vcmUgZWxzZSAtIHdlIHNob3VsZCBhbHdheXMgaGF2ZSBhIGZkIGJ5IG5vdyAqL1xuICAgICAgICBpZiAoc3RyZWFtLmZkKVxuICAgICAgICAgIGZzLmNsb3NlKHN0cmVhbS5mZCwgKCkgPT4ge30pXG5cbiAgICAgICAgdGhpc1tPTkVSUk9SXShlciwgZW50cnkpXG4gICAgICAgIGZ1bGx5RG9uZSgpXG4gICAgICAgIHJldHVyblxuICAgICAgfVxuXG4gICAgICBpZiAoLS1hY3Rpb25zID09PSAwKSB7XG4gICAgICAgIGZzLmNsb3NlKHN0cmVhbS5mZCwgZXIgPT4ge1xuICAgICAgICAgIGZ1bGx5RG9uZSgpXG4gICAgICAgICAgLyogaXN0YW5idWwgaWdub3JlIG5leHQgKi9cbiAgICAgICAgICBlciA/IHRoaXNbT05FUlJPUl0oZXIsIGVudHJ5KSA6IHRoaXNbVU5QRU5EXSgpXG4gICAgICAgIH0pXG4gICAgICB9XG4gICAgfVxuXG4gICAgc3RyZWFtLm9uKCdmaW5pc2gnLCBfID0+IHtcbiAgICAgIC8vIGlmIGZ1dGltZXMgZmFpbHMsIHRyeSB1dGltZXNcbiAgICAgIC8vIGlmIHV0aW1lcyBmYWlscywgZmFpbCB3aXRoIHRoZSBvcmlnaW5hbCBlcnJvclxuICAgICAgLy8gc2FtZSBmb3IgZmNob3duL2Nob3duXG4gICAgICBjb25zdCBhYnMgPSBlbnRyeS5hYnNvbHV0ZVxuICAgICAgY29uc3QgZmQgPSBzdHJlYW0uZmRcblxuICAgICAgaWYgKGVudHJ5Lm10aW1lICYmICF0aGlzLm5vTXRpbWUpIHtcbiAgICAgICAgYWN0aW9ucysrXG4gICAgICAgIGNvbnN0IGF0aW1lID0gZW50cnkuYXRpbWUgfHwgbmV3IERhdGUoKVxuICAgICAgICBjb25zdCBtdGltZSA9IGVudHJ5Lm10aW1lXG4gICAgICAgIGZzLmZ1dGltZXMoZmQsIGF0aW1lLCBtdGltZSwgZXIgPT5cbiAgICAgICAgICBlciA/IGZzLnV0aW1lcyhhYnMsIGF0aW1lLCBtdGltZSwgZXIyID0+IGRvbmUoZXIyICYmIGVyKSlcbiAgICAgICAgICA6IGRvbmUoKSlcbiAgICAgIH1cblxuICAgICAgaWYgKHRoaXNbRE9DSE9XTl0oZW50cnkpKSB7XG4gICAgICAgIGFjdGlvbnMrK1xuICAgICAgICBjb25zdCB1aWQgPSB0aGlzW1VJRF0oZW50cnkpXG4gICAgICAgIGNvbnN0IGdpZCA9IHRoaXNbR0lEXShlbnRyeSlcbiAgICAgICAgZnMuZmNob3duKGZkLCB1aWQsIGdpZCwgZXIgPT5cbiAgICAgICAgICBlciA/IGZzLmNob3duKGFicywgdWlkLCBnaWQsIGVyMiA9PiBkb25lKGVyMiAmJiBlcikpXG4gICAgICAgICAgOiBkb25lKCkpXG4gICAgICB9XG5cbiAgICAgIGRvbmUoKVxuICAgIH0pXG5cbiAgICBjb25zdCB0eCA9IHRoaXMudHJhbnNmb3JtID8gdGhpcy50cmFuc2Zvcm0oZW50cnkpIHx8IGVudHJ5IDogZW50cnlcbiAgICBpZiAodHggIT09IGVudHJ5KSB7XG4gICAgICB0eC5vbignZXJyb3InLCBlciA9PiB0aGlzW09ORVJST1JdKGVyLCBlbnRyeSkpXG4gICAgICBlbnRyeS5waXBlKHR4KVxuICAgIH1cbiAgICB0eC5waXBlKHN0cmVhbSlcbiAgfVxuXG4gIFtESVJFQ1RPUlldIChlbnRyeSwgZnVsbHlEb25lKSB7XG4gICAgY29uc3QgbW9kZSA9IGVudHJ5Lm1vZGUgJiAwbzc3NzcgfHwgdGhpcy5kbW9kZVxuICAgIHRoaXNbTUtESVJdKGVudHJ5LmFic29sdXRlLCBtb2RlLCBlciA9PiB7XG4gICAgICBpZiAoZXIpIHtcbiAgICAgICAgZnVsbHlEb25lKClcbiAgICAgICAgcmV0dXJuIHRoaXNbT05FUlJPUl0oZXIsIGVudHJ5KVxuICAgICAgfVxuXG4gICAgICBsZXQgYWN0aW9ucyA9IDFcbiAgICAgIGNvbnN0IGRvbmUgPSBfID0+IHtcbiAgICAgICAgaWYgKC0tYWN0aW9ucyA9PT0gMCkge1xuICAgICAgICAgIGZ1bGx5RG9uZSgpXG4gICAgICAgICAgdGhpc1tVTlBFTkRdKClcbiAgICAgICAgICBlbnRyeS5yZXN1bWUoKVxuICAgICAgICB9XG4gICAgICB9XG5cbiAgICAgIGlmIChlbnRyeS5tdGltZSAmJiAhdGhpcy5ub010aW1lKSB7XG4gICAgICAgIGFjdGlvbnMrK1xuICAgICAgICBmcy51dGltZXMoZW50cnkuYWJzb2x1dGUsIGVudHJ5LmF0aW1lIHx8IG5ldyBEYXRlKCksIGVudHJ5Lm10aW1lLCBkb25lKVxuICAgICAgfVxuXG4gICAgICBpZiAodGhpc1tET0NIT1dOXShlbnRyeSkpIHtcbiAgICAgICAgYWN0aW9ucysrXG4gICAgICAgIGZzLmNob3duKGVudHJ5LmFic29sdXRlLCB0aGlzW1VJRF0oZW50cnkpLCB0aGlzW0dJRF0oZW50cnkpLCBkb25lKVxuICAgICAgfVxuXG4gICAgICBkb25lKClcbiAgICB9KVxuICB9XG5cbiAgW1VOU1VQUE9SVEVEXSAoZW50cnkpIHtcbiAgICB0aGlzLndhcm4oJ3Vuc3VwcG9ydGVkIGVudHJ5IHR5cGU6ICcgKyBlbnRyeS50eXBlLCBlbnRyeSlcbiAgICBlbnRyeS5yZXN1bWUoKVxuICB9XG5cbiAgW1NZTUxJTktdIChlbnRyeSwgZG9uZSkge1xuICAgIHRoaXNbTElOS10oZW50cnksIGVudHJ5LmxpbmtwYXRoLCAnc3ltbGluaycsIGRvbmUpXG4gIH1cblxuICBbSEFSRExJTktdIChlbnRyeSwgZG9uZSkge1xuICAgIGNvbnN0IGxpbmtwYXRoID0gbm9ybVBhdGgocGF0aC5yZXNvbHZlKHRoaXMuY3dkLCBlbnRyeS5saW5rcGF0aCkpXG4gICAgdGhpc1tMSU5LXShlbnRyeSwgbGlua3BhdGgsICdsaW5rJywgZG9uZSlcbiAgfVxuXG4gIFtQRU5EXSAoKSB7XG4gICAgdGhpc1tQRU5ESU5HXSsrXG4gIH1cblxuICBbVU5QRU5EXSAoKSB7XG4gICAgdGhpc1tQRU5ESU5HXS0tXG4gICAgdGhpc1tNQVlCRUNMT1NFXSgpXG4gIH1cblxuICBbU0tJUF0gKGVudHJ5KSB7XG4gICAgdGhpc1tVTlBFTkRdKClcbiAgICBlbnRyeS5yZXN1bWUoKVxuICB9XG5cbiAgLy8gQ2hlY2sgaWYgd2UgY2FuIHJldXNlIGFuIGV4aXN0aW5nIGZpbGVzeXN0ZW0gZW50cnkgc2FmZWx5IGFuZFxuICAvLyBvdmVyd3JpdGUgaXQsIHJhdGhlciB0aGFuIHVubGlua2luZyBhbmQgcmVjcmVhdGluZ1xuICAvLyBXaW5kb3dzIGRvZXNuJ3QgcmVwb3J0IGEgdXNlZnVsIG5saW5rLCBzbyB3ZSBqdXN0IG5ldmVyIHJldXNlIGVudHJpZXNcbiAgW0lTUkVVU0FCTEVdIChlbnRyeSwgc3QpIHtcbiAgICByZXR1cm4gZW50cnkudHlwZSA9PT0gJ0ZpbGUnICYmXG4gICAgICAhdGhpcy51bmxpbmsgJiZcbiAgICAgIHN0LmlzRmlsZSgpICYmXG4gICAgICBzdC5ubGluayA8PSAxICYmXG4gICAgICAhaXNXaW5kb3dzXG4gIH1cblxuICAvLyBjaGVjayBpZiBhIHRoaW5nIGlzIHRoZXJlLCBhbmQgaWYgc28sIHRyeSB0byBjbG9iYmVyIGl0XG4gIFtDSEVDS0ZTXSAoZW50cnkpIHtcbiAgICB0aGlzW1BFTkRdKClcbiAgICBjb25zdCBwYXRocyA9IFtlbnRyeS5wYXRoXVxuICAgIGlmIChlbnRyeS5saW5rcGF0aClcbiAgICAgIHBhdGhzLnB1c2goZW50cnkubGlua3BhdGgpXG4gICAgdGhpcy5yZXNlcnZhdGlvbnMucmVzZXJ2ZShwYXRocywgZG9uZSA9PiB0aGlzW0NIRUNLRlMyXShlbnRyeSwgZG9uZSkpXG4gIH1cblxuICBbUFJVTkVDQUNIRV0gKGVudHJ5KSB7XG4gICAgLy8gaWYgd2UgYXJlIG5vdCBjcmVhdGluZyBhIGRpcmVjdG9yeSwgYW5kIHRoZSBwYXRoIGlzIGluIHRoZSBkaXJDYWNoZSxcbiAgICAvLyB0aGVuIHRoYXQgbWVhbnMgd2UgYXJlIGFib3V0IHRvIGRlbGV0ZSB0aGUgZGlyZWN0b3J5IHdlIGNyZWF0ZWRcbiAgICAvLyBwcmV2aW91c2x5LCBhbmQgaXQgaXMgbm8gbG9uZ2VyIGdvaW5nIHRvIGJlIGEgZGlyZWN0b3J5LCBhbmQgbmVpdGhlclxuICAgIC8vIGlzIGFueSBvZiBpdHMgY2hpbGRyZW4uXG4gICAgLy8gSWYgYSBzeW1ib2xpYyBsaW5rIGlzIGVuY291bnRlcmVkLCBhbGwgYmV0cyBhcmUgb2ZmLiAgVGhlcmUgaXMgbm9cbiAgICAvLyByZWFzb25hYmxlIHdheSB0byBzYW5pdGl6ZSB0aGUgY2FjaGUgaW4gc3VjaCBhIHdheSB3ZSB3aWxsIGJlIGFibGUgdG9cbiAgICAvLyBhdm9pZCBoYXZpbmcgZmlsZXN5c3RlbSBjb2xsaXNpb25zLiAgSWYgdGhpcyBoYXBwZW5zIHdpdGggYSBub24tc3ltbGlua1xuICAgIC8vIGVudHJ5LCBpdCdsbCBqdXN0IGZhaWwgdG8gdW5wYWNrLCBidXQgYSBzeW1saW5rIHRvIGEgZGlyZWN0b3J5LCB1c2luZyBhblxuICAgIC8vIDguMyBzaG9ydG5hbWUgb3IgY2VydGFpbiB1bmljb2RlIGF0dGFja3MsIGNhbiBldmFkZSBkZXRlY3Rpb24gYW5kIGxlYWRcbiAgICAvLyB0byBhcmJpdHJhcnkgd3JpdGVzIHRvIGFueXdoZXJlIG9uIHRoZSBzeXN0ZW0uXG4gICAgaWYgKGVudHJ5LnR5cGUgPT09ICdTeW1ib2xpY0xpbmsnKVxuICAgICAgZHJvcENhY2hlKHRoaXMuZGlyQ2FjaGUpXG4gICAgZWxzZSBpZiAoZW50cnkudHlwZSAhPT0gJ0RpcmVjdG9yeScpXG4gICAgICBwcnVuZUNhY2hlKHRoaXMuZGlyQ2FjaGUsIGVudHJ5LmFic29sdXRlKVxuICB9XG5cbiAgW0NIRUNLRlMyXSAoZW50cnksIGZ1bGx5RG9uZSkge1xuICAgIHRoaXNbUFJVTkVDQUNIRV0oZW50cnkpXG5cbiAgICBjb25zdCBkb25lID0gZXIgPT4ge1xuICAgICAgdGhpc1tQUlVORUNBQ0hFXShlbnRyeSlcbiAgICAgIGZ1bGx5RG9uZShlcilcbiAgICB9XG5cbiAgICBjb25zdCBjaGVja0N3ZCA9ICgpID0+IHtcbiAgICAgIHRoaXNbTUtESVJdKHRoaXMuY3dkLCB0aGlzLmRtb2RlLCBlciA9PiB7XG4gICAgICAgIGlmIChlcikge1xuICAgICAgICAgIHRoaXNbT05FUlJPUl0oZXIsIGVudHJ5KVxuICAgICAgICAgIGRvbmUoKVxuICAgICAgICAgIHJldHVyblxuICAgICAgICB9XG4gICAgICAgIHRoaXNbQ0hFQ0tFRF9DV0RdID0gdHJ1ZVxuICAgICAgICBzdGFydCgpXG4gICAgICB9KVxuICAgIH1cblxuICAgIGNvbnN0IHN0YXJ0ID0gKCkgPT4ge1xuICAgICAgaWYgKGVudHJ5LmFic29sdXRlICE9PSB0aGlzLmN3ZCkge1xuICAgICAgICBjb25zdCBwYXJlbnQgPSBub3JtUGF0aChwYXRoLmRpcm5hbWUoZW50cnkuYWJzb2x1dGUpKVxuICAgICAgICBpZiAocGFyZW50ICE9PSB0aGlzLmN3ZCkge1xuICAgICAgICAgIHJldHVybiB0aGlzW01LRElSXShwYXJlbnQsIHRoaXMuZG1vZGUsIGVyID0+IHtcbiAgICAgICAgICAgIGlmIChlcikge1xuICAgICAgICAgICAgICB0aGlzW09ORVJST1JdKGVyLCBlbnRyeSlcbiAgICAgICAgICAgICAgZG9uZSgpXG4gICAgICAgICAgICAgIHJldHVyblxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgYWZ0ZXJNYWtlUGFyZW50KClcbiAgICAgICAgICB9KVxuICAgICAgICB9XG4gICAgICB9XG4gICAgICBhZnRlck1ha2VQYXJlbnQoKVxuICAgIH1cblxuICAgIGNvbnN0IGFmdGVyTWFrZVBhcmVudCA9ICgpID0+IHtcbiAgICAgIGZzLmxzdGF0KGVudHJ5LmFic29sdXRlLCAobHN0YXRFciwgc3QpID0+IHtcbiAgICAgICAgaWYgKHN0ICYmICh0aGlzLmtlZXAgfHwgdGhpcy5uZXdlciAmJiBzdC5tdGltZSA+IGVudHJ5Lm10aW1lKSkge1xuICAgICAgICAgIHRoaXNbU0tJUF0oZW50cnkpXG4gICAgICAgICAgZG9uZSgpXG4gICAgICAgICAgcmV0dXJuXG4gICAgICAgIH1cbiAgICAgICAgaWYgKGxzdGF0RXIgfHwgdGhpc1tJU1JFVVNBQkxFXShlbnRyeSwgc3QpKVxuICAgICAgICAgIHJldHVybiB0aGlzW01BS0VGU10obnVsbCwgZW50cnksIGRvbmUpXG5cbiAgICAgICAgaWYgKHN0LmlzRGlyZWN0b3J5KCkpIHtcbiAgICAgICAgICBpZiAoZW50cnkudHlwZSA9PT0gJ0RpcmVjdG9yeScpIHtcbiAgICAgICAgICAgIGNvbnN0IG5lZWRDaG1vZCA9ICF0aGlzLm5vQ2htb2QgJiZcbiAgICAgICAgICAgICAgZW50cnkubW9kZSAmJlxuICAgICAgICAgICAgICAoc3QubW9kZSAmIDBvNzc3NykgIT09IGVudHJ5Lm1vZGVcbiAgICAgICAgICAgIGNvbnN0IGFmdGVyQ2htb2QgPSBlciA9PiB0aGlzW01BS0VGU10oZXIsIGVudHJ5LCBkb25lKVxuICAgICAgICAgICAgaWYgKCFuZWVkQ2htb2QpXG4gICAgICAgICAgICAgIHJldHVybiBhZnRlckNobW9kKClcbiAgICAgICAgICAgIHJldHVybiBmcy5jaG1vZChlbnRyeS5hYnNvbHV0ZSwgZW50cnkubW9kZSwgYWZ0ZXJDaG1vZClcbiAgICAgICAgICB9XG4gICAgICAgICAgLy8gTm90IGEgZGlyIGVudHJ5LCBoYXZlIHRvIHJlbW92ZSBpdC5cbiAgICAgICAgICAvLyBOQjogdGhlIG9ubHkgd2F5IHRvIGVuZCB1cCB3aXRoIGFuIGVudHJ5IHRoYXQgaXMgdGhlIGN3ZFxuICAgICAgICAgIC8vIGl0c2VsZiwgaW4gc3VjaCBhIHdheSB0aGF0ID09IGRvZXMgbm90IGRldGVjdCwgaXMgYVxuICAgICAgICAgIC8vIHRyaWNreSB3aW5kb3dzIGFic29sdXRlIHBhdGggd2l0aCBVTkMgb3IgOC4zIHBhcnRzIChhbmRcbiAgICAgICAgICAvLyBwcmVzZXJ2ZVBhdGhzOnRydWUsIG9yIGVsc2UgaXQgd2lsbCBoYXZlIGJlZW4gc3RyaXBwZWQpLlxuICAgICAgICAgIC8vIEluIHRoYXQgY2FzZSwgdGhlIHVzZXIgaGFzIG9wdGVkIG91dCBvZiBwYXRoIHByb3RlY3Rpb25zXG4gICAgICAgICAgLy8gZXhwbGljaXRseSwgc28gaWYgdGhleSBibG93IGF3YXkgdGhlIGN3ZCwgYydlc3QgbGEgdmllLlxuICAgICAgICAgIGlmIChlbnRyeS5hYnNvbHV0ZSAhPT0gdGhpcy5jd2QpIHtcbiAgICAgICAgICAgIHJldHVybiBmcy5ybWRpcihlbnRyeS5hYnNvbHV0ZSwgZXIgPT5cbiAgICAgICAgICAgICAgdGhpc1tNQUtFRlNdKGVyLCBlbnRyeSwgZG9uZSkpXG4gICAgICAgICAgfVxuICAgICAgICB9XG5cbiAgICAgICAgLy8gbm90IGEgZGlyLCBhbmQgbm90IHJldXNhYmxlXG4gICAgICAgIC8vIGRvbid0IHJlbW92ZSBpZiB0aGUgY3dkLCB3ZSB3YW50IHRoYXQgZXJyb3JcbiAgICAgICAgaWYgKGVudHJ5LmFic29sdXRlID09PSB0aGlzLmN3ZClcbiAgICAgICAgICByZXR1cm4gdGhpc1tNQUtFRlNdKG51bGwsIGVudHJ5LCBkb25lKVxuXG4gICAgICAgIHVubGlua0ZpbGUoZW50cnkuYWJzb2x1dGUsIGVyID0+XG4gICAgICAgICAgdGhpc1tNQUtFRlNdKGVyLCBlbnRyeSwgZG9uZSkpXG4gICAgICB9KVxuICAgIH1cblxuICAgIGlmICh0aGlzW0NIRUNLRURfQ1dEXSlcbiAgICAgIHN0YXJ0KClcbiAgICBlbHNlXG4gICAgICBjaGVja0N3ZCgpXG4gIH1cblxuICBbTUFLRUZTXSAoZXIsIGVudHJ5LCBkb25lKSB7XG4gICAgaWYgKGVyKVxuICAgICAgcmV0dXJuIHRoaXNbT05FUlJPUl0oZXIsIGVudHJ5KVxuXG4gICAgc3dpdGNoIChlbnRyeS50eXBlKSB7XG4gICAgICBjYXNlICdGaWxlJzpcbiAgICAgIGNhc2UgJ09sZEZpbGUnOlxuICAgICAgY2FzZSAnQ29udGlndW91c0ZpbGUnOlxuICAgICAgICByZXR1cm4gdGhpc1tGSUxFXShlbnRyeSwgZG9uZSlcblxuICAgICAgY2FzZSAnTGluayc6XG4gICAgICAgIHJldHVybiB0aGlzW0hBUkRMSU5LXShlbnRyeSwgZG9uZSlcblxuICAgICAgY2FzZSAnU3ltYm9saWNMaW5rJzpcbiAgICAgICAgcmV0dXJuIHRoaXNbU1lNTElOS10oZW50cnksIGRvbmUpXG5cbiAgICAgIGNhc2UgJ0RpcmVjdG9yeSc6XG4gICAgICBjYXNlICdHTlVEdW1wRGlyJzpcbiAgICAgICAgcmV0dXJuIHRoaXNbRElSRUNUT1JZXShlbnRyeSwgZG9uZSlcbiAgICB9XG4gIH1cblxuICBbTElOS10gKGVudHJ5LCBsaW5rcGF0aCwgbGluaywgZG9uZSkge1xuICAgIC8vIFhYWDogZ2V0IHRoZSB0eXBlICgnc3ltbGluaycgb3IgJ2p1bmN0aW9uJykgZm9yIHdpbmRvd3NcbiAgICBmc1tsaW5rXShsaW5rcGF0aCwgZW50cnkuYWJzb2x1dGUsIGVyID0+IHtcbiAgICAgIGlmIChlcilcbiAgICAgICAgcmV0dXJuIHRoaXNbT05FUlJPUl0oZXIsIGVudHJ5KVxuICAgICAgZG9uZSgpXG4gICAgICB0aGlzW1VOUEVORF0oKVxuICAgICAgZW50cnkucmVzdW1lKClcbiAgICB9KVxuICB9XG59XG5cbmNvbnN0IGNhbGxTeW5jID0gZm4gPT4ge1xuICB0cnkge1xuICAgIHJldHVybiBbbnVsbCwgZm4oKV1cbiAgfSBjYXRjaCAoZXIpIHtcbiAgICByZXR1cm4gW2VyLCBudWxsXVxuICB9XG59XG5jbGFzcyBVbnBhY2tTeW5jIGV4dGVuZHMgVW5wYWNrIHtcbiAgW01BS0VGU10gKGVyLCBlbnRyeSkge1xuICAgIHJldHVybiBzdXBlcltNQUtFRlNdKGVyLCBlbnRyeSwgLyogaXN0YW5idWwgaWdub3JlIG5leHQgKi8gKCkgPT4ge30pXG4gIH1cblxuICBbQ0hFQ0tGU10gKGVudHJ5KSB7XG4gICAgdGhpc1tQUlVORUNBQ0hFXShlbnRyeSlcblxuICAgIGlmICghdGhpc1tDSEVDS0VEX0NXRF0pIHtcbiAgICAgIGNvbnN0IGVyID0gdGhpc1tNS0RJUl0odGhpcy5jd2QsIHRoaXMuZG1vZGUpXG4gICAgICBpZiAoZXIpXG4gICAgICAgIHJldHVybiB0aGlzW09ORVJST1JdKGVyLCBlbnRyeSlcbiAgICAgIHRoaXNbQ0hFQ0tFRF9DV0RdID0gdHJ1ZVxuICAgIH1cblxuICAgIC8vIGRvbid0IGJvdGhlciB0byBtYWtlIHRoZSBwYXJlbnQgaWYgdGhlIGN1cnJlbnQgZW50cnkgaXMgdGhlIGN3ZCxcbiAgICAvLyB3ZSd2ZSBhbHJlYWR5IGNoZWNrZWQgaXQuXG4gICAgaWYgKGVudHJ5LmFic29sdXRlICE9PSB0aGlzLmN3ZCkge1xuICAgICAgY29uc3QgcGFyZW50ID0gbm9ybVBhdGgocGF0aC5kaXJuYW1lKGVudHJ5LmFic29sdXRlKSlcbiAgICAgIGlmIChwYXJlbnQgIT09IHRoaXMuY3dkKSB7XG4gICAgICAgIGNvbnN0IG1rUGFyZW50ID0gdGhpc1tNS0RJUl0ocGFyZW50LCB0aGlzLmRtb2RlKVxuICAgICAgICBpZiAobWtQYXJlbnQpXG4gICAgICAgICAgcmV0dXJuIHRoaXNbT05FUlJPUl0obWtQYXJlbnQsIGVudHJ5KVxuICAgICAgfVxuICAgIH1cblxuICAgIGNvbnN0IFtsc3RhdEVyLCBzdF0gPSBjYWxsU3luYygoKSA9PiBmcy5sc3RhdFN5bmMoZW50cnkuYWJzb2x1dGUpKVxuICAgIGlmIChzdCAmJiAodGhpcy5rZWVwIHx8IHRoaXMubmV3ZXIgJiYgc3QubXRpbWUgPiBlbnRyeS5tdGltZSkpXG4gICAgICByZXR1cm4gdGhpc1tTS0lQXShlbnRyeSlcblxuICAgIGlmIChsc3RhdEVyIHx8IHRoaXNbSVNSRVVTQUJMRV0oZW50cnksIHN0KSlcbiAgICAgIHJldHVybiB0aGlzW01BS0VGU10obnVsbCwgZW50cnkpXG5cbiAgICBpZiAoc3QuaXNEaXJlY3RvcnkoKSkge1xuICAgICAgaWYgKGVudHJ5LnR5cGUgPT09ICdEaXJlY3RvcnknKSB7XG4gICAgICAgIGNvbnN0IG5lZWRDaG1vZCA9ICF0aGlzLm5vQ2htb2QgJiZcbiAgICAgICAgICBlbnRyeS5tb2RlICYmXG4gICAgICAgICAgKHN0Lm1vZGUgJiAwbzc3NzcpICE9PSBlbnRyeS5tb2RlXG4gICAgICAgIGNvbnN0IFtlcl0gPSBuZWVkQ2htb2QgPyBjYWxsU3luYygoKSA9PiB7XG4gICAgICAgICAgZnMuY2htb2RTeW5jKGVudHJ5LmFic29sdXRlLCBlbnRyeS5tb2RlKVxuICAgICAgICB9KSA6IFtdXG4gICAgICAgIHJldHVybiB0aGlzW01BS0VGU10oZXIsIGVudHJ5KVxuICAgICAgfVxuICAgICAgLy8gbm90IGEgZGlyIGVudHJ5LCBoYXZlIHRvIHJlbW92ZSBpdFxuICAgICAgY29uc3QgW2VyXSA9IGNhbGxTeW5jKCgpID0+IGZzLnJtZGlyU3luYyhlbnRyeS5hYnNvbHV0ZSkpXG4gICAgICB0aGlzW01BS0VGU10oZXIsIGVudHJ5KVxuICAgIH1cblxuICAgIC8vIG5vdCBhIGRpciwgYW5kIG5vdCByZXVzYWJsZS5cbiAgICAvLyBkb24ndCByZW1vdmUgaWYgaXQncyB0aGUgY3dkLCBzaW5jZSB3ZSB3YW50IHRoYXQgZXJyb3IuXG4gICAgY29uc3QgW2VyXSA9IGVudHJ5LmFic29sdXRlID09PSB0aGlzLmN3ZCA/IFtdXG4gICAgICA6IGNhbGxTeW5jKCgpID0+IHVubGlua0ZpbGVTeW5jKGVudHJ5LmFic29sdXRlKSlcbiAgICB0aGlzW01BS0VGU10oZXIsIGVudHJ5KVxuICB9XG5cbiAgW0ZJTEVdIChlbnRyeSwgZG9uZSkge1xuICAgIGNvbnN0IG1vZGUgPSBlbnRyeS5tb2RlICYgMG83Nzc3IHx8IHRoaXMuZm1vZGVcblxuICAgIGNvbnN0IG9uZXIgPSBlciA9PiB7XG4gICAgICBsZXQgY2xvc2VFcnJvclxuICAgICAgdHJ5IHtcbiAgICAgICAgZnMuY2xvc2VTeW5jKGZkKVxuICAgICAgfSBjYXRjaCAoZSkge1xuICAgICAgICBjbG9zZUVycm9yID0gZVxuICAgICAgfVxuICAgICAgaWYgKGVyIHx8IGNsb3NlRXJyb3IpXG4gICAgICAgIHRoaXNbT05FUlJPUl0oZXIgfHwgY2xvc2VFcnJvciwgZW50cnkpXG4gICAgICBkb25lKClcbiAgICB9XG5cbiAgICBsZXQgc3RyZWFtXG4gICAgbGV0IGZkXG4gICAgdHJ5IHtcbiAgICAgIGZkID0gZnMub3BlblN5bmMoZW50cnkuYWJzb2x1dGUsICd3JywgbW9kZSlcbiAgICB9IGNhdGNoIChlcikge1xuICAgICAgcmV0dXJuIG9uZXIoZXIpXG4gICAgfVxuICAgIGNvbnN0IHR4ID0gdGhpcy50cmFuc2Zvcm0gPyB0aGlzLnRyYW5zZm9ybShlbnRyeSkgfHwgZW50cnkgOiBlbnRyeVxuICAgIGlmICh0eCAhPT0gZW50cnkpIHtcbiAgICAgIHR4Lm9uKCdlcnJvcicsIGVyID0+IHRoaXNbT05FUlJPUl0oZXIsIGVudHJ5KSlcbiAgICAgIGVudHJ5LnBpcGUodHgpXG4gICAgfVxuXG4gICAgdHgub24oJ2RhdGEnLCBjaHVuayA9PiB7XG4gICAgICB0cnkge1xuICAgICAgICBmcy53cml0ZVN5bmMoZmQsIGNodW5rLCAwLCBjaHVuay5sZW5ndGgpXG4gICAgICB9IGNhdGNoIChlcikge1xuICAgICAgICBvbmVyKGVyKVxuICAgICAgfVxuICAgIH0pXG5cbiAgICB0eC5vbignZW5kJywgXyA9PiB7XG4gICAgICBsZXQgZXIgPSBudWxsXG4gICAgICAvLyB0cnkgYm90aCwgZmFsbGluZyBmdXRpbWVzIGJhY2sgdG8gdXRpbWVzXG4gICAgICAvLyBpZiBlaXRoZXIgZmFpbHMsIGhhbmRsZSB0aGUgZmlyc3QgZXJyb3JcbiAgICAgIGlmIChlbnRyeS5tdGltZSAmJiAhdGhpcy5ub010aW1lKSB7XG4gICAgICAgIGNvbnN0IGF0aW1lID0gZW50cnkuYXRpbWUgfHwgbmV3IERhdGUoKVxuICAgICAgICBjb25zdCBtdGltZSA9IGVudHJ5Lm10aW1lXG4gICAgICAgIHRyeSB7XG4gICAgICAgICAgZnMuZnV0aW1lc1N5bmMoZmQsIGF0aW1lLCBtdGltZSlcbiAgICAgICAgfSBjYXRjaCAoZnV0aW1lc2VyKSB7XG4gICAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgIGZzLnV0aW1lc1N5bmMoZW50cnkuYWJzb2x1dGUsIGF0aW1lLCBtdGltZSlcbiAgICAgICAgICB9IGNhdGNoICh1dGltZXNlcikge1xuICAgICAgICAgICAgZXIgPSBmdXRpbWVzZXJcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIH1cblxuICAgICAgaWYgKHRoaXNbRE9DSE9XTl0oZW50cnkpKSB7XG4gICAgICAgIGNvbnN0IHVpZCA9IHRoaXNbVUlEXShlbnRyeSlcbiAgICAgICAgY29uc3QgZ2lkID0gdGhpc1tHSURdKGVudHJ5KVxuXG4gICAgICAgIHRyeSB7XG4gICAgICAgICAgZnMuZmNob3duU3luYyhmZCwgdWlkLCBnaWQpXG4gICAgICAgIH0gY2F0Y2ggKGZjaG93bmVyKSB7XG4gICAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgIGZzLmNob3duU3luYyhlbnRyeS5hYnNvbHV0ZSwgdWlkLCBnaWQpXG4gICAgICAgICAgfSBjYXRjaCAoY2hvd25lcikge1xuICAgICAgICAgICAgZXIgPSBlciB8fCBmY2hvd25lclxuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgfVxuXG4gICAgICBvbmVyKGVyKVxuICAgIH0pXG4gIH1cblxuICBbRElSRUNUT1JZXSAoZW50cnksIGRvbmUpIHtcbiAgICBjb25zdCBtb2RlID0gZW50cnkubW9kZSAmIDBvNzc3NyB8fCB0aGlzLmRtb2RlXG4gICAgY29uc3QgZXIgPSB0aGlzW01LRElSXShlbnRyeS5hYnNvbHV0ZSwgbW9kZSlcbiAgICBpZiAoZXIpIHtcbiAgICAgIHRoaXNbT05FUlJPUl0oZXIsIGVudHJ5KVxuICAgICAgZG9uZSgpXG4gICAgICByZXR1cm5cbiAgICB9XG4gICAgaWYgKGVudHJ5Lm10aW1lICYmICF0aGlzLm5vTXRpbWUpIHtcbiAgICAgIHRyeSB7XG4gICAgICAgIGZzLnV0aW1lc1N5bmMoZW50cnkuYWJzb2x1dGUsIGVudHJ5LmF0aW1lIHx8IG5ldyBEYXRlKCksIGVudHJ5Lm10aW1lKVxuICAgICAgfSBjYXRjaCAoZXIpIHt9XG4gICAgfVxuICAgIGlmICh0aGlzW0RPQ0hPV05dKGVudHJ5KSkge1xuICAgICAgdHJ5IHtcbiAgICAgICAgZnMuY2hvd25TeW5jKGVudHJ5LmFic29sdXRlLCB0aGlzW1VJRF0oZW50cnkpLCB0aGlzW0dJRF0oZW50cnkpKVxuICAgICAgfSBjYXRjaCAoZXIpIHt9XG4gICAgfVxuICAgIGRvbmUoKVxuICAgIGVudHJ5LnJlc3VtZSgpXG4gIH1cblxuICBbTUtESVJdIChkaXIsIG1vZGUpIHtcbiAgICB0cnkge1xuICAgICAgcmV0dXJuIG1rZGlyLnN5bmMobm9ybVBhdGgoZGlyKSwge1xuICAgICAgICB1aWQ6IHRoaXMudWlkLFxuICAgICAgICBnaWQ6IHRoaXMuZ2lkLFxuICAgICAgICBwcm9jZXNzVWlkOiB0aGlzLnByb2Nlc3NVaWQsXG4gICAgICAgIHByb2Nlc3NHaWQ6IHRoaXMucHJvY2Vzc0dpZCxcbiAgICAgICAgdW1hc2s6IHRoaXMucHJvY2Vzc1VtYXNrLFxuICAgICAgICBwcmVzZXJ2ZTogdGhpcy5wcmVzZXJ2ZVBhdGhzLFxuICAgICAgICB1bmxpbms6IHRoaXMudW5saW5rLFxuICAgICAgICBjYWNoZTogdGhpcy5kaXJDYWNoZSxcbiAgICAgICAgY3dkOiB0aGlzLmN3ZCxcbiAgICAgICAgbW9kZTogbW9kZVxuICAgICAgfSlcbiAgICB9IGNhdGNoIChlcikge1xuICAgICAgcmV0dXJuIGVyXG4gICAgfVxuICB9XG5cbiAgW0xJTktdIChlbnRyeSwgbGlua3BhdGgsIGxpbmssIGRvbmUpIHtcbiAgICB0cnkge1xuICAgICAgZnNbbGluayArICdTeW5jJ10obGlua3BhdGgsIGVudHJ5LmFic29sdXRlKVxuICAgICAgZG9uZSgpXG4gICAgICBlbnRyeS5yZXN1bWUoKVxuICAgIH0gY2F0Y2ggKGVyKSB7XG4gICAgICByZXR1cm4gdGhpc1tPTkVSUk9SXShlciwgZW50cnkpXG4gICAgfVxuICB9XG59XG5cblVucGFjay5TeW5jID0gVW5wYWNrU3luY1xubW9kdWxlLmV4cG9ydHMgPSBVbnBhY2tcbiJdLCJuYW1lcyI6W10sImlnbm9yZUxpc3QiOlswXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/swarm-js/node_modules/tar/lib/unpack.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/swarm-js/node_modules/tar/lib/update.js":
/*!**************************************************************!*\
  !*** ./node_modules/swarm-js/node_modules/tar/lib/update.js ***!
  \**************************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";
eval("\n\n// tar -u\n\nconst hlo = __webpack_require__(/*! ./high-level-opt.js */ \"(ssr)/./node_modules/swarm-js/node_modules/tar/lib/high-level-opt.js\")\nconst r = __webpack_require__(/*! ./replace.js */ \"(ssr)/./node_modules/swarm-js/node_modules/tar/lib/replace.js\")\n// just call tar.r with the filter and mtimeCache\n\nconst u = module.exports = (opt_, files, cb) => {\n  const opt = hlo(opt_)\n\n  if (!opt.file)\n    throw new TypeError('file is required')\n\n  if (opt.gzip)\n    throw new TypeError('cannot append to compressed archives')\n\n  if (!files || !Array.isArray(files) || !files.length)\n    throw new TypeError('no files or directories specified')\n\n  files = Array.from(files)\n\n  mtimeFilter(opt)\n  return r(opt, files, cb)\n}\n\nconst mtimeFilter = opt => {\n  const filter = opt.filter\n\n  if (!opt.mtimeCache)\n    opt.mtimeCache = new Map()\n\n  opt.filter = filter ? (path, stat) =>\n    filter(path, stat) && !(opt.mtimeCache.get(path) > stat.mtime)\n    : (path, stat) => !(opt.mtimeCache.get(path) > stat.mtime)\n}\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvc3dhcm0tanMvbm9kZV9tb2R1bGVzL3Rhci9saWIvdXBkYXRlLmpzIiwibWFwcGluZ3MiOiJBQUFZOztBQUVaOztBQUVBLFlBQVksbUJBQU8sQ0FBQyxpR0FBcUI7QUFDekMsVUFBVSxtQkFBTyxDQUFDLG1GQUFjO0FBQ2hDOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSIsInNvdXJjZXMiOlsiL1VzZXJzL3BhbnphL0RvY3VtZW50cy9QZXJzb25hbFByb2plY3RzL3ByZWRpay9ub2RlX21vZHVsZXMvc3dhcm0tanMvbm9kZV9tb2R1bGVzL3Rhci9saWIvdXBkYXRlLmpzIl0sInNvdXJjZXNDb250ZW50IjpbIid1c2Ugc3RyaWN0J1xuXG4vLyB0YXIgLXVcblxuY29uc3QgaGxvID0gcmVxdWlyZSgnLi9oaWdoLWxldmVsLW9wdC5qcycpXG5jb25zdCByID0gcmVxdWlyZSgnLi9yZXBsYWNlLmpzJylcbi8vIGp1c3QgY2FsbCB0YXIuciB3aXRoIHRoZSBmaWx0ZXIgYW5kIG10aW1lQ2FjaGVcblxuY29uc3QgdSA9IG1vZHVsZS5leHBvcnRzID0gKG9wdF8sIGZpbGVzLCBjYikgPT4ge1xuICBjb25zdCBvcHQgPSBobG8ob3B0XylcblxuICBpZiAoIW9wdC5maWxlKVxuICAgIHRocm93IG5ldyBUeXBlRXJyb3IoJ2ZpbGUgaXMgcmVxdWlyZWQnKVxuXG4gIGlmIChvcHQuZ3ppcClcbiAgICB0aHJvdyBuZXcgVHlwZUVycm9yKCdjYW5ub3QgYXBwZW5kIHRvIGNvbXByZXNzZWQgYXJjaGl2ZXMnKVxuXG4gIGlmICghZmlsZXMgfHwgIUFycmF5LmlzQXJyYXkoZmlsZXMpIHx8ICFmaWxlcy5sZW5ndGgpXG4gICAgdGhyb3cgbmV3IFR5cGVFcnJvcignbm8gZmlsZXMgb3IgZGlyZWN0b3JpZXMgc3BlY2lmaWVkJylcblxuICBmaWxlcyA9IEFycmF5LmZyb20oZmlsZXMpXG5cbiAgbXRpbWVGaWx0ZXIob3B0KVxuICByZXR1cm4gcihvcHQsIGZpbGVzLCBjYilcbn1cblxuY29uc3QgbXRpbWVGaWx0ZXIgPSBvcHQgPT4ge1xuICBjb25zdCBmaWx0ZXIgPSBvcHQuZmlsdGVyXG5cbiAgaWYgKCFvcHQubXRpbWVDYWNoZSlcbiAgICBvcHQubXRpbWVDYWNoZSA9IG5ldyBNYXAoKVxuXG4gIG9wdC5maWx0ZXIgPSBmaWx0ZXIgPyAocGF0aCwgc3RhdCkgPT5cbiAgICBmaWx0ZXIocGF0aCwgc3RhdCkgJiYgIShvcHQubXRpbWVDYWNoZS5nZXQocGF0aCkgPiBzdGF0Lm10aW1lKVxuICAgIDogKHBhdGgsIHN0YXQpID0+ICEob3B0Lm10aW1lQ2FjaGUuZ2V0KHBhdGgpID4gc3RhdC5tdGltZSlcbn1cbiJdLCJuYW1lcyI6W10sImlnbm9yZUxpc3QiOlswXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/swarm-js/node_modules/tar/lib/update.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/swarm-js/node_modules/tar/lib/warn-mixin.js":
/*!******************************************************************!*\
  !*** ./node_modules/swarm-js/node_modules/tar/lib/warn-mixin.js ***!
  \******************************************************************/
/***/ ((module) => {

"use strict";
eval("\nmodule.exports = Base => class extends Base {\n  warn (msg, data) {\n    if (!this.strict)\n      this.emit('warn', msg, data)\n    else if (data instanceof Error)\n      this.emit('error', data)\n    else {\n      const er = new Error(msg)\n      er.data = data\n      this.emit('error', er)\n    }\n  }\n}\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvc3dhcm0tanMvbm9kZV9tb2R1bGVzL3Rhci9saWIvd2Fybi1taXhpbi5qcyIsIm1hcHBpbmdzIjoiQUFBWTtBQUNaO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBIiwic291cmNlcyI6WyIvVXNlcnMvcGFuemEvRG9jdW1lbnRzL1BlcnNvbmFsUHJvamVjdHMvcHJlZGlrL25vZGVfbW9kdWxlcy9zd2FybS1qcy9ub2RlX21vZHVsZXMvdGFyL2xpYi93YXJuLW1peGluLmpzIl0sInNvdXJjZXNDb250ZW50IjpbIid1c2Ugc3RyaWN0J1xubW9kdWxlLmV4cG9ydHMgPSBCYXNlID0+IGNsYXNzIGV4dGVuZHMgQmFzZSB7XG4gIHdhcm4gKG1zZywgZGF0YSkge1xuICAgIGlmICghdGhpcy5zdHJpY3QpXG4gICAgICB0aGlzLmVtaXQoJ3dhcm4nLCBtc2csIGRhdGEpXG4gICAgZWxzZSBpZiAoZGF0YSBpbnN0YW5jZW9mIEVycm9yKVxuICAgICAgdGhpcy5lbWl0KCdlcnJvcicsIGRhdGEpXG4gICAgZWxzZSB7XG4gICAgICBjb25zdCBlciA9IG5ldyBFcnJvcihtc2cpXG4gICAgICBlci5kYXRhID0gZGF0YVxuICAgICAgdGhpcy5lbWl0KCdlcnJvcicsIGVyKVxuICAgIH1cbiAgfVxufVxuIl0sIm5hbWVzIjpbXSwiaWdub3JlTGlzdCI6WzBdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/swarm-js/node_modules/tar/lib/warn-mixin.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/swarm-js/node_modules/tar/lib/winchars.js":
/*!****************************************************************!*\
  !*** ./node_modules/swarm-js/node_modules/tar/lib/winchars.js ***!
  \****************************************************************/
/***/ ((module) => {

"use strict";
eval("\n\n// When writing files on Windows, translate the characters to their\n// 0xf000 higher-encoded versions.\n\nconst raw = [\n  '|',\n  '<',\n  '>',\n  '?',\n  ':'\n]\n\nconst win = raw.map(char =>\n  String.fromCharCode(0xf000 + char.charCodeAt(0)))\n\nconst toWin = new Map(raw.map((char, i) => [char, win[i]]))\nconst toRaw = new Map(win.map((char, i) => [char, raw[i]]))\n\nmodule.exports = {\n  encode: s => raw.reduce((s, c) => s.split(c).join(toWin.get(c)), s),\n  decode: s => win.reduce((s, c) => s.split(c).join(toRaw.get(c)), s)\n}\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvc3dhcm0tanMvbm9kZV9tb2R1bGVzL3Rhci9saWIvd2luY2hhcnMuanMiLCJtYXBwaW5ncyI6IkFBQVk7O0FBRVo7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EiLCJzb3VyY2VzIjpbIi9Vc2Vycy9wYW56YS9Eb2N1bWVudHMvUGVyc29uYWxQcm9qZWN0cy9wcmVkaWsvbm9kZV9tb2R1bGVzL3N3YXJtLWpzL25vZGVfbW9kdWxlcy90YXIvbGliL3dpbmNoYXJzLmpzIl0sInNvdXJjZXNDb250ZW50IjpbIid1c2Ugc3RyaWN0J1xuXG4vLyBXaGVuIHdyaXRpbmcgZmlsZXMgb24gV2luZG93cywgdHJhbnNsYXRlIHRoZSBjaGFyYWN0ZXJzIHRvIHRoZWlyXG4vLyAweGYwMDAgaGlnaGVyLWVuY29kZWQgdmVyc2lvbnMuXG5cbmNvbnN0IHJhdyA9IFtcbiAgJ3wnLFxuICAnPCcsXG4gICc+JyxcbiAgJz8nLFxuICAnOidcbl1cblxuY29uc3Qgd2luID0gcmF3Lm1hcChjaGFyID0+XG4gIFN0cmluZy5mcm9tQ2hhckNvZGUoMHhmMDAwICsgY2hhci5jaGFyQ29kZUF0KDApKSlcblxuY29uc3QgdG9XaW4gPSBuZXcgTWFwKHJhdy5tYXAoKGNoYXIsIGkpID0+IFtjaGFyLCB3aW5baV1dKSlcbmNvbnN0IHRvUmF3ID0gbmV3IE1hcCh3aW4ubWFwKChjaGFyLCBpKSA9PiBbY2hhciwgcmF3W2ldXSkpXG5cbm1vZHVsZS5leHBvcnRzID0ge1xuICBlbmNvZGU6IHMgPT4gcmF3LnJlZHVjZSgocywgYykgPT4gcy5zcGxpdChjKS5qb2luKHRvV2luLmdldChjKSksIHMpLFxuICBkZWNvZGU6IHMgPT4gd2luLnJlZHVjZSgocywgYykgPT4gcy5zcGxpdChjKS5qb2luKHRvUmF3LmdldChjKSksIHMpXG59XG4iXSwibmFtZXMiOltdLCJpZ25vcmVMaXN0IjpbMF0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/swarm-js/node_modules/tar/lib/winchars.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/swarm-js/node_modules/tar/lib/write-entry.js":
/*!*******************************************************************!*\
  !*** ./node_modules/swarm-js/node_modules/tar/lib/write-entry.js ***!
  \*******************************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";
eval("\nconst Buffer = __webpack_require__(/*! ./buffer.js */ \"(ssr)/./node_modules/swarm-js/node_modules/tar/lib/buffer.js\")\nconst MiniPass = __webpack_require__(/*! minipass */ \"(ssr)/./node_modules/swarm-js/node_modules/minipass/index.js\")\nconst Pax = __webpack_require__(/*! ./pax.js */ \"(ssr)/./node_modules/swarm-js/node_modules/tar/lib/pax.js\")\nconst Header = __webpack_require__(/*! ./header.js */ \"(ssr)/./node_modules/swarm-js/node_modules/tar/lib/header.js\")\nconst ReadEntry = __webpack_require__(/*! ./read-entry.js */ \"(ssr)/./node_modules/swarm-js/node_modules/tar/lib/read-entry.js\")\nconst fs = __webpack_require__(/*! fs */ \"fs\")\nconst path = __webpack_require__(/*! path */ \"path\")\nconst normPath = __webpack_require__(/*! ./normalize-windows-path.js */ \"(ssr)/./node_modules/swarm-js/node_modules/tar/lib/normalize-windows-path.js\")\nconst stripSlash = __webpack_require__(/*! ./strip-trailing-slashes.js */ \"(ssr)/./node_modules/swarm-js/node_modules/tar/lib/strip-trailing-slashes.js\")\n\nconst prefixPath = (path, prefix) => {\n  if (!prefix)\n    return path\n  path = normPath(path).replace(/^\\.(\\/|$)/, '')\n  return stripSlash(prefix) + '/' + path\n}\n\nconst maxReadSize = 16 * 1024 * 1024\nconst PROCESS = Symbol('process')\nconst FILE = Symbol('file')\nconst DIRECTORY = Symbol('directory')\nconst SYMLINK = Symbol('symlink')\nconst HARDLINK = Symbol('hardlink')\nconst HEADER = Symbol('header')\nconst READ = Symbol('read')\nconst LSTAT = Symbol('lstat')\nconst ONLSTAT = Symbol('onlstat')\nconst ONREAD = Symbol('onread')\nconst ONREADLINK = Symbol('onreadlink')\nconst OPENFILE = Symbol('openfile')\nconst ONOPENFILE = Symbol('onopenfile')\nconst CLOSE = Symbol('close')\nconst MODE = Symbol('mode')\nconst AWAITDRAIN = Symbol('awaitDrain')\nconst ONDRAIN = Symbol('ondrain')\nconst PREFIX = Symbol('prefix')\nconst HAD_ERROR = Symbol('hadError')\nconst warner = __webpack_require__(/*! ./warn-mixin.js */ \"(ssr)/./node_modules/swarm-js/node_modules/tar/lib/warn-mixin.js\")\nconst winchars = __webpack_require__(/*! ./winchars.js */ \"(ssr)/./node_modules/swarm-js/node_modules/tar/lib/winchars.js\")\nconst stripAbsolutePath = __webpack_require__(/*! ./strip-absolute-path.js */ \"(ssr)/./node_modules/swarm-js/node_modules/tar/lib/strip-absolute-path.js\")\n\nconst modeFix = __webpack_require__(/*! ./mode-fix.js */ \"(ssr)/./node_modules/swarm-js/node_modules/tar/lib/mode-fix.js\")\n\nconst WriteEntry = warner(class WriteEntry extends MiniPass {\n  constructor (p, opt) {\n    opt = opt || {}\n    super(opt)\n    if (typeof p !== 'string')\n      throw new TypeError('path is required')\n    this.path = normPath(p)\n    // suppress atime, ctime, uid, gid, uname, gname\n    this.portable = !!opt.portable\n    // until node has builtin pwnam functions, this'll have to do\n    this.myuid = process.getuid && process.getuid() || 0\n    this.myuser = process.env.USER || ''\n    this.maxReadSize = opt.maxReadSize || maxReadSize\n    this.linkCache = opt.linkCache || new Map()\n    this.statCache = opt.statCache || new Map()\n    this.preservePaths = !!opt.preservePaths\n    this.cwd = normPath(opt.cwd || process.cwd())\n    this.strict = !!opt.strict\n    this.noPax = !!opt.noPax\n    this.noMtime = !!opt.noMtime\n    this.mtime = opt.mtime || null\n    this.prefix = opt.prefix ? normPath(opt.prefix) : null\n\n    this.fd = null\n    this.blockLen = null\n    this.blockRemain = null\n    this.buf = null\n    this.offset = null\n    this.length = null\n    this.pos = null\n    this.remain = null\n\n    if (typeof opt.onwarn === 'function')\n      this.on('warn', opt.onwarn)\n\n    if (!this.preservePaths) {\n      const s = stripAbsolutePath(this.path)\n      if (s[0]) {\n        this.warn('stripping ' + s[0] + ' from absolute path', this.path)\n        this.path = s[1]\n      }\n    }\n\n    this.win32 = !!opt.win32 || process.platform === 'win32'\n    if (this.win32) {\n      // force the \\ to / normalization, since we might not *actually*\n      // be on windows, but want \\ to be considered a path separator.\n      this.path = winchars.decode(this.path.replace(/\\\\/g, '/'))\n      p = p.replace(/\\\\/g, '/')\n    }\n\n    this.absolute = normPath(opt.absolute || path.resolve(this.cwd, p))\n\n    if (this.path === '')\n      this.path = './'\n\n    if (this.statCache.has(this.absolute))\n      this[ONLSTAT](this.statCache.get(this.absolute))\n    else\n      this[LSTAT]()\n  }\n\n  emit (ev, ...data) {\n    if (ev === 'error')\n      this[HAD_ERROR] = true\n    return super.emit(ev, ...data)\n  }\n\n  [LSTAT] () {\n    fs.lstat(this.absolute, (er, stat) => {\n      if (er)\n        return this.emit('error', er)\n      this[ONLSTAT](stat)\n    })\n  }\n\n  [ONLSTAT] (stat) {\n    this.statCache.set(this.absolute, stat)\n    this.stat = stat\n    if (!stat.isFile())\n      stat.size = 0\n    this.type = getType(stat)\n    this.emit('stat', stat)\n    this[PROCESS]()\n  }\n\n  [PROCESS] () {\n    switch (this.type) {\n      case 'File': return this[FILE]()\n      case 'Directory': return this[DIRECTORY]()\n      case 'SymbolicLink': return this[SYMLINK]()\n      // unsupported types are ignored.\n      default: return this.end()\n    }\n  }\n\n  [MODE] (mode) {\n    return modeFix(mode, this.type === 'Directory')\n  }\n\n  [PREFIX] (path) {\n    return prefixPath(path, this.prefix)\n  }\n\n  [HEADER] () {\n    if (this.type === 'Directory' && this.portable)\n      this.noMtime = true\n\n    this.header = new Header({\n      path: this[PREFIX](this.path),\n      // only apply the prefix to hard links.\n      linkpath: this.type === 'Link' ? this[PREFIX](this.linkpath)\n      : this.linkpath,\n      // only the permissions and setuid/setgid/sticky bitflags\n      // not the higher-order bits that specify file type\n      mode: this[MODE](this.stat.mode),\n      uid: this.portable ? null : this.stat.uid,\n      gid: this.portable ? null : this.stat.gid,\n      size: this.stat.size,\n      mtime: this.noMtime ? null : this.mtime || this.stat.mtime,\n      type: this.type,\n      uname: this.portable ? null :\n        this.stat.uid === this.myuid ? this.myuser : '',\n      atime: this.portable ? null : this.stat.atime,\n      ctime: this.portable ? null : this.stat.ctime\n    })\n\n    if (this.header.encode() && !this.noPax) {\n      super.write(new Pax({\n        atime: this.portable ? null : this.header.atime,\n        ctime: this.portable ? null : this.header.ctime,\n        gid: this.portable ? null : this.header.gid,\n        mtime: this.noMtime ? null : this.mtime || this.header.mtime,\n        path: this[PREFIX](this.path),\n        linkpath: this.type === 'Link' ? this[PREFIX](this.linkpath)\n        : this.linkpath,\n        size: this.header.size,\n        uid: this.portable ? null : this.header.uid,\n        uname: this.portable ? null : this.header.uname,\n        dev: this.portable ? null : this.stat.dev,\n        ino: this.portable ? null : this.stat.ino,\n        nlink: this.portable ? null : this.stat.nlink\n      }).encode())\n    }\n    super.write(this.header.block)\n  }\n\n  [DIRECTORY] () {\n    if (this.path.substr(-1) !== '/')\n      this.path += '/'\n    this.stat.size = 0\n    this[HEADER]()\n    this.end()\n  }\n\n  [SYMLINK] () {\n    fs.readlink(this.absolute, (er, linkpath) => {\n      if (er)\n        return this.emit('error', er)\n      this[ONREADLINK](linkpath)\n    })\n  }\n\n  [ONREADLINK] (linkpath) {\n    this.linkpath = normPath(linkpath)\n    this[HEADER]()\n    this.end()\n  }\n\n  [HARDLINK] (linkpath) {\n    this.type = 'Link'\n    this.linkpath = normPath(path.relative(this.cwd, linkpath))\n    this.stat.size = 0\n    this[HEADER]()\n    this.end()\n  }\n\n  [FILE] () {\n    if (this.stat.nlink > 1) {\n      const linkKey = this.stat.dev + ':' + this.stat.ino\n      if (this.linkCache.has(linkKey)) {\n        const linkpath = this.linkCache.get(linkKey)\n        if (linkpath.indexOf(this.cwd) === 0)\n          return this[HARDLINK](linkpath)\n      }\n      this.linkCache.set(linkKey, this.absolute)\n    }\n\n    this[HEADER]()\n    if (this.stat.size === 0)\n      return this.end()\n\n    this[OPENFILE]()\n  }\n\n  [OPENFILE] () {\n    fs.open(this.absolute, 'r', (er, fd) => {\n      if (er)\n        return this.emit('error', er)\n      this[ONOPENFILE](fd)\n    })\n  }\n\n  [ONOPENFILE] (fd) {\n    this.fd = fd\n    if (this[HAD_ERROR])\n      return this[CLOSE]()\n\n    this.blockLen = 512 * Math.ceil(this.stat.size / 512)\n    this.blockRemain = this.blockLen\n    const bufLen = Math.min(this.blockLen, this.maxReadSize)\n    this.buf = Buffer.allocUnsafe(bufLen)\n    this.offset = 0\n    this.pos = 0\n    this.remain = this.stat.size\n    this.length = this.buf.length\n    this[READ]()\n  }\n\n  [READ] () {\n    const { fd, buf, offset, length, pos } = this\n    fs.read(fd, buf, offset, length, pos, (er, bytesRead) => {\n      if (er) {\n        // ignoring the error from close(2) is a bad practice, but at\n        // this point we already have an error, don't need another one\n        return this[CLOSE](() => this.emit('error', er))\n      }\n      this[ONREAD](bytesRead)\n    })\n  }\n\n  [CLOSE] (cb) {\n    fs.close(this.fd, cb)\n  }\n\n  [ONREAD] (bytesRead) {\n    if (bytesRead <= 0 && this.remain > 0) {\n      const er = new Error('encountered unexpected EOF')\n      er.path = this.absolute\n      er.syscall = 'read'\n      er.code = 'EOF'\n      return this[CLOSE](() => this.emit('error', er))\n    }\n\n    if (bytesRead > this.remain) {\n      const er = new Error('did not encounter expected EOF')\n      er.path = this.absolute\n      er.syscall = 'read'\n      er.code = 'EOF'\n      return this[CLOSE](() => this.emit('error', er))\n    }\n\n    // null out the rest of the buffer, if we could fit the block padding\n    // at the end of this loop, we've incremented bytesRead and this.remain\n    // to be incremented up to the blockRemain level, as if we had expected\n    // to get a null-padded file, and read it until the end.  then we will\n    // decrement both remain and blockRemain by bytesRead, and know that we\n    // reached the expected EOF, without any null buffer to append.\n    if (bytesRead === this.remain) {\n      for (let i = bytesRead; i < this.length && bytesRead < this.blockRemain; i++) {\n        this.buf[i + this.offset] = 0\n        bytesRead++\n        this.remain++\n      }\n    }\n\n    const writeBuf = this.offset === 0 && bytesRead === this.buf.length ?\n      this.buf : this.buf.slice(this.offset, this.offset + bytesRead)\n\n    const flushed = this.write(writeBuf)\n    if (!flushed)\n      this[AWAITDRAIN](() => this[ONDRAIN]())\n    else\n      this[ONDRAIN]()\n  }\n\n  [AWAITDRAIN] (cb) {\n    this.once('drain', cb)\n  }\n\n  write (writeBuf) {\n    if (this.blockRemain < writeBuf.length) {\n      const er = new Error('writing more data than expected')\n      er.path = this.absolute\n      return this.emit('error', er)\n    }\n    this.remain -= writeBuf.length\n    this.blockRemain -= writeBuf.length\n    this.pos += writeBuf.length\n    this.offset += writeBuf.length\n    return super.write(writeBuf)\n  }\n\n  [ONDRAIN] () {\n    if (!this.remain) {\n      if (this.blockRemain)\n        super.write(Buffer.alloc(this.blockRemain))\n      return this[CLOSE](/* istanbul ignore next - legacy */\n        er => er ? this.emit('error', er) : this.end())\n    }\n\n    if (this.offset >= this.length) {\n      // if we only have a smaller bit left to read, alloc a smaller buffer\n      // otherwise, keep it the same length it was before.\n      this.buf = Buffer.allocUnsafe(Math.min(this.blockRemain, this.buf.length))\n      this.offset = 0\n    }\n    this.length = this.buf.length - this.offset\n    this[READ]()\n  }\n})\n\nclass WriteEntrySync extends WriteEntry {\n  constructor (path, opt) {\n    super(path, opt)\n  }\n\n  [LSTAT] () {\n    this[ONLSTAT](fs.lstatSync(this.absolute))\n  }\n\n  [SYMLINK] () {\n    this[ONREADLINK](fs.readlinkSync(this.absolute))\n  }\n\n  [OPENFILE] () {\n    this[ONOPENFILE](fs.openSync(this.absolute, 'r'))\n  }\n\n  [READ] () {\n    let threw = true\n    try {\n      const { fd, buf, offset, length, pos } = this\n      const bytesRead = fs.readSync(fd, buf, offset, length, pos)\n      this[ONREAD](bytesRead)\n      threw = false\n    } finally {\n      // ignoring the error from close(2) is a bad practice, but at\n      // this point we already have an error, don't need another one\n      if (threw) {\n        try {\n          this[CLOSE](() => {})\n        } catch (er) {}\n      }\n    }\n  }\n\n  [AWAITDRAIN] (cb) {\n    cb()\n  }\n\n  [CLOSE] (cb) {\n    fs.closeSync(this.fd)\n    cb()\n  }\n}\n\nconst WriteEntryTar = warner(class WriteEntryTar extends MiniPass {\n  constructor (readEntry, opt) {\n    opt = opt || {}\n    super(opt)\n    this.preservePaths = !!opt.preservePaths\n    this.portable = !!opt.portable\n    this.strict = !!opt.strict\n    this.noPax = !!opt.noPax\n    this.noMtime = !!opt.noMtime\n\n    this.readEntry = readEntry\n    this.type = readEntry.type\n    if (this.type === 'Directory' && this.portable)\n      this.noMtime = true\n\n    this.prefix = opt.prefix || null\n\n    this.path = normPath(readEntry.path)\n    this.mode = this[MODE](readEntry.mode)\n    this.uid = this.portable ? null : readEntry.uid\n    this.gid = this.portable ? null : readEntry.gid\n    this.uname = this.portable ? null : readEntry.uname\n    this.gname = this.portable ? null : readEntry.gname\n    this.size = readEntry.size\n    this.mtime = this.noMtime ? null : opt.mtime || readEntry.mtime\n    this.atime = this.portable ? null : readEntry.atime\n    this.ctime = this.portable ? null : readEntry.ctime\n    this.linkpath = normPath(readEntry.linkpath)\n\n    if (typeof opt.onwarn === 'function')\n      this.on('warn', opt.onwarn)\n\n    if (!this.preservePaths) {\n      const s = stripAbsolutePath(this.path)\n      if (s[0]) {\n        this.warn(\n          'stripping ' + s[0] + ' from absolute path',\n          this.path\n        )\n        this.path = s[1]\n      }\n    }\n\n    this.remain = readEntry.size\n    this.blockRemain = readEntry.startBlockSize\n\n    this.header = new Header({\n      path: this[PREFIX](this.path),\n      linkpath: this.type === 'Link' ? this[PREFIX](this.linkpath)\n      : this.linkpath,\n      // only the permissions and setuid/setgid/sticky bitflags\n      // not the higher-order bits that specify file type\n      mode: this.mode,\n      uid: this.portable ? null : this.uid,\n      gid: this.portable ? null : this.gid,\n      size: this.size,\n      mtime: this.noMtime ? null : this.mtime,\n      type: this.type,\n      uname: this.portable ? null : this.uname,\n      atime: this.portable ? null : this.atime,\n      ctime: this.portable ? null : this.ctime\n    })\n\n    if (this.header.encode() && !this.noPax)\n      super.write(new Pax({\n        atime: this.portable ? null : this.atime,\n        ctime: this.portable ? null : this.ctime,\n        gid: this.portable ? null : this.gid,\n        mtime: this.noMtime ? null : this.mtime,\n        path: this[PREFIX](this.path),\n        linkpath: this.type === 'Link' ? this[PREFIX](this.linkpath)\n        : this.linkpath,\n        size: this.size,\n        uid: this.portable ? null : this.uid,\n        uname: this.portable ? null : this.uname,\n        dev: this.portable ? null : this.readEntry.dev,\n        ino: this.portable ? null : this.readEntry.ino,\n        nlink: this.portable ? null : this.readEntry.nlink\n      }).encode())\n\n    super.write(this.header.block)\n    readEntry.pipe(this)\n  }\n\n  [PREFIX] (path) {\n    return prefixPath(path, this.prefix)\n  }\n\n  [MODE] (mode) {\n    return modeFix(mode, this.type === 'Directory')\n  }\n\n  write (data) {\n    const writeLen = data.length\n    if (writeLen > this.blockRemain)\n      throw new Error('writing more to entry than is appropriate')\n    this.blockRemain -= writeLen\n    return super.write(data)\n  }\n\n  end () {\n    if (this.blockRemain)\n      super.write(Buffer.alloc(this.blockRemain))\n    return super.end()\n  }\n})\n\nWriteEntry.Sync = WriteEntrySync\nWriteEntry.Tar = WriteEntryTar\n\nconst getType = stat =>\n  stat.isFile() ? 'File'\n  : stat.isDirectory() ? 'Directory'\n  : stat.isSymbolicLink() ? 'SymbolicLink'\n  : 'Unsupported'\n\nmodule.exports = WriteEntry\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvc3dhcm0tanMvbm9kZV9tb2R1bGVzL3Rhci9saWIvd3JpdGUtZW50cnkuanMiLCJtYXBwaW5ncyI6IkFBQVk7QUFDWixlQUFlLG1CQUFPLENBQUMsaUZBQWE7QUFDcEMsaUJBQWlCLG1CQUFPLENBQUMsOEVBQVU7QUFDbkMsWUFBWSxtQkFBTyxDQUFDLDJFQUFVO0FBQzlCLGVBQWUsbUJBQU8sQ0FBQyxpRkFBYTtBQUNwQyxrQkFBa0IsbUJBQU8sQ0FBQyx5RkFBaUI7QUFDM0MsV0FBVyxtQkFBTyxDQUFDLGNBQUk7QUFDdkIsYUFBYSxtQkFBTyxDQUFDLGtCQUFNO0FBQzNCLGlCQUFpQixtQkFBTyxDQUFDLGlIQUE2QjtBQUN0RCxtQkFBbUIsbUJBQU8sQ0FBQyxpSEFBNkI7O0FBRXhEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZUFBZSxtQkFBTyxDQUFDLHlGQUFpQjtBQUN4QyxpQkFBaUIsbUJBQU8sQ0FBQyxxRkFBZTtBQUN4QywwQkFBMEIsbUJBQU8sQ0FBQywyR0FBMEI7O0FBRTVELGdCQUFnQixtQkFBTyxDQUFDLHFGQUFlOztBQUV2QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLOztBQUVMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxZQUFZLCtCQUErQjtBQUMzQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDhCQUE4QixpREFBaUQ7QUFDL0U7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUM7O0FBRUQ7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsY0FBYywrQkFBK0I7QUFDN0M7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsOEJBQThCO0FBQzlCLFVBQVU7QUFDVjtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7O0FBRUw7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTzs7QUFFUDtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQzs7QUFFRDtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUEiLCJzb3VyY2VzIjpbIi9Vc2Vycy9wYW56YS9Eb2N1bWVudHMvUGVyc29uYWxQcm9qZWN0cy9wcmVkaWsvbm9kZV9tb2R1bGVzL3N3YXJtLWpzL25vZGVfbW9kdWxlcy90YXIvbGliL3dyaXRlLWVudHJ5LmpzIl0sInNvdXJjZXNDb250ZW50IjpbIid1c2Ugc3RyaWN0J1xuY29uc3QgQnVmZmVyID0gcmVxdWlyZSgnLi9idWZmZXIuanMnKVxuY29uc3QgTWluaVBhc3MgPSByZXF1aXJlKCdtaW5pcGFzcycpXG5jb25zdCBQYXggPSByZXF1aXJlKCcuL3BheC5qcycpXG5jb25zdCBIZWFkZXIgPSByZXF1aXJlKCcuL2hlYWRlci5qcycpXG5jb25zdCBSZWFkRW50cnkgPSByZXF1aXJlKCcuL3JlYWQtZW50cnkuanMnKVxuY29uc3QgZnMgPSByZXF1aXJlKCdmcycpXG5jb25zdCBwYXRoID0gcmVxdWlyZSgncGF0aCcpXG5jb25zdCBub3JtUGF0aCA9IHJlcXVpcmUoJy4vbm9ybWFsaXplLXdpbmRvd3MtcGF0aC5qcycpXG5jb25zdCBzdHJpcFNsYXNoID0gcmVxdWlyZSgnLi9zdHJpcC10cmFpbGluZy1zbGFzaGVzLmpzJylcblxuY29uc3QgcHJlZml4UGF0aCA9IChwYXRoLCBwcmVmaXgpID0+IHtcbiAgaWYgKCFwcmVmaXgpXG4gICAgcmV0dXJuIHBhdGhcbiAgcGF0aCA9IG5vcm1QYXRoKHBhdGgpLnJlcGxhY2UoL15cXC4oXFwvfCQpLywgJycpXG4gIHJldHVybiBzdHJpcFNsYXNoKHByZWZpeCkgKyAnLycgKyBwYXRoXG59XG5cbmNvbnN0IG1heFJlYWRTaXplID0gMTYgKiAxMDI0ICogMTAyNFxuY29uc3QgUFJPQ0VTUyA9IFN5bWJvbCgncHJvY2VzcycpXG5jb25zdCBGSUxFID0gU3ltYm9sKCdmaWxlJylcbmNvbnN0IERJUkVDVE9SWSA9IFN5bWJvbCgnZGlyZWN0b3J5JylcbmNvbnN0IFNZTUxJTksgPSBTeW1ib2woJ3N5bWxpbmsnKVxuY29uc3QgSEFSRExJTksgPSBTeW1ib2woJ2hhcmRsaW5rJylcbmNvbnN0IEhFQURFUiA9IFN5bWJvbCgnaGVhZGVyJylcbmNvbnN0IFJFQUQgPSBTeW1ib2woJ3JlYWQnKVxuY29uc3QgTFNUQVQgPSBTeW1ib2woJ2xzdGF0JylcbmNvbnN0IE9OTFNUQVQgPSBTeW1ib2woJ29ubHN0YXQnKVxuY29uc3QgT05SRUFEID0gU3ltYm9sKCdvbnJlYWQnKVxuY29uc3QgT05SRUFETElOSyA9IFN5bWJvbCgnb25yZWFkbGluaycpXG5jb25zdCBPUEVORklMRSA9IFN5bWJvbCgnb3BlbmZpbGUnKVxuY29uc3QgT05PUEVORklMRSA9IFN5bWJvbCgnb25vcGVuZmlsZScpXG5jb25zdCBDTE9TRSA9IFN5bWJvbCgnY2xvc2UnKVxuY29uc3QgTU9ERSA9IFN5bWJvbCgnbW9kZScpXG5jb25zdCBBV0FJVERSQUlOID0gU3ltYm9sKCdhd2FpdERyYWluJylcbmNvbnN0IE9ORFJBSU4gPSBTeW1ib2woJ29uZHJhaW4nKVxuY29uc3QgUFJFRklYID0gU3ltYm9sKCdwcmVmaXgnKVxuY29uc3QgSEFEX0VSUk9SID0gU3ltYm9sKCdoYWRFcnJvcicpXG5jb25zdCB3YXJuZXIgPSByZXF1aXJlKCcuL3dhcm4tbWl4aW4uanMnKVxuY29uc3Qgd2luY2hhcnMgPSByZXF1aXJlKCcuL3dpbmNoYXJzLmpzJylcbmNvbnN0IHN0cmlwQWJzb2x1dGVQYXRoID0gcmVxdWlyZSgnLi9zdHJpcC1hYnNvbHV0ZS1wYXRoLmpzJylcblxuY29uc3QgbW9kZUZpeCA9IHJlcXVpcmUoJy4vbW9kZS1maXguanMnKVxuXG5jb25zdCBXcml0ZUVudHJ5ID0gd2FybmVyKGNsYXNzIFdyaXRlRW50cnkgZXh0ZW5kcyBNaW5pUGFzcyB7XG4gIGNvbnN0cnVjdG9yIChwLCBvcHQpIHtcbiAgICBvcHQgPSBvcHQgfHwge31cbiAgICBzdXBlcihvcHQpXG4gICAgaWYgKHR5cGVvZiBwICE9PSAnc3RyaW5nJylcbiAgICAgIHRocm93IG5ldyBUeXBlRXJyb3IoJ3BhdGggaXMgcmVxdWlyZWQnKVxuICAgIHRoaXMucGF0aCA9IG5vcm1QYXRoKHApXG4gICAgLy8gc3VwcHJlc3MgYXRpbWUsIGN0aW1lLCB1aWQsIGdpZCwgdW5hbWUsIGduYW1lXG4gICAgdGhpcy5wb3J0YWJsZSA9ICEhb3B0LnBvcnRhYmxlXG4gICAgLy8gdW50aWwgbm9kZSBoYXMgYnVpbHRpbiBwd25hbSBmdW5jdGlvbnMsIHRoaXMnbGwgaGF2ZSB0byBkb1xuICAgIHRoaXMubXl1aWQgPSBwcm9jZXNzLmdldHVpZCAmJiBwcm9jZXNzLmdldHVpZCgpIHx8IDBcbiAgICB0aGlzLm15dXNlciA9IHByb2Nlc3MuZW52LlVTRVIgfHwgJydcbiAgICB0aGlzLm1heFJlYWRTaXplID0gb3B0Lm1heFJlYWRTaXplIHx8IG1heFJlYWRTaXplXG4gICAgdGhpcy5saW5rQ2FjaGUgPSBvcHQubGlua0NhY2hlIHx8IG5ldyBNYXAoKVxuICAgIHRoaXMuc3RhdENhY2hlID0gb3B0LnN0YXRDYWNoZSB8fCBuZXcgTWFwKClcbiAgICB0aGlzLnByZXNlcnZlUGF0aHMgPSAhIW9wdC5wcmVzZXJ2ZVBhdGhzXG4gICAgdGhpcy5jd2QgPSBub3JtUGF0aChvcHQuY3dkIHx8IHByb2Nlc3MuY3dkKCkpXG4gICAgdGhpcy5zdHJpY3QgPSAhIW9wdC5zdHJpY3RcbiAgICB0aGlzLm5vUGF4ID0gISFvcHQubm9QYXhcbiAgICB0aGlzLm5vTXRpbWUgPSAhIW9wdC5ub010aW1lXG4gICAgdGhpcy5tdGltZSA9IG9wdC5tdGltZSB8fCBudWxsXG4gICAgdGhpcy5wcmVmaXggPSBvcHQucHJlZml4ID8gbm9ybVBhdGgob3B0LnByZWZpeCkgOiBudWxsXG5cbiAgICB0aGlzLmZkID0gbnVsbFxuICAgIHRoaXMuYmxvY2tMZW4gPSBudWxsXG4gICAgdGhpcy5ibG9ja1JlbWFpbiA9IG51bGxcbiAgICB0aGlzLmJ1ZiA9IG51bGxcbiAgICB0aGlzLm9mZnNldCA9IG51bGxcbiAgICB0aGlzLmxlbmd0aCA9IG51bGxcbiAgICB0aGlzLnBvcyA9IG51bGxcbiAgICB0aGlzLnJlbWFpbiA9IG51bGxcblxuICAgIGlmICh0eXBlb2Ygb3B0Lm9ud2FybiA9PT0gJ2Z1bmN0aW9uJylcbiAgICAgIHRoaXMub24oJ3dhcm4nLCBvcHQub253YXJuKVxuXG4gICAgaWYgKCF0aGlzLnByZXNlcnZlUGF0aHMpIHtcbiAgICAgIGNvbnN0IHMgPSBzdHJpcEFic29sdXRlUGF0aCh0aGlzLnBhdGgpXG4gICAgICBpZiAoc1swXSkge1xuICAgICAgICB0aGlzLndhcm4oJ3N0cmlwcGluZyAnICsgc1swXSArICcgZnJvbSBhYnNvbHV0ZSBwYXRoJywgdGhpcy5wYXRoKVxuICAgICAgICB0aGlzLnBhdGggPSBzWzFdXG4gICAgICB9XG4gICAgfVxuXG4gICAgdGhpcy53aW4zMiA9ICEhb3B0LndpbjMyIHx8IHByb2Nlc3MucGxhdGZvcm0gPT09ICd3aW4zMidcbiAgICBpZiAodGhpcy53aW4zMikge1xuICAgICAgLy8gZm9yY2UgdGhlIFxcIHRvIC8gbm9ybWFsaXphdGlvbiwgc2luY2Ugd2UgbWlnaHQgbm90ICphY3R1YWxseSpcbiAgICAgIC8vIGJlIG9uIHdpbmRvd3MsIGJ1dCB3YW50IFxcIHRvIGJlIGNvbnNpZGVyZWQgYSBwYXRoIHNlcGFyYXRvci5cbiAgICAgIHRoaXMucGF0aCA9IHdpbmNoYXJzLmRlY29kZSh0aGlzLnBhdGgucmVwbGFjZSgvXFxcXC9nLCAnLycpKVxuICAgICAgcCA9IHAucmVwbGFjZSgvXFxcXC9nLCAnLycpXG4gICAgfVxuXG4gICAgdGhpcy5hYnNvbHV0ZSA9IG5vcm1QYXRoKG9wdC5hYnNvbHV0ZSB8fCBwYXRoLnJlc29sdmUodGhpcy5jd2QsIHApKVxuXG4gICAgaWYgKHRoaXMucGF0aCA9PT0gJycpXG4gICAgICB0aGlzLnBhdGggPSAnLi8nXG5cbiAgICBpZiAodGhpcy5zdGF0Q2FjaGUuaGFzKHRoaXMuYWJzb2x1dGUpKVxuICAgICAgdGhpc1tPTkxTVEFUXSh0aGlzLnN0YXRDYWNoZS5nZXQodGhpcy5hYnNvbHV0ZSkpXG4gICAgZWxzZVxuICAgICAgdGhpc1tMU1RBVF0oKVxuICB9XG5cbiAgZW1pdCAoZXYsIC4uLmRhdGEpIHtcbiAgICBpZiAoZXYgPT09ICdlcnJvcicpXG4gICAgICB0aGlzW0hBRF9FUlJPUl0gPSB0cnVlXG4gICAgcmV0dXJuIHN1cGVyLmVtaXQoZXYsIC4uLmRhdGEpXG4gIH1cblxuICBbTFNUQVRdICgpIHtcbiAgICBmcy5sc3RhdCh0aGlzLmFic29sdXRlLCAoZXIsIHN0YXQpID0+IHtcbiAgICAgIGlmIChlcilcbiAgICAgICAgcmV0dXJuIHRoaXMuZW1pdCgnZXJyb3InLCBlcilcbiAgICAgIHRoaXNbT05MU1RBVF0oc3RhdClcbiAgICB9KVxuICB9XG5cbiAgW09OTFNUQVRdIChzdGF0KSB7XG4gICAgdGhpcy5zdGF0Q2FjaGUuc2V0KHRoaXMuYWJzb2x1dGUsIHN0YXQpXG4gICAgdGhpcy5zdGF0ID0gc3RhdFxuICAgIGlmICghc3RhdC5pc0ZpbGUoKSlcbiAgICAgIHN0YXQuc2l6ZSA9IDBcbiAgICB0aGlzLnR5cGUgPSBnZXRUeXBlKHN0YXQpXG4gICAgdGhpcy5lbWl0KCdzdGF0Jywgc3RhdClcbiAgICB0aGlzW1BST0NFU1NdKClcbiAgfVxuXG4gIFtQUk9DRVNTXSAoKSB7XG4gICAgc3dpdGNoICh0aGlzLnR5cGUpIHtcbiAgICAgIGNhc2UgJ0ZpbGUnOiByZXR1cm4gdGhpc1tGSUxFXSgpXG4gICAgICBjYXNlICdEaXJlY3RvcnknOiByZXR1cm4gdGhpc1tESVJFQ1RPUlldKClcbiAgICAgIGNhc2UgJ1N5bWJvbGljTGluayc6IHJldHVybiB0aGlzW1NZTUxJTktdKClcbiAgICAgIC8vIHVuc3VwcG9ydGVkIHR5cGVzIGFyZSBpZ25vcmVkLlxuICAgICAgZGVmYXVsdDogcmV0dXJuIHRoaXMuZW5kKClcbiAgICB9XG4gIH1cblxuICBbTU9ERV0gKG1vZGUpIHtcbiAgICByZXR1cm4gbW9kZUZpeChtb2RlLCB0aGlzLnR5cGUgPT09ICdEaXJlY3RvcnknKVxuICB9XG5cbiAgW1BSRUZJWF0gKHBhdGgpIHtcbiAgICByZXR1cm4gcHJlZml4UGF0aChwYXRoLCB0aGlzLnByZWZpeClcbiAgfVxuXG4gIFtIRUFERVJdICgpIHtcbiAgICBpZiAodGhpcy50eXBlID09PSAnRGlyZWN0b3J5JyAmJiB0aGlzLnBvcnRhYmxlKVxuICAgICAgdGhpcy5ub010aW1lID0gdHJ1ZVxuXG4gICAgdGhpcy5oZWFkZXIgPSBuZXcgSGVhZGVyKHtcbiAgICAgIHBhdGg6IHRoaXNbUFJFRklYXSh0aGlzLnBhdGgpLFxuICAgICAgLy8gb25seSBhcHBseSB0aGUgcHJlZml4IHRvIGhhcmQgbGlua3MuXG4gICAgICBsaW5rcGF0aDogdGhpcy50eXBlID09PSAnTGluaycgPyB0aGlzW1BSRUZJWF0odGhpcy5saW5rcGF0aClcbiAgICAgIDogdGhpcy5saW5rcGF0aCxcbiAgICAgIC8vIG9ubHkgdGhlIHBlcm1pc3Npb25zIGFuZCBzZXR1aWQvc2V0Z2lkL3N0aWNreSBiaXRmbGFnc1xuICAgICAgLy8gbm90IHRoZSBoaWdoZXItb3JkZXIgYml0cyB0aGF0IHNwZWNpZnkgZmlsZSB0eXBlXG4gICAgICBtb2RlOiB0aGlzW01PREVdKHRoaXMuc3RhdC5tb2RlKSxcbiAgICAgIHVpZDogdGhpcy5wb3J0YWJsZSA/IG51bGwgOiB0aGlzLnN0YXQudWlkLFxuICAgICAgZ2lkOiB0aGlzLnBvcnRhYmxlID8gbnVsbCA6IHRoaXMuc3RhdC5naWQsXG4gICAgICBzaXplOiB0aGlzLnN0YXQuc2l6ZSxcbiAgICAgIG10aW1lOiB0aGlzLm5vTXRpbWUgPyBudWxsIDogdGhpcy5tdGltZSB8fCB0aGlzLnN0YXQubXRpbWUsXG4gICAgICB0eXBlOiB0aGlzLnR5cGUsXG4gICAgICB1bmFtZTogdGhpcy5wb3J0YWJsZSA/IG51bGwgOlxuICAgICAgICB0aGlzLnN0YXQudWlkID09PSB0aGlzLm15dWlkID8gdGhpcy5teXVzZXIgOiAnJyxcbiAgICAgIGF0aW1lOiB0aGlzLnBvcnRhYmxlID8gbnVsbCA6IHRoaXMuc3RhdC5hdGltZSxcbiAgICAgIGN0aW1lOiB0aGlzLnBvcnRhYmxlID8gbnVsbCA6IHRoaXMuc3RhdC5jdGltZVxuICAgIH0pXG5cbiAgICBpZiAodGhpcy5oZWFkZXIuZW5jb2RlKCkgJiYgIXRoaXMubm9QYXgpIHtcbiAgICAgIHN1cGVyLndyaXRlKG5ldyBQYXgoe1xuICAgICAgICBhdGltZTogdGhpcy5wb3J0YWJsZSA/IG51bGwgOiB0aGlzLmhlYWRlci5hdGltZSxcbiAgICAgICAgY3RpbWU6IHRoaXMucG9ydGFibGUgPyBudWxsIDogdGhpcy5oZWFkZXIuY3RpbWUsXG4gICAgICAgIGdpZDogdGhpcy5wb3J0YWJsZSA/IG51bGwgOiB0aGlzLmhlYWRlci5naWQsXG4gICAgICAgIG10aW1lOiB0aGlzLm5vTXRpbWUgPyBudWxsIDogdGhpcy5tdGltZSB8fCB0aGlzLmhlYWRlci5tdGltZSxcbiAgICAgICAgcGF0aDogdGhpc1tQUkVGSVhdKHRoaXMucGF0aCksXG4gICAgICAgIGxpbmtwYXRoOiB0aGlzLnR5cGUgPT09ICdMaW5rJyA/IHRoaXNbUFJFRklYXSh0aGlzLmxpbmtwYXRoKVxuICAgICAgICA6IHRoaXMubGlua3BhdGgsXG4gICAgICAgIHNpemU6IHRoaXMuaGVhZGVyLnNpemUsXG4gICAgICAgIHVpZDogdGhpcy5wb3J0YWJsZSA/IG51bGwgOiB0aGlzLmhlYWRlci51aWQsXG4gICAgICAgIHVuYW1lOiB0aGlzLnBvcnRhYmxlID8gbnVsbCA6IHRoaXMuaGVhZGVyLnVuYW1lLFxuICAgICAgICBkZXY6IHRoaXMucG9ydGFibGUgPyBudWxsIDogdGhpcy5zdGF0LmRldixcbiAgICAgICAgaW5vOiB0aGlzLnBvcnRhYmxlID8gbnVsbCA6IHRoaXMuc3RhdC5pbm8sXG4gICAgICAgIG5saW5rOiB0aGlzLnBvcnRhYmxlID8gbnVsbCA6IHRoaXMuc3RhdC5ubGlua1xuICAgICAgfSkuZW5jb2RlKCkpXG4gICAgfVxuICAgIHN1cGVyLndyaXRlKHRoaXMuaGVhZGVyLmJsb2NrKVxuICB9XG5cbiAgW0RJUkVDVE9SWV0gKCkge1xuICAgIGlmICh0aGlzLnBhdGguc3Vic3RyKC0xKSAhPT0gJy8nKVxuICAgICAgdGhpcy5wYXRoICs9ICcvJ1xuICAgIHRoaXMuc3RhdC5zaXplID0gMFxuICAgIHRoaXNbSEVBREVSXSgpXG4gICAgdGhpcy5lbmQoKVxuICB9XG5cbiAgW1NZTUxJTktdICgpIHtcbiAgICBmcy5yZWFkbGluayh0aGlzLmFic29sdXRlLCAoZXIsIGxpbmtwYXRoKSA9PiB7XG4gICAgICBpZiAoZXIpXG4gICAgICAgIHJldHVybiB0aGlzLmVtaXQoJ2Vycm9yJywgZXIpXG4gICAgICB0aGlzW09OUkVBRExJTktdKGxpbmtwYXRoKVxuICAgIH0pXG4gIH1cblxuICBbT05SRUFETElOS10gKGxpbmtwYXRoKSB7XG4gICAgdGhpcy5saW5rcGF0aCA9IG5vcm1QYXRoKGxpbmtwYXRoKVxuICAgIHRoaXNbSEVBREVSXSgpXG4gICAgdGhpcy5lbmQoKVxuICB9XG5cbiAgW0hBUkRMSU5LXSAobGlua3BhdGgpIHtcbiAgICB0aGlzLnR5cGUgPSAnTGluaydcbiAgICB0aGlzLmxpbmtwYXRoID0gbm9ybVBhdGgocGF0aC5yZWxhdGl2ZSh0aGlzLmN3ZCwgbGlua3BhdGgpKVxuICAgIHRoaXMuc3RhdC5zaXplID0gMFxuICAgIHRoaXNbSEVBREVSXSgpXG4gICAgdGhpcy5lbmQoKVxuICB9XG5cbiAgW0ZJTEVdICgpIHtcbiAgICBpZiAodGhpcy5zdGF0Lm5saW5rID4gMSkge1xuICAgICAgY29uc3QgbGlua0tleSA9IHRoaXMuc3RhdC5kZXYgKyAnOicgKyB0aGlzLnN0YXQuaW5vXG4gICAgICBpZiAodGhpcy5saW5rQ2FjaGUuaGFzKGxpbmtLZXkpKSB7XG4gICAgICAgIGNvbnN0IGxpbmtwYXRoID0gdGhpcy5saW5rQ2FjaGUuZ2V0KGxpbmtLZXkpXG4gICAgICAgIGlmIChsaW5rcGF0aC5pbmRleE9mKHRoaXMuY3dkKSA9PT0gMClcbiAgICAgICAgICByZXR1cm4gdGhpc1tIQVJETElOS10obGlua3BhdGgpXG4gICAgICB9XG4gICAgICB0aGlzLmxpbmtDYWNoZS5zZXQobGlua0tleSwgdGhpcy5hYnNvbHV0ZSlcbiAgICB9XG5cbiAgICB0aGlzW0hFQURFUl0oKVxuICAgIGlmICh0aGlzLnN0YXQuc2l6ZSA9PT0gMClcbiAgICAgIHJldHVybiB0aGlzLmVuZCgpXG5cbiAgICB0aGlzW09QRU5GSUxFXSgpXG4gIH1cblxuICBbT1BFTkZJTEVdICgpIHtcbiAgICBmcy5vcGVuKHRoaXMuYWJzb2x1dGUsICdyJywgKGVyLCBmZCkgPT4ge1xuICAgICAgaWYgKGVyKVxuICAgICAgICByZXR1cm4gdGhpcy5lbWl0KCdlcnJvcicsIGVyKVxuICAgICAgdGhpc1tPTk9QRU5GSUxFXShmZClcbiAgICB9KVxuICB9XG5cbiAgW09OT1BFTkZJTEVdIChmZCkge1xuICAgIHRoaXMuZmQgPSBmZFxuICAgIGlmICh0aGlzW0hBRF9FUlJPUl0pXG4gICAgICByZXR1cm4gdGhpc1tDTE9TRV0oKVxuXG4gICAgdGhpcy5ibG9ja0xlbiA9IDUxMiAqIE1hdGguY2VpbCh0aGlzLnN0YXQuc2l6ZSAvIDUxMilcbiAgICB0aGlzLmJsb2NrUmVtYWluID0gdGhpcy5ibG9ja0xlblxuICAgIGNvbnN0IGJ1ZkxlbiA9IE1hdGgubWluKHRoaXMuYmxvY2tMZW4sIHRoaXMubWF4UmVhZFNpemUpXG4gICAgdGhpcy5idWYgPSBCdWZmZXIuYWxsb2NVbnNhZmUoYnVmTGVuKVxuICAgIHRoaXMub2Zmc2V0ID0gMFxuICAgIHRoaXMucG9zID0gMFxuICAgIHRoaXMucmVtYWluID0gdGhpcy5zdGF0LnNpemVcbiAgICB0aGlzLmxlbmd0aCA9IHRoaXMuYnVmLmxlbmd0aFxuICAgIHRoaXNbUkVBRF0oKVxuICB9XG5cbiAgW1JFQURdICgpIHtcbiAgICBjb25zdCB7IGZkLCBidWYsIG9mZnNldCwgbGVuZ3RoLCBwb3MgfSA9IHRoaXNcbiAgICBmcy5yZWFkKGZkLCBidWYsIG9mZnNldCwgbGVuZ3RoLCBwb3MsIChlciwgYnl0ZXNSZWFkKSA9PiB7XG4gICAgICBpZiAoZXIpIHtcbiAgICAgICAgLy8gaWdub3JpbmcgdGhlIGVycm9yIGZyb20gY2xvc2UoMikgaXMgYSBiYWQgcHJhY3RpY2UsIGJ1dCBhdFxuICAgICAgICAvLyB0aGlzIHBvaW50IHdlIGFscmVhZHkgaGF2ZSBhbiBlcnJvciwgZG9uJ3QgbmVlZCBhbm90aGVyIG9uZVxuICAgICAgICByZXR1cm4gdGhpc1tDTE9TRV0oKCkgPT4gdGhpcy5lbWl0KCdlcnJvcicsIGVyKSlcbiAgICAgIH1cbiAgICAgIHRoaXNbT05SRUFEXShieXRlc1JlYWQpXG4gICAgfSlcbiAgfVxuXG4gIFtDTE9TRV0gKGNiKSB7XG4gICAgZnMuY2xvc2UodGhpcy5mZCwgY2IpXG4gIH1cblxuICBbT05SRUFEXSAoYnl0ZXNSZWFkKSB7XG4gICAgaWYgKGJ5dGVzUmVhZCA8PSAwICYmIHRoaXMucmVtYWluID4gMCkge1xuICAgICAgY29uc3QgZXIgPSBuZXcgRXJyb3IoJ2VuY291bnRlcmVkIHVuZXhwZWN0ZWQgRU9GJylcbiAgICAgIGVyLnBhdGggPSB0aGlzLmFic29sdXRlXG4gICAgICBlci5zeXNjYWxsID0gJ3JlYWQnXG4gICAgICBlci5jb2RlID0gJ0VPRidcbiAgICAgIHJldHVybiB0aGlzW0NMT1NFXSgoKSA9PiB0aGlzLmVtaXQoJ2Vycm9yJywgZXIpKVxuICAgIH1cblxuICAgIGlmIChieXRlc1JlYWQgPiB0aGlzLnJlbWFpbikge1xuICAgICAgY29uc3QgZXIgPSBuZXcgRXJyb3IoJ2RpZCBub3QgZW5jb3VudGVyIGV4cGVjdGVkIEVPRicpXG4gICAgICBlci5wYXRoID0gdGhpcy5hYnNvbHV0ZVxuICAgICAgZXIuc3lzY2FsbCA9ICdyZWFkJ1xuICAgICAgZXIuY29kZSA9ICdFT0YnXG4gICAgICByZXR1cm4gdGhpc1tDTE9TRV0oKCkgPT4gdGhpcy5lbWl0KCdlcnJvcicsIGVyKSlcbiAgICB9XG5cbiAgICAvLyBudWxsIG91dCB0aGUgcmVzdCBvZiB0aGUgYnVmZmVyLCBpZiB3ZSBjb3VsZCBmaXQgdGhlIGJsb2NrIHBhZGRpbmdcbiAgICAvLyBhdCB0aGUgZW5kIG9mIHRoaXMgbG9vcCwgd2UndmUgaW5jcmVtZW50ZWQgYnl0ZXNSZWFkIGFuZCB0aGlzLnJlbWFpblxuICAgIC8vIHRvIGJlIGluY3JlbWVudGVkIHVwIHRvIHRoZSBibG9ja1JlbWFpbiBsZXZlbCwgYXMgaWYgd2UgaGFkIGV4cGVjdGVkXG4gICAgLy8gdG8gZ2V0IGEgbnVsbC1wYWRkZWQgZmlsZSwgYW5kIHJlYWQgaXQgdW50aWwgdGhlIGVuZC4gIHRoZW4gd2Ugd2lsbFxuICAgIC8vIGRlY3JlbWVudCBib3RoIHJlbWFpbiBhbmQgYmxvY2tSZW1haW4gYnkgYnl0ZXNSZWFkLCBhbmQga25vdyB0aGF0IHdlXG4gICAgLy8gcmVhY2hlZCB0aGUgZXhwZWN0ZWQgRU9GLCB3aXRob3V0IGFueSBudWxsIGJ1ZmZlciB0byBhcHBlbmQuXG4gICAgaWYgKGJ5dGVzUmVhZCA9PT0gdGhpcy5yZW1haW4pIHtcbiAgICAgIGZvciAobGV0IGkgPSBieXRlc1JlYWQ7IGkgPCB0aGlzLmxlbmd0aCAmJiBieXRlc1JlYWQgPCB0aGlzLmJsb2NrUmVtYWluOyBpKyspIHtcbiAgICAgICAgdGhpcy5idWZbaSArIHRoaXMub2Zmc2V0XSA9IDBcbiAgICAgICAgYnl0ZXNSZWFkKytcbiAgICAgICAgdGhpcy5yZW1haW4rK1xuICAgICAgfVxuICAgIH1cblxuICAgIGNvbnN0IHdyaXRlQnVmID0gdGhpcy5vZmZzZXQgPT09IDAgJiYgYnl0ZXNSZWFkID09PSB0aGlzLmJ1Zi5sZW5ndGggP1xuICAgICAgdGhpcy5idWYgOiB0aGlzLmJ1Zi5zbGljZSh0aGlzLm9mZnNldCwgdGhpcy5vZmZzZXQgKyBieXRlc1JlYWQpXG5cbiAgICBjb25zdCBmbHVzaGVkID0gdGhpcy53cml0ZSh3cml0ZUJ1ZilcbiAgICBpZiAoIWZsdXNoZWQpXG4gICAgICB0aGlzW0FXQUlURFJBSU5dKCgpID0+IHRoaXNbT05EUkFJTl0oKSlcbiAgICBlbHNlXG4gICAgICB0aGlzW09ORFJBSU5dKClcbiAgfVxuXG4gIFtBV0FJVERSQUlOXSAoY2IpIHtcbiAgICB0aGlzLm9uY2UoJ2RyYWluJywgY2IpXG4gIH1cblxuICB3cml0ZSAod3JpdGVCdWYpIHtcbiAgICBpZiAodGhpcy5ibG9ja1JlbWFpbiA8IHdyaXRlQnVmLmxlbmd0aCkge1xuICAgICAgY29uc3QgZXIgPSBuZXcgRXJyb3IoJ3dyaXRpbmcgbW9yZSBkYXRhIHRoYW4gZXhwZWN0ZWQnKVxuICAgICAgZXIucGF0aCA9IHRoaXMuYWJzb2x1dGVcbiAgICAgIHJldHVybiB0aGlzLmVtaXQoJ2Vycm9yJywgZXIpXG4gICAgfVxuICAgIHRoaXMucmVtYWluIC09IHdyaXRlQnVmLmxlbmd0aFxuICAgIHRoaXMuYmxvY2tSZW1haW4gLT0gd3JpdGVCdWYubGVuZ3RoXG4gICAgdGhpcy5wb3MgKz0gd3JpdGVCdWYubGVuZ3RoXG4gICAgdGhpcy5vZmZzZXQgKz0gd3JpdGVCdWYubGVuZ3RoXG4gICAgcmV0dXJuIHN1cGVyLndyaXRlKHdyaXRlQnVmKVxuICB9XG5cbiAgW09ORFJBSU5dICgpIHtcbiAgICBpZiAoIXRoaXMucmVtYWluKSB7XG4gICAgICBpZiAodGhpcy5ibG9ja1JlbWFpbilcbiAgICAgICAgc3VwZXIud3JpdGUoQnVmZmVyLmFsbG9jKHRoaXMuYmxvY2tSZW1haW4pKVxuICAgICAgcmV0dXJuIHRoaXNbQ0xPU0VdKC8qIGlzdGFuYnVsIGlnbm9yZSBuZXh0IC0gbGVnYWN5ICovXG4gICAgICAgIGVyID0+IGVyID8gdGhpcy5lbWl0KCdlcnJvcicsIGVyKSA6IHRoaXMuZW5kKCkpXG4gICAgfVxuXG4gICAgaWYgKHRoaXMub2Zmc2V0ID49IHRoaXMubGVuZ3RoKSB7XG4gICAgICAvLyBpZiB3ZSBvbmx5IGhhdmUgYSBzbWFsbGVyIGJpdCBsZWZ0IHRvIHJlYWQsIGFsbG9jIGEgc21hbGxlciBidWZmZXJcbiAgICAgIC8vIG90aGVyd2lzZSwga2VlcCBpdCB0aGUgc2FtZSBsZW5ndGggaXQgd2FzIGJlZm9yZS5cbiAgICAgIHRoaXMuYnVmID0gQnVmZmVyLmFsbG9jVW5zYWZlKE1hdGgubWluKHRoaXMuYmxvY2tSZW1haW4sIHRoaXMuYnVmLmxlbmd0aCkpXG4gICAgICB0aGlzLm9mZnNldCA9IDBcbiAgICB9XG4gICAgdGhpcy5sZW5ndGggPSB0aGlzLmJ1Zi5sZW5ndGggLSB0aGlzLm9mZnNldFxuICAgIHRoaXNbUkVBRF0oKVxuICB9XG59KVxuXG5jbGFzcyBXcml0ZUVudHJ5U3luYyBleHRlbmRzIFdyaXRlRW50cnkge1xuICBjb25zdHJ1Y3RvciAocGF0aCwgb3B0KSB7XG4gICAgc3VwZXIocGF0aCwgb3B0KVxuICB9XG5cbiAgW0xTVEFUXSAoKSB7XG4gICAgdGhpc1tPTkxTVEFUXShmcy5sc3RhdFN5bmModGhpcy5hYnNvbHV0ZSkpXG4gIH1cblxuICBbU1lNTElOS10gKCkge1xuICAgIHRoaXNbT05SRUFETElOS10oZnMucmVhZGxpbmtTeW5jKHRoaXMuYWJzb2x1dGUpKVxuICB9XG5cbiAgW09QRU5GSUxFXSAoKSB7XG4gICAgdGhpc1tPTk9QRU5GSUxFXShmcy5vcGVuU3luYyh0aGlzLmFic29sdXRlLCAncicpKVxuICB9XG5cbiAgW1JFQURdICgpIHtcbiAgICBsZXQgdGhyZXcgPSB0cnVlXG4gICAgdHJ5IHtcbiAgICAgIGNvbnN0IHsgZmQsIGJ1Ziwgb2Zmc2V0LCBsZW5ndGgsIHBvcyB9ID0gdGhpc1xuICAgICAgY29uc3QgYnl0ZXNSZWFkID0gZnMucmVhZFN5bmMoZmQsIGJ1Ziwgb2Zmc2V0LCBsZW5ndGgsIHBvcylcbiAgICAgIHRoaXNbT05SRUFEXShieXRlc1JlYWQpXG4gICAgICB0aHJldyA9IGZhbHNlXG4gICAgfSBmaW5hbGx5IHtcbiAgICAgIC8vIGlnbm9yaW5nIHRoZSBlcnJvciBmcm9tIGNsb3NlKDIpIGlzIGEgYmFkIHByYWN0aWNlLCBidXQgYXRcbiAgICAgIC8vIHRoaXMgcG9pbnQgd2UgYWxyZWFkeSBoYXZlIGFuIGVycm9yLCBkb24ndCBuZWVkIGFub3RoZXIgb25lXG4gICAgICBpZiAodGhyZXcpIHtcbiAgICAgICAgdHJ5IHtcbiAgICAgICAgICB0aGlzW0NMT1NFXSgoKSA9PiB7fSlcbiAgICAgICAgfSBjYXRjaCAoZXIpIHt9XG4gICAgICB9XG4gICAgfVxuICB9XG5cbiAgW0FXQUlURFJBSU5dIChjYikge1xuICAgIGNiKClcbiAgfVxuXG4gIFtDTE9TRV0gKGNiKSB7XG4gICAgZnMuY2xvc2VTeW5jKHRoaXMuZmQpXG4gICAgY2IoKVxuICB9XG59XG5cbmNvbnN0IFdyaXRlRW50cnlUYXIgPSB3YXJuZXIoY2xhc3MgV3JpdGVFbnRyeVRhciBleHRlbmRzIE1pbmlQYXNzIHtcbiAgY29uc3RydWN0b3IgKHJlYWRFbnRyeSwgb3B0KSB7XG4gICAgb3B0ID0gb3B0IHx8IHt9XG4gICAgc3VwZXIob3B0KVxuICAgIHRoaXMucHJlc2VydmVQYXRocyA9ICEhb3B0LnByZXNlcnZlUGF0aHNcbiAgICB0aGlzLnBvcnRhYmxlID0gISFvcHQucG9ydGFibGVcbiAgICB0aGlzLnN0cmljdCA9ICEhb3B0LnN0cmljdFxuICAgIHRoaXMubm9QYXggPSAhIW9wdC5ub1BheFxuICAgIHRoaXMubm9NdGltZSA9ICEhb3B0Lm5vTXRpbWVcblxuICAgIHRoaXMucmVhZEVudHJ5ID0gcmVhZEVudHJ5XG4gICAgdGhpcy50eXBlID0gcmVhZEVudHJ5LnR5cGVcbiAgICBpZiAodGhpcy50eXBlID09PSAnRGlyZWN0b3J5JyAmJiB0aGlzLnBvcnRhYmxlKVxuICAgICAgdGhpcy5ub010aW1lID0gdHJ1ZVxuXG4gICAgdGhpcy5wcmVmaXggPSBvcHQucHJlZml4IHx8IG51bGxcblxuICAgIHRoaXMucGF0aCA9IG5vcm1QYXRoKHJlYWRFbnRyeS5wYXRoKVxuICAgIHRoaXMubW9kZSA9IHRoaXNbTU9ERV0ocmVhZEVudHJ5Lm1vZGUpXG4gICAgdGhpcy51aWQgPSB0aGlzLnBvcnRhYmxlID8gbnVsbCA6IHJlYWRFbnRyeS51aWRcbiAgICB0aGlzLmdpZCA9IHRoaXMucG9ydGFibGUgPyBudWxsIDogcmVhZEVudHJ5LmdpZFxuICAgIHRoaXMudW5hbWUgPSB0aGlzLnBvcnRhYmxlID8gbnVsbCA6IHJlYWRFbnRyeS51bmFtZVxuICAgIHRoaXMuZ25hbWUgPSB0aGlzLnBvcnRhYmxlID8gbnVsbCA6IHJlYWRFbnRyeS5nbmFtZVxuICAgIHRoaXMuc2l6ZSA9IHJlYWRFbnRyeS5zaXplXG4gICAgdGhpcy5tdGltZSA9IHRoaXMubm9NdGltZSA/IG51bGwgOiBvcHQubXRpbWUgfHwgcmVhZEVudHJ5Lm10aW1lXG4gICAgdGhpcy5hdGltZSA9IHRoaXMucG9ydGFibGUgPyBudWxsIDogcmVhZEVudHJ5LmF0aW1lXG4gICAgdGhpcy5jdGltZSA9IHRoaXMucG9ydGFibGUgPyBudWxsIDogcmVhZEVudHJ5LmN0aW1lXG4gICAgdGhpcy5saW5rcGF0aCA9IG5vcm1QYXRoKHJlYWRFbnRyeS5saW5rcGF0aClcblxuICAgIGlmICh0eXBlb2Ygb3B0Lm9ud2FybiA9PT0gJ2Z1bmN0aW9uJylcbiAgICAgIHRoaXMub24oJ3dhcm4nLCBvcHQub253YXJuKVxuXG4gICAgaWYgKCF0aGlzLnByZXNlcnZlUGF0aHMpIHtcbiAgICAgIGNvbnN0IHMgPSBzdHJpcEFic29sdXRlUGF0aCh0aGlzLnBhdGgpXG4gICAgICBpZiAoc1swXSkge1xuICAgICAgICB0aGlzLndhcm4oXG4gICAgICAgICAgJ3N0cmlwcGluZyAnICsgc1swXSArICcgZnJvbSBhYnNvbHV0ZSBwYXRoJyxcbiAgICAgICAgICB0aGlzLnBhdGhcbiAgICAgICAgKVxuICAgICAgICB0aGlzLnBhdGggPSBzWzFdXG4gICAgICB9XG4gICAgfVxuXG4gICAgdGhpcy5yZW1haW4gPSByZWFkRW50cnkuc2l6ZVxuICAgIHRoaXMuYmxvY2tSZW1haW4gPSByZWFkRW50cnkuc3RhcnRCbG9ja1NpemVcblxuICAgIHRoaXMuaGVhZGVyID0gbmV3IEhlYWRlcih7XG4gICAgICBwYXRoOiB0aGlzW1BSRUZJWF0odGhpcy5wYXRoKSxcbiAgICAgIGxpbmtwYXRoOiB0aGlzLnR5cGUgPT09ICdMaW5rJyA/IHRoaXNbUFJFRklYXSh0aGlzLmxpbmtwYXRoKVxuICAgICAgOiB0aGlzLmxpbmtwYXRoLFxuICAgICAgLy8gb25seSB0aGUgcGVybWlzc2lvbnMgYW5kIHNldHVpZC9zZXRnaWQvc3RpY2t5IGJpdGZsYWdzXG4gICAgICAvLyBub3QgdGhlIGhpZ2hlci1vcmRlciBiaXRzIHRoYXQgc3BlY2lmeSBmaWxlIHR5cGVcbiAgICAgIG1vZGU6IHRoaXMubW9kZSxcbiAgICAgIHVpZDogdGhpcy5wb3J0YWJsZSA/IG51bGwgOiB0aGlzLnVpZCxcbiAgICAgIGdpZDogdGhpcy5wb3J0YWJsZSA/IG51bGwgOiB0aGlzLmdpZCxcbiAgICAgIHNpemU6IHRoaXMuc2l6ZSxcbiAgICAgIG10aW1lOiB0aGlzLm5vTXRpbWUgPyBudWxsIDogdGhpcy5tdGltZSxcbiAgICAgIHR5cGU6IHRoaXMudHlwZSxcbiAgICAgIHVuYW1lOiB0aGlzLnBvcnRhYmxlID8gbnVsbCA6IHRoaXMudW5hbWUsXG4gICAgICBhdGltZTogdGhpcy5wb3J0YWJsZSA/IG51bGwgOiB0aGlzLmF0aW1lLFxuICAgICAgY3RpbWU6IHRoaXMucG9ydGFibGUgPyBudWxsIDogdGhpcy5jdGltZVxuICAgIH0pXG5cbiAgICBpZiAodGhpcy5oZWFkZXIuZW5jb2RlKCkgJiYgIXRoaXMubm9QYXgpXG4gICAgICBzdXBlci53cml0ZShuZXcgUGF4KHtcbiAgICAgICAgYXRpbWU6IHRoaXMucG9ydGFibGUgPyBudWxsIDogdGhpcy5hdGltZSxcbiAgICAgICAgY3RpbWU6IHRoaXMucG9ydGFibGUgPyBudWxsIDogdGhpcy5jdGltZSxcbiAgICAgICAgZ2lkOiB0aGlzLnBvcnRhYmxlID8gbnVsbCA6IHRoaXMuZ2lkLFxuICAgICAgICBtdGltZTogdGhpcy5ub010aW1lID8gbnVsbCA6IHRoaXMubXRpbWUsXG4gICAgICAgIHBhdGg6IHRoaXNbUFJFRklYXSh0aGlzLnBhdGgpLFxuICAgICAgICBsaW5rcGF0aDogdGhpcy50eXBlID09PSAnTGluaycgPyB0aGlzW1BSRUZJWF0odGhpcy5saW5rcGF0aClcbiAgICAgICAgOiB0aGlzLmxpbmtwYXRoLFxuICAgICAgICBzaXplOiB0aGlzLnNpemUsXG4gICAgICAgIHVpZDogdGhpcy5wb3J0YWJsZSA/IG51bGwgOiB0aGlzLnVpZCxcbiAgICAgICAgdW5hbWU6IHRoaXMucG9ydGFibGUgPyBudWxsIDogdGhpcy51bmFtZSxcbiAgICAgICAgZGV2OiB0aGlzLnBvcnRhYmxlID8gbnVsbCA6IHRoaXMucmVhZEVudHJ5LmRldixcbiAgICAgICAgaW5vOiB0aGlzLnBvcnRhYmxlID8gbnVsbCA6IHRoaXMucmVhZEVudHJ5LmlubyxcbiAgICAgICAgbmxpbms6IHRoaXMucG9ydGFibGUgPyBudWxsIDogdGhpcy5yZWFkRW50cnkubmxpbmtcbiAgICAgIH0pLmVuY29kZSgpKVxuXG4gICAgc3VwZXIud3JpdGUodGhpcy5oZWFkZXIuYmxvY2spXG4gICAgcmVhZEVudHJ5LnBpcGUodGhpcylcbiAgfVxuXG4gIFtQUkVGSVhdIChwYXRoKSB7XG4gICAgcmV0dXJuIHByZWZpeFBhdGgocGF0aCwgdGhpcy5wcmVmaXgpXG4gIH1cblxuICBbTU9ERV0gKG1vZGUpIHtcbiAgICByZXR1cm4gbW9kZUZpeChtb2RlLCB0aGlzLnR5cGUgPT09ICdEaXJlY3RvcnknKVxuICB9XG5cbiAgd3JpdGUgKGRhdGEpIHtcbiAgICBjb25zdCB3cml0ZUxlbiA9IGRhdGEubGVuZ3RoXG4gICAgaWYgKHdyaXRlTGVuID4gdGhpcy5ibG9ja1JlbWFpbilcbiAgICAgIHRocm93IG5ldyBFcnJvcignd3JpdGluZyBtb3JlIHRvIGVudHJ5IHRoYW4gaXMgYXBwcm9wcmlhdGUnKVxuICAgIHRoaXMuYmxvY2tSZW1haW4gLT0gd3JpdGVMZW5cbiAgICByZXR1cm4gc3VwZXIud3JpdGUoZGF0YSlcbiAgfVxuXG4gIGVuZCAoKSB7XG4gICAgaWYgKHRoaXMuYmxvY2tSZW1haW4pXG4gICAgICBzdXBlci53cml0ZShCdWZmZXIuYWxsb2ModGhpcy5ibG9ja1JlbWFpbikpXG4gICAgcmV0dXJuIHN1cGVyLmVuZCgpXG4gIH1cbn0pXG5cbldyaXRlRW50cnkuU3luYyA9IFdyaXRlRW50cnlTeW5jXG5Xcml0ZUVudHJ5LlRhciA9IFdyaXRlRW50cnlUYXJcblxuY29uc3QgZ2V0VHlwZSA9IHN0YXQgPT5cbiAgc3RhdC5pc0ZpbGUoKSA/ICdGaWxlJ1xuICA6IHN0YXQuaXNEaXJlY3RvcnkoKSA/ICdEaXJlY3RvcnknXG4gIDogc3RhdC5pc1N5bWJvbGljTGluaygpID8gJ1N5bWJvbGljTGluaydcbiAgOiAnVW5zdXBwb3J0ZWQnXG5cbm1vZHVsZS5leHBvcnRzID0gV3JpdGVFbnRyeVxuIl0sIm5hbWVzIjpbXSwiaWdub3JlTGlzdCI6WzBdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/swarm-js/node_modules/tar/lib/write-entry.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/swarm-js/node_modules/yallist/iterator.js":
/*!****************************************************************!*\
  !*** ./node_modules/swarm-js/node_modules/yallist/iterator.js ***!
  \****************************************************************/
/***/ ((module) => {

"use strict";
eval("\nmodule.exports = function (Yallist) {\n  Yallist.prototype[Symbol.iterator] = function* () {\n    for (let walker = this.head; walker; walker = walker.next) {\n      yield walker.value\n    }\n  }\n}\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvc3dhcm0tanMvbm9kZV9tb2R1bGVzL3lhbGxpc3QvaXRlcmF0b3IuanMiLCJtYXBwaW5ncyI6IkFBQVk7QUFDWjtBQUNBO0FBQ0EsaUNBQWlDLFFBQVE7QUFDekM7QUFDQTtBQUNBO0FBQ0EiLCJzb3VyY2VzIjpbIi9Vc2Vycy9wYW56YS9Eb2N1bWVudHMvUGVyc29uYWxQcm9qZWN0cy9wcmVkaWsvbm9kZV9tb2R1bGVzL3N3YXJtLWpzL25vZGVfbW9kdWxlcy95YWxsaXN0L2l0ZXJhdG9yLmpzIl0sInNvdXJjZXNDb250ZW50IjpbIid1c2Ugc3RyaWN0J1xubW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbiAoWWFsbGlzdCkge1xuICBZYWxsaXN0LnByb3RvdHlwZVtTeW1ib2wuaXRlcmF0b3JdID0gZnVuY3Rpb24qICgpIHtcbiAgICBmb3IgKGxldCB3YWxrZXIgPSB0aGlzLmhlYWQ7IHdhbGtlcjsgd2Fsa2VyID0gd2Fsa2VyLm5leHQpIHtcbiAgICAgIHlpZWxkIHdhbGtlci52YWx1ZVxuICAgIH1cbiAgfVxufVxuIl0sIm5hbWVzIjpbXSwiaWdub3JlTGlzdCI6WzBdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/swarm-js/node_modules/yallist/iterator.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/swarm-js/node_modules/yallist/yallist.js":
/*!***************************************************************!*\
  !*** ./node_modules/swarm-js/node_modules/yallist/yallist.js ***!
  \***************************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";
eval("\nmodule.exports = Yallist\n\nYallist.Node = Node\nYallist.create = Yallist\n\nfunction Yallist (list) {\n  var self = this\n  if (!(self instanceof Yallist)) {\n    self = new Yallist()\n  }\n\n  self.tail = null\n  self.head = null\n  self.length = 0\n\n  if (list && typeof list.forEach === 'function') {\n    list.forEach(function (item) {\n      self.push(item)\n    })\n  } else if (arguments.length > 0) {\n    for (var i = 0, l = arguments.length; i < l; i++) {\n      self.push(arguments[i])\n    }\n  }\n\n  return self\n}\n\nYallist.prototype.removeNode = function (node) {\n  if (node.list !== this) {\n    throw new Error('removing node which does not belong to this list')\n  }\n\n  var next = node.next\n  var prev = node.prev\n\n  if (next) {\n    next.prev = prev\n  }\n\n  if (prev) {\n    prev.next = next\n  }\n\n  if (node === this.head) {\n    this.head = next\n  }\n  if (node === this.tail) {\n    this.tail = prev\n  }\n\n  node.list.length--\n  node.next = null\n  node.prev = null\n  node.list = null\n\n  return next\n}\n\nYallist.prototype.unshiftNode = function (node) {\n  if (node === this.head) {\n    return\n  }\n\n  if (node.list) {\n    node.list.removeNode(node)\n  }\n\n  var head = this.head\n  node.list = this\n  node.next = head\n  if (head) {\n    head.prev = node\n  }\n\n  this.head = node\n  if (!this.tail) {\n    this.tail = node\n  }\n  this.length++\n}\n\nYallist.prototype.pushNode = function (node) {\n  if (node === this.tail) {\n    return\n  }\n\n  if (node.list) {\n    node.list.removeNode(node)\n  }\n\n  var tail = this.tail\n  node.list = this\n  node.prev = tail\n  if (tail) {\n    tail.next = node\n  }\n\n  this.tail = node\n  if (!this.head) {\n    this.head = node\n  }\n  this.length++\n}\n\nYallist.prototype.push = function () {\n  for (var i = 0, l = arguments.length; i < l; i++) {\n    push(this, arguments[i])\n  }\n  return this.length\n}\n\nYallist.prototype.unshift = function () {\n  for (var i = 0, l = arguments.length; i < l; i++) {\n    unshift(this, arguments[i])\n  }\n  return this.length\n}\n\nYallist.prototype.pop = function () {\n  if (!this.tail) {\n    return undefined\n  }\n\n  var res = this.tail.value\n  this.tail = this.tail.prev\n  if (this.tail) {\n    this.tail.next = null\n  } else {\n    this.head = null\n  }\n  this.length--\n  return res\n}\n\nYallist.prototype.shift = function () {\n  if (!this.head) {\n    return undefined\n  }\n\n  var res = this.head.value\n  this.head = this.head.next\n  if (this.head) {\n    this.head.prev = null\n  } else {\n    this.tail = null\n  }\n  this.length--\n  return res\n}\n\nYallist.prototype.forEach = function (fn, thisp) {\n  thisp = thisp || this\n  for (var walker = this.head, i = 0; walker !== null; i++) {\n    fn.call(thisp, walker.value, i, this)\n    walker = walker.next\n  }\n}\n\nYallist.prototype.forEachReverse = function (fn, thisp) {\n  thisp = thisp || this\n  for (var walker = this.tail, i = this.length - 1; walker !== null; i--) {\n    fn.call(thisp, walker.value, i, this)\n    walker = walker.prev\n  }\n}\n\nYallist.prototype.get = function (n) {\n  for (var i = 0, walker = this.head; walker !== null && i < n; i++) {\n    // abort out of the list early if we hit a cycle\n    walker = walker.next\n  }\n  if (i === n && walker !== null) {\n    return walker.value\n  }\n}\n\nYallist.prototype.getReverse = function (n) {\n  for (var i = 0, walker = this.tail; walker !== null && i < n; i++) {\n    // abort out of the list early if we hit a cycle\n    walker = walker.prev\n  }\n  if (i === n && walker !== null) {\n    return walker.value\n  }\n}\n\nYallist.prototype.map = function (fn, thisp) {\n  thisp = thisp || this\n  var res = new Yallist()\n  for (var walker = this.head; walker !== null;) {\n    res.push(fn.call(thisp, walker.value, this))\n    walker = walker.next\n  }\n  return res\n}\n\nYallist.prototype.mapReverse = function (fn, thisp) {\n  thisp = thisp || this\n  var res = new Yallist()\n  for (var walker = this.tail; walker !== null;) {\n    res.push(fn.call(thisp, walker.value, this))\n    walker = walker.prev\n  }\n  return res\n}\n\nYallist.prototype.reduce = function (fn, initial) {\n  var acc\n  var walker = this.head\n  if (arguments.length > 1) {\n    acc = initial\n  } else if (this.head) {\n    walker = this.head.next\n    acc = this.head.value\n  } else {\n    throw new TypeError('Reduce of empty list with no initial value')\n  }\n\n  for (var i = 0; walker !== null; i++) {\n    acc = fn(acc, walker.value, i)\n    walker = walker.next\n  }\n\n  return acc\n}\n\nYallist.prototype.reduceReverse = function (fn, initial) {\n  var acc\n  var walker = this.tail\n  if (arguments.length > 1) {\n    acc = initial\n  } else if (this.tail) {\n    walker = this.tail.prev\n    acc = this.tail.value\n  } else {\n    throw new TypeError('Reduce of empty list with no initial value')\n  }\n\n  for (var i = this.length - 1; walker !== null; i--) {\n    acc = fn(acc, walker.value, i)\n    walker = walker.prev\n  }\n\n  return acc\n}\n\nYallist.prototype.toArray = function () {\n  var arr = new Array(this.length)\n  for (var i = 0, walker = this.head; walker !== null; i++) {\n    arr[i] = walker.value\n    walker = walker.next\n  }\n  return arr\n}\n\nYallist.prototype.toArrayReverse = function () {\n  var arr = new Array(this.length)\n  for (var i = 0, walker = this.tail; walker !== null; i++) {\n    arr[i] = walker.value\n    walker = walker.prev\n  }\n  return arr\n}\n\nYallist.prototype.slice = function (from, to) {\n  to = to || this.length\n  if (to < 0) {\n    to += this.length\n  }\n  from = from || 0\n  if (from < 0) {\n    from += this.length\n  }\n  var ret = new Yallist()\n  if (to < from || to < 0) {\n    return ret\n  }\n  if (from < 0) {\n    from = 0\n  }\n  if (to > this.length) {\n    to = this.length\n  }\n  for (var i = 0, walker = this.head; walker !== null && i < from; i++) {\n    walker = walker.next\n  }\n  for (; walker !== null && i < to; i++, walker = walker.next) {\n    ret.push(walker.value)\n  }\n  return ret\n}\n\nYallist.prototype.sliceReverse = function (from, to) {\n  to = to || this.length\n  if (to < 0) {\n    to += this.length\n  }\n  from = from || 0\n  if (from < 0) {\n    from += this.length\n  }\n  var ret = new Yallist()\n  if (to < from || to < 0) {\n    return ret\n  }\n  if (from < 0) {\n    from = 0\n  }\n  if (to > this.length) {\n    to = this.length\n  }\n  for (var i = this.length, walker = this.tail; walker !== null && i > to; i--) {\n    walker = walker.prev\n  }\n  for (; walker !== null && i > from; i--, walker = walker.prev) {\n    ret.push(walker.value)\n  }\n  return ret\n}\n\nYallist.prototype.splice = function (start, deleteCount /*, ...nodes */) {\n  if (start > this.length) {\n    start = this.length - 1\n  }\n  if (start < 0) {\n    start = this.length + start;\n  }\n\n  for (var i = 0, walker = this.head; walker !== null && i < start; i++) {\n    walker = walker.next\n  }\n\n  var ret = []\n  for (var i = 0; walker && i < deleteCount; i++) {\n    ret.push(walker.value)\n    walker = this.removeNode(walker)\n  }\n  if (walker === null) {\n    walker = this.tail\n  }\n\n  if (walker !== this.head && walker !== this.tail) {\n    walker = walker.prev\n  }\n\n  for (var i = 2; i < arguments.length; i++) {\n    walker = insert(this, walker, arguments[i])\n  }\n  return ret;\n}\n\nYallist.prototype.reverse = function () {\n  var head = this.head\n  var tail = this.tail\n  for (var walker = head; walker !== null; walker = walker.prev) {\n    var p = walker.prev\n    walker.prev = walker.next\n    walker.next = p\n  }\n  this.head = tail\n  this.tail = head\n  return this\n}\n\nfunction insert (self, node, value) {\n  var inserted = node === self.head ?\n    new Node(value, null, node, self) :\n    new Node(value, node, node.next, self)\n\n  if (inserted.next === null) {\n    self.tail = inserted\n  }\n  if (inserted.prev === null) {\n    self.head = inserted\n  }\n\n  self.length++\n\n  return inserted\n}\n\nfunction push (self, item) {\n  self.tail = new Node(item, self.tail, null, self)\n  if (!self.head) {\n    self.head = self.tail\n  }\n  self.length++\n}\n\nfunction unshift (self, item) {\n  self.head = new Node(item, null, self.head, self)\n  if (!self.tail) {\n    self.tail = self.head\n  }\n  self.length++\n}\n\nfunction Node (value, prev, next, list) {\n  if (!(this instanceof Node)) {\n    return new Node(value, prev, next, list)\n  }\n\n  this.list = list\n  this.value = value\n\n  if (prev) {\n    prev.next = this\n    this.prev = prev\n  } else {\n    this.prev = null\n  }\n\n  if (next) {\n    next.prev = this\n    this.next = next\n  } else {\n    this.next = null\n  }\n}\n\ntry {\n  // add if support for Symbol.iterator is present\n  __webpack_require__(/*! ./iterator.js */ \"(ssr)/./node_modules/swarm-js/node_modules/yallist/iterator.js\")(Yallist)\n} catch (er) {}\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvc3dhcm0tanMvbm9kZV9tb2R1bGVzL3lhbGxpc3QveWFsbGlzdC5qcyIsIm1hcHBpbmdzIjoiQUFBWTtBQUNaOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMLElBQUk7QUFDSiwwQ0FBMEMsT0FBTztBQUNqRDtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSx3Q0FBd0MsT0FBTztBQUMvQztBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLHdDQUF3QyxPQUFPO0FBQy9DO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsSUFBSTtBQUNKO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxJQUFJO0FBQ0o7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0Esc0NBQXNDLGlCQUFpQjtBQUN2RDtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0Esb0RBQW9ELGlCQUFpQjtBQUNyRTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLHNDQUFzQywwQkFBMEI7QUFDaEU7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxzQ0FBc0MsMEJBQTBCO0FBQ2hFO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLCtCQUErQixnQkFBZ0I7QUFDL0M7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSwrQkFBK0IsZ0JBQWdCO0FBQy9DO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLElBQUk7QUFDSjtBQUNBO0FBQ0EsSUFBSTtBQUNKO0FBQ0E7O0FBRUEsa0JBQWtCLGlCQUFpQjtBQUNuQztBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsSUFBSTtBQUNKO0FBQ0E7QUFDQSxJQUFJO0FBQ0o7QUFDQTs7QUFFQSxnQ0FBZ0MsaUJBQWlCO0FBQ2pEO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxzQ0FBc0MsaUJBQWlCO0FBQ3ZEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLHNDQUFzQyxpQkFBaUI7QUFDdkQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHNDQUFzQyw2QkFBNkI7QUFDbkU7QUFDQTtBQUNBLFNBQVMsMkJBQTJCO0FBQ3BDO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZ0RBQWdELDJCQUEyQjtBQUMzRTtBQUNBO0FBQ0EsU0FBUyw2QkFBNkI7QUFDdEM7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUEsc0NBQXNDLDhCQUE4QjtBQUNwRTtBQUNBOztBQUVBO0FBQ0Esa0JBQWtCLDJCQUEyQjtBQUM3QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBLGtCQUFrQixzQkFBc0I7QUFDeEM7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsMEJBQTBCLGlCQUFpQjtBQUMzQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsSUFBSTtBQUNKO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsSUFBSTtBQUNKO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsRUFBRSxtQkFBTyxDQUFDLHFGQUFlO0FBQ3pCLEVBQUUiLCJzb3VyY2VzIjpbIi9Vc2Vycy9wYW56YS9Eb2N1bWVudHMvUGVyc29uYWxQcm9qZWN0cy9wcmVkaWsvbm9kZV9tb2R1bGVzL3N3YXJtLWpzL25vZGVfbW9kdWxlcy95YWxsaXN0L3lhbGxpc3QuanMiXSwic291cmNlc0NvbnRlbnQiOlsiJ3VzZSBzdHJpY3QnXG5tb2R1bGUuZXhwb3J0cyA9IFlhbGxpc3RcblxuWWFsbGlzdC5Ob2RlID0gTm9kZVxuWWFsbGlzdC5jcmVhdGUgPSBZYWxsaXN0XG5cbmZ1bmN0aW9uIFlhbGxpc3QgKGxpc3QpIHtcbiAgdmFyIHNlbGYgPSB0aGlzXG4gIGlmICghKHNlbGYgaW5zdGFuY2VvZiBZYWxsaXN0KSkge1xuICAgIHNlbGYgPSBuZXcgWWFsbGlzdCgpXG4gIH1cblxuICBzZWxmLnRhaWwgPSBudWxsXG4gIHNlbGYuaGVhZCA9IG51bGxcbiAgc2VsZi5sZW5ndGggPSAwXG5cbiAgaWYgKGxpc3QgJiYgdHlwZW9mIGxpc3QuZm9yRWFjaCA9PT0gJ2Z1bmN0aW9uJykge1xuICAgIGxpc3QuZm9yRWFjaChmdW5jdGlvbiAoaXRlbSkge1xuICAgICAgc2VsZi5wdXNoKGl0ZW0pXG4gICAgfSlcbiAgfSBlbHNlIGlmIChhcmd1bWVudHMubGVuZ3RoID4gMCkge1xuICAgIGZvciAodmFyIGkgPSAwLCBsID0gYXJndW1lbnRzLmxlbmd0aDsgaSA8IGw7IGkrKykge1xuICAgICAgc2VsZi5wdXNoKGFyZ3VtZW50c1tpXSlcbiAgICB9XG4gIH1cblxuICByZXR1cm4gc2VsZlxufVxuXG5ZYWxsaXN0LnByb3RvdHlwZS5yZW1vdmVOb2RlID0gZnVuY3Rpb24gKG5vZGUpIHtcbiAgaWYgKG5vZGUubGlzdCAhPT0gdGhpcykge1xuICAgIHRocm93IG5ldyBFcnJvcigncmVtb3Zpbmcgbm9kZSB3aGljaCBkb2VzIG5vdCBiZWxvbmcgdG8gdGhpcyBsaXN0JylcbiAgfVxuXG4gIHZhciBuZXh0ID0gbm9kZS5uZXh0XG4gIHZhciBwcmV2ID0gbm9kZS5wcmV2XG5cbiAgaWYgKG5leHQpIHtcbiAgICBuZXh0LnByZXYgPSBwcmV2XG4gIH1cblxuICBpZiAocHJldikge1xuICAgIHByZXYubmV4dCA9IG5leHRcbiAgfVxuXG4gIGlmIChub2RlID09PSB0aGlzLmhlYWQpIHtcbiAgICB0aGlzLmhlYWQgPSBuZXh0XG4gIH1cbiAgaWYgKG5vZGUgPT09IHRoaXMudGFpbCkge1xuICAgIHRoaXMudGFpbCA9IHByZXZcbiAgfVxuXG4gIG5vZGUubGlzdC5sZW5ndGgtLVxuICBub2RlLm5leHQgPSBudWxsXG4gIG5vZGUucHJldiA9IG51bGxcbiAgbm9kZS5saXN0ID0gbnVsbFxuXG4gIHJldHVybiBuZXh0XG59XG5cbllhbGxpc3QucHJvdG90eXBlLnVuc2hpZnROb2RlID0gZnVuY3Rpb24gKG5vZGUpIHtcbiAgaWYgKG5vZGUgPT09IHRoaXMuaGVhZCkge1xuICAgIHJldHVyblxuICB9XG5cbiAgaWYgKG5vZGUubGlzdCkge1xuICAgIG5vZGUubGlzdC5yZW1vdmVOb2RlKG5vZGUpXG4gIH1cblxuICB2YXIgaGVhZCA9IHRoaXMuaGVhZFxuICBub2RlLmxpc3QgPSB0aGlzXG4gIG5vZGUubmV4dCA9IGhlYWRcbiAgaWYgKGhlYWQpIHtcbiAgICBoZWFkLnByZXYgPSBub2RlXG4gIH1cblxuICB0aGlzLmhlYWQgPSBub2RlXG4gIGlmICghdGhpcy50YWlsKSB7XG4gICAgdGhpcy50YWlsID0gbm9kZVxuICB9XG4gIHRoaXMubGVuZ3RoKytcbn1cblxuWWFsbGlzdC5wcm90b3R5cGUucHVzaE5vZGUgPSBmdW5jdGlvbiAobm9kZSkge1xuICBpZiAobm9kZSA9PT0gdGhpcy50YWlsKSB7XG4gICAgcmV0dXJuXG4gIH1cblxuICBpZiAobm9kZS5saXN0KSB7XG4gICAgbm9kZS5saXN0LnJlbW92ZU5vZGUobm9kZSlcbiAgfVxuXG4gIHZhciB0YWlsID0gdGhpcy50YWlsXG4gIG5vZGUubGlzdCA9IHRoaXNcbiAgbm9kZS5wcmV2ID0gdGFpbFxuICBpZiAodGFpbCkge1xuICAgIHRhaWwubmV4dCA9IG5vZGVcbiAgfVxuXG4gIHRoaXMudGFpbCA9IG5vZGVcbiAgaWYgKCF0aGlzLmhlYWQpIHtcbiAgICB0aGlzLmhlYWQgPSBub2RlXG4gIH1cbiAgdGhpcy5sZW5ndGgrK1xufVxuXG5ZYWxsaXN0LnByb3RvdHlwZS5wdXNoID0gZnVuY3Rpb24gKCkge1xuICBmb3IgKHZhciBpID0gMCwgbCA9IGFyZ3VtZW50cy5sZW5ndGg7IGkgPCBsOyBpKyspIHtcbiAgICBwdXNoKHRoaXMsIGFyZ3VtZW50c1tpXSlcbiAgfVxuICByZXR1cm4gdGhpcy5sZW5ndGhcbn1cblxuWWFsbGlzdC5wcm90b3R5cGUudW5zaGlmdCA9IGZ1bmN0aW9uICgpIHtcbiAgZm9yICh2YXIgaSA9IDAsIGwgPSBhcmd1bWVudHMubGVuZ3RoOyBpIDwgbDsgaSsrKSB7XG4gICAgdW5zaGlmdCh0aGlzLCBhcmd1bWVudHNbaV0pXG4gIH1cbiAgcmV0dXJuIHRoaXMubGVuZ3RoXG59XG5cbllhbGxpc3QucHJvdG90eXBlLnBvcCA9IGZ1bmN0aW9uICgpIHtcbiAgaWYgKCF0aGlzLnRhaWwpIHtcbiAgICByZXR1cm4gdW5kZWZpbmVkXG4gIH1cblxuICB2YXIgcmVzID0gdGhpcy50YWlsLnZhbHVlXG4gIHRoaXMudGFpbCA9IHRoaXMudGFpbC5wcmV2XG4gIGlmICh0aGlzLnRhaWwpIHtcbiAgICB0aGlzLnRhaWwubmV4dCA9IG51bGxcbiAgfSBlbHNlIHtcbiAgICB0aGlzLmhlYWQgPSBudWxsXG4gIH1cbiAgdGhpcy5sZW5ndGgtLVxuICByZXR1cm4gcmVzXG59XG5cbllhbGxpc3QucHJvdG90eXBlLnNoaWZ0ID0gZnVuY3Rpb24gKCkge1xuICBpZiAoIXRoaXMuaGVhZCkge1xuICAgIHJldHVybiB1bmRlZmluZWRcbiAgfVxuXG4gIHZhciByZXMgPSB0aGlzLmhlYWQudmFsdWVcbiAgdGhpcy5oZWFkID0gdGhpcy5oZWFkLm5leHRcbiAgaWYgKHRoaXMuaGVhZCkge1xuICAgIHRoaXMuaGVhZC5wcmV2ID0gbnVsbFxuICB9IGVsc2Uge1xuICAgIHRoaXMudGFpbCA9IG51bGxcbiAgfVxuICB0aGlzLmxlbmd0aC0tXG4gIHJldHVybiByZXNcbn1cblxuWWFsbGlzdC5wcm90b3R5cGUuZm9yRWFjaCA9IGZ1bmN0aW9uIChmbiwgdGhpc3ApIHtcbiAgdGhpc3AgPSB0aGlzcCB8fCB0aGlzXG4gIGZvciAodmFyIHdhbGtlciA9IHRoaXMuaGVhZCwgaSA9IDA7IHdhbGtlciAhPT0gbnVsbDsgaSsrKSB7XG4gICAgZm4uY2FsbCh0aGlzcCwgd2Fsa2VyLnZhbHVlLCBpLCB0aGlzKVxuICAgIHdhbGtlciA9IHdhbGtlci5uZXh0XG4gIH1cbn1cblxuWWFsbGlzdC5wcm90b3R5cGUuZm9yRWFjaFJldmVyc2UgPSBmdW5jdGlvbiAoZm4sIHRoaXNwKSB7XG4gIHRoaXNwID0gdGhpc3AgfHwgdGhpc1xuICBmb3IgKHZhciB3YWxrZXIgPSB0aGlzLnRhaWwsIGkgPSB0aGlzLmxlbmd0aCAtIDE7IHdhbGtlciAhPT0gbnVsbDsgaS0tKSB7XG4gICAgZm4uY2FsbCh0aGlzcCwgd2Fsa2VyLnZhbHVlLCBpLCB0aGlzKVxuICAgIHdhbGtlciA9IHdhbGtlci5wcmV2XG4gIH1cbn1cblxuWWFsbGlzdC5wcm90b3R5cGUuZ2V0ID0gZnVuY3Rpb24gKG4pIHtcbiAgZm9yICh2YXIgaSA9IDAsIHdhbGtlciA9IHRoaXMuaGVhZDsgd2Fsa2VyICE9PSBudWxsICYmIGkgPCBuOyBpKyspIHtcbiAgICAvLyBhYm9ydCBvdXQgb2YgdGhlIGxpc3QgZWFybHkgaWYgd2UgaGl0IGEgY3ljbGVcbiAgICB3YWxrZXIgPSB3YWxrZXIubmV4dFxuICB9XG4gIGlmIChpID09PSBuICYmIHdhbGtlciAhPT0gbnVsbCkge1xuICAgIHJldHVybiB3YWxrZXIudmFsdWVcbiAgfVxufVxuXG5ZYWxsaXN0LnByb3RvdHlwZS5nZXRSZXZlcnNlID0gZnVuY3Rpb24gKG4pIHtcbiAgZm9yICh2YXIgaSA9IDAsIHdhbGtlciA9IHRoaXMudGFpbDsgd2Fsa2VyICE9PSBudWxsICYmIGkgPCBuOyBpKyspIHtcbiAgICAvLyBhYm9ydCBvdXQgb2YgdGhlIGxpc3QgZWFybHkgaWYgd2UgaGl0IGEgY3ljbGVcbiAgICB3YWxrZXIgPSB3YWxrZXIucHJldlxuICB9XG4gIGlmIChpID09PSBuICYmIHdhbGtlciAhPT0gbnVsbCkge1xuICAgIHJldHVybiB3YWxrZXIudmFsdWVcbiAgfVxufVxuXG5ZYWxsaXN0LnByb3RvdHlwZS5tYXAgPSBmdW5jdGlvbiAoZm4sIHRoaXNwKSB7XG4gIHRoaXNwID0gdGhpc3AgfHwgdGhpc1xuICB2YXIgcmVzID0gbmV3IFlhbGxpc3QoKVxuICBmb3IgKHZhciB3YWxrZXIgPSB0aGlzLmhlYWQ7IHdhbGtlciAhPT0gbnVsbDspIHtcbiAgICByZXMucHVzaChmbi5jYWxsKHRoaXNwLCB3YWxrZXIudmFsdWUsIHRoaXMpKVxuICAgIHdhbGtlciA9IHdhbGtlci5uZXh0XG4gIH1cbiAgcmV0dXJuIHJlc1xufVxuXG5ZYWxsaXN0LnByb3RvdHlwZS5tYXBSZXZlcnNlID0gZnVuY3Rpb24gKGZuLCB0aGlzcCkge1xuICB0aGlzcCA9IHRoaXNwIHx8IHRoaXNcbiAgdmFyIHJlcyA9IG5ldyBZYWxsaXN0KClcbiAgZm9yICh2YXIgd2Fsa2VyID0gdGhpcy50YWlsOyB3YWxrZXIgIT09IG51bGw7KSB7XG4gICAgcmVzLnB1c2goZm4uY2FsbCh0aGlzcCwgd2Fsa2VyLnZhbHVlLCB0aGlzKSlcbiAgICB3YWxrZXIgPSB3YWxrZXIucHJldlxuICB9XG4gIHJldHVybiByZXNcbn1cblxuWWFsbGlzdC5wcm90b3R5cGUucmVkdWNlID0gZnVuY3Rpb24gKGZuLCBpbml0aWFsKSB7XG4gIHZhciBhY2NcbiAgdmFyIHdhbGtlciA9IHRoaXMuaGVhZFxuICBpZiAoYXJndW1lbnRzLmxlbmd0aCA+IDEpIHtcbiAgICBhY2MgPSBpbml0aWFsXG4gIH0gZWxzZSBpZiAodGhpcy5oZWFkKSB7XG4gICAgd2Fsa2VyID0gdGhpcy5oZWFkLm5leHRcbiAgICBhY2MgPSB0aGlzLmhlYWQudmFsdWVcbiAgfSBlbHNlIHtcbiAgICB0aHJvdyBuZXcgVHlwZUVycm9yKCdSZWR1Y2Ugb2YgZW1wdHkgbGlzdCB3aXRoIG5vIGluaXRpYWwgdmFsdWUnKVxuICB9XG5cbiAgZm9yICh2YXIgaSA9IDA7IHdhbGtlciAhPT0gbnVsbDsgaSsrKSB7XG4gICAgYWNjID0gZm4oYWNjLCB3YWxrZXIudmFsdWUsIGkpXG4gICAgd2Fsa2VyID0gd2Fsa2VyLm5leHRcbiAgfVxuXG4gIHJldHVybiBhY2Ncbn1cblxuWWFsbGlzdC5wcm90b3R5cGUucmVkdWNlUmV2ZXJzZSA9IGZ1bmN0aW9uIChmbiwgaW5pdGlhbCkge1xuICB2YXIgYWNjXG4gIHZhciB3YWxrZXIgPSB0aGlzLnRhaWxcbiAgaWYgKGFyZ3VtZW50cy5sZW5ndGggPiAxKSB7XG4gICAgYWNjID0gaW5pdGlhbFxuICB9IGVsc2UgaWYgKHRoaXMudGFpbCkge1xuICAgIHdhbGtlciA9IHRoaXMudGFpbC5wcmV2XG4gICAgYWNjID0gdGhpcy50YWlsLnZhbHVlXG4gIH0gZWxzZSB7XG4gICAgdGhyb3cgbmV3IFR5cGVFcnJvcignUmVkdWNlIG9mIGVtcHR5IGxpc3Qgd2l0aCBubyBpbml0aWFsIHZhbHVlJylcbiAgfVxuXG4gIGZvciAodmFyIGkgPSB0aGlzLmxlbmd0aCAtIDE7IHdhbGtlciAhPT0gbnVsbDsgaS0tKSB7XG4gICAgYWNjID0gZm4oYWNjLCB3YWxrZXIudmFsdWUsIGkpXG4gICAgd2Fsa2VyID0gd2Fsa2VyLnByZXZcbiAgfVxuXG4gIHJldHVybiBhY2Ncbn1cblxuWWFsbGlzdC5wcm90b3R5cGUudG9BcnJheSA9IGZ1bmN0aW9uICgpIHtcbiAgdmFyIGFyciA9IG5ldyBBcnJheSh0aGlzLmxlbmd0aClcbiAgZm9yICh2YXIgaSA9IDAsIHdhbGtlciA9IHRoaXMuaGVhZDsgd2Fsa2VyICE9PSBudWxsOyBpKyspIHtcbiAgICBhcnJbaV0gPSB3YWxrZXIudmFsdWVcbiAgICB3YWxrZXIgPSB3YWxrZXIubmV4dFxuICB9XG4gIHJldHVybiBhcnJcbn1cblxuWWFsbGlzdC5wcm90b3R5cGUudG9BcnJheVJldmVyc2UgPSBmdW5jdGlvbiAoKSB7XG4gIHZhciBhcnIgPSBuZXcgQXJyYXkodGhpcy5sZW5ndGgpXG4gIGZvciAodmFyIGkgPSAwLCB3YWxrZXIgPSB0aGlzLnRhaWw7IHdhbGtlciAhPT0gbnVsbDsgaSsrKSB7XG4gICAgYXJyW2ldID0gd2Fsa2VyLnZhbHVlXG4gICAgd2Fsa2VyID0gd2Fsa2VyLnByZXZcbiAgfVxuICByZXR1cm4gYXJyXG59XG5cbllhbGxpc3QucHJvdG90eXBlLnNsaWNlID0gZnVuY3Rpb24gKGZyb20sIHRvKSB7XG4gIHRvID0gdG8gfHwgdGhpcy5sZW5ndGhcbiAgaWYgKHRvIDwgMCkge1xuICAgIHRvICs9IHRoaXMubGVuZ3RoXG4gIH1cbiAgZnJvbSA9IGZyb20gfHwgMFxuICBpZiAoZnJvbSA8IDApIHtcbiAgICBmcm9tICs9IHRoaXMubGVuZ3RoXG4gIH1cbiAgdmFyIHJldCA9IG5ldyBZYWxsaXN0KClcbiAgaWYgKHRvIDwgZnJvbSB8fCB0byA8IDApIHtcbiAgICByZXR1cm4gcmV0XG4gIH1cbiAgaWYgKGZyb20gPCAwKSB7XG4gICAgZnJvbSA9IDBcbiAgfVxuICBpZiAodG8gPiB0aGlzLmxlbmd0aCkge1xuICAgIHRvID0gdGhpcy5sZW5ndGhcbiAgfVxuICBmb3IgKHZhciBpID0gMCwgd2Fsa2VyID0gdGhpcy5oZWFkOyB3YWxrZXIgIT09IG51bGwgJiYgaSA8IGZyb207IGkrKykge1xuICAgIHdhbGtlciA9IHdhbGtlci5uZXh0XG4gIH1cbiAgZm9yICg7IHdhbGtlciAhPT0gbnVsbCAmJiBpIDwgdG87IGkrKywgd2Fsa2VyID0gd2Fsa2VyLm5leHQpIHtcbiAgICByZXQucHVzaCh3YWxrZXIudmFsdWUpXG4gIH1cbiAgcmV0dXJuIHJldFxufVxuXG5ZYWxsaXN0LnByb3RvdHlwZS5zbGljZVJldmVyc2UgPSBmdW5jdGlvbiAoZnJvbSwgdG8pIHtcbiAgdG8gPSB0byB8fCB0aGlzLmxlbmd0aFxuICBpZiAodG8gPCAwKSB7XG4gICAgdG8gKz0gdGhpcy5sZW5ndGhcbiAgfVxuICBmcm9tID0gZnJvbSB8fCAwXG4gIGlmIChmcm9tIDwgMCkge1xuICAgIGZyb20gKz0gdGhpcy5sZW5ndGhcbiAgfVxuICB2YXIgcmV0ID0gbmV3IFlhbGxpc3QoKVxuICBpZiAodG8gPCBmcm9tIHx8IHRvIDwgMCkge1xuICAgIHJldHVybiByZXRcbiAgfVxuICBpZiAoZnJvbSA8IDApIHtcbiAgICBmcm9tID0gMFxuICB9XG4gIGlmICh0byA+IHRoaXMubGVuZ3RoKSB7XG4gICAgdG8gPSB0aGlzLmxlbmd0aFxuICB9XG4gIGZvciAodmFyIGkgPSB0aGlzLmxlbmd0aCwgd2Fsa2VyID0gdGhpcy50YWlsOyB3YWxrZXIgIT09IG51bGwgJiYgaSA+IHRvOyBpLS0pIHtcbiAgICB3YWxrZXIgPSB3YWxrZXIucHJldlxuICB9XG4gIGZvciAoOyB3YWxrZXIgIT09IG51bGwgJiYgaSA+IGZyb207IGktLSwgd2Fsa2VyID0gd2Fsa2VyLnByZXYpIHtcbiAgICByZXQucHVzaCh3YWxrZXIudmFsdWUpXG4gIH1cbiAgcmV0dXJuIHJldFxufVxuXG5ZYWxsaXN0LnByb3RvdHlwZS5zcGxpY2UgPSBmdW5jdGlvbiAoc3RhcnQsIGRlbGV0ZUNvdW50IC8qLCAuLi5ub2RlcyAqLykge1xuICBpZiAoc3RhcnQgPiB0aGlzLmxlbmd0aCkge1xuICAgIHN0YXJ0ID0gdGhpcy5sZW5ndGggLSAxXG4gIH1cbiAgaWYgKHN0YXJ0IDwgMCkge1xuICAgIHN0YXJ0ID0gdGhpcy5sZW5ndGggKyBzdGFydDtcbiAgfVxuXG4gIGZvciAodmFyIGkgPSAwLCB3YWxrZXIgPSB0aGlzLmhlYWQ7IHdhbGtlciAhPT0gbnVsbCAmJiBpIDwgc3RhcnQ7IGkrKykge1xuICAgIHdhbGtlciA9IHdhbGtlci5uZXh0XG4gIH1cblxuICB2YXIgcmV0ID0gW11cbiAgZm9yICh2YXIgaSA9IDA7IHdhbGtlciAmJiBpIDwgZGVsZXRlQ291bnQ7IGkrKykge1xuICAgIHJldC5wdXNoKHdhbGtlci52YWx1ZSlcbiAgICB3YWxrZXIgPSB0aGlzLnJlbW92ZU5vZGUod2Fsa2VyKVxuICB9XG4gIGlmICh3YWxrZXIgPT09IG51bGwpIHtcbiAgICB3YWxrZXIgPSB0aGlzLnRhaWxcbiAgfVxuXG4gIGlmICh3YWxrZXIgIT09IHRoaXMuaGVhZCAmJiB3YWxrZXIgIT09IHRoaXMudGFpbCkge1xuICAgIHdhbGtlciA9IHdhbGtlci5wcmV2XG4gIH1cblxuICBmb3IgKHZhciBpID0gMjsgaSA8IGFyZ3VtZW50cy5sZW5ndGg7IGkrKykge1xuICAgIHdhbGtlciA9IGluc2VydCh0aGlzLCB3YWxrZXIsIGFyZ3VtZW50c1tpXSlcbiAgfVxuICByZXR1cm4gcmV0O1xufVxuXG5ZYWxsaXN0LnByb3RvdHlwZS5yZXZlcnNlID0gZnVuY3Rpb24gKCkge1xuICB2YXIgaGVhZCA9IHRoaXMuaGVhZFxuICB2YXIgdGFpbCA9IHRoaXMudGFpbFxuICBmb3IgKHZhciB3YWxrZXIgPSBoZWFkOyB3YWxrZXIgIT09IG51bGw7IHdhbGtlciA9IHdhbGtlci5wcmV2KSB7XG4gICAgdmFyIHAgPSB3YWxrZXIucHJldlxuICAgIHdhbGtlci5wcmV2ID0gd2Fsa2VyLm5leHRcbiAgICB3YWxrZXIubmV4dCA9IHBcbiAgfVxuICB0aGlzLmhlYWQgPSB0YWlsXG4gIHRoaXMudGFpbCA9IGhlYWRcbiAgcmV0dXJuIHRoaXNcbn1cblxuZnVuY3Rpb24gaW5zZXJ0IChzZWxmLCBub2RlLCB2YWx1ZSkge1xuICB2YXIgaW5zZXJ0ZWQgPSBub2RlID09PSBzZWxmLmhlYWQgP1xuICAgIG5ldyBOb2RlKHZhbHVlLCBudWxsLCBub2RlLCBzZWxmKSA6XG4gICAgbmV3IE5vZGUodmFsdWUsIG5vZGUsIG5vZGUubmV4dCwgc2VsZilcblxuICBpZiAoaW5zZXJ0ZWQubmV4dCA9PT0gbnVsbCkge1xuICAgIHNlbGYudGFpbCA9IGluc2VydGVkXG4gIH1cbiAgaWYgKGluc2VydGVkLnByZXYgPT09IG51bGwpIHtcbiAgICBzZWxmLmhlYWQgPSBpbnNlcnRlZFxuICB9XG5cbiAgc2VsZi5sZW5ndGgrK1xuXG4gIHJldHVybiBpbnNlcnRlZFxufVxuXG5mdW5jdGlvbiBwdXNoIChzZWxmLCBpdGVtKSB7XG4gIHNlbGYudGFpbCA9IG5ldyBOb2RlKGl0ZW0sIHNlbGYudGFpbCwgbnVsbCwgc2VsZilcbiAgaWYgKCFzZWxmLmhlYWQpIHtcbiAgICBzZWxmLmhlYWQgPSBzZWxmLnRhaWxcbiAgfVxuICBzZWxmLmxlbmd0aCsrXG59XG5cbmZ1bmN0aW9uIHVuc2hpZnQgKHNlbGYsIGl0ZW0pIHtcbiAgc2VsZi5oZWFkID0gbmV3IE5vZGUoaXRlbSwgbnVsbCwgc2VsZi5oZWFkLCBzZWxmKVxuICBpZiAoIXNlbGYudGFpbCkge1xuICAgIHNlbGYudGFpbCA9IHNlbGYuaGVhZFxuICB9XG4gIHNlbGYubGVuZ3RoKytcbn1cblxuZnVuY3Rpb24gTm9kZSAodmFsdWUsIHByZXYsIG5leHQsIGxpc3QpIHtcbiAgaWYgKCEodGhpcyBpbnN0YW5jZW9mIE5vZGUpKSB7XG4gICAgcmV0dXJuIG5ldyBOb2RlKHZhbHVlLCBwcmV2LCBuZXh0LCBsaXN0KVxuICB9XG5cbiAgdGhpcy5saXN0ID0gbGlzdFxuICB0aGlzLnZhbHVlID0gdmFsdWVcblxuICBpZiAocHJldikge1xuICAgIHByZXYubmV4dCA9IHRoaXNcbiAgICB0aGlzLnByZXYgPSBwcmV2XG4gIH0gZWxzZSB7XG4gICAgdGhpcy5wcmV2ID0gbnVsbFxuICB9XG5cbiAgaWYgKG5leHQpIHtcbiAgICBuZXh0LnByZXYgPSB0aGlzXG4gICAgdGhpcy5uZXh0ID0gbmV4dFxuICB9IGVsc2Uge1xuICAgIHRoaXMubmV4dCA9IG51bGxcbiAgfVxufVxuXG50cnkge1xuICAvLyBhZGQgaWYgc3VwcG9ydCBmb3IgU3ltYm9sLml0ZXJhdG9yIGlzIHByZXNlbnRcbiAgcmVxdWlyZSgnLi9pdGVyYXRvci5qcycpKFlhbGxpc3QpXG59IGNhdGNoIChlcikge31cbiJdLCJuYW1lcyI6W10sImlnbm9yZUxpc3QiOlswXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/swarm-js/node_modules/yallist/yallist.js\n");

/***/ })

};
;
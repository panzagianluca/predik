/*
 * ATTENTION: An "eval-source-map" devtool has been used.
 * This devtool is neither made for production nor for readable output files.
 * It uses "eval()" calls to create a separate source file with attached SourceMaps in the browser devtools.
 * If you are trying to read the output file, select a different devtool (https://webpack.js.org/configuration/devtool/)
 * or disable the default devtool with "devtool: false".
 * If you are looking for production-ready output files, see mode: "production" (https://webpack.js.org/configuration/mode/).
 */
exports.id = "vendor-chunks/web3-eth-abi";
exports.ids = ["vendor-chunks/web3-eth-abi"];
exports.modules = {

/***/ "(ssr)/./node_modules/web3-eth-abi/lib/index.js":
/*!************************************************!*\
  !*** ./node_modules/web3-eth-abi/lib/index.js ***!
  \************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

eval("/*\n This file is part of web3.js.\n\n web3.js is free software: you can redistribute it and/or modify\n it under the terms of the GNU Lesser General Public License as published by\n the Free Software Foundation, either version 3 of the License, or\n (at your option) any later version.\n\n web3.js is distributed in the hope that it will be useful,\n but WITHOUT ANY WARRANTY; without even the implied warranty of\n MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n GNU Lesser General Public License for more details.\n\n You should have received a copy of the GNU Lesser General Public License\n along with web3.js.  If not, see <http://www.gnu.org/licenses/>.\n */\n/**\n * @file index.js\n * @author Marek Kotewicz <marek@parity.io>\n * @author Fabian Vogelsteller <fabian@frozeman.de>\n * @date 2018\n */\nvar Buffer = (__webpack_require__(/*! buffer */ \"buffer\").Buffer);\nvar utils = __webpack_require__(/*! web3-utils */ \"(ssr)/./node_modules/web3-utils/lib/index.js\");\nvar EthersAbiCoder = (__webpack_require__(/*! @ethersproject/abi */ \"(ssr)/./node_modules/@ethersproject/abi/lib.esm/index.js\").AbiCoder);\nvar ParamType = (__webpack_require__(/*! @ethersproject/abi */ \"(ssr)/./node_modules/@ethersproject/abi/lib.esm/index.js\").ParamType);\nvar ethersAbiCoder = new EthersAbiCoder(function (type, value) {\n    if (type.match(/^u?int/) && !Array.isArray(value) && (!(!!value && typeof value === 'object') || value.constructor.name !== 'BN')) {\n        return value.toString();\n    }\n    return value;\n});\n// result method\nfunction Result() {\n}\n/**\n * ABICoder prototype should be used to encode/decode solidity params of any type\n */\nvar ABICoder = function () {\n};\n/**\n * Encodes the function name to its ABI representation, which are the first 4 bytes of the sha3 of the function name including  types.\n *\n * @method encodeFunctionSignature\n * @param {String|Object} functionName\n * @return {String} encoded function name\n */\nABICoder.prototype.encodeFunctionSignature = function (functionName) {\n    if (typeof functionName === 'function' || typeof functionName === 'object' && functionName) {\n        functionName = utils._jsonInterfaceMethodToString(functionName);\n    }\n    return utils.sha3(functionName).slice(0, 10);\n};\n/**\n * Encodes the function name to its ABI representation, which are the first 4 bytes of the sha3 of the function name including  types.\n *\n * @method encodeEventSignature\n * @param {String|Object} functionName\n * @return {String} encoded function name\n */\nABICoder.prototype.encodeEventSignature = function (functionName) {\n    if (typeof functionName === 'function' || typeof functionName === 'object' && functionName) {\n        functionName = utils._jsonInterfaceMethodToString(functionName);\n    }\n    return utils.sha3(functionName);\n};\n/**\n * Should be used to encode plain param\n *\n * @method encodeParameter\n *\n * @param {String|Object} type\n * @param {any} param\n *\n * @return {String} encoded plain param\n */\nABICoder.prototype.encodeParameter = function (type, param) {\n    return this.encodeParameters([type], [param]);\n};\n/**\n * Should be used to encode list of params\n *\n * @method encodeParameters\n *\n * @param {Array<String|Object>} types\n * @param {Array<any>} params\n *\n * @return {String} encoded list of params\n */\nABICoder.prototype.encodeParameters = function (types, params) {\n    var self = this;\n    types = self.mapTypes(types);\n    params = params.map(function (param, index) {\n        let type = types[index];\n        if (typeof type === 'object' && type.type) {\n            // We may get a named type of shape {name, type}\n            type = type.type;\n        }\n        param = self.formatParam(type, param);\n        // Format params for tuples\n        if (typeof type === 'string' && type.includes('tuple')) {\n            const coder = ethersAbiCoder._getCoder(ParamType.from(type));\n            const modifyParams = (coder, param) => {\n                if (coder.name === 'array') {\n                    if (!coder.type.match(/\\[(\\d+)\\]/)) {\n                        return param.map(p => modifyParams(ethersAbiCoder._getCoder(ParamType.from(coder.type.replace('[]', ''))), p));\n                    }\n                    const arrayLength = parseInt(coder.type.match(/\\[(\\d+)\\]/)[1]);\n                    if (param.length !== arrayLength) {\n                        throw new Error('Array length does not matches with the given input');\n                    }\n                    return param.map(p => modifyParams(ethersAbiCoder._getCoder(ParamType.from(coder.type.replace(/\\[\\d+\\]/, ''))), p));\n                }\n                coder.coders.forEach((c, i) => {\n                    if (c.name === 'tuple') {\n                        modifyParams(c, param[i]);\n                    }\n                    else {\n                        param[i] = self.formatParam(c.name, param[i]);\n                    }\n                });\n            };\n            modifyParams(coder, param);\n        }\n        return param;\n    });\n    return ethersAbiCoder.encode(types, params);\n};\n/**\n * Map types if simplified format is used\n *\n * @method mapTypes\n * @param {Array} types\n * @return {Array}\n */\nABICoder.prototype.mapTypes = function (types) {\n    var self = this;\n    var mappedTypes = [];\n    types.forEach(function (type) {\n        // Remap `function` type params to bytes24 since Ethers does not\n        // recognize former type. Solidity docs say `Function` is a bytes24\n        // encoding the contract address followed by the function selector hash.\n        if (typeof type === 'object' && type.type === 'function') {\n            type = Object.assign({}, type, { type: \"bytes24\" });\n        }\n        if (self.isSimplifiedStructFormat(type)) {\n            var structName = Object.keys(type)[0];\n            mappedTypes.push(Object.assign(self.mapStructNameAndType(structName), {\n                components: self.mapStructToCoderFormat(type[structName])\n            }));\n            return;\n        }\n        mappedTypes.push(type);\n    });\n    return mappedTypes;\n};\n/**\n * Check if type is simplified struct format\n *\n * @method isSimplifiedStructFormat\n * @param {string | Object} type\n * @returns {boolean}\n */\nABICoder.prototype.isSimplifiedStructFormat = function (type) {\n    return typeof type === 'object' && typeof type.components === 'undefined' && typeof type.name === 'undefined';\n};\n/**\n * Maps the correct tuple type and name when the simplified format in encode/decodeParameter is used\n *\n * @method mapStructNameAndType\n * @param {string} structName\n * @return {{type: string, name: *}}\n */\nABICoder.prototype.mapStructNameAndType = function (structName) {\n    var type = 'tuple';\n    if (structName.indexOf('[]') > -1) {\n        type = 'tuple[]';\n        structName = structName.slice(0, -2);\n    }\n    return { type: type, name: structName };\n};\n/**\n * Maps the simplified format in to the expected format of the ABICoder\n *\n * @method mapStructToCoderFormat\n * @param {Object} struct\n * @return {Array}\n */\nABICoder.prototype.mapStructToCoderFormat = function (struct) {\n    var self = this;\n    var components = [];\n    Object.keys(struct).forEach(function (key) {\n        if (typeof struct[key] === 'object') {\n            components.push(Object.assign(self.mapStructNameAndType(key), {\n                components: self.mapStructToCoderFormat(struct[key])\n            }));\n            return;\n        }\n        components.push({\n            name: key,\n            type: struct[key]\n        });\n    });\n    return components;\n};\n/**\n * Handle some formatting of params for backwards compatability with Ethers V4\n *\n * @method formatParam\n * @param {String} - type\n * @param {any} - param\n * @return {any} - The formatted param\n */\nABICoder.prototype.formatParam = function (type, param) {\n    const paramTypeBytes = new RegExp(/^bytes([0-9]*)$/);\n    const paramTypeBytesArray = new RegExp(/^bytes([0-9]*)\\[\\]$/);\n    const paramTypeNumber = new RegExp(/^(u?int)([0-9]*)$/);\n    const paramTypeNumberArray = new RegExp(/^(u?int)([0-9]*)\\[\\]$/);\n    // Format BN to string\n    if (utils.isBN(param) || utils.isBigNumber(param)) {\n        return param.toString(10);\n    }\n    if (type.match(paramTypeBytesArray) || type.match(paramTypeNumberArray)) {\n        return param.map(p => this.formatParam(type.replace('[]', ''), p));\n    }\n    // Format correct width for u?int[0-9]*\n    let match = type.match(paramTypeNumber);\n    if (match) {\n        let size = parseInt(match[2] || \"256\");\n        if (size / 8 < param.length) {\n            // pad to correct bit width\n            param = utils.leftPad(param, size);\n        }\n    }\n    // Format correct length for bytes[0-9]+\n    match = type.match(paramTypeBytes);\n    if (match) {\n        if (Buffer.isBuffer(param)) {\n            param = utils.toHex(param);\n        }\n        // format to correct length\n        let size = parseInt(match[1]);\n        if (size) {\n            let maxSize = size * 2;\n            if (param.substring(0, 2) === '0x') {\n                maxSize += 2;\n            }\n            if (param.length < maxSize) {\n                // pad to correct length\n                param = utils.rightPad(param, size * 2);\n            }\n        }\n        // format odd-length bytes to even-length\n        if (param.length % 2 === 1) {\n            param = '0x0' + param.substring(2);\n        }\n    }\n    return param;\n};\n/**\n * Encodes a function call from its json interface and parameters.\n *\n * @method encodeFunctionCall\n * @param {Array} jsonInterface\n * @param {Array} params\n * @return {String} The encoded ABI for this function call\n */\nABICoder.prototype.encodeFunctionCall = function (jsonInterface, params) {\n    return this.encodeFunctionSignature(jsonInterface) + this.encodeParameters(jsonInterface.inputs, params).replace('0x', '');\n};\n/**\n * Should be used to decode bytes to plain param\n *\n * @method decodeParameter\n * @param {String} type\n * @param {String} bytes\n * @return {Object} plain param\n */\nABICoder.prototype.decodeParameter = function (type, bytes) {\n    return this.decodeParameters([type], bytes)[0];\n};\n/**\n * Should be used to decode list of params\n *\n * @method decodeParameter\n * @param {Array} outputs\n * @param {String} bytes\n * @return {Array} array of plain params\n */\nABICoder.prototype.decodeParameters = function (outputs, bytes) {\n    return this.decodeParametersWith(outputs, bytes, false);\n};\n/**\n * Should be used to decode list of params\n *\n * @method decodeParameter\n * @param {Array} outputs\n * @param {String} bytes\n * @param {Boolean} loose\n * @return {Array} array of plain params\n */\nABICoder.prototype.decodeParametersWith = function (outputs, bytes, loose) {\n    if (outputs.length > 0 && (!bytes || bytes === '0x' || bytes === '0X')) {\n        throw new Error('Returned values aren\\'t valid, did it run Out of Gas? ' +\n            'You might also see this error if you are not using the ' +\n            'correct ABI for the contract you are retrieving data from, ' +\n            'requesting data from a block number that does not exist, ' +\n            'or querying a node which is not fully synced.');\n    }\n    var res = ethersAbiCoder.decode(this.mapTypes(outputs), '0x' + bytes.replace(/0x/i, ''), loose);\n    var returnValue = new Result();\n    returnValue.__length__ = 0;\n    outputs.forEach(function (output, i) {\n        var decodedValue = res[returnValue.__length__];\n        const isStringObject = typeof output === 'object' && output.type && output.type === 'string';\n        const isStringType = typeof output === 'string' && output === 'string';\n        // only convert `0x` to null if it's not string value\n        decodedValue = (decodedValue === '0x' && !isStringObject && !isStringType) ? null : decodedValue;\n        returnValue[i] = decodedValue;\n        if ((typeof output === 'function' || !!output && typeof output === 'object') && output.name) {\n            returnValue[output.name] = decodedValue;\n        }\n        returnValue.__length__++;\n    });\n    return returnValue;\n};\n/**\n * Decodes events non- and indexed parameters.\n *\n * @method decodeLog\n * @param {Object} inputs\n * @param {String} data\n * @param {Array} topics\n * @return {Array} array of plain params\n */\nABICoder.prototype.decodeLog = function (inputs, data, topics) {\n    var _this = this;\n    topics = Array.isArray(topics) ? topics : [topics];\n    data = data || '';\n    var notIndexedInputs = [];\n    var indexedParams = [];\n    var topicCount = 0;\n    // TODO check for anonymous logs?\n    inputs.forEach(function (input, i) {\n        if (input.indexed) {\n            indexedParams[i] = (['bool', 'int', 'uint', 'address', 'fixed', 'ufixed'].find(function (staticType) {\n                return input.type.indexOf(staticType) !== -1;\n            })) ? _this.decodeParameter(input.type, topics[topicCount]) : topics[topicCount];\n            topicCount++;\n        }\n        else {\n            notIndexedInputs[i] = input;\n        }\n    });\n    var nonIndexedData = data;\n    var notIndexedParams = (nonIndexedData) ? this.decodeParametersWith(notIndexedInputs, nonIndexedData, true) : [];\n    var returnValue = new Result();\n    returnValue.__length__ = 0;\n    inputs.forEach(function (res, i) {\n        returnValue[i] = (res.type === 'string') ? '' : null;\n        if (typeof notIndexedParams[i] !== 'undefined') {\n            returnValue[i] = notIndexedParams[i];\n        }\n        if (typeof indexedParams[i] !== 'undefined') {\n            returnValue[i] = indexedParams[i];\n        }\n        if (res.name) {\n            returnValue[res.name] = returnValue[i];\n        }\n        returnValue.__length__++;\n    });\n    return returnValue;\n};\nvar coder = new ABICoder();\nmodule.exports = coder;\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvd2ViMy1ldGgtYWJpL2xpYi9pbmRleC5qcyIsIm1hcHBpbmdzIjoiQUFBQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0EsMkJBQTJCO0FBQzNCO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYSxvREFBd0I7QUFDckMsWUFBWSxtQkFBTyxDQUFDLGdFQUFZO0FBQ2hDLHFCQUFxQixvSEFBc0M7QUFDM0QsZ0JBQWdCLHFIQUF1QztBQUN2RDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQztBQUNEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFdBQVcsZUFBZTtBQUMxQixZQUFZLFFBQVE7QUFDcEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFdBQVcsZUFBZTtBQUMxQixZQUFZLFFBQVE7QUFDcEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsV0FBVyxlQUFlO0FBQzFCLFdBQVcsS0FBSztBQUNoQjtBQUNBLFlBQVksUUFBUTtBQUNwQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxXQUFXLHNCQUFzQjtBQUNqQyxXQUFXLFlBQVk7QUFDdkI7QUFDQSxZQUFZLFFBQVE7QUFDcEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxpREFBaUQ7QUFDakQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsaUJBQWlCO0FBQ2pCO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFdBQVcsT0FBTztBQUNsQixZQUFZO0FBQ1o7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsbUNBQW1DLFVBQVUsaUJBQWlCO0FBQzlEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFdBQVcsaUJBQWlCO0FBQzVCLGFBQWE7QUFDYjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsV0FBVyxRQUFRO0FBQ25CLGFBQWE7QUFDYjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWE7QUFDYjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsV0FBVyxRQUFRO0FBQ25CLFlBQVk7QUFDWjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1QsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFdBQVcsUUFBUTtBQUNuQixXQUFXLEtBQUs7QUFDaEIsWUFBWSxLQUFLO0FBQ2pCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFdBQVcsT0FBTztBQUNsQixXQUFXLE9BQU87QUFDbEIsWUFBWSxRQUFRO0FBQ3BCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxXQUFXLFFBQVE7QUFDbkIsV0FBVyxRQUFRO0FBQ25CLFlBQVksUUFBUTtBQUNwQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsV0FBVyxPQUFPO0FBQ2xCLFdBQVcsUUFBUTtBQUNuQixZQUFZLE9BQU87QUFDbkI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFdBQVcsT0FBTztBQUNsQixXQUFXLFFBQVE7QUFDbkIsV0FBVyxTQUFTO0FBQ3BCLFlBQVksT0FBTztBQUNuQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFdBQVcsUUFBUTtBQUNuQixXQUFXLFFBQVE7QUFDbkIsV0FBVyxPQUFPO0FBQ2xCLFlBQVksT0FBTztBQUNuQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWE7QUFDYjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBIiwic291cmNlcyI6WyIvVXNlcnMvcGFuemEvRG9jdW1lbnRzL1BlcnNvbmFsUHJvamVjdHMvcHJlZGlrL25vZGVfbW9kdWxlcy93ZWIzLWV0aC1hYmkvbGliL2luZGV4LmpzIl0sInNvdXJjZXNDb250ZW50IjpbIi8qXG4gVGhpcyBmaWxlIGlzIHBhcnQgb2Ygd2ViMy5qcy5cblxuIHdlYjMuanMgaXMgZnJlZSBzb2Z0d2FyZTogeW91IGNhbiByZWRpc3RyaWJ1dGUgaXQgYW5kL29yIG1vZGlmeVxuIGl0IHVuZGVyIHRoZSB0ZXJtcyBvZiB0aGUgR05VIExlc3NlciBHZW5lcmFsIFB1YmxpYyBMaWNlbnNlIGFzIHB1Ymxpc2hlZCBieVxuIHRoZSBGcmVlIFNvZnR3YXJlIEZvdW5kYXRpb24sIGVpdGhlciB2ZXJzaW9uIDMgb2YgdGhlIExpY2Vuc2UsIG9yXG4gKGF0IHlvdXIgb3B0aW9uKSBhbnkgbGF0ZXIgdmVyc2lvbi5cblxuIHdlYjMuanMgaXMgZGlzdHJpYnV0ZWQgaW4gdGhlIGhvcGUgdGhhdCBpdCB3aWxsIGJlIHVzZWZ1bCxcbiBidXQgV0lUSE9VVCBBTlkgV0FSUkFOVFk7IHdpdGhvdXQgZXZlbiB0aGUgaW1wbGllZCB3YXJyYW50eSBvZlxuIE1FUkNIQU5UQUJJTElUWSBvciBGSVRORVNTIEZPUiBBIFBBUlRJQ1VMQVIgUFVSUE9TRS4gIFNlZSB0aGVcbiBHTlUgTGVzc2VyIEdlbmVyYWwgUHVibGljIExpY2Vuc2UgZm9yIG1vcmUgZGV0YWlscy5cblxuIFlvdSBzaG91bGQgaGF2ZSByZWNlaXZlZCBhIGNvcHkgb2YgdGhlIEdOVSBMZXNzZXIgR2VuZXJhbCBQdWJsaWMgTGljZW5zZVxuIGFsb25nIHdpdGggd2ViMy5qcy4gIElmIG5vdCwgc2VlIDxodHRwOi8vd3d3LmdudS5vcmcvbGljZW5zZXMvPi5cbiAqL1xuLyoqXG4gKiBAZmlsZSBpbmRleC5qc1xuICogQGF1dGhvciBNYXJlayBLb3Rld2ljeiA8bWFyZWtAcGFyaXR5LmlvPlxuICogQGF1dGhvciBGYWJpYW4gVm9nZWxzdGVsbGVyIDxmYWJpYW5AZnJvemVtYW4uZGU+XG4gKiBAZGF0ZSAyMDE4XG4gKi9cbnZhciBCdWZmZXIgPSByZXF1aXJlKCdidWZmZXInKS5CdWZmZXI7XG52YXIgdXRpbHMgPSByZXF1aXJlKCd3ZWIzLXV0aWxzJyk7XG52YXIgRXRoZXJzQWJpQ29kZXIgPSByZXF1aXJlKCdAZXRoZXJzcHJvamVjdC9hYmknKS5BYmlDb2RlcjtcbnZhciBQYXJhbVR5cGUgPSByZXF1aXJlKCdAZXRoZXJzcHJvamVjdC9hYmknKS5QYXJhbVR5cGU7XG52YXIgZXRoZXJzQWJpQ29kZXIgPSBuZXcgRXRoZXJzQWJpQ29kZXIoZnVuY3Rpb24gKHR5cGUsIHZhbHVlKSB7XG4gICAgaWYgKHR5cGUubWF0Y2goL151P2ludC8pICYmICFBcnJheS5pc0FycmF5KHZhbHVlKSAmJiAoISghIXZhbHVlICYmIHR5cGVvZiB2YWx1ZSA9PT0gJ29iamVjdCcpIHx8IHZhbHVlLmNvbnN0cnVjdG9yLm5hbWUgIT09ICdCTicpKSB7XG4gICAgICAgIHJldHVybiB2YWx1ZS50b1N0cmluZygpO1xuICAgIH1cbiAgICByZXR1cm4gdmFsdWU7XG59KTtcbi8vIHJlc3VsdCBtZXRob2RcbmZ1bmN0aW9uIFJlc3VsdCgpIHtcbn1cbi8qKlxuICogQUJJQ29kZXIgcHJvdG90eXBlIHNob3VsZCBiZSB1c2VkIHRvIGVuY29kZS9kZWNvZGUgc29saWRpdHkgcGFyYW1zIG9mIGFueSB0eXBlXG4gKi9cbnZhciBBQklDb2RlciA9IGZ1bmN0aW9uICgpIHtcbn07XG4vKipcbiAqIEVuY29kZXMgdGhlIGZ1bmN0aW9uIG5hbWUgdG8gaXRzIEFCSSByZXByZXNlbnRhdGlvbiwgd2hpY2ggYXJlIHRoZSBmaXJzdCA0IGJ5dGVzIG9mIHRoZSBzaGEzIG9mIHRoZSBmdW5jdGlvbiBuYW1lIGluY2x1ZGluZyAgdHlwZXMuXG4gKlxuICogQG1ldGhvZCBlbmNvZGVGdW5jdGlvblNpZ25hdHVyZVxuICogQHBhcmFtIHtTdHJpbmd8T2JqZWN0fSBmdW5jdGlvbk5hbWVcbiAqIEByZXR1cm4ge1N0cmluZ30gZW5jb2RlZCBmdW5jdGlvbiBuYW1lXG4gKi9cbkFCSUNvZGVyLnByb3RvdHlwZS5lbmNvZGVGdW5jdGlvblNpZ25hdHVyZSA9IGZ1bmN0aW9uIChmdW5jdGlvbk5hbWUpIHtcbiAgICBpZiAodHlwZW9mIGZ1bmN0aW9uTmFtZSA9PT0gJ2Z1bmN0aW9uJyB8fCB0eXBlb2YgZnVuY3Rpb25OYW1lID09PSAnb2JqZWN0JyAmJiBmdW5jdGlvbk5hbWUpIHtcbiAgICAgICAgZnVuY3Rpb25OYW1lID0gdXRpbHMuX2pzb25JbnRlcmZhY2VNZXRob2RUb1N0cmluZyhmdW5jdGlvbk5hbWUpO1xuICAgIH1cbiAgICByZXR1cm4gdXRpbHMuc2hhMyhmdW5jdGlvbk5hbWUpLnNsaWNlKDAsIDEwKTtcbn07XG4vKipcbiAqIEVuY29kZXMgdGhlIGZ1bmN0aW9uIG5hbWUgdG8gaXRzIEFCSSByZXByZXNlbnRhdGlvbiwgd2hpY2ggYXJlIHRoZSBmaXJzdCA0IGJ5dGVzIG9mIHRoZSBzaGEzIG9mIHRoZSBmdW5jdGlvbiBuYW1lIGluY2x1ZGluZyAgdHlwZXMuXG4gKlxuICogQG1ldGhvZCBlbmNvZGVFdmVudFNpZ25hdHVyZVxuICogQHBhcmFtIHtTdHJpbmd8T2JqZWN0fSBmdW5jdGlvbk5hbWVcbiAqIEByZXR1cm4ge1N0cmluZ30gZW5jb2RlZCBmdW5jdGlvbiBuYW1lXG4gKi9cbkFCSUNvZGVyLnByb3RvdHlwZS5lbmNvZGVFdmVudFNpZ25hdHVyZSA9IGZ1bmN0aW9uIChmdW5jdGlvbk5hbWUpIHtcbiAgICBpZiAodHlwZW9mIGZ1bmN0aW9uTmFtZSA9PT0gJ2Z1bmN0aW9uJyB8fCB0eXBlb2YgZnVuY3Rpb25OYW1lID09PSAnb2JqZWN0JyAmJiBmdW5jdGlvbk5hbWUpIHtcbiAgICAgICAgZnVuY3Rpb25OYW1lID0gdXRpbHMuX2pzb25JbnRlcmZhY2VNZXRob2RUb1N0cmluZyhmdW5jdGlvbk5hbWUpO1xuICAgIH1cbiAgICByZXR1cm4gdXRpbHMuc2hhMyhmdW5jdGlvbk5hbWUpO1xufTtcbi8qKlxuICogU2hvdWxkIGJlIHVzZWQgdG8gZW5jb2RlIHBsYWluIHBhcmFtXG4gKlxuICogQG1ldGhvZCBlbmNvZGVQYXJhbWV0ZXJcbiAqXG4gKiBAcGFyYW0ge1N0cmluZ3xPYmplY3R9IHR5cGVcbiAqIEBwYXJhbSB7YW55fSBwYXJhbVxuICpcbiAqIEByZXR1cm4ge1N0cmluZ30gZW5jb2RlZCBwbGFpbiBwYXJhbVxuICovXG5BQklDb2Rlci5wcm90b3R5cGUuZW5jb2RlUGFyYW1ldGVyID0gZnVuY3Rpb24gKHR5cGUsIHBhcmFtKSB7XG4gICAgcmV0dXJuIHRoaXMuZW5jb2RlUGFyYW1ldGVycyhbdHlwZV0sIFtwYXJhbV0pO1xufTtcbi8qKlxuICogU2hvdWxkIGJlIHVzZWQgdG8gZW5jb2RlIGxpc3Qgb2YgcGFyYW1zXG4gKlxuICogQG1ldGhvZCBlbmNvZGVQYXJhbWV0ZXJzXG4gKlxuICogQHBhcmFtIHtBcnJheTxTdHJpbmd8T2JqZWN0Pn0gdHlwZXNcbiAqIEBwYXJhbSB7QXJyYXk8YW55Pn0gcGFyYW1zXG4gKlxuICogQHJldHVybiB7U3RyaW5nfSBlbmNvZGVkIGxpc3Qgb2YgcGFyYW1zXG4gKi9cbkFCSUNvZGVyLnByb3RvdHlwZS5lbmNvZGVQYXJhbWV0ZXJzID0gZnVuY3Rpb24gKHR5cGVzLCBwYXJhbXMpIHtcbiAgICB2YXIgc2VsZiA9IHRoaXM7XG4gICAgdHlwZXMgPSBzZWxmLm1hcFR5cGVzKHR5cGVzKTtcbiAgICBwYXJhbXMgPSBwYXJhbXMubWFwKGZ1bmN0aW9uIChwYXJhbSwgaW5kZXgpIHtcbiAgICAgICAgbGV0IHR5cGUgPSB0eXBlc1tpbmRleF07XG4gICAgICAgIGlmICh0eXBlb2YgdHlwZSA9PT0gJ29iamVjdCcgJiYgdHlwZS50eXBlKSB7XG4gICAgICAgICAgICAvLyBXZSBtYXkgZ2V0IGEgbmFtZWQgdHlwZSBvZiBzaGFwZSB7bmFtZSwgdHlwZX1cbiAgICAgICAgICAgIHR5cGUgPSB0eXBlLnR5cGU7XG4gICAgICAgIH1cbiAgICAgICAgcGFyYW0gPSBzZWxmLmZvcm1hdFBhcmFtKHR5cGUsIHBhcmFtKTtcbiAgICAgICAgLy8gRm9ybWF0IHBhcmFtcyBmb3IgdHVwbGVzXG4gICAgICAgIGlmICh0eXBlb2YgdHlwZSA9PT0gJ3N0cmluZycgJiYgdHlwZS5pbmNsdWRlcygndHVwbGUnKSkge1xuICAgICAgICAgICAgY29uc3QgY29kZXIgPSBldGhlcnNBYmlDb2Rlci5fZ2V0Q29kZXIoUGFyYW1UeXBlLmZyb20odHlwZSkpO1xuICAgICAgICAgICAgY29uc3QgbW9kaWZ5UGFyYW1zID0gKGNvZGVyLCBwYXJhbSkgPT4ge1xuICAgICAgICAgICAgICAgIGlmIChjb2Rlci5uYW1lID09PSAnYXJyYXknKSB7XG4gICAgICAgICAgICAgICAgICAgIGlmICghY29kZXIudHlwZS5tYXRjaCgvXFxbKFxcZCspXFxdLykpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBwYXJhbS5tYXAocCA9PiBtb2RpZnlQYXJhbXMoZXRoZXJzQWJpQ29kZXIuX2dldENvZGVyKFBhcmFtVHlwZS5mcm9tKGNvZGVyLnR5cGUucmVwbGFjZSgnW10nLCAnJykpKSwgcCkpO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIGNvbnN0IGFycmF5TGVuZ3RoID0gcGFyc2VJbnQoY29kZXIudHlwZS5tYXRjaCgvXFxbKFxcZCspXFxdLylbMV0pO1xuICAgICAgICAgICAgICAgICAgICBpZiAocGFyYW0ubGVuZ3RoICE9PSBhcnJheUxlbmd0aCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdBcnJheSBsZW5ndGggZG9lcyBub3QgbWF0Y2hlcyB3aXRoIHRoZSBnaXZlbiBpbnB1dCcpO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBwYXJhbS5tYXAocCA9PiBtb2RpZnlQYXJhbXMoZXRoZXJzQWJpQ29kZXIuX2dldENvZGVyKFBhcmFtVHlwZS5mcm9tKGNvZGVyLnR5cGUucmVwbGFjZSgvXFxbXFxkK1xcXS8sICcnKSkpLCBwKSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGNvZGVyLmNvZGVycy5mb3JFYWNoKChjLCBpKSA9PiB7XG4gICAgICAgICAgICAgICAgICAgIGlmIChjLm5hbWUgPT09ICd0dXBsZScpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIG1vZGlmeVBhcmFtcyhjLCBwYXJhbVtpXSk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBwYXJhbVtpXSA9IHNlbGYuZm9ybWF0UGFyYW0oYy5uYW1lLCBwYXJhbVtpXSk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIH07XG4gICAgICAgICAgICBtb2RpZnlQYXJhbXMoY29kZXIsIHBhcmFtKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gcGFyYW07XG4gICAgfSk7XG4gICAgcmV0dXJuIGV0aGVyc0FiaUNvZGVyLmVuY29kZSh0eXBlcywgcGFyYW1zKTtcbn07XG4vKipcbiAqIE1hcCB0eXBlcyBpZiBzaW1wbGlmaWVkIGZvcm1hdCBpcyB1c2VkXG4gKlxuICogQG1ldGhvZCBtYXBUeXBlc1xuICogQHBhcmFtIHtBcnJheX0gdHlwZXNcbiAqIEByZXR1cm4ge0FycmF5fVxuICovXG5BQklDb2Rlci5wcm90b3R5cGUubWFwVHlwZXMgPSBmdW5jdGlvbiAodHlwZXMpIHtcbiAgICB2YXIgc2VsZiA9IHRoaXM7XG4gICAgdmFyIG1hcHBlZFR5cGVzID0gW107XG4gICAgdHlwZXMuZm9yRWFjaChmdW5jdGlvbiAodHlwZSkge1xuICAgICAgICAvLyBSZW1hcCBgZnVuY3Rpb25gIHR5cGUgcGFyYW1zIHRvIGJ5dGVzMjQgc2luY2UgRXRoZXJzIGRvZXMgbm90XG4gICAgICAgIC8vIHJlY29nbml6ZSBmb3JtZXIgdHlwZS4gU29saWRpdHkgZG9jcyBzYXkgYEZ1bmN0aW9uYCBpcyBhIGJ5dGVzMjRcbiAgICAgICAgLy8gZW5jb2RpbmcgdGhlIGNvbnRyYWN0IGFkZHJlc3MgZm9sbG93ZWQgYnkgdGhlIGZ1bmN0aW9uIHNlbGVjdG9yIGhhc2guXG4gICAgICAgIGlmICh0eXBlb2YgdHlwZSA9PT0gJ29iamVjdCcgJiYgdHlwZS50eXBlID09PSAnZnVuY3Rpb24nKSB7XG4gICAgICAgICAgICB0eXBlID0gT2JqZWN0LmFzc2lnbih7fSwgdHlwZSwgeyB0eXBlOiBcImJ5dGVzMjRcIiB9KTtcbiAgICAgICAgfVxuICAgICAgICBpZiAoc2VsZi5pc1NpbXBsaWZpZWRTdHJ1Y3RGb3JtYXQodHlwZSkpIHtcbiAgICAgICAgICAgIHZhciBzdHJ1Y3ROYW1lID0gT2JqZWN0LmtleXModHlwZSlbMF07XG4gICAgICAgICAgICBtYXBwZWRUeXBlcy5wdXNoKE9iamVjdC5hc3NpZ24oc2VsZi5tYXBTdHJ1Y3ROYW1lQW5kVHlwZShzdHJ1Y3ROYW1lKSwge1xuICAgICAgICAgICAgICAgIGNvbXBvbmVudHM6IHNlbGYubWFwU3RydWN0VG9Db2RlckZvcm1hdCh0eXBlW3N0cnVjdE5hbWVdKVxuICAgICAgICAgICAgfSkpO1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICAgIG1hcHBlZFR5cGVzLnB1c2godHlwZSk7XG4gICAgfSk7XG4gICAgcmV0dXJuIG1hcHBlZFR5cGVzO1xufTtcbi8qKlxuICogQ2hlY2sgaWYgdHlwZSBpcyBzaW1wbGlmaWVkIHN0cnVjdCBmb3JtYXRcbiAqXG4gKiBAbWV0aG9kIGlzU2ltcGxpZmllZFN0cnVjdEZvcm1hdFxuICogQHBhcmFtIHtzdHJpbmcgfCBPYmplY3R9IHR5cGVcbiAqIEByZXR1cm5zIHtib29sZWFufVxuICovXG5BQklDb2Rlci5wcm90b3R5cGUuaXNTaW1wbGlmaWVkU3RydWN0Rm9ybWF0ID0gZnVuY3Rpb24gKHR5cGUpIHtcbiAgICByZXR1cm4gdHlwZW9mIHR5cGUgPT09ICdvYmplY3QnICYmIHR5cGVvZiB0eXBlLmNvbXBvbmVudHMgPT09ICd1bmRlZmluZWQnICYmIHR5cGVvZiB0eXBlLm5hbWUgPT09ICd1bmRlZmluZWQnO1xufTtcbi8qKlxuICogTWFwcyB0aGUgY29ycmVjdCB0dXBsZSB0eXBlIGFuZCBuYW1lIHdoZW4gdGhlIHNpbXBsaWZpZWQgZm9ybWF0IGluIGVuY29kZS9kZWNvZGVQYXJhbWV0ZXIgaXMgdXNlZFxuICpcbiAqIEBtZXRob2QgbWFwU3RydWN0TmFtZUFuZFR5cGVcbiAqIEBwYXJhbSB7c3RyaW5nfSBzdHJ1Y3ROYW1lXG4gKiBAcmV0dXJuIHt7dHlwZTogc3RyaW5nLCBuYW1lOiAqfX1cbiAqL1xuQUJJQ29kZXIucHJvdG90eXBlLm1hcFN0cnVjdE5hbWVBbmRUeXBlID0gZnVuY3Rpb24gKHN0cnVjdE5hbWUpIHtcbiAgICB2YXIgdHlwZSA9ICd0dXBsZSc7XG4gICAgaWYgKHN0cnVjdE5hbWUuaW5kZXhPZignW10nKSA+IC0xKSB7XG4gICAgICAgIHR5cGUgPSAndHVwbGVbXSc7XG4gICAgICAgIHN0cnVjdE5hbWUgPSBzdHJ1Y3ROYW1lLnNsaWNlKDAsIC0yKTtcbiAgICB9XG4gICAgcmV0dXJuIHsgdHlwZTogdHlwZSwgbmFtZTogc3RydWN0TmFtZSB9O1xufTtcbi8qKlxuICogTWFwcyB0aGUgc2ltcGxpZmllZCBmb3JtYXQgaW4gdG8gdGhlIGV4cGVjdGVkIGZvcm1hdCBvZiB0aGUgQUJJQ29kZXJcbiAqXG4gKiBAbWV0aG9kIG1hcFN0cnVjdFRvQ29kZXJGb3JtYXRcbiAqIEBwYXJhbSB7T2JqZWN0fSBzdHJ1Y3RcbiAqIEByZXR1cm4ge0FycmF5fVxuICovXG5BQklDb2Rlci5wcm90b3R5cGUubWFwU3RydWN0VG9Db2RlckZvcm1hdCA9IGZ1bmN0aW9uIChzdHJ1Y3QpIHtcbiAgICB2YXIgc2VsZiA9IHRoaXM7XG4gICAgdmFyIGNvbXBvbmVudHMgPSBbXTtcbiAgICBPYmplY3Qua2V5cyhzdHJ1Y3QpLmZvckVhY2goZnVuY3Rpb24gKGtleSkge1xuICAgICAgICBpZiAodHlwZW9mIHN0cnVjdFtrZXldID09PSAnb2JqZWN0Jykge1xuICAgICAgICAgICAgY29tcG9uZW50cy5wdXNoKE9iamVjdC5hc3NpZ24oc2VsZi5tYXBTdHJ1Y3ROYW1lQW5kVHlwZShrZXkpLCB7XG4gICAgICAgICAgICAgICAgY29tcG9uZW50czogc2VsZi5tYXBTdHJ1Y3RUb0NvZGVyRm9ybWF0KHN0cnVjdFtrZXldKVxuICAgICAgICAgICAgfSkpO1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICAgIGNvbXBvbmVudHMucHVzaCh7XG4gICAgICAgICAgICBuYW1lOiBrZXksXG4gICAgICAgICAgICB0eXBlOiBzdHJ1Y3Rba2V5XVxuICAgICAgICB9KTtcbiAgICB9KTtcbiAgICByZXR1cm4gY29tcG9uZW50cztcbn07XG4vKipcbiAqIEhhbmRsZSBzb21lIGZvcm1hdHRpbmcgb2YgcGFyYW1zIGZvciBiYWNrd2FyZHMgY29tcGF0YWJpbGl0eSB3aXRoIEV0aGVycyBWNFxuICpcbiAqIEBtZXRob2QgZm9ybWF0UGFyYW1cbiAqIEBwYXJhbSB7U3RyaW5nfSAtIHR5cGVcbiAqIEBwYXJhbSB7YW55fSAtIHBhcmFtXG4gKiBAcmV0dXJuIHthbnl9IC0gVGhlIGZvcm1hdHRlZCBwYXJhbVxuICovXG5BQklDb2Rlci5wcm90b3R5cGUuZm9ybWF0UGFyYW0gPSBmdW5jdGlvbiAodHlwZSwgcGFyYW0pIHtcbiAgICBjb25zdCBwYXJhbVR5cGVCeXRlcyA9IG5ldyBSZWdFeHAoL15ieXRlcyhbMC05XSopJC8pO1xuICAgIGNvbnN0IHBhcmFtVHlwZUJ5dGVzQXJyYXkgPSBuZXcgUmVnRXhwKC9eYnl0ZXMoWzAtOV0qKVxcW1xcXSQvKTtcbiAgICBjb25zdCBwYXJhbVR5cGVOdW1iZXIgPSBuZXcgUmVnRXhwKC9eKHU/aW50KShbMC05XSopJC8pO1xuICAgIGNvbnN0IHBhcmFtVHlwZU51bWJlckFycmF5ID0gbmV3IFJlZ0V4cCgvXih1P2ludCkoWzAtOV0qKVxcW1xcXSQvKTtcbiAgICAvLyBGb3JtYXQgQk4gdG8gc3RyaW5nXG4gICAgaWYgKHV0aWxzLmlzQk4ocGFyYW0pIHx8IHV0aWxzLmlzQmlnTnVtYmVyKHBhcmFtKSkge1xuICAgICAgICByZXR1cm4gcGFyYW0udG9TdHJpbmcoMTApO1xuICAgIH1cbiAgICBpZiAodHlwZS5tYXRjaChwYXJhbVR5cGVCeXRlc0FycmF5KSB8fCB0eXBlLm1hdGNoKHBhcmFtVHlwZU51bWJlckFycmF5KSkge1xuICAgICAgICByZXR1cm4gcGFyYW0ubWFwKHAgPT4gdGhpcy5mb3JtYXRQYXJhbSh0eXBlLnJlcGxhY2UoJ1tdJywgJycpLCBwKSk7XG4gICAgfVxuICAgIC8vIEZvcm1hdCBjb3JyZWN0IHdpZHRoIGZvciB1P2ludFswLTldKlxuICAgIGxldCBtYXRjaCA9IHR5cGUubWF0Y2gocGFyYW1UeXBlTnVtYmVyKTtcbiAgICBpZiAobWF0Y2gpIHtcbiAgICAgICAgbGV0IHNpemUgPSBwYXJzZUludChtYXRjaFsyXSB8fCBcIjI1NlwiKTtcbiAgICAgICAgaWYgKHNpemUgLyA4IDwgcGFyYW0ubGVuZ3RoKSB7XG4gICAgICAgICAgICAvLyBwYWQgdG8gY29ycmVjdCBiaXQgd2lkdGhcbiAgICAgICAgICAgIHBhcmFtID0gdXRpbHMubGVmdFBhZChwYXJhbSwgc2l6ZSk7XG4gICAgICAgIH1cbiAgICB9XG4gICAgLy8gRm9ybWF0IGNvcnJlY3QgbGVuZ3RoIGZvciBieXRlc1swLTldK1xuICAgIG1hdGNoID0gdHlwZS5tYXRjaChwYXJhbVR5cGVCeXRlcyk7XG4gICAgaWYgKG1hdGNoKSB7XG4gICAgICAgIGlmIChCdWZmZXIuaXNCdWZmZXIocGFyYW0pKSB7XG4gICAgICAgICAgICBwYXJhbSA9IHV0aWxzLnRvSGV4KHBhcmFtKTtcbiAgICAgICAgfVxuICAgICAgICAvLyBmb3JtYXQgdG8gY29ycmVjdCBsZW5ndGhcbiAgICAgICAgbGV0IHNpemUgPSBwYXJzZUludChtYXRjaFsxXSk7XG4gICAgICAgIGlmIChzaXplKSB7XG4gICAgICAgICAgICBsZXQgbWF4U2l6ZSA9IHNpemUgKiAyO1xuICAgICAgICAgICAgaWYgKHBhcmFtLnN1YnN0cmluZygwLCAyKSA9PT0gJzB4Jykge1xuICAgICAgICAgICAgICAgIG1heFNpemUgKz0gMjtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmIChwYXJhbS5sZW5ndGggPCBtYXhTaXplKSB7XG4gICAgICAgICAgICAgICAgLy8gcGFkIHRvIGNvcnJlY3QgbGVuZ3RoXG4gICAgICAgICAgICAgICAgcGFyYW0gPSB1dGlscy5yaWdodFBhZChwYXJhbSwgc2l6ZSAqIDIpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIC8vIGZvcm1hdCBvZGQtbGVuZ3RoIGJ5dGVzIHRvIGV2ZW4tbGVuZ3RoXG4gICAgICAgIGlmIChwYXJhbS5sZW5ndGggJSAyID09PSAxKSB7XG4gICAgICAgICAgICBwYXJhbSA9ICcweDAnICsgcGFyYW0uc3Vic3RyaW5nKDIpO1xuICAgICAgICB9XG4gICAgfVxuICAgIHJldHVybiBwYXJhbTtcbn07XG4vKipcbiAqIEVuY29kZXMgYSBmdW5jdGlvbiBjYWxsIGZyb20gaXRzIGpzb24gaW50ZXJmYWNlIGFuZCBwYXJhbWV0ZXJzLlxuICpcbiAqIEBtZXRob2QgZW5jb2RlRnVuY3Rpb25DYWxsXG4gKiBAcGFyYW0ge0FycmF5fSBqc29uSW50ZXJmYWNlXG4gKiBAcGFyYW0ge0FycmF5fSBwYXJhbXNcbiAqIEByZXR1cm4ge1N0cmluZ30gVGhlIGVuY29kZWQgQUJJIGZvciB0aGlzIGZ1bmN0aW9uIGNhbGxcbiAqL1xuQUJJQ29kZXIucHJvdG90eXBlLmVuY29kZUZ1bmN0aW9uQ2FsbCA9IGZ1bmN0aW9uIChqc29uSW50ZXJmYWNlLCBwYXJhbXMpIHtcbiAgICByZXR1cm4gdGhpcy5lbmNvZGVGdW5jdGlvblNpZ25hdHVyZShqc29uSW50ZXJmYWNlKSArIHRoaXMuZW5jb2RlUGFyYW1ldGVycyhqc29uSW50ZXJmYWNlLmlucHV0cywgcGFyYW1zKS5yZXBsYWNlKCcweCcsICcnKTtcbn07XG4vKipcbiAqIFNob3VsZCBiZSB1c2VkIHRvIGRlY29kZSBieXRlcyB0byBwbGFpbiBwYXJhbVxuICpcbiAqIEBtZXRob2QgZGVjb2RlUGFyYW1ldGVyXG4gKiBAcGFyYW0ge1N0cmluZ30gdHlwZVxuICogQHBhcmFtIHtTdHJpbmd9IGJ5dGVzXG4gKiBAcmV0dXJuIHtPYmplY3R9IHBsYWluIHBhcmFtXG4gKi9cbkFCSUNvZGVyLnByb3RvdHlwZS5kZWNvZGVQYXJhbWV0ZXIgPSBmdW5jdGlvbiAodHlwZSwgYnl0ZXMpIHtcbiAgICByZXR1cm4gdGhpcy5kZWNvZGVQYXJhbWV0ZXJzKFt0eXBlXSwgYnl0ZXMpWzBdO1xufTtcbi8qKlxuICogU2hvdWxkIGJlIHVzZWQgdG8gZGVjb2RlIGxpc3Qgb2YgcGFyYW1zXG4gKlxuICogQG1ldGhvZCBkZWNvZGVQYXJhbWV0ZXJcbiAqIEBwYXJhbSB7QXJyYXl9IG91dHB1dHNcbiAqIEBwYXJhbSB7U3RyaW5nfSBieXRlc1xuICogQHJldHVybiB7QXJyYXl9IGFycmF5IG9mIHBsYWluIHBhcmFtc1xuICovXG5BQklDb2Rlci5wcm90b3R5cGUuZGVjb2RlUGFyYW1ldGVycyA9IGZ1bmN0aW9uIChvdXRwdXRzLCBieXRlcykge1xuICAgIHJldHVybiB0aGlzLmRlY29kZVBhcmFtZXRlcnNXaXRoKG91dHB1dHMsIGJ5dGVzLCBmYWxzZSk7XG59O1xuLyoqXG4gKiBTaG91bGQgYmUgdXNlZCB0byBkZWNvZGUgbGlzdCBvZiBwYXJhbXNcbiAqXG4gKiBAbWV0aG9kIGRlY29kZVBhcmFtZXRlclxuICogQHBhcmFtIHtBcnJheX0gb3V0cHV0c1xuICogQHBhcmFtIHtTdHJpbmd9IGJ5dGVzXG4gKiBAcGFyYW0ge0Jvb2xlYW59IGxvb3NlXG4gKiBAcmV0dXJuIHtBcnJheX0gYXJyYXkgb2YgcGxhaW4gcGFyYW1zXG4gKi9cbkFCSUNvZGVyLnByb3RvdHlwZS5kZWNvZGVQYXJhbWV0ZXJzV2l0aCA9IGZ1bmN0aW9uIChvdXRwdXRzLCBieXRlcywgbG9vc2UpIHtcbiAgICBpZiAob3V0cHV0cy5sZW5ndGggPiAwICYmICghYnl0ZXMgfHwgYnl0ZXMgPT09ICcweCcgfHwgYnl0ZXMgPT09ICcwWCcpKSB7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcignUmV0dXJuZWQgdmFsdWVzIGFyZW5cXCd0IHZhbGlkLCBkaWQgaXQgcnVuIE91dCBvZiBHYXM/ICcgK1xuICAgICAgICAgICAgJ1lvdSBtaWdodCBhbHNvIHNlZSB0aGlzIGVycm9yIGlmIHlvdSBhcmUgbm90IHVzaW5nIHRoZSAnICtcbiAgICAgICAgICAgICdjb3JyZWN0IEFCSSBmb3IgdGhlIGNvbnRyYWN0IHlvdSBhcmUgcmV0cmlldmluZyBkYXRhIGZyb20sICcgK1xuICAgICAgICAgICAgJ3JlcXVlc3RpbmcgZGF0YSBmcm9tIGEgYmxvY2sgbnVtYmVyIHRoYXQgZG9lcyBub3QgZXhpc3QsICcgK1xuICAgICAgICAgICAgJ29yIHF1ZXJ5aW5nIGEgbm9kZSB3aGljaCBpcyBub3QgZnVsbHkgc3luY2VkLicpO1xuICAgIH1cbiAgICB2YXIgcmVzID0gZXRoZXJzQWJpQ29kZXIuZGVjb2RlKHRoaXMubWFwVHlwZXMob3V0cHV0cyksICcweCcgKyBieXRlcy5yZXBsYWNlKC8weC9pLCAnJyksIGxvb3NlKTtcbiAgICB2YXIgcmV0dXJuVmFsdWUgPSBuZXcgUmVzdWx0KCk7XG4gICAgcmV0dXJuVmFsdWUuX19sZW5ndGhfXyA9IDA7XG4gICAgb3V0cHV0cy5mb3JFYWNoKGZ1bmN0aW9uIChvdXRwdXQsIGkpIHtcbiAgICAgICAgdmFyIGRlY29kZWRWYWx1ZSA9IHJlc1tyZXR1cm5WYWx1ZS5fX2xlbmd0aF9fXTtcbiAgICAgICAgY29uc3QgaXNTdHJpbmdPYmplY3QgPSB0eXBlb2Ygb3V0cHV0ID09PSAnb2JqZWN0JyAmJiBvdXRwdXQudHlwZSAmJiBvdXRwdXQudHlwZSA9PT0gJ3N0cmluZyc7XG4gICAgICAgIGNvbnN0IGlzU3RyaW5nVHlwZSA9IHR5cGVvZiBvdXRwdXQgPT09ICdzdHJpbmcnICYmIG91dHB1dCA9PT0gJ3N0cmluZyc7XG4gICAgICAgIC8vIG9ubHkgY29udmVydCBgMHhgIHRvIG51bGwgaWYgaXQncyBub3Qgc3RyaW5nIHZhbHVlXG4gICAgICAgIGRlY29kZWRWYWx1ZSA9IChkZWNvZGVkVmFsdWUgPT09ICcweCcgJiYgIWlzU3RyaW5nT2JqZWN0ICYmICFpc1N0cmluZ1R5cGUpID8gbnVsbCA6IGRlY29kZWRWYWx1ZTtcbiAgICAgICAgcmV0dXJuVmFsdWVbaV0gPSBkZWNvZGVkVmFsdWU7XG4gICAgICAgIGlmICgodHlwZW9mIG91dHB1dCA9PT0gJ2Z1bmN0aW9uJyB8fCAhIW91dHB1dCAmJiB0eXBlb2Ygb3V0cHV0ID09PSAnb2JqZWN0JykgJiYgb3V0cHV0Lm5hbWUpIHtcbiAgICAgICAgICAgIHJldHVyblZhbHVlW291dHB1dC5uYW1lXSA9IGRlY29kZWRWYWx1ZTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm5WYWx1ZS5fX2xlbmd0aF9fKys7XG4gICAgfSk7XG4gICAgcmV0dXJuIHJldHVyblZhbHVlO1xufTtcbi8qKlxuICogRGVjb2RlcyBldmVudHMgbm9uLSBhbmQgaW5kZXhlZCBwYXJhbWV0ZXJzLlxuICpcbiAqIEBtZXRob2QgZGVjb2RlTG9nXG4gKiBAcGFyYW0ge09iamVjdH0gaW5wdXRzXG4gKiBAcGFyYW0ge1N0cmluZ30gZGF0YVxuICogQHBhcmFtIHtBcnJheX0gdG9waWNzXG4gKiBAcmV0dXJuIHtBcnJheX0gYXJyYXkgb2YgcGxhaW4gcGFyYW1zXG4gKi9cbkFCSUNvZGVyLnByb3RvdHlwZS5kZWNvZGVMb2cgPSBmdW5jdGlvbiAoaW5wdXRzLCBkYXRhLCB0b3BpY3MpIHtcbiAgICB2YXIgX3RoaXMgPSB0aGlzO1xuICAgIHRvcGljcyA9IEFycmF5LmlzQXJyYXkodG9waWNzKSA/IHRvcGljcyA6IFt0b3BpY3NdO1xuICAgIGRhdGEgPSBkYXRhIHx8ICcnO1xuICAgIHZhciBub3RJbmRleGVkSW5wdXRzID0gW107XG4gICAgdmFyIGluZGV4ZWRQYXJhbXMgPSBbXTtcbiAgICB2YXIgdG9waWNDb3VudCA9IDA7XG4gICAgLy8gVE9ETyBjaGVjayBmb3IgYW5vbnltb3VzIGxvZ3M/XG4gICAgaW5wdXRzLmZvckVhY2goZnVuY3Rpb24gKGlucHV0LCBpKSB7XG4gICAgICAgIGlmIChpbnB1dC5pbmRleGVkKSB7XG4gICAgICAgICAgICBpbmRleGVkUGFyYW1zW2ldID0gKFsnYm9vbCcsICdpbnQnLCAndWludCcsICdhZGRyZXNzJywgJ2ZpeGVkJywgJ3VmaXhlZCddLmZpbmQoZnVuY3Rpb24gKHN0YXRpY1R5cGUpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gaW5wdXQudHlwZS5pbmRleE9mKHN0YXRpY1R5cGUpICE9PSAtMTtcbiAgICAgICAgICAgIH0pKSA/IF90aGlzLmRlY29kZVBhcmFtZXRlcihpbnB1dC50eXBlLCB0b3BpY3NbdG9waWNDb3VudF0pIDogdG9waWNzW3RvcGljQ291bnRdO1xuICAgICAgICAgICAgdG9waWNDb3VudCsrO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgbm90SW5kZXhlZElucHV0c1tpXSA9IGlucHV0O1xuICAgICAgICB9XG4gICAgfSk7XG4gICAgdmFyIG5vbkluZGV4ZWREYXRhID0gZGF0YTtcbiAgICB2YXIgbm90SW5kZXhlZFBhcmFtcyA9IChub25JbmRleGVkRGF0YSkgPyB0aGlzLmRlY29kZVBhcmFtZXRlcnNXaXRoKG5vdEluZGV4ZWRJbnB1dHMsIG5vbkluZGV4ZWREYXRhLCB0cnVlKSA6IFtdO1xuICAgIHZhciByZXR1cm5WYWx1ZSA9IG5ldyBSZXN1bHQoKTtcbiAgICByZXR1cm5WYWx1ZS5fX2xlbmd0aF9fID0gMDtcbiAgICBpbnB1dHMuZm9yRWFjaChmdW5jdGlvbiAocmVzLCBpKSB7XG4gICAgICAgIHJldHVyblZhbHVlW2ldID0gKHJlcy50eXBlID09PSAnc3RyaW5nJykgPyAnJyA6IG51bGw7XG4gICAgICAgIGlmICh0eXBlb2Ygbm90SW5kZXhlZFBhcmFtc1tpXSAhPT0gJ3VuZGVmaW5lZCcpIHtcbiAgICAgICAgICAgIHJldHVyblZhbHVlW2ldID0gbm90SW5kZXhlZFBhcmFtc1tpXTtcbiAgICAgICAgfVxuICAgICAgICBpZiAodHlwZW9mIGluZGV4ZWRQYXJhbXNbaV0gIT09ICd1bmRlZmluZWQnKSB7XG4gICAgICAgICAgICByZXR1cm5WYWx1ZVtpXSA9IGluZGV4ZWRQYXJhbXNbaV07XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHJlcy5uYW1lKSB7XG4gICAgICAgICAgICByZXR1cm5WYWx1ZVtyZXMubmFtZV0gPSByZXR1cm5WYWx1ZVtpXTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm5WYWx1ZS5fX2xlbmd0aF9fKys7XG4gICAgfSk7XG4gICAgcmV0dXJuIHJldHVyblZhbHVlO1xufTtcbnZhciBjb2RlciA9IG5ldyBBQklDb2RlcigpO1xubW9kdWxlLmV4cG9ydHMgPSBjb2RlcjtcbiJdLCJuYW1lcyI6W10sImlnbm9yZUxpc3QiOlswXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/web3-eth-abi/lib/index.js\n");

/***/ })

};
;
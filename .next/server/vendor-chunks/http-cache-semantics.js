"use strict";
/*
 * ATTENTION: An "eval-source-map" devtool has been used.
 * This devtool is neither made for production nor for readable output files.
 * It uses "eval()" calls to create a separate source file with attached SourceMaps in the browser devtools.
 * If you are trying to read the output file, select a different devtool (https://webpack.js.org/configuration/devtool/)
 * or disable the default devtool with "devtool: false".
 * If you are looking for production-ready output files, see mode: "production" (https://webpack.js.org/configuration/mode/).
 */
exports.id = "vendor-chunks/http-cache-semantics";
exports.ids = ["vendor-chunks/http-cache-semantics"];
exports.modules = {

/***/ "(ssr)/./node_modules/http-cache-semantics/index.js":
/*!****************************************************!*\
  !*** ./node_modules/http-cache-semantics/index.js ***!
  \****************************************************/
/***/ ((module) => {

eval("\n\n/**\n * @typedef {Object} HttpRequest\n * @property {Record<string, string>} headers - Request headers\n * @property {string} [method] - HTTP method\n * @property {string} [url] - Request URL\n */\n\n/**\n * @typedef {Object} HttpResponse\n * @property {Record<string, string>} headers - Response headers\n * @property {number} [status] - HTTP status code\n */\n\n/**\n * Set of default cacheable status codes per RFC 7231 section 6.1.\n * @type {Set<number>}\n */\nconst statusCodeCacheableByDefault = new Set([\n    200,\n    203,\n    204,\n    206,\n    300,\n    301,\n    308,\n    404,\n    405,\n    410,\n    414,\n    501,\n]);\n\n/**\n * Set of HTTP status codes that the cache implementation understands.\n * Note: This implementation does not understand partial responses (206).\n * @type {Set<number>}\n */\nconst understoodStatuses = new Set([\n    200,\n    203,\n    204,\n    300,\n    301,\n    302,\n    303,\n    307,\n    308,\n    404,\n    405,\n    410,\n    414,\n    501,\n]);\n\n/**\n * Set of HTTP error status codes.\n * @type {Set<number>}\n */\nconst errorStatusCodes = new Set([\n    500,\n    502,\n    503,\n    504,\n]);\n\n/**\n * Object representing hop-by-hop headers that should be removed.\n * @type {Record<string, boolean>}\n */\nconst hopByHopHeaders = {\n    date: true, // included, because we add Age update Date\n    connection: true,\n    'keep-alive': true,\n    'proxy-authenticate': true,\n    'proxy-authorization': true,\n    te: true,\n    trailer: true,\n    'transfer-encoding': true,\n    upgrade: true,\n};\n\n/**\n * Headers that are excluded from revalidation update.\n * @type {Record<string, boolean>}\n */\nconst excludedFromRevalidationUpdate = {\n    // Since the old body is reused, it doesn't make sense to change properties of the body\n    'content-length': true,\n    'content-encoding': true,\n    'transfer-encoding': true,\n    'content-range': true,\n};\n\n/**\n * Converts a string to a number or returns zero if the conversion fails.\n * @param {string} s - The string to convert.\n * @returns {number} The parsed number or 0.\n */\nfunction toNumberOrZero(s) {\n    const n = parseInt(s, 10);\n    return isFinite(n) ? n : 0;\n}\n\n/**\n * Determines if the given response is an error response.\n * Implements RFC 5861 behavior.\n * @param {HttpResponse|undefined} response - The HTTP response object.\n * @returns {boolean} true if the response is an error or undefined, false otherwise.\n */\nfunction isErrorResponse(response) {\n    // consider undefined response as faulty\n    if (!response) {\n        return true;\n    }\n    return errorStatusCodes.has(response.status);\n}\n\n/**\n * Parses a Cache-Control header string into an object.\n * @param {string} [header] - The Cache-Control header value.\n * @returns {Record<string, string|boolean>} An object representing Cache-Control directives.\n */\nfunction parseCacheControl(header) {\n    /** @type {Record<string, string|boolean>} */\n    const cc = {};\n    if (!header) return cc;\n\n    // TODO: When there is more than one value present for a given directive (e.g., two Expires header fields, multiple Cache-Control: max-age directives),\n    // the directive's value is considered invalid. Caches are encouraged to consider responses that have invalid freshness information to be stale\n    const parts = header.trim().split(/,/);\n    for (const part of parts) {\n        const [k, v] = part.split(/=/, 2);\n        cc[k.trim()] = v === undefined ? true : v.trim().replace(/^\"|\"$/g, '');\n    }\n\n    return cc;\n}\n\n/**\n * Formats a Cache-Control directives object into a header string.\n * @param {Record<string, string|boolean>} cc - The Cache-Control directives.\n * @returns {string|undefined} A formatted Cache-Control header string or undefined if empty.\n */\nfunction formatCacheControl(cc) {\n    let parts = [];\n    for (const k in cc) {\n        const v = cc[k];\n        parts.push(v === true ? k : k + '=' + v);\n    }\n    if (!parts.length) {\n        return undefined;\n    }\n    return parts.join(', ');\n}\n\nmodule.exports = class CachePolicy {\n    /**\n     * Creates a new CachePolicy instance.\n     * @param {HttpRequest} req - Incoming client request.\n     * @param {HttpResponse} res - Received server response.\n     * @param {Object} [options={}] - Configuration options.\n     * @param {boolean} [options.shared=true] - Is the cache shared (a public proxy)? `false` for personal browser caches.\n     * @param {number} [options.cacheHeuristic=0.1] - Fallback heuristic (age fraction) for cache duration.\n     * @param {number} [options.immutableMinTimeToLive=86400000] - Minimum TTL for immutable responses in milliseconds.\n     * @param {boolean} [options.ignoreCargoCult=false] - Detect nonsense cache headers, and override them.\n     * @param {any} [options._fromObject] - Internal parameter for deserialization. Do not use.\n     */\n    constructor(\n        req,\n        res,\n        {\n            shared,\n            cacheHeuristic,\n            immutableMinTimeToLive,\n            ignoreCargoCult,\n            _fromObject,\n        } = {}\n    ) {\n        if (_fromObject) {\n            this._fromObject(_fromObject);\n            return;\n        }\n\n        if (!res || !res.headers) {\n            throw Error('Response headers missing');\n        }\n        this._assertRequestHasHeaders(req);\n\n        /** @type {number} Timestamp when the response was received */\n        this._responseTime = this.now();\n        /** @type {boolean} Indicates if the cache is shared */\n        this._isShared = shared !== false;\n        /** @type {boolean} Indicates if legacy cargo cult directives should be ignored */\n        this._ignoreCargoCult = !!ignoreCargoCult;\n        /** @type {number} Heuristic cache fraction */\n        this._cacheHeuristic =\n            undefined !== cacheHeuristic ? cacheHeuristic : 0.1; // 10% matches IE\n        /** @type {number} Minimum TTL for immutable responses in ms */\n        this._immutableMinTtl =\n            undefined !== immutableMinTimeToLive\n                ? immutableMinTimeToLive\n                : 24 * 3600 * 1000;\n\n        /** @type {number} HTTP status code */\n        this._status = 'status' in res ? res.status : 200;\n        /** @type {Record<string, string>} Response headers */\n        this._resHeaders = res.headers;\n        /** @type {Record<string, string|boolean>} Parsed Cache-Control directives from response */\n        this._rescc = parseCacheControl(res.headers['cache-control']);\n        /** @type {string} HTTP method (e.g., GET, POST) */\n        this._method = 'method' in req ? req.method : 'GET';\n        /** @type {string} Request URL */\n        this._url = req.url;\n        /** @type {string} Host header from the request */\n        this._host = req.headers.host;\n        /** @type {boolean} Whether the request does not include an Authorization header */\n        this._noAuthorization = !req.headers.authorization;\n        /** @type {Record<string, string>|null} Request headers used for Vary matching */\n        this._reqHeaders = res.headers.vary ? req.headers : null; // Don't keep all request headers if they won't be used\n        /** @type {Record<string, string|boolean>} Parsed Cache-Control directives from request */\n        this._reqcc = parseCacheControl(req.headers['cache-control']);\n\n        // Assume that if someone uses legacy, non-standard uncecessary options they don't understand caching,\n        // so there's no point stricly adhering to the blindly copy&pasted directives.\n        if (\n            this._ignoreCargoCult &&\n            'pre-check' in this._rescc &&\n            'post-check' in this._rescc\n        ) {\n            delete this._rescc['pre-check'];\n            delete this._rescc['post-check'];\n            delete this._rescc['no-cache'];\n            delete this._rescc['no-store'];\n            delete this._rescc['must-revalidate'];\n            this._resHeaders = Object.assign({}, this._resHeaders, {\n                'cache-control': formatCacheControl(this._rescc),\n            });\n            delete this._resHeaders.expires;\n            delete this._resHeaders.pragma;\n        }\n\n        // When the Cache-Control header field is not present in a request, caches MUST consider the no-cache request pragma-directive\n        // as having the same effect as if \"Cache-Control: no-cache\" were present (see Section 5.2.1).\n        if (\n            res.headers['cache-control'] == null &&\n            /no-cache/.test(res.headers.pragma)\n        ) {\n            this._rescc['no-cache'] = true;\n        }\n    }\n\n    /**\n     * You can monkey-patch it for testing.\n     * @returns {number} Current time in milliseconds.\n     */\n    now() {\n        return Date.now();\n    }\n\n    /**\n     * Determines if the response is storable in a cache.\n     * @returns {boolean} `false` if can never be cached.\n     */\n    storable() {\n        // The \"no-store\" request directive indicates that a cache MUST NOT store any part of either this request or any response to it.\n        return !!(\n            !this._reqcc['no-store'] &&\n            // A cache MUST NOT store a response to any request, unless:\n            // The request method is understood by the cache and defined as being cacheable, and\n            ('GET' === this._method ||\n                'HEAD' === this._method ||\n                ('POST' === this._method && this._hasExplicitExpiration())) &&\n            // the response status code is understood by the cache, and\n            understoodStatuses.has(this._status) &&\n            // the \"no-store\" cache directive does not appear in request or response header fields, and\n            !this._rescc['no-store'] &&\n            // the \"private\" response directive does not appear in the response, if the cache is shared, and\n            (!this._isShared || !this._rescc.private) &&\n            // the Authorization header field does not appear in the request, if the cache is shared,\n            (!this._isShared ||\n                this._noAuthorization ||\n                this._allowsStoringAuthenticated()) &&\n            // the response either:\n            // contains an Expires header field, or\n            (this._resHeaders.expires ||\n                // contains a max-age response directive, or\n                // contains a s-maxage response directive and the cache is shared, or\n                // contains a public response directive.\n                this._rescc['max-age'] ||\n                (this._isShared && this._rescc['s-maxage']) ||\n                this._rescc.public ||\n                // has a status code that is defined as cacheable by default\n                statusCodeCacheableByDefault.has(this._status))\n        );\n    }\n\n    /**\n     * @returns {boolean} true if expiration is explicitly defined.\n     */\n    _hasExplicitExpiration() {\n        // 4.2.1 Calculating Freshness Lifetime\n        return !!(\n            (this._isShared && this._rescc['s-maxage']) ||\n            this._rescc['max-age'] ||\n            this._resHeaders.expires\n        );\n    }\n\n    /**\n     * @param {HttpRequest} req - a request\n     * @throws {Error} if the headers are missing.\n     */\n    _assertRequestHasHeaders(req) {\n        if (!req || !req.headers) {\n            throw Error('Request headers missing');\n        }\n    }\n\n    /**\n     * Checks if the request matches the cache and can be satisfied from the cache immediately,\n     * without having to make a request to the server.\n     *\n     * This doesn't support `stale-while-revalidate`. See `evaluateRequest()` for a more complete solution.\n     *\n     * @param {HttpRequest} req - The new incoming HTTP request.\n     * @returns {boolean} `true`` if the cached response used to construct this cache policy satisfies the request without revalidation.\n     */\n    satisfiesWithoutRevalidation(req) {\n        const result = this.evaluateRequest(req);\n        return !result.revalidation;\n    }\n\n    /**\n     * @param {{headers: Record<string, string>, synchronous: boolean}|undefined} revalidation - Revalidation information, if any.\n     * @returns {{response: {headers: Record<string, string>}, revalidation: {headers: Record<string, string>, synchronous: boolean}|undefined}} An object with a cached response headers and revalidation info.\n     */\n    _evaluateRequestHitResult(revalidation) {\n        return {\n            response: {\n                headers: this.responseHeaders(),\n            },\n            revalidation,\n        };\n    }\n\n    /**\n     * @param {HttpRequest} request - new incoming\n     * @param {boolean} synchronous - whether revalidation must be synchronous (not s-w-r).\n     * @returns {{headers: Record<string, string>, synchronous: boolean}} An object with revalidation headers and a synchronous flag.\n     */\n    _evaluateRequestRevalidation(request, synchronous) {\n        return {\n            synchronous,\n            headers: this.revalidationHeaders(request),\n        };\n    }\n\n    /**\n     * @param {HttpRequest} request - new incoming\n     * @returns {{response: undefined, revalidation: {headers: Record<string, string>, synchronous: boolean}}} An object indicating no cached response and revalidation details.\n     */\n    _evaluateRequestMissResult(request) {\n        return {\n            response: undefined,\n            revalidation: this._evaluateRequestRevalidation(request, true),\n        };\n    }\n\n    /**\n     * Checks if the given request matches this cache entry, and how the cache can be used to satisfy it. Returns an object with:\n     *\n     * ```\n     * {\n     *     // If defined, you must send a request to the server.\n     *     revalidation: {\n     *         headers: {}, // HTTP headers to use when sending the revalidation response\n     *         // If true, you MUST wait for a response from the server before using the cache\n     *         // If false, this is stale-while-revalidate. The cache is stale, but you can use it while you update it asynchronously.\n     *         synchronous: bool,\n     *     },\n     *     // If defined, you can use this cached response.\n     *     response: {\n     *         headers: {}, // Updated cached HTTP headers you must use when responding to the client\n     *     },\n     * }\n     * ```\n     * @param {HttpRequest} req - new incoming HTTP request\n     * @returns {{response: {headers: Record<string, string>}|undefined, revalidation: {headers: Record<string, string>, synchronous: boolean}|undefined}} An object containing keys:\n     *   - revalidation: { headers: Record<string, string>, synchronous: boolean } Set if you should send this to the origin server\n     *   - response: { headers: Record<string, string> } Set if you can respond to the client with these cached headers\n     */\n    evaluateRequest(req) {\n        this._assertRequestHasHeaders(req);\n\n        // In all circumstances, a cache MUST NOT ignore the must-revalidate directive\n        if (this._rescc['must-revalidate']) {\n            return this._evaluateRequestMissResult(req);\n        }\n\n        if (!this._requestMatches(req, false)) {\n            return this._evaluateRequestMissResult(req);\n        }\n\n        // When presented with a request, a cache MUST NOT reuse a stored response, unless:\n        // the presented request does not contain the no-cache pragma (Section 5.4), nor the no-cache cache directive,\n        // unless the stored response is successfully validated (Section 4.3), and\n        const requestCC = parseCacheControl(req.headers['cache-control']);\n\n        if (requestCC['no-cache'] || /no-cache/.test(req.headers.pragma)) {\n            return this._evaluateRequestMissResult(req);\n        }\n\n        if (requestCC['max-age'] && this.age() > toNumberOrZero(requestCC['max-age'])) {\n            return this._evaluateRequestMissResult(req);\n        }\n\n        if (requestCC['min-fresh'] && this.maxAge() - this.age() < toNumberOrZero(requestCC['min-fresh'])) {\n            return this._evaluateRequestMissResult(req);\n        }\n\n        // the stored response is either:\n        // fresh, or allowed to be served stale\n        if (this.stale()) {\n            // If a value is present, then the client is willing to accept a response that has\n            // exceeded its freshness lifetime by no more than the specified number of seconds\n            const allowsStaleWithoutRevalidation = 'max-stale' in requestCC &&\n                (true === requestCC['max-stale'] || requestCC['max-stale'] > this.age() - this.maxAge());\n\n            if (allowsStaleWithoutRevalidation) {\n                return this._evaluateRequestHitResult(undefined);\n            }\n\n            if (this.useStaleWhileRevalidate()) {\n                return this._evaluateRequestHitResult(this._evaluateRequestRevalidation(req, false));\n            }\n\n            return this._evaluateRequestMissResult(req);\n        }\n\n        return this._evaluateRequestHitResult(undefined);\n    }\n\n    /**\n     * @param {HttpRequest} req - check if this is for the same cache entry\n     * @param {boolean} allowHeadMethod - allow a HEAD method to match.\n     * @returns {boolean} `true` if the request matches.\n     */\n    _requestMatches(req, allowHeadMethod) {\n        // The presented effective request URI and that of the stored response match, and\n        return !!(\n            (!this._url || this._url === req.url) &&\n            this._host === req.headers.host &&\n            // the request method associated with the stored response allows it to be used for the presented request, and\n            (!req.method ||\n                this._method === req.method ||\n                (allowHeadMethod && 'HEAD' === req.method)) &&\n            // selecting header fields nominated by the stored response (if any) match those presented, and\n            this._varyMatches(req)\n        );\n    }\n\n    /**\n     * Determines whether storing authenticated responses is allowed.\n     * @returns {boolean} `true` if allowed.\n     */\n    _allowsStoringAuthenticated() {\n        // following Cache-Control response directives (Section 5.2.2) have such an effect: must-revalidate, public, and s-maxage.\n        return !!(\n            this._rescc['must-revalidate'] ||\n            this._rescc.public ||\n            this._rescc['s-maxage']\n        );\n    }\n\n    /**\n     * Checks whether the Vary header in the response matches the new request.\n     * @param {HttpRequest} req - incoming HTTP request\n     * @returns {boolean} `true` if the vary headers match.\n     */\n    _varyMatches(req) {\n        if (!this._resHeaders.vary) {\n            return true;\n        }\n\n        // A Vary header field-value of \"*\" always fails to match\n        if (this._resHeaders.vary === '*') {\n            return false;\n        }\n\n        const fields = this._resHeaders.vary\n            .trim()\n            .toLowerCase()\n            .split(/\\s*,\\s*/);\n        for (const name of fields) {\n            if (req.headers[name] !== this._reqHeaders[name]) return false;\n        }\n        return true;\n    }\n\n    /**\n     * Creates a copy of the given headers without any hop-by-hop headers.\n     * @param {Record<string, string>} inHeaders - old headers from the cached response\n     * @returns {Record<string, string>} A new headers object without hop-by-hop headers.\n     */\n    _copyWithoutHopByHopHeaders(inHeaders) {\n        /** @type {Record<string, string>} */\n        const headers = {};\n        for (const name in inHeaders) {\n            if (hopByHopHeaders[name]) continue;\n            headers[name] = inHeaders[name];\n        }\n        // 9.1.  Connection\n        if (inHeaders.connection) {\n            const tokens = inHeaders.connection.trim().split(/\\s*,\\s*/);\n            for (const name of tokens) {\n                delete headers[name];\n            }\n        }\n        if (headers.warning) {\n            const warnings = headers.warning.split(/,/).filter(warning => {\n                return !/^\\s*1[0-9][0-9]/.test(warning);\n            });\n            if (!warnings.length) {\n                delete headers.warning;\n            } else {\n                headers.warning = warnings.join(',').trim();\n            }\n        }\n        return headers;\n    }\n\n    /**\n     * Returns the response headers adjusted for serving the cached response.\n     * Removes hop-by-hop headers and updates the Age and Date headers.\n     * @returns {Record<string, string>} The adjusted response headers.\n     */\n    responseHeaders() {\n        const headers = this._copyWithoutHopByHopHeaders(this._resHeaders);\n        const age = this.age();\n\n        // A cache SHOULD generate 113 warning if it heuristically chose a freshness\n        // lifetime greater than 24 hours and the response's age is greater than 24 hours.\n        if (\n            age > 3600 * 24 &&\n            !this._hasExplicitExpiration() &&\n            this.maxAge() > 3600 * 24\n        ) {\n            headers.warning =\n                (headers.warning ? `${headers.warning}, ` : '') +\n                '113 - \"rfc7234 5.5.4\"';\n        }\n        headers.age = `${Math.round(age)}`;\n        headers.date = new Date(this.now()).toUTCString();\n        return headers;\n    }\n\n    /**\n     * Returns the Date header value from the response or the current time if invalid.\n     * @returns {number} Timestamp (in milliseconds) representing the Date header or response time.\n     */\n    date() {\n        const serverDate = Date.parse(this._resHeaders.date);\n        if (isFinite(serverDate)) {\n            return serverDate;\n        }\n        return this._responseTime;\n    }\n\n    /**\n     * Value of the Age header, in seconds, updated for the current time.\n     * May be fractional.\n     * @returns {number} The age in seconds.\n     */\n    age() {\n        let age = this._ageValue();\n\n        const residentTime = (this.now() - this._responseTime) / 1000;\n        return age + residentTime;\n    }\n\n    /**\n     * @returns {number} The Age header value as a number.\n     */\n    _ageValue() {\n        return toNumberOrZero(this._resHeaders.age);\n    }\n\n    /**\n     * Possibly outdated value of applicable max-age (or heuristic equivalent) in seconds.\n     * This counts since response's `Date`.\n     *\n     * For an up-to-date value, see `timeToLive()`.\n     *\n     * Returns the maximum age (freshness lifetime) of the response in seconds.\n     * @returns {number} The max-age value in seconds.\n     */\n    maxAge() {\n        if (!this.storable() || this._rescc['no-cache']) {\n            return 0;\n        }\n\n        // Shared responses with cookies are cacheable according to the RFC, but IMHO it'd be unwise to do so by default\n        // so this implementation requires explicit opt-in via public header\n        if (\n            this._isShared &&\n            (this._resHeaders['set-cookie'] &&\n                !this._rescc.public &&\n                !this._rescc.immutable)\n        ) {\n            return 0;\n        }\n\n        if (this._resHeaders.vary === '*') {\n            return 0;\n        }\n\n        if (this._isShared) {\n            if (this._rescc['proxy-revalidate']) {\n                return 0;\n            }\n            // if a response includes the s-maxage directive, a shared cache recipient MUST ignore the Expires field.\n            if (this._rescc['s-maxage']) {\n                return toNumberOrZero(this._rescc['s-maxage']);\n            }\n        }\n\n        // If a response includes a Cache-Control field with the max-age directive, a recipient MUST ignore the Expires field.\n        if (this._rescc['max-age']) {\n            return toNumberOrZero(this._rescc['max-age']);\n        }\n\n        const defaultMinTtl = this._rescc.immutable ? this._immutableMinTtl : 0;\n\n        const serverDate = this.date();\n        if (this._resHeaders.expires) {\n            const expires = Date.parse(this._resHeaders.expires);\n            // A cache recipient MUST interpret invalid date formats, especially the value \"0\", as representing a time in the past (i.e., \"already expired\").\n            if (Number.isNaN(expires) || expires < serverDate) {\n                return 0;\n            }\n            return Math.max(defaultMinTtl, (expires - serverDate) / 1000);\n        }\n\n        if (this._resHeaders['last-modified']) {\n            const lastModified = Date.parse(this._resHeaders['last-modified']);\n            if (isFinite(lastModified) && serverDate > lastModified) {\n                return Math.max(\n                    defaultMinTtl,\n                    ((serverDate - lastModified) / 1000) * this._cacheHeuristic\n                );\n            }\n        }\n\n        return defaultMinTtl;\n    }\n\n    /**\n     * Remaining time this cache entry may be useful for, in *milliseconds*.\n     * You can use this as an expiration time for your cache storage.\n     *\n     * Prefer this method over `maxAge()`, because it includes other factors like `age` and `stale-while-revalidate`.\n     * @returns {number} Time-to-live in milliseconds.\n     */\n    timeToLive() {\n        const age = this.maxAge() - this.age();\n        const staleIfErrorAge = age + toNumberOrZero(this._rescc['stale-if-error']);\n        const staleWhileRevalidateAge = age + toNumberOrZero(this._rescc['stale-while-revalidate']);\n        return Math.round(Math.max(0, age, staleIfErrorAge, staleWhileRevalidateAge) * 1000);\n    }\n\n    /**\n     * If true, this cache entry is past its expiration date.\n     * Note that stale cache may be useful sometimes, see `evaluateRequest()`.\n     * @returns {boolean} `false` doesn't mean it's fresh nor usable\n     */\n    stale() {\n        return this.maxAge() <= this.age();\n    }\n\n    /**\n     * @returns {boolean} `true` if `stale-if-error` condition allows use of a stale response.\n     */\n    _useStaleIfError() {\n        return this.maxAge() + toNumberOrZero(this._rescc['stale-if-error']) > this.age();\n    }\n\n    /** See `evaluateRequest()` for a more complete solution\n     * @returns {boolean} `true` if `stale-while-revalidate` is currently allowed.\n     */\n    useStaleWhileRevalidate() {\n        const swr = toNumberOrZero(this._rescc['stale-while-revalidate']);\n        return swr > 0 && this.maxAge() + swr > this.age();\n    }\n\n    /**\n     * Creates a `CachePolicy` instance from a serialized object.\n     * @param {Object} obj - The serialized object.\n     * @returns {CachePolicy} A new CachePolicy instance.\n     */\n    static fromObject(obj) {\n        return new this(undefined, undefined, { _fromObject: obj });\n    }\n\n    /**\n     * @param {any} obj - The serialized object.\n     * @throws {Error} If already initialized or if the object is invalid.\n     */\n    _fromObject(obj) {\n        if (this._responseTime) throw Error('Reinitialized');\n        if (!obj || obj.v !== 1) throw Error('Invalid serialization');\n\n        this._responseTime = obj.t;\n        this._isShared = obj.sh;\n        this._cacheHeuristic = obj.ch;\n        this._immutableMinTtl =\n            obj.imm !== undefined ? obj.imm : 24 * 3600 * 1000;\n        this._ignoreCargoCult = !!obj.icc;\n        this._status = obj.st;\n        this._resHeaders = obj.resh;\n        this._rescc = obj.rescc;\n        this._method = obj.m;\n        this._url = obj.u;\n        this._host = obj.h;\n        this._noAuthorization = obj.a;\n        this._reqHeaders = obj.reqh;\n        this._reqcc = obj.reqcc;\n    }\n\n    /**\n     * Serializes the `CachePolicy` instance into a JSON-serializable object.\n     * @returns {Object} The serialized object.\n     */\n    toObject() {\n        return {\n            v: 1,\n            t: this._responseTime,\n            sh: this._isShared,\n            ch: this._cacheHeuristic,\n            imm: this._immutableMinTtl,\n            icc: this._ignoreCargoCult,\n            st: this._status,\n            resh: this._resHeaders,\n            rescc: this._rescc,\n            m: this._method,\n            u: this._url,\n            h: this._host,\n            a: this._noAuthorization,\n            reqh: this._reqHeaders,\n            reqcc: this._reqcc,\n        };\n    }\n\n    /**\n     * Headers for sending to the origin server to revalidate stale response.\n     * Allows server to return 304 to allow reuse of the previous response.\n     *\n     * Hop by hop headers are always stripped.\n     * Revalidation headers may be added or removed, depending on request.\n     * @param {HttpRequest} incomingReq - The incoming HTTP request.\n     * @returns {Record<string, string>} The headers for the revalidation request.\n     */\n    revalidationHeaders(incomingReq) {\n        this._assertRequestHasHeaders(incomingReq);\n        const headers = this._copyWithoutHopByHopHeaders(incomingReq.headers);\n\n        // This implementation does not understand range requests\n        delete headers['if-range'];\n\n        if (!this._requestMatches(incomingReq, true) || !this.storable()) {\n            // revalidation allowed via HEAD\n            // not for the same resource, or wasn't allowed to be cached anyway\n            delete headers['if-none-match'];\n            delete headers['if-modified-since'];\n            return headers;\n        }\n\n        /* MUST send that entity-tag in any cache validation request (using If-Match or If-None-Match) if an entity-tag has been provided by the origin server. */\n        if (this._resHeaders.etag) {\n            headers['if-none-match'] = headers['if-none-match']\n                ? `${headers['if-none-match']}, ${this._resHeaders.etag}`\n                : this._resHeaders.etag;\n        }\n\n        // Clients MAY issue simple (non-subrange) GET requests with either weak validators or strong validators. Clients MUST NOT use weak validators in other forms of request.\n        const forbidsWeakValidators =\n            headers['accept-ranges'] ||\n            headers['if-match'] ||\n            headers['if-unmodified-since'] ||\n            (this._method && this._method != 'GET');\n\n        /* SHOULD send the Last-Modified value in non-subrange cache validation requests (using If-Modified-Since) if only a Last-Modified value has been provided by the origin server.\n        Note: This implementation does not understand partial responses (206) */\n        if (forbidsWeakValidators) {\n            delete headers['if-modified-since'];\n\n            if (headers['if-none-match']) {\n                const etags = headers['if-none-match']\n                    .split(/,/)\n                    .filter(etag => {\n                        return !/^\\s*W\\//.test(etag);\n                    });\n                if (!etags.length) {\n                    delete headers['if-none-match'];\n                } else {\n                    headers['if-none-match'] = etags.join(',').trim();\n                }\n            }\n        } else if (\n            this._resHeaders['last-modified'] &&\n            !headers['if-modified-since']\n        ) {\n            headers['if-modified-since'] = this._resHeaders['last-modified'];\n        }\n\n        return headers;\n    }\n\n    /**\n     * Creates new CachePolicy with information combined from the previews response,\n     * and the new revalidation response.\n     *\n     * Returns {policy, modified} where modified is a boolean indicating\n     * whether the response body has been modified, and old cached body can't be used.\n     *\n     * @param {HttpRequest} request - The latest HTTP request asking for the cached entry.\n     * @param {HttpResponse} response - The latest revalidation HTTP response from the origin server.\n     * @returns {{policy: CachePolicy, modified: boolean, matches: boolean}} The updated policy and modification status.\n     * @throws {Error} If the response headers are missing.\n     */\n    revalidatedPolicy(request, response) {\n        this._assertRequestHasHeaders(request);\n\n        if (this._useStaleIfError() && isErrorResponse(response)) {\n          return {\n              policy: this,\n              modified: false,\n              matches: true,\n          };\n        }\n\n        if (!response || !response.headers) {\n            throw Error('Response headers missing');\n        }\n\n        // These aren't going to be supported exactly, since one CachePolicy object\n        // doesn't know about all the other cached objects.\n        let matches = false;\n        if (response.status !== undefined && response.status != 304) {\n            matches = false;\n        } else if (\n            response.headers.etag &&\n            !/^\\s*W\\//.test(response.headers.etag)\n        ) {\n            // \"All of the stored responses with the same strong validator are selected.\n            // If none of the stored responses contain the same strong validator,\n            // then the cache MUST NOT use the new response to update any stored responses.\"\n            matches =\n                this._resHeaders.etag &&\n                this._resHeaders.etag.replace(/^\\s*W\\//, '') ===\n                    response.headers.etag;\n        } else if (this._resHeaders.etag && response.headers.etag) {\n            // \"If the new response contains a weak validator and that validator corresponds\n            // to one of the cache's stored responses,\n            // then the most recent of those matching stored responses is selected for update.\"\n            matches =\n                this._resHeaders.etag.replace(/^\\s*W\\//, '') ===\n                response.headers.etag.replace(/^\\s*W\\//, '');\n        } else if (this._resHeaders['last-modified']) {\n            matches =\n                this._resHeaders['last-modified'] ===\n                response.headers['last-modified'];\n        } else {\n            // If the new response does not include any form of validator (such as in the case where\n            // a client generates an If-Modified-Since request from a source other than the Last-Modified\n            // response header field), and there is only one stored response, and that stored response also\n            // lacks a validator, then that stored response is selected for update.\n            if (\n                !this._resHeaders.etag &&\n                !this._resHeaders['last-modified'] &&\n                !response.headers.etag &&\n                !response.headers['last-modified']\n            ) {\n                matches = true;\n            }\n        }\n\n        const optionsCopy = {\n            shared: this._isShared,\n            cacheHeuristic: this._cacheHeuristic,\n            immutableMinTimeToLive: this._immutableMinTtl,\n            ignoreCargoCult: this._ignoreCargoCult,\n        };\n\n        if (!matches) {\n            return {\n                policy: new this.constructor(request, response, optionsCopy),\n                // Client receiving 304 without body, even if it's invalid/mismatched has no option\n                // but to reuse a cached body. We don't have a good way to tell clients to do\n                // error recovery in such case.\n                modified: response.status != 304,\n                matches: false,\n            };\n        }\n\n        // use other header fields provided in the 304 (Not Modified) response to replace all instances\n        // of the corresponding header fields in the stored response.\n        const headers = {};\n        for (const k in this._resHeaders) {\n            headers[k] =\n                k in response.headers && !excludedFromRevalidationUpdate[k]\n                    ? response.headers[k]\n                    : this._resHeaders[k];\n        }\n\n        const newResponse = Object.assign({}, response, {\n            status: this._status,\n            method: this._method,\n            headers,\n        });\n        return {\n            policy: new this.constructor(request, newResponse, optionsCopy),\n            modified: false,\n            matches: true,\n        };\n    }\n};\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvaHR0cC1jYWNoZS1zZW1hbnRpY3MvaW5kZXguanMiLCJtYXBwaW5ncyI6IkFBQWE7O0FBRWI7QUFDQSxhQUFhLFFBQVE7QUFDckIsY0FBYyx3QkFBd0I7QUFDdEMsY0FBYyxRQUFRO0FBQ3RCLGNBQWMsUUFBUTtBQUN0Qjs7QUFFQTtBQUNBLGFBQWEsUUFBUTtBQUNyQixjQUFjLHdCQUF3QjtBQUN0QyxjQUFjLFFBQVE7QUFDdEI7O0FBRUE7QUFDQTtBQUNBLFVBQVU7QUFDVjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsVUFBVTtBQUNWO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLFVBQVU7QUFDVjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsVUFBVTtBQUNWO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsVUFBVTtBQUNWO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLFdBQVcsUUFBUTtBQUNuQixhQUFhLFFBQVE7QUFDckI7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxXQUFXLHdCQUF3QjtBQUNuQyxhQUFhLFNBQVM7QUFDdEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsV0FBVyxRQUFRO0FBQ25CLGFBQWEsZ0NBQWdDO0FBQzdDO0FBQ0E7QUFDQSxlQUFlLGdDQUFnQztBQUMvQztBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7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Q0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsVUFBVTtBQUNWO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFVBQVU7QUFDVjtBQUNBO0FBQ0E7QUFDQSxVQUFVO0FBQ1Y7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQSw0Q0FBNEM7QUFDNUM7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBIiwic291cmNlcyI6WyIvVXNlcnMvcGFuemEvRG9jdW1lbnRzL1BlcnNvbmFsUHJvamVjdHMvcHJlZGlrL25vZGVfbW9kdWxlcy9odHRwLWNhY2hlLXNlbWFudGljcy9pbmRleC5qcyJdLCJzb3VyY2VzQ29udGVudCI6WyIndXNlIHN0cmljdCc7XG5cbi8qKlxuICogQHR5cGVkZWYge09iamVjdH0gSHR0cFJlcXVlc3RcbiAqIEBwcm9wZXJ0eSB7UmVjb3JkPHN0cmluZywgc3RyaW5nPn0gaGVhZGVycyAtIFJlcXVlc3QgaGVhZGVyc1xuICogQHByb3BlcnR5IHtzdHJpbmd9IFttZXRob2RdIC0gSFRUUCBtZXRob2RcbiAqIEBwcm9wZXJ0eSB7c3RyaW5nfSBbdXJsXSAtIFJlcXVlc3QgVVJMXG4gKi9cblxuLyoqXG4gKiBAdHlwZWRlZiB7T2JqZWN0fSBIdHRwUmVzcG9uc2VcbiAqIEBwcm9wZXJ0eSB7UmVjb3JkPHN0cmluZywgc3RyaW5nPn0gaGVhZGVycyAtIFJlc3BvbnNlIGhlYWRlcnNcbiAqIEBwcm9wZXJ0eSB7bnVtYmVyfSBbc3RhdHVzXSAtIEhUVFAgc3RhdHVzIGNvZGVcbiAqL1xuXG4vKipcbiAqIFNldCBvZiBkZWZhdWx0IGNhY2hlYWJsZSBzdGF0dXMgY29kZXMgcGVyIFJGQyA3MjMxIHNlY3Rpb24gNi4xLlxuICogQHR5cGUge1NldDxudW1iZXI+fVxuICovXG5jb25zdCBzdGF0dXNDb2RlQ2FjaGVhYmxlQnlEZWZhdWx0ID0gbmV3IFNldChbXG4gICAgMjAwLFxuICAgIDIwMyxcbiAgICAyMDQsXG4gICAgMjA2LFxuICAgIDMwMCxcbiAgICAzMDEsXG4gICAgMzA4LFxuICAgIDQwNCxcbiAgICA0MDUsXG4gICAgNDEwLFxuICAgIDQxNCxcbiAgICA1MDEsXG5dKTtcblxuLyoqXG4gKiBTZXQgb2YgSFRUUCBzdGF0dXMgY29kZXMgdGhhdCB0aGUgY2FjaGUgaW1wbGVtZW50YXRpb24gdW5kZXJzdGFuZHMuXG4gKiBOb3RlOiBUaGlzIGltcGxlbWVudGF0aW9uIGRvZXMgbm90IHVuZGVyc3RhbmQgcGFydGlhbCByZXNwb25zZXMgKDIwNikuXG4gKiBAdHlwZSB7U2V0PG51bWJlcj59XG4gKi9cbmNvbnN0IHVuZGVyc3Rvb2RTdGF0dXNlcyA9IG5ldyBTZXQoW1xuICAgIDIwMCxcbiAgICAyMDMsXG4gICAgMjA0LFxuICAgIDMwMCxcbiAgICAzMDEsXG4gICAgMzAyLFxuICAgIDMwMyxcbiAgICAzMDcsXG4gICAgMzA4LFxuICAgIDQwNCxcbiAgICA0MDUsXG4gICAgNDEwLFxuICAgIDQxNCxcbiAgICA1MDEsXG5dKTtcblxuLyoqXG4gKiBTZXQgb2YgSFRUUCBlcnJvciBzdGF0dXMgY29kZXMuXG4gKiBAdHlwZSB7U2V0PG51bWJlcj59XG4gKi9cbmNvbnN0IGVycm9yU3RhdHVzQ29kZXMgPSBuZXcgU2V0KFtcbiAgICA1MDAsXG4gICAgNTAyLFxuICAgIDUwMyxcbiAgICA1MDQsXG5dKTtcblxuLyoqXG4gKiBPYmplY3QgcmVwcmVzZW50aW5nIGhvcC1ieS1ob3AgaGVhZGVycyB0aGF0IHNob3VsZCBiZSByZW1vdmVkLlxuICogQHR5cGUge1JlY29yZDxzdHJpbmcsIGJvb2xlYW4+fVxuICovXG5jb25zdCBob3BCeUhvcEhlYWRlcnMgPSB7XG4gICAgZGF0ZTogdHJ1ZSwgLy8gaW5jbHVkZWQsIGJlY2F1c2Ugd2UgYWRkIEFnZSB1cGRhdGUgRGF0ZVxuICAgIGNvbm5lY3Rpb246IHRydWUsXG4gICAgJ2tlZXAtYWxpdmUnOiB0cnVlLFxuICAgICdwcm94eS1hdXRoZW50aWNhdGUnOiB0cnVlLFxuICAgICdwcm94eS1hdXRob3JpemF0aW9uJzogdHJ1ZSxcbiAgICB0ZTogdHJ1ZSxcbiAgICB0cmFpbGVyOiB0cnVlLFxuICAgICd0cmFuc2Zlci1lbmNvZGluZyc6IHRydWUsXG4gICAgdXBncmFkZTogdHJ1ZSxcbn07XG5cbi8qKlxuICogSGVhZGVycyB0aGF0IGFyZSBleGNsdWRlZCBmcm9tIHJldmFsaWRhdGlvbiB1cGRhdGUuXG4gKiBAdHlwZSB7UmVjb3JkPHN0cmluZywgYm9vbGVhbj59XG4gKi9cbmNvbnN0IGV4Y2x1ZGVkRnJvbVJldmFsaWRhdGlvblVwZGF0ZSA9IHtcbiAgICAvLyBTaW5jZSB0aGUgb2xkIGJvZHkgaXMgcmV1c2VkLCBpdCBkb2Vzbid0IG1ha2Ugc2Vuc2UgdG8gY2hhbmdlIHByb3BlcnRpZXMgb2YgdGhlIGJvZHlcbiAgICAnY29udGVudC1sZW5ndGgnOiB0cnVlLFxuICAgICdjb250ZW50LWVuY29kaW5nJzogdHJ1ZSxcbiAgICAndHJhbnNmZXItZW5jb2RpbmcnOiB0cnVlLFxuICAgICdjb250ZW50LXJhbmdlJzogdHJ1ZSxcbn07XG5cbi8qKlxuICogQ29udmVydHMgYSBzdHJpbmcgdG8gYSBudW1iZXIgb3IgcmV0dXJucyB6ZXJvIGlmIHRoZSBjb252ZXJzaW9uIGZhaWxzLlxuICogQHBhcmFtIHtzdHJpbmd9IHMgLSBUaGUgc3RyaW5nIHRvIGNvbnZlcnQuXG4gKiBAcmV0dXJucyB7bnVtYmVyfSBUaGUgcGFyc2VkIG51bWJlciBvciAwLlxuICovXG5mdW5jdGlvbiB0b051bWJlck9yWmVybyhzKSB7XG4gICAgY29uc3QgbiA9IHBhcnNlSW50KHMsIDEwKTtcbiAgICByZXR1cm4gaXNGaW5pdGUobikgPyBuIDogMDtcbn1cblxuLyoqXG4gKiBEZXRlcm1pbmVzIGlmIHRoZSBnaXZlbiByZXNwb25zZSBpcyBhbiBlcnJvciByZXNwb25zZS5cbiAqIEltcGxlbWVudHMgUkZDIDU4NjEgYmVoYXZpb3IuXG4gKiBAcGFyYW0ge0h0dHBSZXNwb25zZXx1bmRlZmluZWR9IHJlc3BvbnNlIC0gVGhlIEhUVFAgcmVzcG9uc2Ugb2JqZWN0LlxuICogQHJldHVybnMge2Jvb2xlYW59IHRydWUgaWYgdGhlIHJlc3BvbnNlIGlzIGFuIGVycm9yIG9yIHVuZGVmaW5lZCwgZmFsc2Ugb3RoZXJ3aXNlLlxuICovXG5mdW5jdGlvbiBpc0Vycm9yUmVzcG9uc2UocmVzcG9uc2UpIHtcbiAgICAvLyBjb25zaWRlciB1bmRlZmluZWQgcmVzcG9uc2UgYXMgZmF1bHR5XG4gICAgaWYgKCFyZXNwb25zZSkge1xuICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICB9XG4gICAgcmV0dXJuIGVycm9yU3RhdHVzQ29kZXMuaGFzKHJlc3BvbnNlLnN0YXR1cyk7XG59XG5cbi8qKlxuICogUGFyc2VzIGEgQ2FjaGUtQ29udHJvbCBoZWFkZXIgc3RyaW5nIGludG8gYW4gb2JqZWN0LlxuICogQHBhcmFtIHtzdHJpbmd9IFtoZWFkZXJdIC0gVGhlIENhY2hlLUNvbnRyb2wgaGVhZGVyIHZhbHVlLlxuICogQHJldHVybnMge1JlY29yZDxzdHJpbmcsIHN0cmluZ3xib29sZWFuPn0gQW4gb2JqZWN0IHJlcHJlc2VudGluZyBDYWNoZS1Db250cm9sIGRpcmVjdGl2ZXMuXG4gKi9cbmZ1bmN0aW9uIHBhcnNlQ2FjaGVDb250cm9sKGhlYWRlcikge1xuICAgIC8qKiBAdHlwZSB7UmVjb3JkPHN0cmluZywgc3RyaW5nfGJvb2xlYW4+fSAqL1xuICAgIGNvbnN0IGNjID0ge307XG4gICAgaWYgKCFoZWFkZXIpIHJldHVybiBjYztcblxuICAgIC8vIFRPRE86IFdoZW4gdGhlcmUgaXMgbW9yZSB0aGFuIG9uZSB2YWx1ZSBwcmVzZW50IGZvciBhIGdpdmVuIGRpcmVjdGl2ZSAoZS5nLiwgdHdvIEV4cGlyZXMgaGVhZGVyIGZpZWxkcywgbXVsdGlwbGUgQ2FjaGUtQ29udHJvbDogbWF4LWFnZSBkaXJlY3RpdmVzKSxcbiAgICAvLyB0aGUgZGlyZWN0aXZlJ3MgdmFsdWUgaXMgY29uc2lkZXJlZCBpbnZhbGlkLiBDYWNoZXMgYXJlIGVuY291cmFnZWQgdG8gY29uc2lkZXIgcmVzcG9uc2VzIHRoYXQgaGF2ZSBpbnZhbGlkIGZyZXNobmVzcyBpbmZvcm1hdGlvbiB0byBiZSBzdGFsZVxuICAgIGNvbnN0IHBhcnRzID0gaGVhZGVyLnRyaW0oKS5zcGxpdCgvLC8pO1xuICAgIGZvciAoY29uc3QgcGFydCBvZiBwYXJ0cykge1xuICAgICAgICBjb25zdCBbaywgdl0gPSBwYXJ0LnNwbGl0KC89LywgMik7XG4gICAgICAgIGNjW2sudHJpbSgpXSA9IHYgPT09IHVuZGVmaW5lZCA/IHRydWUgOiB2LnRyaW0oKS5yZXBsYWNlKC9eXCJ8XCIkL2csICcnKTtcbiAgICB9XG5cbiAgICByZXR1cm4gY2M7XG59XG5cbi8qKlxuICogRm9ybWF0cyBhIENhY2hlLUNvbnRyb2wgZGlyZWN0aXZlcyBvYmplY3QgaW50byBhIGhlYWRlciBzdHJpbmcuXG4gKiBAcGFyYW0ge1JlY29yZDxzdHJpbmcsIHN0cmluZ3xib29sZWFuPn0gY2MgLSBUaGUgQ2FjaGUtQ29udHJvbCBkaXJlY3RpdmVzLlxuICogQHJldHVybnMge3N0cmluZ3x1bmRlZmluZWR9IEEgZm9ybWF0dGVkIENhY2hlLUNvbnRyb2wgaGVhZGVyIHN0cmluZyBvciB1bmRlZmluZWQgaWYgZW1wdHkuXG4gKi9cbmZ1bmN0aW9uIGZvcm1hdENhY2hlQ29udHJvbChjYykge1xuICAgIGxldCBwYXJ0cyA9IFtdO1xuICAgIGZvciAoY29uc3QgayBpbiBjYykge1xuICAgICAgICBjb25zdCB2ID0gY2Nba107XG4gICAgICAgIHBhcnRzLnB1c2godiA9PT0gdHJ1ZSA/IGsgOiBrICsgJz0nICsgdik7XG4gICAgfVxuICAgIGlmICghcGFydHMubGVuZ3RoKSB7XG4gICAgICAgIHJldHVybiB1bmRlZmluZWQ7XG4gICAgfVxuICAgIHJldHVybiBwYXJ0cy5qb2luKCcsICcpO1xufVxuXG5tb2R1bGUuZXhwb3J0cyA9IGNsYXNzIENhY2hlUG9saWN5IHtcbiAgICAvKipcbiAgICAgKiBDcmVhdGVzIGEgbmV3IENhY2hlUG9saWN5IGluc3RhbmNlLlxuICAgICAqIEBwYXJhbSB7SHR0cFJlcXVlc3R9IHJlcSAtIEluY29taW5nIGNsaWVudCByZXF1ZXN0LlxuICAgICAqIEBwYXJhbSB7SHR0cFJlc3BvbnNlfSByZXMgLSBSZWNlaXZlZCBzZXJ2ZXIgcmVzcG9uc2UuXG4gICAgICogQHBhcmFtIHtPYmplY3R9IFtvcHRpb25zPXt9XSAtIENvbmZpZ3VyYXRpb24gb3B0aW9ucy5cbiAgICAgKiBAcGFyYW0ge2Jvb2xlYW59IFtvcHRpb25zLnNoYXJlZD10cnVlXSAtIElzIHRoZSBjYWNoZSBzaGFyZWQgKGEgcHVibGljIHByb3h5KT8gYGZhbHNlYCBmb3IgcGVyc29uYWwgYnJvd3NlciBjYWNoZXMuXG4gICAgICogQHBhcmFtIHtudW1iZXJ9IFtvcHRpb25zLmNhY2hlSGV1cmlzdGljPTAuMV0gLSBGYWxsYmFjayBoZXVyaXN0aWMgKGFnZSBmcmFjdGlvbikgZm9yIGNhY2hlIGR1cmF0aW9uLlxuICAgICAqIEBwYXJhbSB7bnVtYmVyfSBbb3B0aW9ucy5pbW11dGFibGVNaW5UaW1lVG9MaXZlPTg2NDAwMDAwXSAtIE1pbmltdW0gVFRMIGZvciBpbW11dGFibGUgcmVzcG9uc2VzIGluIG1pbGxpc2Vjb25kcy5cbiAgICAgKiBAcGFyYW0ge2Jvb2xlYW59IFtvcHRpb25zLmlnbm9yZUNhcmdvQ3VsdD1mYWxzZV0gLSBEZXRlY3Qgbm9uc2Vuc2UgY2FjaGUgaGVhZGVycywgYW5kIG92ZXJyaWRlIHRoZW0uXG4gICAgICogQHBhcmFtIHthbnl9IFtvcHRpb25zLl9mcm9tT2JqZWN0XSAtIEludGVybmFsIHBhcmFtZXRlciBmb3IgZGVzZXJpYWxpemF0aW9uLiBEbyBub3QgdXNlLlxuICAgICAqL1xuICAgIGNvbnN0cnVjdG9yKFxuICAgICAgICByZXEsXG4gICAgICAgIHJlcyxcbiAgICAgICAge1xuICAgICAgICAgICAgc2hhcmVkLFxuICAgICAgICAgICAgY2FjaGVIZXVyaXN0aWMsXG4gICAgICAgICAgICBpbW11dGFibGVNaW5UaW1lVG9MaXZlLFxuICAgICAgICAgICAgaWdub3JlQ2FyZ29DdWx0LFxuICAgICAgICAgICAgX2Zyb21PYmplY3QsXG4gICAgICAgIH0gPSB7fVxuICAgICkge1xuICAgICAgICBpZiAoX2Zyb21PYmplY3QpIHtcbiAgICAgICAgICAgIHRoaXMuX2Zyb21PYmplY3QoX2Zyb21PYmplY3QpO1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG5cbiAgICAgICAgaWYgKCFyZXMgfHwgIXJlcy5oZWFkZXJzKSB7XG4gICAgICAgICAgICB0aHJvdyBFcnJvcignUmVzcG9uc2UgaGVhZGVycyBtaXNzaW5nJyk7XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy5fYXNzZXJ0UmVxdWVzdEhhc0hlYWRlcnMocmVxKTtcblxuICAgICAgICAvKiogQHR5cGUge251bWJlcn0gVGltZXN0YW1wIHdoZW4gdGhlIHJlc3BvbnNlIHdhcyByZWNlaXZlZCAqL1xuICAgICAgICB0aGlzLl9yZXNwb25zZVRpbWUgPSB0aGlzLm5vdygpO1xuICAgICAgICAvKiogQHR5cGUge2Jvb2xlYW59IEluZGljYXRlcyBpZiB0aGUgY2FjaGUgaXMgc2hhcmVkICovXG4gICAgICAgIHRoaXMuX2lzU2hhcmVkID0gc2hhcmVkICE9PSBmYWxzZTtcbiAgICAgICAgLyoqIEB0eXBlIHtib29sZWFufSBJbmRpY2F0ZXMgaWYgbGVnYWN5IGNhcmdvIGN1bHQgZGlyZWN0aXZlcyBzaG91bGQgYmUgaWdub3JlZCAqL1xuICAgICAgICB0aGlzLl9pZ25vcmVDYXJnb0N1bHQgPSAhIWlnbm9yZUNhcmdvQ3VsdDtcbiAgICAgICAgLyoqIEB0eXBlIHtudW1iZXJ9IEhldXJpc3RpYyBjYWNoZSBmcmFjdGlvbiAqL1xuICAgICAgICB0aGlzLl9jYWNoZUhldXJpc3RpYyA9XG4gICAgICAgICAgICB1bmRlZmluZWQgIT09IGNhY2hlSGV1cmlzdGljID8gY2FjaGVIZXVyaXN0aWMgOiAwLjE7IC8vIDEwJSBtYXRjaGVzIElFXG4gICAgICAgIC8qKiBAdHlwZSB7bnVtYmVyfSBNaW5pbXVtIFRUTCBmb3IgaW1tdXRhYmxlIHJlc3BvbnNlcyBpbiBtcyAqL1xuICAgICAgICB0aGlzLl9pbW11dGFibGVNaW5UdGwgPVxuICAgICAgICAgICAgdW5kZWZpbmVkICE9PSBpbW11dGFibGVNaW5UaW1lVG9MaXZlXG4gICAgICAgICAgICAgICAgPyBpbW11dGFibGVNaW5UaW1lVG9MaXZlXG4gICAgICAgICAgICAgICAgOiAyNCAqIDM2MDAgKiAxMDAwO1xuXG4gICAgICAgIC8qKiBAdHlwZSB7bnVtYmVyfSBIVFRQIHN0YXR1cyBjb2RlICovXG4gICAgICAgIHRoaXMuX3N0YXR1cyA9ICdzdGF0dXMnIGluIHJlcyA/IHJlcy5zdGF0dXMgOiAyMDA7XG4gICAgICAgIC8qKiBAdHlwZSB7UmVjb3JkPHN0cmluZywgc3RyaW5nPn0gUmVzcG9uc2UgaGVhZGVycyAqL1xuICAgICAgICB0aGlzLl9yZXNIZWFkZXJzID0gcmVzLmhlYWRlcnM7XG4gICAgICAgIC8qKiBAdHlwZSB7UmVjb3JkPHN0cmluZywgc3RyaW5nfGJvb2xlYW4+fSBQYXJzZWQgQ2FjaGUtQ29udHJvbCBkaXJlY3RpdmVzIGZyb20gcmVzcG9uc2UgKi9cbiAgICAgICAgdGhpcy5fcmVzY2MgPSBwYXJzZUNhY2hlQ29udHJvbChyZXMuaGVhZGVyc1snY2FjaGUtY29udHJvbCddKTtcbiAgICAgICAgLyoqIEB0eXBlIHtzdHJpbmd9IEhUVFAgbWV0aG9kIChlLmcuLCBHRVQsIFBPU1QpICovXG4gICAgICAgIHRoaXMuX21ldGhvZCA9ICdtZXRob2QnIGluIHJlcSA/IHJlcS5tZXRob2QgOiAnR0VUJztcbiAgICAgICAgLyoqIEB0eXBlIHtzdHJpbmd9IFJlcXVlc3QgVVJMICovXG4gICAgICAgIHRoaXMuX3VybCA9IHJlcS51cmw7XG4gICAgICAgIC8qKiBAdHlwZSB7c3RyaW5nfSBIb3N0IGhlYWRlciBmcm9tIHRoZSByZXF1ZXN0ICovXG4gICAgICAgIHRoaXMuX2hvc3QgPSByZXEuaGVhZGVycy5ob3N0O1xuICAgICAgICAvKiogQHR5cGUge2Jvb2xlYW59IFdoZXRoZXIgdGhlIHJlcXVlc3QgZG9lcyBub3QgaW5jbHVkZSBhbiBBdXRob3JpemF0aW9uIGhlYWRlciAqL1xuICAgICAgICB0aGlzLl9ub0F1dGhvcml6YXRpb24gPSAhcmVxLmhlYWRlcnMuYXV0aG9yaXphdGlvbjtcbiAgICAgICAgLyoqIEB0eXBlIHtSZWNvcmQ8c3RyaW5nLCBzdHJpbmc+fG51bGx9IFJlcXVlc3QgaGVhZGVycyB1c2VkIGZvciBWYXJ5IG1hdGNoaW5nICovXG4gICAgICAgIHRoaXMuX3JlcUhlYWRlcnMgPSByZXMuaGVhZGVycy52YXJ5ID8gcmVxLmhlYWRlcnMgOiBudWxsOyAvLyBEb24ndCBrZWVwIGFsbCByZXF1ZXN0IGhlYWRlcnMgaWYgdGhleSB3b24ndCBiZSB1c2VkXG4gICAgICAgIC8qKiBAdHlwZSB7UmVjb3JkPHN0cmluZywgc3RyaW5nfGJvb2xlYW4+fSBQYXJzZWQgQ2FjaGUtQ29udHJvbCBkaXJlY3RpdmVzIGZyb20gcmVxdWVzdCAqL1xuICAgICAgICB0aGlzLl9yZXFjYyA9IHBhcnNlQ2FjaGVDb250cm9sKHJlcS5oZWFkZXJzWydjYWNoZS1jb250cm9sJ10pO1xuXG4gICAgICAgIC8vIEFzc3VtZSB0aGF0IGlmIHNvbWVvbmUgdXNlcyBsZWdhY3ksIG5vbi1zdGFuZGFyZCB1bmNlY2Vzc2FyeSBvcHRpb25zIHRoZXkgZG9uJ3QgdW5kZXJzdGFuZCBjYWNoaW5nLFxuICAgICAgICAvLyBzbyB0aGVyZSdzIG5vIHBvaW50IHN0cmljbHkgYWRoZXJpbmcgdG8gdGhlIGJsaW5kbHkgY29weSZwYXN0ZWQgZGlyZWN0aXZlcy5cbiAgICAgICAgaWYgKFxuICAgICAgICAgICAgdGhpcy5faWdub3JlQ2FyZ29DdWx0ICYmXG4gICAgICAgICAgICAncHJlLWNoZWNrJyBpbiB0aGlzLl9yZXNjYyAmJlxuICAgICAgICAgICAgJ3Bvc3QtY2hlY2snIGluIHRoaXMuX3Jlc2NjXG4gICAgICAgICkge1xuICAgICAgICAgICAgZGVsZXRlIHRoaXMuX3Jlc2NjWydwcmUtY2hlY2snXTtcbiAgICAgICAgICAgIGRlbGV0ZSB0aGlzLl9yZXNjY1sncG9zdC1jaGVjayddO1xuICAgICAgICAgICAgZGVsZXRlIHRoaXMuX3Jlc2NjWyduby1jYWNoZSddO1xuICAgICAgICAgICAgZGVsZXRlIHRoaXMuX3Jlc2NjWyduby1zdG9yZSddO1xuICAgICAgICAgICAgZGVsZXRlIHRoaXMuX3Jlc2NjWydtdXN0LXJldmFsaWRhdGUnXTtcbiAgICAgICAgICAgIHRoaXMuX3Jlc0hlYWRlcnMgPSBPYmplY3QuYXNzaWduKHt9LCB0aGlzLl9yZXNIZWFkZXJzLCB7XG4gICAgICAgICAgICAgICAgJ2NhY2hlLWNvbnRyb2wnOiBmb3JtYXRDYWNoZUNvbnRyb2wodGhpcy5fcmVzY2MpLFxuICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICBkZWxldGUgdGhpcy5fcmVzSGVhZGVycy5leHBpcmVzO1xuICAgICAgICAgICAgZGVsZXRlIHRoaXMuX3Jlc0hlYWRlcnMucHJhZ21hO1xuICAgICAgICB9XG5cbiAgICAgICAgLy8gV2hlbiB0aGUgQ2FjaGUtQ29udHJvbCBoZWFkZXIgZmllbGQgaXMgbm90IHByZXNlbnQgaW4gYSByZXF1ZXN0LCBjYWNoZXMgTVVTVCBjb25zaWRlciB0aGUgbm8tY2FjaGUgcmVxdWVzdCBwcmFnbWEtZGlyZWN0aXZlXG4gICAgICAgIC8vIGFzIGhhdmluZyB0aGUgc2FtZSBlZmZlY3QgYXMgaWYgXCJDYWNoZS1Db250cm9sOiBuby1jYWNoZVwiIHdlcmUgcHJlc2VudCAoc2VlIFNlY3Rpb24gNS4yLjEpLlxuICAgICAgICBpZiAoXG4gICAgICAgICAgICByZXMuaGVhZGVyc1snY2FjaGUtY29udHJvbCddID09IG51bGwgJiZcbiAgICAgICAgICAgIC9uby1jYWNoZS8udGVzdChyZXMuaGVhZGVycy5wcmFnbWEpXG4gICAgICAgICkge1xuICAgICAgICAgICAgdGhpcy5fcmVzY2NbJ25vLWNhY2hlJ10gPSB0cnVlO1xuICAgICAgICB9XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogWW91IGNhbiBtb25rZXktcGF0Y2ggaXQgZm9yIHRlc3RpbmcuXG4gICAgICogQHJldHVybnMge251bWJlcn0gQ3VycmVudCB0aW1lIGluIG1pbGxpc2Vjb25kcy5cbiAgICAgKi9cbiAgICBub3coKSB7XG4gICAgICAgIHJldHVybiBEYXRlLm5vdygpO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIERldGVybWluZXMgaWYgdGhlIHJlc3BvbnNlIGlzIHN0b3JhYmxlIGluIGEgY2FjaGUuXG4gICAgICogQHJldHVybnMge2Jvb2xlYW59IGBmYWxzZWAgaWYgY2FuIG5ldmVyIGJlIGNhY2hlZC5cbiAgICAgKi9cbiAgICBzdG9yYWJsZSgpIHtcbiAgICAgICAgLy8gVGhlIFwibm8tc3RvcmVcIiByZXF1ZXN0IGRpcmVjdGl2ZSBpbmRpY2F0ZXMgdGhhdCBhIGNhY2hlIE1VU1QgTk9UIHN0b3JlIGFueSBwYXJ0IG9mIGVpdGhlciB0aGlzIHJlcXVlc3Qgb3IgYW55IHJlc3BvbnNlIHRvIGl0LlxuICAgICAgICByZXR1cm4gISEoXG4gICAgICAgICAgICAhdGhpcy5fcmVxY2NbJ25vLXN0b3JlJ10gJiZcbiAgICAgICAgICAgIC8vIEEgY2FjaGUgTVVTVCBOT1Qgc3RvcmUgYSByZXNwb25zZSB0byBhbnkgcmVxdWVzdCwgdW5sZXNzOlxuICAgICAgICAgICAgLy8gVGhlIHJlcXVlc3QgbWV0aG9kIGlzIHVuZGVyc3Rvb2QgYnkgdGhlIGNhY2hlIGFuZCBkZWZpbmVkIGFzIGJlaW5nIGNhY2hlYWJsZSwgYW5kXG4gICAgICAgICAgICAoJ0dFVCcgPT09IHRoaXMuX21ldGhvZCB8fFxuICAgICAgICAgICAgICAgICdIRUFEJyA9PT0gdGhpcy5fbWV0aG9kIHx8XG4gICAgICAgICAgICAgICAgKCdQT1NUJyA9PT0gdGhpcy5fbWV0aG9kICYmIHRoaXMuX2hhc0V4cGxpY2l0RXhwaXJhdGlvbigpKSkgJiZcbiAgICAgICAgICAgIC8vIHRoZSByZXNwb25zZSBzdGF0dXMgY29kZSBpcyB1bmRlcnN0b29kIGJ5IHRoZSBjYWNoZSwgYW5kXG4gICAgICAgICAgICB1bmRlcnN0b29kU3RhdHVzZXMuaGFzKHRoaXMuX3N0YXR1cykgJiZcbiAgICAgICAgICAgIC8vIHRoZSBcIm5vLXN0b3JlXCIgY2FjaGUgZGlyZWN0aXZlIGRvZXMgbm90IGFwcGVhciBpbiByZXF1ZXN0IG9yIHJlc3BvbnNlIGhlYWRlciBmaWVsZHMsIGFuZFxuICAgICAgICAgICAgIXRoaXMuX3Jlc2NjWyduby1zdG9yZSddICYmXG4gICAgICAgICAgICAvLyB0aGUgXCJwcml2YXRlXCIgcmVzcG9uc2UgZGlyZWN0aXZlIGRvZXMgbm90IGFwcGVhciBpbiB0aGUgcmVzcG9uc2UsIGlmIHRoZSBjYWNoZSBpcyBzaGFyZWQsIGFuZFxuICAgICAgICAgICAgKCF0aGlzLl9pc1NoYXJlZCB8fCAhdGhpcy5fcmVzY2MucHJpdmF0ZSkgJiZcbiAgICAgICAgICAgIC8vIHRoZSBBdXRob3JpemF0aW9uIGhlYWRlciBmaWVsZCBkb2VzIG5vdCBhcHBlYXIgaW4gdGhlIHJlcXVlc3QsIGlmIHRoZSBjYWNoZSBpcyBzaGFyZWQsXG4gICAgICAgICAgICAoIXRoaXMuX2lzU2hhcmVkIHx8XG4gICAgICAgICAgICAgICAgdGhpcy5fbm9BdXRob3JpemF0aW9uIHx8XG4gICAgICAgICAgICAgICAgdGhpcy5fYWxsb3dzU3RvcmluZ0F1dGhlbnRpY2F0ZWQoKSkgJiZcbiAgICAgICAgICAgIC8vIHRoZSByZXNwb25zZSBlaXRoZXI6XG4gICAgICAgICAgICAvLyBjb250YWlucyBhbiBFeHBpcmVzIGhlYWRlciBmaWVsZCwgb3JcbiAgICAgICAgICAgICh0aGlzLl9yZXNIZWFkZXJzLmV4cGlyZXMgfHxcbiAgICAgICAgICAgICAgICAvLyBjb250YWlucyBhIG1heC1hZ2UgcmVzcG9uc2UgZGlyZWN0aXZlLCBvclxuICAgICAgICAgICAgICAgIC8vIGNvbnRhaW5zIGEgcy1tYXhhZ2UgcmVzcG9uc2UgZGlyZWN0aXZlIGFuZCB0aGUgY2FjaGUgaXMgc2hhcmVkLCBvclxuICAgICAgICAgICAgICAgIC8vIGNvbnRhaW5zIGEgcHVibGljIHJlc3BvbnNlIGRpcmVjdGl2ZS5cbiAgICAgICAgICAgICAgICB0aGlzLl9yZXNjY1snbWF4LWFnZSddIHx8XG4gICAgICAgICAgICAgICAgKHRoaXMuX2lzU2hhcmVkICYmIHRoaXMuX3Jlc2NjWydzLW1heGFnZSddKSB8fFxuICAgICAgICAgICAgICAgIHRoaXMuX3Jlc2NjLnB1YmxpYyB8fFxuICAgICAgICAgICAgICAgIC8vIGhhcyBhIHN0YXR1cyBjb2RlIHRoYXQgaXMgZGVmaW5lZCBhcyBjYWNoZWFibGUgYnkgZGVmYXVsdFxuICAgICAgICAgICAgICAgIHN0YXR1c0NvZGVDYWNoZWFibGVCeURlZmF1bHQuaGFzKHRoaXMuX3N0YXR1cykpXG4gICAgICAgICk7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogQHJldHVybnMge2Jvb2xlYW59IHRydWUgaWYgZXhwaXJhdGlvbiBpcyBleHBsaWNpdGx5IGRlZmluZWQuXG4gICAgICovXG4gICAgX2hhc0V4cGxpY2l0RXhwaXJhdGlvbigpIHtcbiAgICAgICAgLy8gNC4yLjEgQ2FsY3VsYXRpbmcgRnJlc2huZXNzIExpZmV0aW1lXG4gICAgICAgIHJldHVybiAhIShcbiAgICAgICAgICAgICh0aGlzLl9pc1NoYXJlZCAmJiB0aGlzLl9yZXNjY1sncy1tYXhhZ2UnXSkgfHxcbiAgICAgICAgICAgIHRoaXMuX3Jlc2NjWydtYXgtYWdlJ10gfHxcbiAgICAgICAgICAgIHRoaXMuX3Jlc0hlYWRlcnMuZXhwaXJlc1xuICAgICAgICApO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIEBwYXJhbSB7SHR0cFJlcXVlc3R9IHJlcSAtIGEgcmVxdWVzdFxuICAgICAqIEB0aHJvd3Mge0Vycm9yfSBpZiB0aGUgaGVhZGVycyBhcmUgbWlzc2luZy5cbiAgICAgKi9cbiAgICBfYXNzZXJ0UmVxdWVzdEhhc0hlYWRlcnMocmVxKSB7XG4gICAgICAgIGlmICghcmVxIHx8ICFyZXEuaGVhZGVycykge1xuICAgICAgICAgICAgdGhyb3cgRXJyb3IoJ1JlcXVlc3QgaGVhZGVycyBtaXNzaW5nJyk7XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBDaGVja3MgaWYgdGhlIHJlcXVlc3QgbWF0Y2hlcyB0aGUgY2FjaGUgYW5kIGNhbiBiZSBzYXRpc2ZpZWQgZnJvbSB0aGUgY2FjaGUgaW1tZWRpYXRlbHksXG4gICAgICogd2l0aG91dCBoYXZpbmcgdG8gbWFrZSBhIHJlcXVlc3QgdG8gdGhlIHNlcnZlci5cbiAgICAgKlxuICAgICAqIFRoaXMgZG9lc24ndCBzdXBwb3J0IGBzdGFsZS13aGlsZS1yZXZhbGlkYXRlYC4gU2VlIGBldmFsdWF0ZVJlcXVlc3QoKWAgZm9yIGEgbW9yZSBjb21wbGV0ZSBzb2x1dGlvbi5cbiAgICAgKlxuICAgICAqIEBwYXJhbSB7SHR0cFJlcXVlc3R9IHJlcSAtIFRoZSBuZXcgaW5jb21pbmcgSFRUUCByZXF1ZXN0LlxuICAgICAqIEByZXR1cm5zIHtib29sZWFufSBgdHJ1ZWBgIGlmIHRoZSBjYWNoZWQgcmVzcG9uc2UgdXNlZCB0byBjb25zdHJ1Y3QgdGhpcyBjYWNoZSBwb2xpY3kgc2F0aXNmaWVzIHRoZSByZXF1ZXN0IHdpdGhvdXQgcmV2YWxpZGF0aW9uLlxuICAgICAqL1xuICAgIHNhdGlzZmllc1dpdGhvdXRSZXZhbGlkYXRpb24ocmVxKSB7XG4gICAgICAgIGNvbnN0IHJlc3VsdCA9IHRoaXMuZXZhbHVhdGVSZXF1ZXN0KHJlcSk7XG4gICAgICAgIHJldHVybiAhcmVzdWx0LnJldmFsaWRhdGlvbjtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBAcGFyYW0ge3toZWFkZXJzOiBSZWNvcmQ8c3RyaW5nLCBzdHJpbmc+LCBzeW5jaHJvbm91czogYm9vbGVhbn18dW5kZWZpbmVkfSByZXZhbGlkYXRpb24gLSBSZXZhbGlkYXRpb24gaW5mb3JtYXRpb24sIGlmIGFueS5cbiAgICAgKiBAcmV0dXJucyB7e3Jlc3BvbnNlOiB7aGVhZGVyczogUmVjb3JkPHN0cmluZywgc3RyaW5nPn0sIHJldmFsaWRhdGlvbjoge2hlYWRlcnM6IFJlY29yZDxzdHJpbmcsIHN0cmluZz4sIHN5bmNocm9ub3VzOiBib29sZWFufXx1bmRlZmluZWR9fSBBbiBvYmplY3Qgd2l0aCBhIGNhY2hlZCByZXNwb25zZSBoZWFkZXJzIGFuZCByZXZhbGlkYXRpb24gaW5mby5cbiAgICAgKi9cbiAgICBfZXZhbHVhdGVSZXF1ZXN0SGl0UmVzdWx0KHJldmFsaWRhdGlvbikge1xuICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgcmVzcG9uc2U6IHtcbiAgICAgICAgICAgICAgICBoZWFkZXJzOiB0aGlzLnJlc3BvbnNlSGVhZGVycygpLFxuICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIHJldmFsaWRhdGlvbixcbiAgICAgICAgfTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBAcGFyYW0ge0h0dHBSZXF1ZXN0fSByZXF1ZXN0IC0gbmV3IGluY29taW5nXG4gICAgICogQHBhcmFtIHtib29sZWFufSBzeW5jaHJvbm91cyAtIHdoZXRoZXIgcmV2YWxpZGF0aW9uIG11c3QgYmUgc3luY2hyb25vdXMgKG5vdCBzLXctcikuXG4gICAgICogQHJldHVybnMge3toZWFkZXJzOiBSZWNvcmQ8c3RyaW5nLCBzdHJpbmc+LCBzeW5jaHJvbm91czogYm9vbGVhbn19IEFuIG9iamVjdCB3aXRoIHJldmFsaWRhdGlvbiBoZWFkZXJzIGFuZCBhIHN5bmNocm9ub3VzIGZsYWcuXG4gICAgICovXG4gICAgX2V2YWx1YXRlUmVxdWVzdFJldmFsaWRhdGlvbihyZXF1ZXN0LCBzeW5jaHJvbm91cykge1xuICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgc3luY2hyb25vdXMsXG4gICAgICAgICAgICBoZWFkZXJzOiB0aGlzLnJldmFsaWRhdGlvbkhlYWRlcnMocmVxdWVzdCksXG4gICAgICAgIH07XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogQHBhcmFtIHtIdHRwUmVxdWVzdH0gcmVxdWVzdCAtIG5ldyBpbmNvbWluZ1xuICAgICAqIEByZXR1cm5zIHt7cmVzcG9uc2U6IHVuZGVmaW5lZCwgcmV2YWxpZGF0aW9uOiB7aGVhZGVyczogUmVjb3JkPHN0cmluZywgc3RyaW5nPiwgc3luY2hyb25vdXM6IGJvb2xlYW59fX0gQW4gb2JqZWN0IGluZGljYXRpbmcgbm8gY2FjaGVkIHJlc3BvbnNlIGFuZCByZXZhbGlkYXRpb24gZGV0YWlscy5cbiAgICAgKi9cbiAgICBfZXZhbHVhdGVSZXF1ZXN0TWlzc1Jlc3VsdChyZXF1ZXN0KSB7XG4gICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICByZXNwb25zZTogdW5kZWZpbmVkLFxuICAgICAgICAgICAgcmV2YWxpZGF0aW9uOiB0aGlzLl9ldmFsdWF0ZVJlcXVlc3RSZXZhbGlkYXRpb24ocmVxdWVzdCwgdHJ1ZSksXG4gICAgICAgIH07XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogQ2hlY2tzIGlmIHRoZSBnaXZlbiByZXF1ZXN0IG1hdGNoZXMgdGhpcyBjYWNoZSBlbnRyeSwgYW5kIGhvdyB0aGUgY2FjaGUgY2FuIGJlIHVzZWQgdG8gc2F0aXNmeSBpdC4gUmV0dXJucyBhbiBvYmplY3Qgd2l0aDpcbiAgICAgKlxuICAgICAqIGBgYFxuICAgICAqIHtcbiAgICAgKiAgICAgLy8gSWYgZGVmaW5lZCwgeW91IG11c3Qgc2VuZCBhIHJlcXVlc3QgdG8gdGhlIHNlcnZlci5cbiAgICAgKiAgICAgcmV2YWxpZGF0aW9uOiB7XG4gICAgICogICAgICAgICBoZWFkZXJzOiB7fSwgLy8gSFRUUCBoZWFkZXJzIHRvIHVzZSB3aGVuIHNlbmRpbmcgdGhlIHJldmFsaWRhdGlvbiByZXNwb25zZVxuICAgICAqICAgICAgICAgLy8gSWYgdHJ1ZSwgeW91IE1VU1Qgd2FpdCBmb3IgYSByZXNwb25zZSBmcm9tIHRoZSBzZXJ2ZXIgYmVmb3JlIHVzaW5nIHRoZSBjYWNoZVxuICAgICAqICAgICAgICAgLy8gSWYgZmFsc2UsIHRoaXMgaXMgc3RhbGUtd2hpbGUtcmV2YWxpZGF0ZS4gVGhlIGNhY2hlIGlzIHN0YWxlLCBidXQgeW91IGNhbiB1c2UgaXQgd2hpbGUgeW91IHVwZGF0ZSBpdCBhc3luY2hyb25vdXNseS5cbiAgICAgKiAgICAgICAgIHN5bmNocm9ub3VzOiBib29sLFxuICAgICAqICAgICB9LFxuICAgICAqICAgICAvLyBJZiBkZWZpbmVkLCB5b3UgY2FuIHVzZSB0aGlzIGNhY2hlZCByZXNwb25zZS5cbiAgICAgKiAgICAgcmVzcG9uc2U6IHtcbiAgICAgKiAgICAgICAgIGhlYWRlcnM6IHt9LCAvLyBVcGRhdGVkIGNhY2hlZCBIVFRQIGhlYWRlcnMgeW91IG11c3QgdXNlIHdoZW4gcmVzcG9uZGluZyB0byB0aGUgY2xpZW50XG4gICAgICogICAgIH0sXG4gICAgICogfVxuICAgICAqIGBgYFxuICAgICAqIEBwYXJhbSB7SHR0cFJlcXVlc3R9IHJlcSAtIG5ldyBpbmNvbWluZyBIVFRQIHJlcXVlc3RcbiAgICAgKiBAcmV0dXJucyB7e3Jlc3BvbnNlOiB7aGVhZGVyczogUmVjb3JkPHN0cmluZywgc3RyaW5nPn18dW5kZWZpbmVkLCByZXZhbGlkYXRpb246IHtoZWFkZXJzOiBSZWNvcmQ8c3RyaW5nLCBzdHJpbmc+LCBzeW5jaHJvbm91czogYm9vbGVhbn18dW5kZWZpbmVkfX0gQW4gb2JqZWN0IGNvbnRhaW5pbmcga2V5czpcbiAgICAgKiAgIC0gcmV2YWxpZGF0aW9uOiB7IGhlYWRlcnM6IFJlY29yZDxzdHJpbmcsIHN0cmluZz4sIHN5bmNocm9ub3VzOiBib29sZWFuIH0gU2V0IGlmIHlvdSBzaG91bGQgc2VuZCB0aGlzIHRvIHRoZSBvcmlnaW4gc2VydmVyXG4gICAgICogICAtIHJlc3BvbnNlOiB7IGhlYWRlcnM6IFJlY29yZDxzdHJpbmcsIHN0cmluZz4gfSBTZXQgaWYgeW91IGNhbiByZXNwb25kIHRvIHRoZSBjbGllbnQgd2l0aCB0aGVzZSBjYWNoZWQgaGVhZGVyc1xuICAgICAqL1xuICAgIGV2YWx1YXRlUmVxdWVzdChyZXEpIHtcbiAgICAgICAgdGhpcy5fYXNzZXJ0UmVxdWVzdEhhc0hlYWRlcnMocmVxKTtcblxuICAgICAgICAvLyBJbiBhbGwgY2lyY3Vtc3RhbmNlcywgYSBjYWNoZSBNVVNUIE5PVCBpZ25vcmUgdGhlIG11c3QtcmV2YWxpZGF0ZSBkaXJlY3RpdmVcbiAgICAgICAgaWYgKHRoaXMuX3Jlc2NjWydtdXN0LXJldmFsaWRhdGUnXSkge1xuICAgICAgICAgICAgcmV0dXJuIHRoaXMuX2V2YWx1YXRlUmVxdWVzdE1pc3NSZXN1bHQocmVxKTtcbiAgICAgICAgfVxuXG4gICAgICAgIGlmICghdGhpcy5fcmVxdWVzdE1hdGNoZXMocmVxLCBmYWxzZSkpIHtcbiAgICAgICAgICAgIHJldHVybiB0aGlzLl9ldmFsdWF0ZVJlcXVlc3RNaXNzUmVzdWx0KHJlcSk7XG4gICAgICAgIH1cblxuICAgICAgICAvLyBXaGVuIHByZXNlbnRlZCB3aXRoIGEgcmVxdWVzdCwgYSBjYWNoZSBNVVNUIE5PVCByZXVzZSBhIHN0b3JlZCByZXNwb25zZSwgdW5sZXNzOlxuICAgICAgICAvLyB0aGUgcHJlc2VudGVkIHJlcXVlc3QgZG9lcyBub3QgY29udGFpbiB0aGUgbm8tY2FjaGUgcHJhZ21hIChTZWN0aW9uIDUuNCksIG5vciB0aGUgbm8tY2FjaGUgY2FjaGUgZGlyZWN0aXZlLFxuICAgICAgICAvLyB1bmxlc3MgdGhlIHN0b3JlZCByZXNwb25zZSBpcyBzdWNjZXNzZnVsbHkgdmFsaWRhdGVkIChTZWN0aW9uIDQuMyksIGFuZFxuICAgICAgICBjb25zdCByZXF1ZXN0Q0MgPSBwYXJzZUNhY2hlQ29udHJvbChyZXEuaGVhZGVyc1snY2FjaGUtY29udHJvbCddKTtcblxuICAgICAgICBpZiAocmVxdWVzdENDWyduby1jYWNoZSddIHx8IC9uby1jYWNoZS8udGVzdChyZXEuaGVhZGVycy5wcmFnbWEpKSB7XG4gICAgICAgICAgICByZXR1cm4gdGhpcy5fZXZhbHVhdGVSZXF1ZXN0TWlzc1Jlc3VsdChyZXEpO1xuICAgICAgICB9XG5cbiAgICAgICAgaWYgKHJlcXVlc3RDQ1snbWF4LWFnZSddICYmIHRoaXMuYWdlKCkgPiB0b051bWJlck9yWmVybyhyZXF1ZXN0Q0NbJ21heC1hZ2UnXSkpIHtcbiAgICAgICAgICAgIHJldHVybiB0aGlzLl9ldmFsdWF0ZVJlcXVlc3RNaXNzUmVzdWx0KHJlcSk7XG4gICAgICAgIH1cblxuICAgICAgICBpZiAocmVxdWVzdENDWydtaW4tZnJlc2gnXSAmJiB0aGlzLm1heEFnZSgpIC0gdGhpcy5hZ2UoKSA8IHRvTnVtYmVyT3JaZXJvKHJlcXVlc3RDQ1snbWluLWZyZXNoJ10pKSB7XG4gICAgICAgICAgICByZXR1cm4gdGhpcy5fZXZhbHVhdGVSZXF1ZXN0TWlzc1Jlc3VsdChyZXEpO1xuICAgICAgICB9XG5cbiAgICAgICAgLy8gdGhlIHN0b3JlZCByZXNwb25zZSBpcyBlaXRoZXI6XG4gICAgICAgIC8vIGZyZXNoLCBvciBhbGxvd2VkIHRvIGJlIHNlcnZlZCBzdGFsZVxuICAgICAgICBpZiAodGhpcy5zdGFsZSgpKSB7XG4gICAgICAgICAgICAvLyBJZiBhIHZhbHVlIGlzIHByZXNlbnQsIHRoZW4gdGhlIGNsaWVudCBpcyB3aWxsaW5nIHRvIGFjY2VwdCBhIHJlc3BvbnNlIHRoYXQgaGFzXG4gICAgICAgICAgICAvLyBleGNlZWRlZCBpdHMgZnJlc2huZXNzIGxpZmV0aW1lIGJ5IG5vIG1vcmUgdGhhbiB0aGUgc3BlY2lmaWVkIG51bWJlciBvZiBzZWNvbmRzXG4gICAgICAgICAgICBjb25zdCBhbGxvd3NTdGFsZVdpdGhvdXRSZXZhbGlkYXRpb24gPSAnbWF4LXN0YWxlJyBpbiByZXF1ZXN0Q0MgJiZcbiAgICAgICAgICAgICAgICAodHJ1ZSA9PT0gcmVxdWVzdENDWydtYXgtc3RhbGUnXSB8fCByZXF1ZXN0Q0NbJ21heC1zdGFsZSddID4gdGhpcy5hZ2UoKSAtIHRoaXMubWF4QWdlKCkpO1xuXG4gICAgICAgICAgICBpZiAoYWxsb3dzU3RhbGVXaXRob3V0UmV2YWxpZGF0aW9uKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHRoaXMuX2V2YWx1YXRlUmVxdWVzdEhpdFJlc3VsdCh1bmRlZmluZWQpO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICBpZiAodGhpcy51c2VTdGFsZVdoaWxlUmV2YWxpZGF0ZSgpKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHRoaXMuX2V2YWx1YXRlUmVxdWVzdEhpdFJlc3VsdCh0aGlzLl9ldmFsdWF0ZVJlcXVlc3RSZXZhbGlkYXRpb24ocmVxLCBmYWxzZSkpO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICByZXR1cm4gdGhpcy5fZXZhbHVhdGVSZXF1ZXN0TWlzc1Jlc3VsdChyZXEpO1xuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuIHRoaXMuX2V2YWx1YXRlUmVxdWVzdEhpdFJlc3VsdCh1bmRlZmluZWQpO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIEBwYXJhbSB7SHR0cFJlcXVlc3R9IHJlcSAtIGNoZWNrIGlmIHRoaXMgaXMgZm9yIHRoZSBzYW1lIGNhY2hlIGVudHJ5XG4gICAgICogQHBhcmFtIHtib29sZWFufSBhbGxvd0hlYWRNZXRob2QgLSBhbGxvdyBhIEhFQUQgbWV0aG9kIHRvIG1hdGNoLlxuICAgICAqIEByZXR1cm5zIHtib29sZWFufSBgdHJ1ZWAgaWYgdGhlIHJlcXVlc3QgbWF0Y2hlcy5cbiAgICAgKi9cbiAgICBfcmVxdWVzdE1hdGNoZXMocmVxLCBhbGxvd0hlYWRNZXRob2QpIHtcbiAgICAgICAgLy8gVGhlIHByZXNlbnRlZCBlZmZlY3RpdmUgcmVxdWVzdCBVUkkgYW5kIHRoYXQgb2YgdGhlIHN0b3JlZCByZXNwb25zZSBtYXRjaCwgYW5kXG4gICAgICAgIHJldHVybiAhIShcbiAgICAgICAgICAgICghdGhpcy5fdXJsIHx8IHRoaXMuX3VybCA9PT0gcmVxLnVybCkgJiZcbiAgICAgICAgICAgIHRoaXMuX2hvc3QgPT09IHJlcS5oZWFkZXJzLmhvc3QgJiZcbiAgICAgICAgICAgIC8vIHRoZSByZXF1ZXN0IG1ldGhvZCBhc3NvY2lhdGVkIHdpdGggdGhlIHN0b3JlZCByZXNwb25zZSBhbGxvd3MgaXQgdG8gYmUgdXNlZCBmb3IgdGhlIHByZXNlbnRlZCByZXF1ZXN0LCBhbmRcbiAgICAgICAgICAgICghcmVxLm1ldGhvZCB8fFxuICAgICAgICAgICAgICAgIHRoaXMuX21ldGhvZCA9PT0gcmVxLm1ldGhvZCB8fFxuICAgICAgICAgICAgICAgIChhbGxvd0hlYWRNZXRob2QgJiYgJ0hFQUQnID09PSByZXEubWV0aG9kKSkgJiZcbiAgICAgICAgICAgIC8vIHNlbGVjdGluZyBoZWFkZXIgZmllbGRzIG5vbWluYXRlZCBieSB0aGUgc3RvcmVkIHJlc3BvbnNlIChpZiBhbnkpIG1hdGNoIHRob3NlIHByZXNlbnRlZCwgYW5kXG4gICAgICAgICAgICB0aGlzLl92YXJ5TWF0Y2hlcyhyZXEpXG4gICAgICAgICk7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogRGV0ZXJtaW5lcyB3aGV0aGVyIHN0b3JpbmcgYXV0aGVudGljYXRlZCByZXNwb25zZXMgaXMgYWxsb3dlZC5cbiAgICAgKiBAcmV0dXJucyB7Ym9vbGVhbn0gYHRydWVgIGlmIGFsbG93ZWQuXG4gICAgICovXG4gICAgX2FsbG93c1N0b3JpbmdBdXRoZW50aWNhdGVkKCkge1xuICAgICAgICAvLyBmb2xsb3dpbmcgQ2FjaGUtQ29udHJvbCByZXNwb25zZSBkaXJlY3RpdmVzIChTZWN0aW9uIDUuMi4yKSBoYXZlIHN1Y2ggYW4gZWZmZWN0OiBtdXN0LXJldmFsaWRhdGUsIHB1YmxpYywgYW5kIHMtbWF4YWdlLlxuICAgICAgICByZXR1cm4gISEoXG4gICAgICAgICAgICB0aGlzLl9yZXNjY1snbXVzdC1yZXZhbGlkYXRlJ10gfHxcbiAgICAgICAgICAgIHRoaXMuX3Jlc2NjLnB1YmxpYyB8fFxuICAgICAgICAgICAgdGhpcy5fcmVzY2NbJ3MtbWF4YWdlJ11cbiAgICAgICAgKTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBDaGVja3Mgd2hldGhlciB0aGUgVmFyeSBoZWFkZXIgaW4gdGhlIHJlc3BvbnNlIG1hdGNoZXMgdGhlIG5ldyByZXF1ZXN0LlxuICAgICAqIEBwYXJhbSB7SHR0cFJlcXVlc3R9IHJlcSAtIGluY29taW5nIEhUVFAgcmVxdWVzdFxuICAgICAqIEByZXR1cm5zIHtib29sZWFufSBgdHJ1ZWAgaWYgdGhlIHZhcnkgaGVhZGVycyBtYXRjaC5cbiAgICAgKi9cbiAgICBfdmFyeU1hdGNoZXMocmVxKSB7XG4gICAgICAgIGlmICghdGhpcy5fcmVzSGVhZGVycy52YXJ5KSB7XG4gICAgICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgICAgfVxuXG4gICAgICAgIC8vIEEgVmFyeSBoZWFkZXIgZmllbGQtdmFsdWUgb2YgXCIqXCIgYWx3YXlzIGZhaWxzIHRvIG1hdGNoXG4gICAgICAgIGlmICh0aGlzLl9yZXNIZWFkZXJzLnZhcnkgPT09ICcqJykge1xuICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICB9XG5cbiAgICAgICAgY29uc3QgZmllbGRzID0gdGhpcy5fcmVzSGVhZGVycy52YXJ5XG4gICAgICAgICAgICAudHJpbSgpXG4gICAgICAgICAgICAudG9Mb3dlckNhc2UoKVxuICAgICAgICAgICAgLnNwbGl0KC9cXHMqLFxccyovKTtcbiAgICAgICAgZm9yIChjb25zdCBuYW1lIG9mIGZpZWxkcykge1xuICAgICAgICAgICAgaWYgKHJlcS5oZWFkZXJzW25hbWVdICE9PSB0aGlzLl9yZXFIZWFkZXJzW25hbWVdKSByZXR1cm4gZmFsc2U7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogQ3JlYXRlcyBhIGNvcHkgb2YgdGhlIGdpdmVuIGhlYWRlcnMgd2l0aG91dCBhbnkgaG9wLWJ5LWhvcCBoZWFkZXJzLlxuICAgICAqIEBwYXJhbSB7UmVjb3JkPHN0cmluZywgc3RyaW5nPn0gaW5IZWFkZXJzIC0gb2xkIGhlYWRlcnMgZnJvbSB0aGUgY2FjaGVkIHJlc3BvbnNlXG4gICAgICogQHJldHVybnMge1JlY29yZDxzdHJpbmcsIHN0cmluZz59IEEgbmV3IGhlYWRlcnMgb2JqZWN0IHdpdGhvdXQgaG9wLWJ5LWhvcCBoZWFkZXJzLlxuICAgICAqL1xuICAgIF9jb3B5V2l0aG91dEhvcEJ5SG9wSGVhZGVycyhpbkhlYWRlcnMpIHtcbiAgICAgICAgLyoqIEB0eXBlIHtSZWNvcmQ8c3RyaW5nLCBzdHJpbmc+fSAqL1xuICAgICAgICBjb25zdCBoZWFkZXJzID0ge307XG4gICAgICAgIGZvciAoY29uc3QgbmFtZSBpbiBpbkhlYWRlcnMpIHtcbiAgICAgICAgICAgIGlmIChob3BCeUhvcEhlYWRlcnNbbmFtZV0pIGNvbnRpbnVlO1xuICAgICAgICAgICAgaGVhZGVyc1tuYW1lXSA9IGluSGVhZGVyc1tuYW1lXTtcbiAgICAgICAgfVxuICAgICAgICAvLyA5LjEuICBDb25uZWN0aW9uXG4gICAgICAgIGlmIChpbkhlYWRlcnMuY29ubmVjdGlvbikge1xuICAgICAgICAgICAgY29uc3QgdG9rZW5zID0gaW5IZWFkZXJzLmNvbm5lY3Rpb24udHJpbSgpLnNwbGl0KC9cXHMqLFxccyovKTtcbiAgICAgICAgICAgIGZvciAoY29uc3QgbmFtZSBvZiB0b2tlbnMpIHtcbiAgICAgICAgICAgICAgICBkZWxldGUgaGVhZGVyc1tuYW1lXTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBpZiAoaGVhZGVycy53YXJuaW5nKSB7XG4gICAgICAgICAgICBjb25zdCB3YXJuaW5ncyA9IGhlYWRlcnMud2FybmluZy5zcGxpdCgvLC8pLmZpbHRlcih3YXJuaW5nID0+IHtcbiAgICAgICAgICAgICAgICByZXR1cm4gIS9eXFxzKjFbMC05XVswLTldLy50ZXN0KHdhcm5pbmcpO1xuICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICBpZiAoIXdhcm5pbmdzLmxlbmd0aCkge1xuICAgICAgICAgICAgICAgIGRlbGV0ZSBoZWFkZXJzLndhcm5pbmc7XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgIGhlYWRlcnMud2FybmluZyA9IHdhcm5pbmdzLmpvaW4oJywnKS50cmltKCk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIGhlYWRlcnM7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogUmV0dXJucyB0aGUgcmVzcG9uc2UgaGVhZGVycyBhZGp1c3RlZCBmb3Igc2VydmluZyB0aGUgY2FjaGVkIHJlc3BvbnNlLlxuICAgICAqIFJlbW92ZXMgaG9wLWJ5LWhvcCBoZWFkZXJzIGFuZCB1cGRhdGVzIHRoZSBBZ2UgYW5kIERhdGUgaGVhZGVycy5cbiAgICAgKiBAcmV0dXJucyB7UmVjb3JkPHN0cmluZywgc3RyaW5nPn0gVGhlIGFkanVzdGVkIHJlc3BvbnNlIGhlYWRlcnMuXG4gICAgICovXG4gICAgcmVzcG9uc2VIZWFkZXJzKCkge1xuICAgICAgICBjb25zdCBoZWFkZXJzID0gdGhpcy5fY29weVdpdGhvdXRIb3BCeUhvcEhlYWRlcnModGhpcy5fcmVzSGVhZGVycyk7XG4gICAgICAgIGNvbnN0IGFnZSA9IHRoaXMuYWdlKCk7XG5cbiAgICAgICAgLy8gQSBjYWNoZSBTSE9VTEQgZ2VuZXJhdGUgMTEzIHdhcm5pbmcgaWYgaXQgaGV1cmlzdGljYWxseSBjaG9zZSBhIGZyZXNobmVzc1xuICAgICAgICAvLyBsaWZldGltZSBncmVhdGVyIHRoYW4gMjQgaG91cnMgYW5kIHRoZSByZXNwb25zZSdzIGFnZSBpcyBncmVhdGVyIHRoYW4gMjQgaG91cnMuXG4gICAgICAgIGlmIChcbiAgICAgICAgICAgIGFnZSA+IDM2MDAgKiAyNCAmJlxuICAgICAgICAgICAgIXRoaXMuX2hhc0V4cGxpY2l0RXhwaXJhdGlvbigpICYmXG4gICAgICAgICAgICB0aGlzLm1heEFnZSgpID4gMzYwMCAqIDI0XG4gICAgICAgICkge1xuICAgICAgICAgICAgaGVhZGVycy53YXJuaW5nID1cbiAgICAgICAgICAgICAgICAoaGVhZGVycy53YXJuaW5nID8gYCR7aGVhZGVycy53YXJuaW5nfSwgYCA6ICcnKSArXG4gICAgICAgICAgICAgICAgJzExMyAtIFwicmZjNzIzNCA1LjUuNFwiJztcbiAgICAgICAgfVxuICAgICAgICBoZWFkZXJzLmFnZSA9IGAke01hdGgucm91bmQoYWdlKX1gO1xuICAgICAgICBoZWFkZXJzLmRhdGUgPSBuZXcgRGF0ZSh0aGlzLm5vdygpKS50b1VUQ1N0cmluZygpO1xuICAgICAgICByZXR1cm4gaGVhZGVycztcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBSZXR1cm5zIHRoZSBEYXRlIGhlYWRlciB2YWx1ZSBmcm9tIHRoZSByZXNwb25zZSBvciB0aGUgY3VycmVudCB0aW1lIGlmIGludmFsaWQuXG4gICAgICogQHJldHVybnMge251bWJlcn0gVGltZXN0YW1wIChpbiBtaWxsaXNlY29uZHMpIHJlcHJlc2VudGluZyB0aGUgRGF0ZSBoZWFkZXIgb3IgcmVzcG9uc2UgdGltZS5cbiAgICAgKi9cbiAgICBkYXRlKCkge1xuICAgICAgICBjb25zdCBzZXJ2ZXJEYXRlID0gRGF0ZS5wYXJzZSh0aGlzLl9yZXNIZWFkZXJzLmRhdGUpO1xuICAgICAgICBpZiAoaXNGaW5pdGUoc2VydmVyRGF0ZSkpIHtcbiAgICAgICAgICAgIHJldHVybiBzZXJ2ZXJEYXRlO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiB0aGlzLl9yZXNwb25zZVRpbWU7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogVmFsdWUgb2YgdGhlIEFnZSBoZWFkZXIsIGluIHNlY29uZHMsIHVwZGF0ZWQgZm9yIHRoZSBjdXJyZW50IHRpbWUuXG4gICAgICogTWF5IGJlIGZyYWN0aW9uYWwuXG4gICAgICogQHJldHVybnMge251bWJlcn0gVGhlIGFnZSBpbiBzZWNvbmRzLlxuICAgICAqL1xuICAgIGFnZSgpIHtcbiAgICAgICAgbGV0IGFnZSA9IHRoaXMuX2FnZVZhbHVlKCk7XG5cbiAgICAgICAgY29uc3QgcmVzaWRlbnRUaW1lID0gKHRoaXMubm93KCkgLSB0aGlzLl9yZXNwb25zZVRpbWUpIC8gMTAwMDtcbiAgICAgICAgcmV0dXJuIGFnZSArIHJlc2lkZW50VGltZTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBAcmV0dXJucyB7bnVtYmVyfSBUaGUgQWdlIGhlYWRlciB2YWx1ZSBhcyBhIG51bWJlci5cbiAgICAgKi9cbiAgICBfYWdlVmFsdWUoKSB7XG4gICAgICAgIHJldHVybiB0b051bWJlck9yWmVybyh0aGlzLl9yZXNIZWFkZXJzLmFnZSk7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogUG9zc2libHkgb3V0ZGF0ZWQgdmFsdWUgb2YgYXBwbGljYWJsZSBtYXgtYWdlIChvciBoZXVyaXN0aWMgZXF1aXZhbGVudCkgaW4gc2Vjb25kcy5cbiAgICAgKiBUaGlzIGNvdW50cyBzaW5jZSByZXNwb25zZSdzIGBEYXRlYC5cbiAgICAgKlxuICAgICAqIEZvciBhbiB1cC10by1kYXRlIHZhbHVlLCBzZWUgYHRpbWVUb0xpdmUoKWAuXG4gICAgICpcbiAgICAgKiBSZXR1cm5zIHRoZSBtYXhpbXVtIGFnZSAoZnJlc2huZXNzIGxpZmV0aW1lKSBvZiB0aGUgcmVzcG9uc2UgaW4gc2Vjb25kcy5cbiAgICAgKiBAcmV0dXJucyB7bnVtYmVyfSBUaGUgbWF4LWFnZSB2YWx1ZSBpbiBzZWNvbmRzLlxuICAgICAqL1xuICAgIG1heEFnZSgpIHtcbiAgICAgICAgaWYgKCF0aGlzLnN0b3JhYmxlKCkgfHwgdGhpcy5fcmVzY2NbJ25vLWNhY2hlJ10pIHtcbiAgICAgICAgICAgIHJldHVybiAwO1xuICAgICAgICB9XG5cbiAgICAgICAgLy8gU2hhcmVkIHJlc3BvbnNlcyB3aXRoIGNvb2tpZXMgYXJlIGNhY2hlYWJsZSBhY2NvcmRpbmcgdG8gdGhlIFJGQywgYnV0IElNSE8gaXQnZCBiZSB1bndpc2UgdG8gZG8gc28gYnkgZGVmYXVsdFxuICAgICAgICAvLyBzbyB0aGlzIGltcGxlbWVudGF0aW9uIHJlcXVpcmVzIGV4cGxpY2l0IG9wdC1pbiB2aWEgcHVibGljIGhlYWRlclxuICAgICAgICBpZiAoXG4gICAgICAgICAgICB0aGlzLl9pc1NoYXJlZCAmJlxuICAgICAgICAgICAgKHRoaXMuX3Jlc0hlYWRlcnNbJ3NldC1jb29raWUnXSAmJlxuICAgICAgICAgICAgICAgICF0aGlzLl9yZXNjYy5wdWJsaWMgJiZcbiAgICAgICAgICAgICAgICAhdGhpcy5fcmVzY2MuaW1tdXRhYmxlKVxuICAgICAgICApIHtcbiAgICAgICAgICAgIHJldHVybiAwO1xuICAgICAgICB9XG5cbiAgICAgICAgaWYgKHRoaXMuX3Jlc0hlYWRlcnMudmFyeSA9PT0gJyonKSB7XG4gICAgICAgICAgICByZXR1cm4gMDtcbiAgICAgICAgfVxuXG4gICAgICAgIGlmICh0aGlzLl9pc1NoYXJlZCkge1xuICAgICAgICAgICAgaWYgKHRoaXMuX3Jlc2NjWydwcm94eS1yZXZhbGlkYXRlJ10pIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gMDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIC8vIGlmIGEgcmVzcG9uc2UgaW5jbHVkZXMgdGhlIHMtbWF4YWdlIGRpcmVjdGl2ZSwgYSBzaGFyZWQgY2FjaGUgcmVjaXBpZW50IE1VU1QgaWdub3JlIHRoZSBFeHBpcmVzIGZpZWxkLlxuICAgICAgICAgICAgaWYgKHRoaXMuX3Jlc2NjWydzLW1heGFnZSddKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHRvTnVtYmVyT3JaZXJvKHRoaXMuX3Jlc2NjWydzLW1heGFnZSddKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuXG4gICAgICAgIC8vIElmIGEgcmVzcG9uc2UgaW5jbHVkZXMgYSBDYWNoZS1Db250cm9sIGZpZWxkIHdpdGggdGhlIG1heC1hZ2UgZGlyZWN0aXZlLCBhIHJlY2lwaWVudCBNVVNUIGlnbm9yZSB0aGUgRXhwaXJlcyBmaWVsZC5cbiAgICAgICAgaWYgKHRoaXMuX3Jlc2NjWydtYXgtYWdlJ10pIHtcbiAgICAgICAgICAgIHJldHVybiB0b051bWJlck9yWmVybyh0aGlzLl9yZXNjY1snbWF4LWFnZSddKTtcbiAgICAgICAgfVxuXG4gICAgICAgIGNvbnN0IGRlZmF1bHRNaW5UdGwgPSB0aGlzLl9yZXNjYy5pbW11dGFibGUgPyB0aGlzLl9pbW11dGFibGVNaW5UdGwgOiAwO1xuXG4gICAgICAgIGNvbnN0IHNlcnZlckRhdGUgPSB0aGlzLmRhdGUoKTtcbiAgICAgICAgaWYgKHRoaXMuX3Jlc0hlYWRlcnMuZXhwaXJlcykge1xuICAgICAgICAgICAgY29uc3QgZXhwaXJlcyA9IERhdGUucGFyc2UodGhpcy5fcmVzSGVhZGVycy5leHBpcmVzKTtcbiAgICAgICAgICAgIC8vIEEgY2FjaGUgcmVjaXBpZW50IE1VU1QgaW50ZXJwcmV0IGludmFsaWQgZGF0ZSBmb3JtYXRzLCBlc3BlY2lhbGx5IHRoZSB2YWx1ZSBcIjBcIiwgYXMgcmVwcmVzZW50aW5nIGEgdGltZSBpbiB0aGUgcGFzdCAoaS5lLiwgXCJhbHJlYWR5IGV4cGlyZWRcIikuXG4gICAgICAgICAgICBpZiAoTnVtYmVyLmlzTmFOKGV4cGlyZXMpIHx8IGV4cGlyZXMgPCBzZXJ2ZXJEYXRlKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIDA7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm4gTWF0aC5tYXgoZGVmYXVsdE1pblR0bCwgKGV4cGlyZXMgLSBzZXJ2ZXJEYXRlKSAvIDEwMDApO1xuICAgICAgICB9XG5cbiAgICAgICAgaWYgKHRoaXMuX3Jlc0hlYWRlcnNbJ2xhc3QtbW9kaWZpZWQnXSkge1xuICAgICAgICAgICAgY29uc3QgbGFzdE1vZGlmaWVkID0gRGF0ZS5wYXJzZSh0aGlzLl9yZXNIZWFkZXJzWydsYXN0LW1vZGlmaWVkJ10pO1xuICAgICAgICAgICAgaWYgKGlzRmluaXRlKGxhc3RNb2RpZmllZCkgJiYgc2VydmVyRGF0ZSA+IGxhc3RNb2RpZmllZCkge1xuICAgICAgICAgICAgICAgIHJldHVybiBNYXRoLm1heChcbiAgICAgICAgICAgICAgICAgICAgZGVmYXVsdE1pblR0bCxcbiAgICAgICAgICAgICAgICAgICAgKChzZXJ2ZXJEYXRlIC0gbGFzdE1vZGlmaWVkKSAvIDEwMDApICogdGhpcy5fY2FjaGVIZXVyaXN0aWNcbiAgICAgICAgICAgICAgICApO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuIGRlZmF1bHRNaW5UdGw7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogUmVtYWluaW5nIHRpbWUgdGhpcyBjYWNoZSBlbnRyeSBtYXkgYmUgdXNlZnVsIGZvciwgaW4gKm1pbGxpc2Vjb25kcyouXG4gICAgICogWW91IGNhbiB1c2UgdGhpcyBhcyBhbiBleHBpcmF0aW9uIHRpbWUgZm9yIHlvdXIgY2FjaGUgc3RvcmFnZS5cbiAgICAgKlxuICAgICAqIFByZWZlciB0aGlzIG1ldGhvZCBvdmVyIGBtYXhBZ2UoKWAsIGJlY2F1c2UgaXQgaW5jbHVkZXMgb3RoZXIgZmFjdG9ycyBsaWtlIGBhZ2VgIGFuZCBgc3RhbGUtd2hpbGUtcmV2YWxpZGF0ZWAuXG4gICAgICogQHJldHVybnMge251bWJlcn0gVGltZS10by1saXZlIGluIG1pbGxpc2Vjb25kcy5cbiAgICAgKi9cbiAgICB0aW1lVG9MaXZlKCkge1xuICAgICAgICBjb25zdCBhZ2UgPSB0aGlzLm1heEFnZSgpIC0gdGhpcy5hZ2UoKTtcbiAgICAgICAgY29uc3Qgc3RhbGVJZkVycm9yQWdlID0gYWdlICsgdG9OdW1iZXJPclplcm8odGhpcy5fcmVzY2NbJ3N0YWxlLWlmLWVycm9yJ10pO1xuICAgICAgICBjb25zdCBzdGFsZVdoaWxlUmV2YWxpZGF0ZUFnZSA9IGFnZSArIHRvTnVtYmVyT3JaZXJvKHRoaXMuX3Jlc2NjWydzdGFsZS13aGlsZS1yZXZhbGlkYXRlJ10pO1xuICAgICAgICByZXR1cm4gTWF0aC5yb3VuZChNYXRoLm1heCgwLCBhZ2UsIHN0YWxlSWZFcnJvckFnZSwgc3RhbGVXaGlsZVJldmFsaWRhdGVBZ2UpICogMTAwMCk7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogSWYgdHJ1ZSwgdGhpcyBjYWNoZSBlbnRyeSBpcyBwYXN0IGl0cyBleHBpcmF0aW9uIGRhdGUuXG4gICAgICogTm90ZSB0aGF0IHN0YWxlIGNhY2hlIG1heSBiZSB1c2VmdWwgc29tZXRpbWVzLCBzZWUgYGV2YWx1YXRlUmVxdWVzdCgpYC5cbiAgICAgKiBAcmV0dXJucyB7Ym9vbGVhbn0gYGZhbHNlYCBkb2Vzbid0IG1lYW4gaXQncyBmcmVzaCBub3IgdXNhYmxlXG4gICAgICovXG4gICAgc3RhbGUoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLm1heEFnZSgpIDw9IHRoaXMuYWdlKCk7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogQHJldHVybnMge2Jvb2xlYW59IGB0cnVlYCBpZiBgc3RhbGUtaWYtZXJyb3JgIGNvbmRpdGlvbiBhbGxvd3MgdXNlIG9mIGEgc3RhbGUgcmVzcG9uc2UuXG4gICAgICovXG4gICAgX3VzZVN0YWxlSWZFcnJvcigpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMubWF4QWdlKCkgKyB0b051bWJlck9yWmVybyh0aGlzLl9yZXNjY1snc3RhbGUtaWYtZXJyb3InXSkgPiB0aGlzLmFnZSgpO1xuICAgIH1cblxuICAgIC8qKiBTZWUgYGV2YWx1YXRlUmVxdWVzdCgpYCBmb3IgYSBtb3JlIGNvbXBsZXRlIHNvbHV0aW9uXG4gICAgICogQHJldHVybnMge2Jvb2xlYW59IGB0cnVlYCBpZiBgc3RhbGUtd2hpbGUtcmV2YWxpZGF0ZWAgaXMgY3VycmVudGx5IGFsbG93ZWQuXG4gICAgICovXG4gICAgdXNlU3RhbGVXaGlsZVJldmFsaWRhdGUoKSB7XG4gICAgICAgIGNvbnN0IHN3ciA9IHRvTnVtYmVyT3JaZXJvKHRoaXMuX3Jlc2NjWydzdGFsZS13aGlsZS1yZXZhbGlkYXRlJ10pO1xuICAgICAgICByZXR1cm4gc3dyID4gMCAmJiB0aGlzLm1heEFnZSgpICsgc3dyID4gdGhpcy5hZ2UoKTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBDcmVhdGVzIGEgYENhY2hlUG9saWN5YCBpbnN0YW5jZSBmcm9tIGEgc2VyaWFsaXplZCBvYmplY3QuXG4gICAgICogQHBhcmFtIHtPYmplY3R9IG9iaiAtIFRoZSBzZXJpYWxpemVkIG9iamVjdC5cbiAgICAgKiBAcmV0dXJucyB7Q2FjaGVQb2xpY3l9IEEgbmV3IENhY2hlUG9saWN5IGluc3RhbmNlLlxuICAgICAqL1xuICAgIHN0YXRpYyBmcm9tT2JqZWN0KG9iaikge1xuICAgICAgICByZXR1cm4gbmV3IHRoaXModW5kZWZpbmVkLCB1bmRlZmluZWQsIHsgX2Zyb21PYmplY3Q6IG9iaiB9KTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBAcGFyYW0ge2FueX0gb2JqIC0gVGhlIHNlcmlhbGl6ZWQgb2JqZWN0LlxuICAgICAqIEB0aHJvd3Mge0Vycm9yfSBJZiBhbHJlYWR5IGluaXRpYWxpemVkIG9yIGlmIHRoZSBvYmplY3QgaXMgaW52YWxpZC5cbiAgICAgKi9cbiAgICBfZnJvbU9iamVjdChvYmopIHtcbiAgICAgICAgaWYgKHRoaXMuX3Jlc3BvbnNlVGltZSkgdGhyb3cgRXJyb3IoJ1JlaW5pdGlhbGl6ZWQnKTtcbiAgICAgICAgaWYgKCFvYmogfHwgb2JqLnYgIT09IDEpIHRocm93IEVycm9yKCdJbnZhbGlkIHNlcmlhbGl6YXRpb24nKTtcblxuICAgICAgICB0aGlzLl9yZXNwb25zZVRpbWUgPSBvYmoudDtcbiAgICAgICAgdGhpcy5faXNTaGFyZWQgPSBvYmouc2g7XG4gICAgICAgIHRoaXMuX2NhY2hlSGV1cmlzdGljID0gb2JqLmNoO1xuICAgICAgICB0aGlzLl9pbW11dGFibGVNaW5UdGwgPVxuICAgICAgICAgICAgb2JqLmltbSAhPT0gdW5kZWZpbmVkID8gb2JqLmltbSA6IDI0ICogMzYwMCAqIDEwMDA7XG4gICAgICAgIHRoaXMuX2lnbm9yZUNhcmdvQ3VsdCA9ICEhb2JqLmljYztcbiAgICAgICAgdGhpcy5fc3RhdHVzID0gb2JqLnN0O1xuICAgICAgICB0aGlzLl9yZXNIZWFkZXJzID0gb2JqLnJlc2g7XG4gICAgICAgIHRoaXMuX3Jlc2NjID0gb2JqLnJlc2NjO1xuICAgICAgICB0aGlzLl9tZXRob2QgPSBvYmoubTtcbiAgICAgICAgdGhpcy5fdXJsID0gb2JqLnU7XG4gICAgICAgIHRoaXMuX2hvc3QgPSBvYmouaDtcbiAgICAgICAgdGhpcy5fbm9BdXRob3JpemF0aW9uID0gb2JqLmE7XG4gICAgICAgIHRoaXMuX3JlcUhlYWRlcnMgPSBvYmoucmVxaDtcbiAgICAgICAgdGhpcy5fcmVxY2MgPSBvYmoucmVxY2M7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogU2VyaWFsaXplcyB0aGUgYENhY2hlUG9saWN5YCBpbnN0YW5jZSBpbnRvIGEgSlNPTi1zZXJpYWxpemFibGUgb2JqZWN0LlxuICAgICAqIEByZXR1cm5zIHtPYmplY3R9IFRoZSBzZXJpYWxpemVkIG9iamVjdC5cbiAgICAgKi9cbiAgICB0b09iamVjdCgpIHtcbiAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgIHY6IDEsXG4gICAgICAgICAgICB0OiB0aGlzLl9yZXNwb25zZVRpbWUsXG4gICAgICAgICAgICBzaDogdGhpcy5faXNTaGFyZWQsXG4gICAgICAgICAgICBjaDogdGhpcy5fY2FjaGVIZXVyaXN0aWMsXG4gICAgICAgICAgICBpbW06IHRoaXMuX2ltbXV0YWJsZU1pblR0bCxcbiAgICAgICAgICAgIGljYzogdGhpcy5faWdub3JlQ2FyZ29DdWx0LFxuICAgICAgICAgICAgc3Q6IHRoaXMuX3N0YXR1cyxcbiAgICAgICAgICAgIHJlc2g6IHRoaXMuX3Jlc0hlYWRlcnMsXG4gICAgICAgICAgICByZXNjYzogdGhpcy5fcmVzY2MsXG4gICAgICAgICAgICBtOiB0aGlzLl9tZXRob2QsXG4gICAgICAgICAgICB1OiB0aGlzLl91cmwsXG4gICAgICAgICAgICBoOiB0aGlzLl9ob3N0LFxuICAgICAgICAgICAgYTogdGhpcy5fbm9BdXRob3JpemF0aW9uLFxuICAgICAgICAgICAgcmVxaDogdGhpcy5fcmVxSGVhZGVycyxcbiAgICAgICAgICAgIHJlcWNjOiB0aGlzLl9yZXFjYyxcbiAgICAgICAgfTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBIZWFkZXJzIGZvciBzZW5kaW5nIHRvIHRoZSBvcmlnaW4gc2VydmVyIHRvIHJldmFsaWRhdGUgc3RhbGUgcmVzcG9uc2UuXG4gICAgICogQWxsb3dzIHNlcnZlciB0byByZXR1cm4gMzA0IHRvIGFsbG93IHJldXNlIG9mIHRoZSBwcmV2aW91cyByZXNwb25zZS5cbiAgICAgKlxuICAgICAqIEhvcCBieSBob3AgaGVhZGVycyBhcmUgYWx3YXlzIHN0cmlwcGVkLlxuICAgICAqIFJldmFsaWRhdGlvbiBoZWFkZXJzIG1heSBiZSBhZGRlZCBvciByZW1vdmVkLCBkZXBlbmRpbmcgb24gcmVxdWVzdC5cbiAgICAgKiBAcGFyYW0ge0h0dHBSZXF1ZXN0fSBpbmNvbWluZ1JlcSAtIFRoZSBpbmNvbWluZyBIVFRQIHJlcXVlc3QuXG4gICAgICogQHJldHVybnMge1JlY29yZDxzdHJpbmcsIHN0cmluZz59IFRoZSBoZWFkZXJzIGZvciB0aGUgcmV2YWxpZGF0aW9uIHJlcXVlc3QuXG4gICAgICovXG4gICAgcmV2YWxpZGF0aW9uSGVhZGVycyhpbmNvbWluZ1JlcSkge1xuICAgICAgICB0aGlzLl9hc3NlcnRSZXF1ZXN0SGFzSGVhZGVycyhpbmNvbWluZ1JlcSk7XG4gICAgICAgIGNvbnN0IGhlYWRlcnMgPSB0aGlzLl9jb3B5V2l0aG91dEhvcEJ5SG9wSGVhZGVycyhpbmNvbWluZ1JlcS5oZWFkZXJzKTtcblxuICAgICAgICAvLyBUaGlzIGltcGxlbWVudGF0aW9uIGRvZXMgbm90IHVuZGVyc3RhbmQgcmFuZ2UgcmVxdWVzdHNcbiAgICAgICAgZGVsZXRlIGhlYWRlcnNbJ2lmLXJhbmdlJ107XG5cbiAgICAgICAgaWYgKCF0aGlzLl9yZXF1ZXN0TWF0Y2hlcyhpbmNvbWluZ1JlcSwgdHJ1ZSkgfHwgIXRoaXMuc3RvcmFibGUoKSkge1xuICAgICAgICAgICAgLy8gcmV2YWxpZGF0aW9uIGFsbG93ZWQgdmlhIEhFQURcbiAgICAgICAgICAgIC8vIG5vdCBmb3IgdGhlIHNhbWUgcmVzb3VyY2UsIG9yIHdhc24ndCBhbGxvd2VkIHRvIGJlIGNhY2hlZCBhbnl3YXlcbiAgICAgICAgICAgIGRlbGV0ZSBoZWFkZXJzWydpZi1ub25lLW1hdGNoJ107XG4gICAgICAgICAgICBkZWxldGUgaGVhZGVyc1snaWYtbW9kaWZpZWQtc2luY2UnXTtcbiAgICAgICAgICAgIHJldHVybiBoZWFkZXJzO1xuICAgICAgICB9XG5cbiAgICAgICAgLyogTVVTVCBzZW5kIHRoYXQgZW50aXR5LXRhZyBpbiBhbnkgY2FjaGUgdmFsaWRhdGlvbiByZXF1ZXN0ICh1c2luZyBJZi1NYXRjaCBvciBJZi1Ob25lLU1hdGNoKSBpZiBhbiBlbnRpdHktdGFnIGhhcyBiZWVuIHByb3ZpZGVkIGJ5IHRoZSBvcmlnaW4gc2VydmVyLiAqL1xuICAgICAgICBpZiAodGhpcy5fcmVzSGVhZGVycy5ldGFnKSB7XG4gICAgICAgICAgICBoZWFkZXJzWydpZi1ub25lLW1hdGNoJ10gPSBoZWFkZXJzWydpZi1ub25lLW1hdGNoJ11cbiAgICAgICAgICAgICAgICA/IGAke2hlYWRlcnNbJ2lmLW5vbmUtbWF0Y2gnXX0sICR7dGhpcy5fcmVzSGVhZGVycy5ldGFnfWBcbiAgICAgICAgICAgICAgICA6IHRoaXMuX3Jlc0hlYWRlcnMuZXRhZztcbiAgICAgICAgfVxuXG4gICAgICAgIC8vIENsaWVudHMgTUFZIGlzc3VlIHNpbXBsZSAobm9uLXN1YnJhbmdlKSBHRVQgcmVxdWVzdHMgd2l0aCBlaXRoZXIgd2VhayB2YWxpZGF0b3JzIG9yIHN0cm9uZyB2YWxpZGF0b3JzLiBDbGllbnRzIE1VU1QgTk9UIHVzZSB3ZWFrIHZhbGlkYXRvcnMgaW4gb3RoZXIgZm9ybXMgb2YgcmVxdWVzdC5cbiAgICAgICAgY29uc3QgZm9yYmlkc1dlYWtWYWxpZGF0b3JzID1cbiAgICAgICAgICAgIGhlYWRlcnNbJ2FjY2VwdC1yYW5nZXMnXSB8fFxuICAgICAgICAgICAgaGVhZGVyc1snaWYtbWF0Y2gnXSB8fFxuICAgICAgICAgICAgaGVhZGVyc1snaWYtdW5tb2RpZmllZC1zaW5jZSddIHx8XG4gICAgICAgICAgICAodGhpcy5fbWV0aG9kICYmIHRoaXMuX21ldGhvZCAhPSAnR0VUJyk7XG5cbiAgICAgICAgLyogU0hPVUxEIHNlbmQgdGhlIExhc3QtTW9kaWZpZWQgdmFsdWUgaW4gbm9uLXN1YnJhbmdlIGNhY2hlIHZhbGlkYXRpb24gcmVxdWVzdHMgKHVzaW5nIElmLU1vZGlmaWVkLVNpbmNlKSBpZiBvbmx5IGEgTGFzdC1Nb2RpZmllZCB2YWx1ZSBoYXMgYmVlbiBwcm92aWRlZCBieSB0aGUgb3JpZ2luIHNlcnZlci5cbiAgICAgICAgTm90ZTogVGhpcyBpbXBsZW1lbnRhdGlvbiBkb2VzIG5vdCB1bmRlcnN0YW5kIHBhcnRpYWwgcmVzcG9uc2VzICgyMDYpICovXG4gICAgICAgIGlmIChmb3JiaWRzV2Vha1ZhbGlkYXRvcnMpIHtcbiAgICAgICAgICAgIGRlbGV0ZSBoZWFkZXJzWydpZi1tb2RpZmllZC1zaW5jZSddO1xuXG4gICAgICAgICAgICBpZiAoaGVhZGVyc1snaWYtbm9uZS1tYXRjaCddKSB7XG4gICAgICAgICAgICAgICAgY29uc3QgZXRhZ3MgPSBoZWFkZXJzWydpZi1ub25lLW1hdGNoJ11cbiAgICAgICAgICAgICAgICAgICAgLnNwbGl0KC8sLylcbiAgICAgICAgICAgICAgICAgICAgLmZpbHRlcihldGFnID0+IHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiAhL15cXHMqV1xcLy8udGVzdChldGFnKTtcbiAgICAgICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgaWYgKCFldGFncy5sZW5ndGgpIHtcbiAgICAgICAgICAgICAgICAgICAgZGVsZXRlIGhlYWRlcnNbJ2lmLW5vbmUtbWF0Y2gnXTtcbiAgICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICBoZWFkZXJzWydpZi1ub25lLW1hdGNoJ10gPSBldGFncy5qb2luKCcsJykudHJpbSgpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgfSBlbHNlIGlmIChcbiAgICAgICAgICAgIHRoaXMuX3Jlc0hlYWRlcnNbJ2xhc3QtbW9kaWZpZWQnXSAmJlxuICAgICAgICAgICAgIWhlYWRlcnNbJ2lmLW1vZGlmaWVkLXNpbmNlJ11cbiAgICAgICAgKSB7XG4gICAgICAgICAgICBoZWFkZXJzWydpZi1tb2RpZmllZC1zaW5jZSddID0gdGhpcy5fcmVzSGVhZGVyc1snbGFzdC1tb2RpZmllZCddO1xuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuIGhlYWRlcnM7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogQ3JlYXRlcyBuZXcgQ2FjaGVQb2xpY3kgd2l0aCBpbmZvcm1hdGlvbiBjb21iaW5lZCBmcm9tIHRoZSBwcmV2aWV3cyByZXNwb25zZSxcbiAgICAgKiBhbmQgdGhlIG5ldyByZXZhbGlkYXRpb24gcmVzcG9uc2UuXG4gICAgICpcbiAgICAgKiBSZXR1cm5zIHtwb2xpY3ksIG1vZGlmaWVkfSB3aGVyZSBtb2RpZmllZCBpcyBhIGJvb2xlYW4gaW5kaWNhdGluZ1xuICAgICAqIHdoZXRoZXIgdGhlIHJlc3BvbnNlIGJvZHkgaGFzIGJlZW4gbW9kaWZpZWQsIGFuZCBvbGQgY2FjaGVkIGJvZHkgY2FuJ3QgYmUgdXNlZC5cbiAgICAgKlxuICAgICAqIEBwYXJhbSB7SHR0cFJlcXVlc3R9IHJlcXVlc3QgLSBUaGUgbGF0ZXN0IEhUVFAgcmVxdWVzdCBhc2tpbmcgZm9yIHRoZSBjYWNoZWQgZW50cnkuXG4gICAgICogQHBhcmFtIHtIdHRwUmVzcG9uc2V9IHJlc3BvbnNlIC0gVGhlIGxhdGVzdCByZXZhbGlkYXRpb24gSFRUUCByZXNwb25zZSBmcm9tIHRoZSBvcmlnaW4gc2VydmVyLlxuICAgICAqIEByZXR1cm5zIHt7cG9saWN5OiBDYWNoZVBvbGljeSwgbW9kaWZpZWQ6IGJvb2xlYW4sIG1hdGNoZXM6IGJvb2xlYW59fSBUaGUgdXBkYXRlZCBwb2xpY3kgYW5kIG1vZGlmaWNhdGlvbiBzdGF0dXMuXG4gICAgICogQHRocm93cyB7RXJyb3J9IElmIHRoZSByZXNwb25zZSBoZWFkZXJzIGFyZSBtaXNzaW5nLlxuICAgICAqL1xuICAgIHJldmFsaWRhdGVkUG9saWN5KHJlcXVlc3QsIHJlc3BvbnNlKSB7XG4gICAgICAgIHRoaXMuX2Fzc2VydFJlcXVlc3RIYXNIZWFkZXJzKHJlcXVlc3QpO1xuXG4gICAgICAgIGlmICh0aGlzLl91c2VTdGFsZUlmRXJyb3IoKSAmJiBpc0Vycm9yUmVzcG9uc2UocmVzcG9uc2UpKSB7XG4gICAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgICAgcG9saWN5OiB0aGlzLFxuICAgICAgICAgICAgICBtb2RpZmllZDogZmFsc2UsXG4gICAgICAgICAgICAgIG1hdGNoZXM6IHRydWUsXG4gICAgICAgICAgfTtcbiAgICAgICAgfVxuXG4gICAgICAgIGlmICghcmVzcG9uc2UgfHwgIXJlc3BvbnNlLmhlYWRlcnMpIHtcbiAgICAgICAgICAgIHRocm93IEVycm9yKCdSZXNwb25zZSBoZWFkZXJzIG1pc3NpbmcnKTtcbiAgICAgICAgfVxuXG4gICAgICAgIC8vIFRoZXNlIGFyZW4ndCBnb2luZyB0byBiZSBzdXBwb3J0ZWQgZXhhY3RseSwgc2luY2Ugb25lIENhY2hlUG9saWN5IG9iamVjdFxuICAgICAgICAvLyBkb2Vzbid0IGtub3cgYWJvdXQgYWxsIHRoZSBvdGhlciBjYWNoZWQgb2JqZWN0cy5cbiAgICAgICAgbGV0IG1hdGNoZXMgPSBmYWxzZTtcbiAgICAgICAgaWYgKHJlc3BvbnNlLnN0YXR1cyAhPT0gdW5kZWZpbmVkICYmIHJlc3BvbnNlLnN0YXR1cyAhPSAzMDQpIHtcbiAgICAgICAgICAgIG1hdGNoZXMgPSBmYWxzZTtcbiAgICAgICAgfSBlbHNlIGlmIChcbiAgICAgICAgICAgIHJlc3BvbnNlLmhlYWRlcnMuZXRhZyAmJlxuICAgICAgICAgICAgIS9eXFxzKldcXC8vLnRlc3QocmVzcG9uc2UuaGVhZGVycy5ldGFnKVxuICAgICAgICApIHtcbiAgICAgICAgICAgIC8vIFwiQWxsIG9mIHRoZSBzdG9yZWQgcmVzcG9uc2VzIHdpdGggdGhlIHNhbWUgc3Ryb25nIHZhbGlkYXRvciBhcmUgc2VsZWN0ZWQuXG4gICAgICAgICAgICAvLyBJZiBub25lIG9mIHRoZSBzdG9yZWQgcmVzcG9uc2VzIGNvbnRhaW4gdGhlIHNhbWUgc3Ryb25nIHZhbGlkYXRvcixcbiAgICAgICAgICAgIC8vIHRoZW4gdGhlIGNhY2hlIE1VU1QgTk9UIHVzZSB0aGUgbmV3IHJlc3BvbnNlIHRvIHVwZGF0ZSBhbnkgc3RvcmVkIHJlc3BvbnNlcy5cIlxuICAgICAgICAgICAgbWF0Y2hlcyA9XG4gICAgICAgICAgICAgICAgdGhpcy5fcmVzSGVhZGVycy5ldGFnICYmXG4gICAgICAgICAgICAgICAgdGhpcy5fcmVzSGVhZGVycy5ldGFnLnJlcGxhY2UoL15cXHMqV1xcLy8sICcnKSA9PT1cbiAgICAgICAgICAgICAgICAgICAgcmVzcG9uc2UuaGVhZGVycy5ldGFnO1xuICAgICAgICB9IGVsc2UgaWYgKHRoaXMuX3Jlc0hlYWRlcnMuZXRhZyAmJiByZXNwb25zZS5oZWFkZXJzLmV0YWcpIHtcbiAgICAgICAgICAgIC8vIFwiSWYgdGhlIG5ldyByZXNwb25zZSBjb250YWlucyBhIHdlYWsgdmFsaWRhdG9yIGFuZCB0aGF0IHZhbGlkYXRvciBjb3JyZXNwb25kc1xuICAgICAgICAgICAgLy8gdG8gb25lIG9mIHRoZSBjYWNoZSdzIHN0b3JlZCByZXNwb25zZXMsXG4gICAgICAgICAgICAvLyB0aGVuIHRoZSBtb3N0IHJlY2VudCBvZiB0aG9zZSBtYXRjaGluZyBzdG9yZWQgcmVzcG9uc2VzIGlzIHNlbGVjdGVkIGZvciB1cGRhdGUuXCJcbiAgICAgICAgICAgIG1hdGNoZXMgPVxuICAgICAgICAgICAgICAgIHRoaXMuX3Jlc0hlYWRlcnMuZXRhZy5yZXBsYWNlKC9eXFxzKldcXC8vLCAnJykgPT09XG4gICAgICAgICAgICAgICAgcmVzcG9uc2UuaGVhZGVycy5ldGFnLnJlcGxhY2UoL15cXHMqV1xcLy8sICcnKTtcbiAgICAgICAgfSBlbHNlIGlmICh0aGlzLl9yZXNIZWFkZXJzWydsYXN0LW1vZGlmaWVkJ10pIHtcbiAgICAgICAgICAgIG1hdGNoZXMgPVxuICAgICAgICAgICAgICAgIHRoaXMuX3Jlc0hlYWRlcnNbJ2xhc3QtbW9kaWZpZWQnXSA9PT1cbiAgICAgICAgICAgICAgICByZXNwb25zZS5oZWFkZXJzWydsYXN0LW1vZGlmaWVkJ107XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAvLyBJZiB0aGUgbmV3IHJlc3BvbnNlIGRvZXMgbm90IGluY2x1ZGUgYW55IGZvcm0gb2YgdmFsaWRhdG9yIChzdWNoIGFzIGluIHRoZSBjYXNlIHdoZXJlXG4gICAgICAgICAgICAvLyBhIGNsaWVudCBnZW5lcmF0ZXMgYW4gSWYtTW9kaWZpZWQtU2luY2UgcmVxdWVzdCBmcm9tIGEgc291cmNlIG90aGVyIHRoYW4gdGhlIExhc3QtTW9kaWZpZWRcbiAgICAgICAgICAgIC8vIHJlc3BvbnNlIGhlYWRlciBmaWVsZCksIGFuZCB0aGVyZSBpcyBvbmx5IG9uZSBzdG9yZWQgcmVzcG9uc2UsIGFuZCB0aGF0IHN0b3JlZCByZXNwb25zZSBhbHNvXG4gICAgICAgICAgICAvLyBsYWNrcyBhIHZhbGlkYXRvciwgdGhlbiB0aGF0IHN0b3JlZCByZXNwb25zZSBpcyBzZWxlY3RlZCBmb3IgdXBkYXRlLlxuICAgICAgICAgICAgaWYgKFxuICAgICAgICAgICAgICAgICF0aGlzLl9yZXNIZWFkZXJzLmV0YWcgJiZcbiAgICAgICAgICAgICAgICAhdGhpcy5fcmVzSGVhZGVyc1snbGFzdC1tb2RpZmllZCddICYmXG4gICAgICAgICAgICAgICAgIXJlc3BvbnNlLmhlYWRlcnMuZXRhZyAmJlxuICAgICAgICAgICAgICAgICFyZXNwb25zZS5oZWFkZXJzWydsYXN0LW1vZGlmaWVkJ11cbiAgICAgICAgICAgICkge1xuICAgICAgICAgICAgICAgIG1hdGNoZXMgPSB0cnVlO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG5cbiAgICAgICAgY29uc3Qgb3B0aW9uc0NvcHkgPSB7XG4gICAgICAgICAgICBzaGFyZWQ6IHRoaXMuX2lzU2hhcmVkLFxuICAgICAgICAgICAgY2FjaGVIZXVyaXN0aWM6IHRoaXMuX2NhY2hlSGV1cmlzdGljLFxuICAgICAgICAgICAgaW1tdXRhYmxlTWluVGltZVRvTGl2ZTogdGhpcy5faW1tdXRhYmxlTWluVHRsLFxuICAgICAgICAgICAgaWdub3JlQ2FyZ29DdWx0OiB0aGlzLl9pZ25vcmVDYXJnb0N1bHQsXG4gICAgICAgIH07XG5cbiAgICAgICAgaWYgKCFtYXRjaGVzKSB7XG4gICAgICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgICAgIHBvbGljeTogbmV3IHRoaXMuY29uc3RydWN0b3IocmVxdWVzdCwgcmVzcG9uc2UsIG9wdGlvbnNDb3B5KSxcbiAgICAgICAgICAgICAgICAvLyBDbGllbnQgcmVjZWl2aW5nIDMwNCB3aXRob3V0IGJvZHksIGV2ZW4gaWYgaXQncyBpbnZhbGlkL21pc21hdGNoZWQgaGFzIG5vIG9wdGlvblxuICAgICAgICAgICAgICAgIC8vIGJ1dCB0byByZXVzZSBhIGNhY2hlZCBib2R5LiBXZSBkb24ndCBoYXZlIGEgZ29vZCB3YXkgdG8gdGVsbCBjbGllbnRzIHRvIGRvXG4gICAgICAgICAgICAgICAgLy8gZXJyb3IgcmVjb3ZlcnkgaW4gc3VjaCBjYXNlLlxuICAgICAgICAgICAgICAgIG1vZGlmaWVkOiByZXNwb25zZS5zdGF0dXMgIT0gMzA0LFxuICAgICAgICAgICAgICAgIG1hdGNoZXM6IGZhbHNlLFxuICAgICAgICAgICAgfTtcbiAgICAgICAgfVxuXG4gICAgICAgIC8vIHVzZSBvdGhlciBoZWFkZXIgZmllbGRzIHByb3ZpZGVkIGluIHRoZSAzMDQgKE5vdCBNb2RpZmllZCkgcmVzcG9uc2UgdG8gcmVwbGFjZSBhbGwgaW5zdGFuY2VzXG4gICAgICAgIC8vIG9mIHRoZSBjb3JyZXNwb25kaW5nIGhlYWRlciBmaWVsZHMgaW4gdGhlIHN0b3JlZCByZXNwb25zZS5cbiAgICAgICAgY29uc3QgaGVhZGVycyA9IHt9O1xuICAgICAgICBmb3IgKGNvbnN0IGsgaW4gdGhpcy5fcmVzSGVhZGVycykge1xuICAgICAgICAgICAgaGVhZGVyc1trXSA9XG4gICAgICAgICAgICAgICAgayBpbiByZXNwb25zZS5oZWFkZXJzICYmICFleGNsdWRlZEZyb21SZXZhbGlkYXRpb25VcGRhdGVba11cbiAgICAgICAgICAgICAgICAgICAgPyByZXNwb25zZS5oZWFkZXJzW2tdXG4gICAgICAgICAgICAgICAgICAgIDogdGhpcy5fcmVzSGVhZGVyc1trXTtcbiAgICAgICAgfVxuXG4gICAgICAgIGNvbnN0IG5ld1Jlc3BvbnNlID0gT2JqZWN0LmFzc2lnbih7fSwgcmVzcG9uc2UsIHtcbiAgICAgICAgICAgIHN0YXR1czogdGhpcy5fc3RhdHVzLFxuICAgICAgICAgICAgbWV0aG9kOiB0aGlzLl9tZXRob2QsXG4gICAgICAgICAgICBoZWFkZXJzLFxuICAgICAgICB9KTtcbiAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgIHBvbGljeTogbmV3IHRoaXMuY29uc3RydWN0b3IocmVxdWVzdCwgbmV3UmVzcG9uc2UsIG9wdGlvbnNDb3B5KSxcbiAgICAgICAgICAgIG1vZGlmaWVkOiBmYWxzZSxcbiAgICAgICAgICAgIG1hdGNoZXM6IHRydWUsXG4gICAgICAgIH07XG4gICAgfVxufTtcbiJdLCJuYW1lcyI6W10sImlnbm9yZUxpc3QiOlswXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/http-cache-semantics/index.js\n");

/***/ })

};
;
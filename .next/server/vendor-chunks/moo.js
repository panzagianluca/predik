/*
 * ATTENTION: An "eval-source-map" devtool has been used.
 * This devtool is neither made for production nor for readable output files.
 * It uses "eval()" calls to create a separate source file with attached SourceMaps in the browser devtools.
 * If you are trying to read the output file, select a different devtool (https://webpack.js.org/configuration/devtool/)
 * or disable the default devtool with "devtool: false".
 * If you are looking for production-ready output files, see mode: "production" (https://webpack.js.org/configuration/mode/).
 */
exports.id = "vendor-chunks/moo";
exports.ids = ["vendor-chunks/moo"];
exports.modules = {

/***/ "(ssr)/./node_modules/moo/moo.js":
/*!*********************************!*\
  !*** ./node_modules/moo/moo.js ***!
  \*********************************/
/***/ (function(module, exports) {

eval("var __WEBPACK_AMD_DEFINE_FACTORY__, __WEBPACK_AMD_DEFINE_ARRAY__, __WEBPACK_AMD_DEFINE_RESULT__;(function(root, factory) {\n  if (true) {\n    !(__WEBPACK_AMD_DEFINE_ARRAY__ = [], __WEBPACK_AMD_DEFINE_FACTORY__ = (factory),\n\t\t__WEBPACK_AMD_DEFINE_RESULT__ = (typeof __WEBPACK_AMD_DEFINE_FACTORY__ === 'function' ?\n\t\t(__WEBPACK_AMD_DEFINE_FACTORY__.apply(exports, __WEBPACK_AMD_DEFINE_ARRAY__)) : __WEBPACK_AMD_DEFINE_FACTORY__),\n\t\t__WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__)) /* global define */\n  } else {}\n}(this, function() {\n  'use strict';\n\n  var hasOwnProperty = Object.prototype.hasOwnProperty\n  var toString = Object.prototype.toString\n  var hasSticky = typeof new RegExp().sticky === 'boolean'\n\n  /***************************************************************************/\n\n  function isRegExp(o) { return o && toString.call(o) === '[object RegExp]' }\n  function isObject(o) { return o && typeof o === 'object' && !isRegExp(o) && !Array.isArray(o) }\n\n  function reEscape(s) {\n    return s.replace(/[-\\/\\\\^$*+?.()|[\\]{}]/g, '\\\\$&')\n  }\n  function reGroups(s) {\n    var re = new RegExp('|' + s)\n    return re.exec('').length - 1\n  }\n  function reCapture(s) {\n    return '(' + s + ')'\n  }\n  function reUnion(regexps) {\n    if (!regexps.length) return '(?!)'\n    var source =  regexps.map(function(s) {\n      return \"(?:\" + s + \")\"\n    }).join('|')\n    return \"(?:\" + source + \")\"\n  }\n\n  function regexpOrLiteral(obj) {\n    if (typeof obj === 'string') {\n      return '(?:' + reEscape(obj) + ')'\n\n    } else if (isRegExp(obj)) {\n      // TODO: consider /u support\n      if (obj.ignoreCase) throw new Error('RegExp /i flag not allowed')\n      if (obj.global) throw new Error('RegExp /g flag is implied')\n      if (obj.sticky) throw new Error('RegExp /y flag is implied')\n      if (obj.multiline) throw new Error('RegExp /m flag is implied')\n      return obj.source\n\n    } else {\n      throw new Error('Not a pattern: ' + obj)\n    }\n  }\n\n  function pad(s, length) {\n    if (s.length > length) {\n      return s\n    }\n    return Array(length - s.length + 1).join(\" \") + s\n  }\n\n  function lastNLines(string, numLines) {\n    var position = string.length\n    var lineBreaks = 0;\n    while (true) {\n      var idx = string.lastIndexOf(\"\\n\", position - 1)\n      if (idx === -1) {\n        break;\n      } else {\n        lineBreaks++\n      }\n      position = idx\n      if (lineBreaks === numLines) {\n        break;\n      }\n      if (position === 0) {\n        break;\n      }\n    }\n    var startPosition = \n      lineBreaks < numLines ?\n      0 : \n      position + 1\n    return string.substring(startPosition).split(\"\\n\")\n  }\n\n  function objectToRules(object) {\n    var keys = Object.getOwnPropertyNames(object)\n    var result = []\n    for (var i = 0; i < keys.length; i++) {\n      var key = keys[i]\n      var thing = object[key]\n      var rules = [].concat(thing)\n      if (key === 'include') {\n        for (var j = 0; j < rules.length; j++) {\n          result.push({include: rules[j]})\n        }\n        continue\n      }\n      var match = []\n      rules.forEach(function(rule) {\n        if (isObject(rule)) {\n          if (match.length) result.push(ruleOptions(key, match))\n          result.push(ruleOptions(key, rule))\n          match = []\n        } else {\n          match.push(rule)\n        }\n      })\n      if (match.length) result.push(ruleOptions(key, match))\n    }\n    return result\n  }\n\n  function arrayToRules(array) {\n    var result = []\n    for (var i = 0; i < array.length; i++) {\n      var obj = array[i]\n      if (obj.include) {\n        var include = [].concat(obj.include)\n        for (var j = 0; j < include.length; j++) {\n          result.push({include: include[j]})\n        }\n        continue\n      }\n      if (!obj.type) {\n        throw new Error('Rule has no type: ' + JSON.stringify(obj))\n      }\n      result.push(ruleOptions(obj.type, obj))\n    }\n    return result\n  }\n\n  function ruleOptions(type, obj) {\n    if (!isObject(obj)) {\n      obj = { match: obj }\n    }\n    if (obj.include) {\n      throw new Error('Matching rules cannot also include states')\n    }\n\n    // nb. error and fallback imply lineBreaks\n    var options = {\n      defaultType: type,\n      lineBreaks: !!obj.error || !!obj.fallback,\n      pop: false,\n      next: null,\n      push: null,\n      error: false,\n      fallback: false,\n      value: null,\n      type: null,\n      shouldThrow: false,\n    }\n\n    // Avoid Object.assign(), so we support IE9+\n    for (var key in obj) {\n      if (hasOwnProperty.call(obj, key)) {\n        options[key] = obj[key]\n      }\n    }\n\n    // type transform cannot be a string\n    if (typeof options.type === 'string' && type !== options.type) {\n      throw new Error(\"Type transform cannot be a string (type '\" + options.type + \"' for token '\" + type + \"')\")\n    }\n\n    // convert to array\n    var match = options.match\n    options.match = Array.isArray(match) ? match : match ? [match] : []\n    options.match.sort(function(a, b) {\n      return isRegExp(a) && isRegExp(b) ? 0\n           : isRegExp(b) ? -1 : isRegExp(a) ? +1 : b.length - a.length\n    })\n    return options\n  }\n\n  function toRules(spec) {\n    return Array.isArray(spec) ? arrayToRules(spec) : objectToRules(spec)\n  }\n\n  var defaultErrorRule = ruleOptions('error', {lineBreaks: true, shouldThrow: true})\n  function compileRules(rules, hasStates) {\n    var errorRule = null\n    var fast = Object.create(null)\n    var fastAllowed = true\n    var unicodeFlag = null\n    var groups = []\n    var parts = []\n\n    // If there is a fallback rule, then disable fast matching\n    for (var i = 0; i < rules.length; i++) {\n      if (rules[i].fallback) {\n        fastAllowed = false\n      }\n    }\n\n    for (var i = 0; i < rules.length; i++) {\n      var options = rules[i]\n\n      if (options.include) {\n        // all valid inclusions are removed by states() preprocessor\n        throw new Error('Inheritance is not allowed in stateless lexers')\n      }\n\n      if (options.error || options.fallback) {\n        // errorRule can only be set once\n        if (errorRule) {\n          if (!options.fallback === !errorRule.fallback) {\n            throw new Error(\"Multiple \" + (options.fallback ? \"fallback\" : \"error\") + \" rules not allowed (for token '\" + options.defaultType + \"')\")\n          } else {\n            throw new Error(\"fallback and error are mutually exclusive (for token '\" + options.defaultType + \"')\")\n          }\n        }\n        errorRule = options\n      }\n\n      var match = options.match.slice()\n      if (fastAllowed) {\n        while (match.length && typeof match[0] === 'string' && match[0].length === 1) {\n          var word = match.shift()\n          fast[word.charCodeAt(0)] = options\n        }\n      }\n\n      // Warn about inappropriate state-switching options\n      if (options.pop || options.push || options.next) {\n        if (!hasStates) {\n          throw new Error(\"State-switching options are not allowed in stateless lexers (for token '\" + options.defaultType + \"')\")\n        }\n        if (options.fallback) {\n          throw new Error(\"State-switching options are not allowed on fallback tokens (for token '\" + options.defaultType + \"')\")\n        }\n      }\n\n      // Only rules with a .match are included in the RegExp\n      if (match.length === 0) {\n        continue\n      }\n      fastAllowed = false\n\n      groups.push(options)\n\n      // Check unicode flag is used everywhere or nowhere\n      for (var j = 0; j < match.length; j++) {\n        var obj = match[j]\n        if (!isRegExp(obj)) {\n          continue\n        }\n\n        if (unicodeFlag === null) {\n          unicodeFlag = obj.unicode\n        } else if (unicodeFlag !== obj.unicode && options.fallback === false) {\n          throw new Error('If one rule is /u then all must be')\n        }\n      }\n\n      // convert to RegExp\n      var pat = reUnion(match.map(regexpOrLiteral))\n\n      // validate\n      var regexp = new RegExp(pat)\n      if (regexp.test(\"\")) {\n        throw new Error(\"RegExp matches empty string: \" + regexp)\n      }\n      var groupCount = reGroups(pat)\n      if (groupCount > 0) {\n        throw new Error(\"RegExp has capture groups: \" + regexp + \"\\nUse (?: â€¦ ) instead\")\n      }\n\n      // try and detect rules matching newlines\n      if (!options.lineBreaks && regexp.test('\\n')) {\n        throw new Error('Rule should declare lineBreaks: ' + regexp)\n      }\n\n      // store regex\n      parts.push(reCapture(pat))\n    }\n\n\n    // If there's no fallback rule, use the sticky flag so we only look for\n    // matches at the current index.\n    //\n    // If we don't support the sticky flag, then fake it using an irrefutable\n    // match (i.e. an empty pattern).\n    var fallbackRule = errorRule && errorRule.fallback\n    var flags = hasSticky && !fallbackRule ? 'ym' : 'gm'\n    var suffix = hasSticky || fallbackRule ? '' : '|'\n\n    if (unicodeFlag === true) flags += \"u\"\n    var combined = new RegExp(reUnion(parts) + suffix, flags)\n    return {regexp: combined, groups: groups, fast: fast, error: errorRule || defaultErrorRule}\n  }\n\n  function compile(rules) {\n    var result = compileRules(toRules(rules))\n    return new Lexer({start: result}, 'start')\n  }\n\n  function checkStateGroup(g, name, map) {\n    var state = g && (g.push || g.next)\n    if (state && !map[state]) {\n      throw new Error(\"Missing state '\" + state + \"' (in token '\" + g.defaultType + \"' of state '\" + name + \"')\")\n    }\n    if (g && g.pop && +g.pop !== 1) {\n      throw new Error(\"pop must be 1 (in token '\" + g.defaultType + \"' of state '\" + name + \"')\")\n    }\n  }\n  function compileStates(states, start) {\n    var all = states.$all ? toRules(states.$all) : []\n    delete states.$all\n\n    var keys = Object.getOwnPropertyNames(states)\n    if (!start) start = keys[0]\n\n    var ruleMap = Object.create(null)\n    for (var i = 0; i < keys.length; i++) {\n      var key = keys[i]\n      ruleMap[key] = toRules(states[key]).concat(all)\n    }\n    for (var i = 0; i < keys.length; i++) {\n      var key = keys[i]\n      var rules = ruleMap[key]\n      var included = Object.create(null)\n      for (var j = 0; j < rules.length; j++) {\n        var rule = rules[j]\n        if (!rule.include) continue\n        var splice = [j, 1]\n        if (rule.include !== key && !included[rule.include]) {\n          included[rule.include] = true\n          var newRules = ruleMap[rule.include]\n          if (!newRules) {\n            throw new Error(\"Cannot include nonexistent state '\" + rule.include + \"' (in state '\" + key + \"')\")\n          }\n          for (var k = 0; k < newRules.length; k++) {\n            var newRule = newRules[k]\n            if (rules.indexOf(newRule) !== -1) continue\n            splice.push(newRule)\n          }\n        }\n        rules.splice.apply(rules, splice)\n        j--\n      }\n    }\n\n    var map = Object.create(null)\n    for (var i = 0; i < keys.length; i++) {\n      var key = keys[i]\n      map[key] = compileRules(ruleMap[key], true)\n    }\n\n    for (var i = 0; i < keys.length; i++) {\n      var name = keys[i]\n      var state = map[name]\n      var groups = state.groups\n      for (var j = 0; j < groups.length; j++) {\n        checkStateGroup(groups[j], name, map)\n      }\n      var fastKeys = Object.getOwnPropertyNames(state.fast)\n      for (var j = 0; j < fastKeys.length; j++) {\n        checkStateGroup(state.fast[fastKeys[j]], name, map)\n      }\n    }\n\n    return new Lexer(map, start)\n  }\n\n  function keywordTransform(map) {\n\n    // Use a JavaScript Map to map keywords to their corresponding token type\n    // unless Map is unsupported, then fall back to using an Object:\n    var isMap = typeof Map !== 'undefined'\n    var reverseMap = isMap ? new Map : Object.create(null)\n\n    var types = Object.getOwnPropertyNames(map)\n    for (var i = 0; i < types.length; i++) {\n      var tokenType = types[i]\n      var item = map[tokenType]\n      var keywordList = Array.isArray(item) ? item : [item]\n      keywordList.forEach(function(keyword) {\n        if (typeof keyword !== 'string') {\n          throw new Error(\"keyword must be string (in keyword '\" + tokenType + \"')\")\n        }\n        if (isMap) {\n          reverseMap.set(keyword, tokenType)\n        } else {\n          reverseMap[keyword] = tokenType\n        }\n      })\n    }\n    return function(k) {\n      return isMap ? reverseMap.get(k) : reverseMap[k]\n    }\n  }\n\n  /***************************************************************************/\n\n  var Lexer = function(states, state) {\n    this.startState = state\n    this.states = states\n    this.buffer = ''\n    this.stack = []\n    this.reset()\n  }\n\n  Lexer.prototype.reset = function(data, info) {\n    this.buffer = data || ''\n    this.index = 0\n    this.line = info ? info.line : 1\n    this.col = info ? info.col : 1\n    this.queuedToken = info ? info.queuedToken : null\n    this.queuedText = info ? info.queuedText: \"\";\n    this.queuedThrow = info ? info.queuedThrow : null\n    this.setState(info ? info.state : this.startState)\n    this.stack = info && info.stack ? info.stack.slice() : []\n    return this\n  }\n\n  Lexer.prototype.save = function() {\n    return {\n      line: this.line,\n      col: this.col,\n      state: this.state,\n      stack: this.stack.slice(),\n      queuedToken: this.queuedToken,\n      queuedText: this.queuedText,\n      queuedThrow: this.queuedThrow,\n    }\n  }\n\n  Lexer.prototype.setState = function(state) {\n    if (!state || this.state === state) return\n    this.state = state\n    var info = this.states[state]\n    this.groups = info.groups\n    this.error = info.error\n    this.re = info.regexp\n    this.fast = info.fast\n  }\n\n  Lexer.prototype.popState = function() {\n    this.setState(this.stack.pop())\n  }\n\n  Lexer.prototype.pushState = function(state) {\n    this.stack.push(this.state)\n    this.setState(state)\n  }\n\n  var eat = hasSticky ? function(re, buffer) { // assume re is /y\n    return re.exec(buffer)\n  } : function(re, buffer) { // assume re is /g\n    var match = re.exec(buffer)\n    // will always match, since we used the |(?:) trick\n    if (match[0].length === 0) {\n      return null\n    }\n    return match\n  }\n\n  Lexer.prototype._getGroup = function(match) {\n    var groupCount = this.groups.length\n    for (var i = 0; i < groupCount; i++) {\n      if (match[i + 1] !== undefined) {\n        return this.groups[i]\n      }\n    }\n    throw new Error('Cannot find token type for matched text')\n  }\n\n  function tokenToString() {\n    return this.value\n  }\n\n  Lexer.prototype.next = function() {\n    var index = this.index\n\n    // If a fallback token matched, we don't need to re-run the RegExp\n    if (this.queuedGroup) {\n      var token = this._token(this.queuedGroup, this.queuedText, index)\n      this.queuedGroup = null\n      this.queuedText = \"\"\n      return token\n    }\n\n    var buffer = this.buffer\n    if (index === buffer.length) {\n      return // EOF\n    }\n\n    // Fast matching for single characters\n    var group = this.fast[buffer.charCodeAt(index)]\n    if (group) {\n      return this._token(group, buffer.charAt(index), index)\n    }\n\n    // Execute RegExp\n    var re = this.re\n    re.lastIndex = index\n    var match = eat(re, buffer)\n\n    // Error tokens match the remaining buffer\n    var error = this.error\n    if (match == null) {\n      return this._token(error, buffer.slice(index, buffer.length), index)\n    }\n\n    var group = this._getGroup(match)\n    var text = match[0]\n\n    if (error.fallback && match.index !== index) {\n      this.queuedGroup = group\n      this.queuedText = text\n\n      // Fallback tokens contain the unmatched portion of the buffer\n      return this._token(error, buffer.slice(index, match.index), index)\n    }\n\n    return this._token(group, text, index)\n  }\n\n  Lexer.prototype._token = function(group, text, offset) {\n    // count line breaks\n    var lineBreaks = 0\n    if (group.lineBreaks) {\n      var matchNL = /\\n/g\n      var nl = 1\n      if (text === '\\n') {\n        lineBreaks = 1\n      } else {\n        while (matchNL.exec(text)) { lineBreaks++; nl = matchNL.lastIndex }\n      }\n    }\n\n    var token = {\n      type: (typeof group.type === 'function' && group.type(text)) || group.defaultType,\n      value: typeof group.value === 'function' ? group.value(text) : text,\n      text: text,\n      toString: tokenToString,\n      offset: offset,\n      lineBreaks: lineBreaks,\n      line: this.line,\n      col: this.col,\n    }\n    // nb. adding more props to token object will make V8 sad!\n\n    var size = text.length\n    this.index += size\n    this.line += lineBreaks\n    if (lineBreaks !== 0) {\n      this.col = size - nl + 1\n    } else {\n      this.col += size\n    }\n\n    // throw, if no rule with {error: true}\n    if (group.shouldThrow) {\n      var err = new Error(this.formatError(token, \"invalid syntax\"))\n      throw err;\n    }\n\n    if (group.pop) this.popState()\n    else if (group.push) this.pushState(group.push)\n    else if (group.next) this.setState(group.next)\n\n    return token\n  }\n\n  if (typeof Symbol !== 'undefined' && Symbol.iterator) {\n    var LexerIterator = function(lexer) {\n      this.lexer = lexer\n    }\n\n    LexerIterator.prototype.next = function() {\n      var token = this.lexer.next()\n      return {value: token, done: !token}\n    }\n\n    LexerIterator.prototype[Symbol.iterator] = function() {\n      return this\n    }\n\n    Lexer.prototype[Symbol.iterator] = function() {\n      return new LexerIterator(this)\n    }\n  }\n\n  Lexer.prototype.formatError = function(token, message) {\n    if (token == null) {\n      // An undefined token indicates EOF\n      var text = this.buffer.slice(this.index)\n      var token = {\n        text: text,\n        offset: this.index,\n        lineBreaks: text.indexOf('\\n') === -1 ? 0 : 1,\n        line: this.line,\n        col: this.col,\n      }\n    }\n    \n    var numLinesAround = 2\n    var firstDisplayedLine = Math.max(token.line - numLinesAround, 1)\n    var lastDisplayedLine = token.line + numLinesAround\n    var lastLineDigits = String(lastDisplayedLine).length\n    var displayedLines = lastNLines(\n        this.buffer, \n        (this.line - token.line) + numLinesAround + 1\n      )\n      .slice(0, 5)\n    var errorLines = []\n    errorLines.push(message + \" at line \" + token.line + \" col \" + token.col + \":\")\n    errorLines.push(\"\")\n    for (var i = 0; i < displayedLines.length; i++) {\n      var line = displayedLines[i]\n      var lineNo = firstDisplayedLine + i\n      errorLines.push(pad(String(lineNo), lastLineDigits) + \"  \" + line);\n      if (lineNo === token.line) {\n        errorLines.push(pad(\"\", lastLineDigits + token.col + 1) + \"^\")\n      }\n    }\n    return errorLines.join(\"\\n\")\n  }\n\n  Lexer.prototype.clone = function() {\n    return new Lexer(this.states, this.state)\n  }\n\n  Lexer.prototype.has = function(tokenType) {\n    return true\n  }\n\n\n  return {\n    compile: compile,\n    states: compileStates,\n    error: Object.freeze({error: true}),\n    fallback: Object.freeze({fallback: true}),\n    keywords: keywordTransform,\n  }\n\n}));\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,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O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFFBQVE7QUFDUixxQ0FBcUMsY0FBYztBQUNuRDtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBOztBQUVBLCtCQUErQjtBQUMvQjtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsY0FBYztBQUNkOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG9CQUFvQiwyQkFBMkI7QUFDL0M7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7OztBQUdBO0FBQ0E7QUFDQTtBQUNBLDBCQUEwQixZQUFZO0FBQ3RDLDZCQUE2QixlQUFlO0FBQzVDO0FBQ0E7O0FBRUEsQ0FBQyIsInNvdXJjZXMiOlsiL1VzZXJzL3BhbnphL0RvY3VtZW50cy9QZXJzb25hbFByb2plY3RzL3ByZWRpay9ub2RlX21vZHVsZXMvbW9vL21vby5qcyJdLCJzb3VyY2VzQ29udGVudCI6WyIoZnVuY3Rpb24ocm9vdCwgZmFjdG9yeSkge1xuICBpZiAodHlwZW9mIGRlZmluZSA9PT0gJ2Z1bmN0aW9uJyAmJiBkZWZpbmUuYW1kKSB7XG4gICAgZGVmaW5lKFtdLCBmYWN0b3J5KSAvKiBnbG9iYWwgZGVmaW5lICovXG4gIH0gZWxzZSBpZiAodHlwZW9mIG1vZHVsZSA9PT0gJ29iamVjdCcgJiYgbW9kdWxlLmV4cG9ydHMpIHtcbiAgICBtb2R1bGUuZXhwb3J0cyA9IGZhY3RvcnkoKVxuICB9IGVsc2Uge1xuICAgIHJvb3QubW9vID0gZmFjdG9yeSgpXG4gIH1cbn0odGhpcywgZnVuY3Rpb24oKSB7XG4gICd1c2Ugc3RyaWN0JztcblxuICB2YXIgaGFzT3duUHJvcGVydHkgPSBPYmplY3QucHJvdG90eXBlLmhhc093blByb3BlcnR5XG4gIHZhciB0b1N0cmluZyA9IE9iamVjdC5wcm90b3R5cGUudG9TdHJpbmdcbiAgdmFyIGhhc1N0aWNreSA9IHR5cGVvZiBuZXcgUmVnRXhwKCkuc3RpY2t5ID09PSAnYm9vbGVhbidcblxuICAvKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqL1xuXG4gIGZ1bmN0aW9uIGlzUmVnRXhwKG8pIHsgcmV0dXJuIG8gJiYgdG9TdHJpbmcuY2FsbChvKSA9PT0gJ1tvYmplY3QgUmVnRXhwXScgfVxuICBmdW5jdGlvbiBpc09iamVjdChvKSB7IHJldHVybiBvICYmIHR5cGVvZiBvID09PSAnb2JqZWN0JyAmJiAhaXNSZWdFeHAobykgJiYgIUFycmF5LmlzQXJyYXkobykgfVxuXG4gIGZ1bmN0aW9uIHJlRXNjYXBlKHMpIHtcbiAgICByZXR1cm4gcy5yZXBsYWNlKC9bLVxcL1xcXFxeJCorPy4oKXxbXFxde31dL2csICdcXFxcJCYnKVxuICB9XG4gIGZ1bmN0aW9uIHJlR3JvdXBzKHMpIHtcbiAgICB2YXIgcmUgPSBuZXcgUmVnRXhwKCd8JyArIHMpXG4gICAgcmV0dXJuIHJlLmV4ZWMoJycpLmxlbmd0aCAtIDFcbiAgfVxuICBmdW5jdGlvbiByZUNhcHR1cmUocykge1xuICAgIHJldHVybiAnKCcgKyBzICsgJyknXG4gIH1cbiAgZnVuY3Rpb24gcmVVbmlvbihyZWdleHBzKSB7XG4gICAgaWYgKCFyZWdleHBzLmxlbmd0aCkgcmV0dXJuICcoPyEpJ1xuICAgIHZhciBzb3VyY2UgPSAgcmVnZXhwcy5tYXAoZnVuY3Rpb24ocykge1xuICAgICAgcmV0dXJuIFwiKD86XCIgKyBzICsgXCIpXCJcbiAgICB9KS5qb2luKCd8JylcbiAgICByZXR1cm4gXCIoPzpcIiArIHNvdXJjZSArIFwiKVwiXG4gIH1cblxuICBmdW5jdGlvbiByZWdleHBPckxpdGVyYWwob2JqKSB7XG4gICAgaWYgKHR5cGVvZiBvYmogPT09ICdzdHJpbmcnKSB7XG4gICAgICByZXR1cm4gJyg/OicgKyByZUVzY2FwZShvYmopICsgJyknXG5cbiAgICB9IGVsc2UgaWYgKGlzUmVnRXhwKG9iaikpIHtcbiAgICAgIC8vIFRPRE86IGNvbnNpZGVyIC91IHN1cHBvcnRcbiAgICAgIGlmIChvYmouaWdub3JlQ2FzZSkgdGhyb3cgbmV3IEVycm9yKCdSZWdFeHAgL2kgZmxhZyBub3QgYWxsb3dlZCcpXG4gICAgICBpZiAob2JqLmdsb2JhbCkgdGhyb3cgbmV3IEVycm9yKCdSZWdFeHAgL2cgZmxhZyBpcyBpbXBsaWVkJylcbiAgICAgIGlmIChvYmouc3RpY2t5KSB0aHJvdyBuZXcgRXJyb3IoJ1JlZ0V4cCAveSBmbGFnIGlzIGltcGxpZWQnKVxuICAgICAgaWYgKG9iai5tdWx0aWxpbmUpIHRocm93IG5ldyBFcnJvcignUmVnRXhwIC9tIGZsYWcgaXMgaW1wbGllZCcpXG4gICAgICByZXR1cm4gb2JqLnNvdXJjZVxuXG4gICAgfSBlbHNlIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcignTm90IGEgcGF0dGVybjogJyArIG9iailcbiAgICB9XG4gIH1cblxuICBmdW5jdGlvbiBwYWQocywgbGVuZ3RoKSB7XG4gICAgaWYgKHMubGVuZ3RoID4gbGVuZ3RoKSB7XG4gICAgICByZXR1cm4gc1xuICAgIH1cbiAgICByZXR1cm4gQXJyYXkobGVuZ3RoIC0gcy5sZW5ndGggKyAxKS5qb2luKFwiIFwiKSArIHNcbiAgfVxuXG4gIGZ1bmN0aW9uIGxhc3ROTGluZXMoc3RyaW5nLCBudW1MaW5lcykge1xuICAgIHZhciBwb3NpdGlvbiA9IHN0cmluZy5sZW5ndGhcbiAgICB2YXIgbGluZUJyZWFrcyA9IDA7XG4gICAgd2hpbGUgKHRydWUpIHtcbiAgICAgIHZhciBpZHggPSBzdHJpbmcubGFzdEluZGV4T2YoXCJcXG5cIiwgcG9zaXRpb24gLSAxKVxuICAgICAgaWYgKGlkeCA9PT0gLTEpIHtcbiAgICAgICAgYnJlYWs7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBsaW5lQnJlYWtzKytcbiAgICAgIH1cbiAgICAgIHBvc2l0aW9uID0gaWR4XG4gICAgICBpZiAobGluZUJyZWFrcyA9PT0gbnVtTGluZXMpIHtcbiAgICAgICAgYnJlYWs7XG4gICAgICB9XG4gICAgICBpZiAocG9zaXRpb24gPT09IDApIHtcbiAgICAgICAgYnJlYWs7XG4gICAgICB9XG4gICAgfVxuICAgIHZhciBzdGFydFBvc2l0aW9uID0gXG4gICAgICBsaW5lQnJlYWtzIDwgbnVtTGluZXMgP1xuICAgICAgMCA6IFxuICAgICAgcG9zaXRpb24gKyAxXG4gICAgcmV0dXJuIHN0cmluZy5zdWJzdHJpbmcoc3RhcnRQb3NpdGlvbikuc3BsaXQoXCJcXG5cIilcbiAgfVxuXG4gIGZ1bmN0aW9uIG9iamVjdFRvUnVsZXMob2JqZWN0KSB7XG4gICAgdmFyIGtleXMgPSBPYmplY3QuZ2V0T3duUHJvcGVydHlOYW1lcyhvYmplY3QpXG4gICAgdmFyIHJlc3VsdCA9IFtdXG4gICAgZm9yICh2YXIgaSA9IDA7IGkgPCBrZXlzLmxlbmd0aDsgaSsrKSB7XG4gICAgICB2YXIga2V5ID0ga2V5c1tpXVxuICAgICAgdmFyIHRoaW5nID0gb2JqZWN0W2tleV1cbiAgICAgIHZhciBydWxlcyA9IFtdLmNvbmNhdCh0aGluZylcbiAgICAgIGlmIChrZXkgPT09ICdpbmNsdWRlJykge1xuICAgICAgICBmb3IgKHZhciBqID0gMDsgaiA8IHJ1bGVzLmxlbmd0aDsgaisrKSB7XG4gICAgICAgICAgcmVzdWx0LnB1c2goe2luY2x1ZGU6IHJ1bGVzW2pdfSlcbiAgICAgICAgfVxuICAgICAgICBjb250aW51ZVxuICAgICAgfVxuICAgICAgdmFyIG1hdGNoID0gW11cbiAgICAgIHJ1bGVzLmZvckVhY2goZnVuY3Rpb24ocnVsZSkge1xuICAgICAgICBpZiAoaXNPYmplY3QocnVsZSkpIHtcbiAgICAgICAgICBpZiAobWF0Y2gubGVuZ3RoKSByZXN1bHQucHVzaChydWxlT3B0aW9ucyhrZXksIG1hdGNoKSlcbiAgICAgICAgICByZXN1bHQucHVzaChydWxlT3B0aW9ucyhrZXksIHJ1bGUpKVxuICAgICAgICAgIG1hdGNoID0gW11cbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICBtYXRjaC5wdXNoKHJ1bGUpXG4gICAgICAgIH1cbiAgICAgIH0pXG4gICAgICBpZiAobWF0Y2gubGVuZ3RoKSByZXN1bHQucHVzaChydWxlT3B0aW9ucyhrZXksIG1hdGNoKSlcbiAgICB9XG4gICAgcmV0dXJuIHJlc3VsdFxuICB9XG5cbiAgZnVuY3Rpb24gYXJyYXlUb1J1bGVzKGFycmF5KSB7XG4gICAgdmFyIHJlc3VsdCA9IFtdXG4gICAgZm9yICh2YXIgaSA9IDA7IGkgPCBhcnJheS5sZW5ndGg7IGkrKykge1xuICAgICAgdmFyIG9iaiA9IGFycmF5W2ldXG4gICAgICBpZiAob2JqLmluY2x1ZGUpIHtcbiAgICAgICAgdmFyIGluY2x1ZGUgPSBbXS5jb25jYXQob2JqLmluY2x1ZGUpXG4gICAgICAgIGZvciAodmFyIGogPSAwOyBqIDwgaW5jbHVkZS5sZW5ndGg7IGorKykge1xuICAgICAgICAgIHJlc3VsdC5wdXNoKHtpbmNsdWRlOiBpbmNsdWRlW2pdfSlcbiAgICAgICAgfVxuICAgICAgICBjb250aW51ZVxuICAgICAgfVxuICAgICAgaWYgKCFvYmoudHlwZSkge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ1J1bGUgaGFzIG5vIHR5cGU6ICcgKyBKU09OLnN0cmluZ2lmeShvYmopKVxuICAgICAgfVxuICAgICAgcmVzdWx0LnB1c2gocnVsZU9wdGlvbnMob2JqLnR5cGUsIG9iaikpXG4gICAgfVxuICAgIHJldHVybiByZXN1bHRcbiAgfVxuXG4gIGZ1bmN0aW9uIHJ1bGVPcHRpb25zKHR5cGUsIG9iaikge1xuICAgIGlmICghaXNPYmplY3Qob2JqKSkge1xuICAgICAgb2JqID0geyBtYXRjaDogb2JqIH1cbiAgICB9XG4gICAgaWYgKG9iai5pbmNsdWRlKSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoJ01hdGNoaW5nIHJ1bGVzIGNhbm5vdCBhbHNvIGluY2x1ZGUgc3RhdGVzJylcbiAgICB9XG5cbiAgICAvLyBuYi4gZXJyb3IgYW5kIGZhbGxiYWNrIGltcGx5IGxpbmVCcmVha3NcbiAgICB2YXIgb3B0aW9ucyA9IHtcbiAgICAgIGRlZmF1bHRUeXBlOiB0eXBlLFxuICAgICAgbGluZUJyZWFrczogISFvYmouZXJyb3IgfHwgISFvYmouZmFsbGJhY2ssXG4gICAgICBwb3A6IGZhbHNlLFxuICAgICAgbmV4dDogbnVsbCxcbiAgICAgIHB1c2g6IG51bGwsXG4gICAgICBlcnJvcjogZmFsc2UsXG4gICAgICBmYWxsYmFjazogZmFsc2UsXG4gICAgICB2YWx1ZTogbnVsbCxcbiAgICAgIHR5cGU6IG51bGwsXG4gICAgICBzaG91bGRUaHJvdzogZmFsc2UsXG4gICAgfVxuXG4gICAgLy8gQXZvaWQgT2JqZWN0LmFzc2lnbigpLCBzbyB3ZSBzdXBwb3J0IElFOStcbiAgICBmb3IgKHZhciBrZXkgaW4gb2JqKSB7XG4gICAgICBpZiAoaGFzT3duUHJvcGVydHkuY2FsbChvYmosIGtleSkpIHtcbiAgICAgICAgb3B0aW9uc1trZXldID0gb2JqW2tleV1cbiAgICAgIH1cbiAgICB9XG5cbiAgICAvLyB0eXBlIHRyYW5zZm9ybSBjYW5ub3QgYmUgYSBzdHJpbmdcbiAgICBpZiAodHlwZW9mIG9wdGlvbnMudHlwZSA9PT0gJ3N0cmluZycgJiYgdHlwZSAhPT0gb3B0aW9ucy50eXBlKSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoXCJUeXBlIHRyYW5zZm9ybSBjYW5ub3QgYmUgYSBzdHJpbmcgKHR5cGUgJ1wiICsgb3B0aW9ucy50eXBlICsgXCInIGZvciB0b2tlbiAnXCIgKyB0eXBlICsgXCInKVwiKVxuICAgIH1cblxuICAgIC8vIGNvbnZlcnQgdG8gYXJyYXlcbiAgICB2YXIgbWF0Y2ggPSBvcHRpb25zLm1hdGNoXG4gICAgb3B0aW9ucy5tYXRjaCA9IEFycmF5LmlzQXJyYXkobWF0Y2gpID8gbWF0Y2ggOiBtYXRjaCA/IFttYXRjaF0gOiBbXVxuICAgIG9wdGlvbnMubWF0Y2guc29ydChmdW5jdGlvbihhLCBiKSB7XG4gICAgICByZXR1cm4gaXNSZWdFeHAoYSkgJiYgaXNSZWdFeHAoYikgPyAwXG4gICAgICAgICAgIDogaXNSZWdFeHAoYikgPyAtMSA6IGlzUmVnRXhwKGEpID8gKzEgOiBiLmxlbmd0aCAtIGEubGVuZ3RoXG4gICAgfSlcbiAgICByZXR1cm4gb3B0aW9uc1xuICB9XG5cbiAgZnVuY3Rpb24gdG9SdWxlcyhzcGVjKSB7XG4gICAgcmV0dXJuIEFycmF5LmlzQXJyYXkoc3BlYykgPyBhcnJheVRvUnVsZXMoc3BlYykgOiBvYmplY3RUb1J1bGVzKHNwZWMpXG4gIH1cblxuICB2YXIgZGVmYXVsdEVycm9yUnVsZSA9IHJ1bGVPcHRpb25zKCdlcnJvcicsIHtsaW5lQnJlYWtzOiB0cnVlLCBzaG91bGRUaHJvdzogdHJ1ZX0pXG4gIGZ1bmN0aW9uIGNvbXBpbGVSdWxlcyhydWxlcywgaGFzU3RhdGVzKSB7XG4gICAgdmFyIGVycm9yUnVsZSA9IG51bGxcbiAgICB2YXIgZmFzdCA9IE9iamVjdC5jcmVhdGUobnVsbClcbiAgICB2YXIgZmFzdEFsbG93ZWQgPSB0cnVlXG4gICAgdmFyIHVuaWNvZGVGbGFnID0gbnVsbFxuICAgIHZhciBncm91cHMgPSBbXVxuICAgIHZhciBwYXJ0cyA9IFtdXG5cbiAgICAvLyBJZiB0aGVyZSBpcyBhIGZhbGxiYWNrIHJ1bGUsIHRoZW4gZGlzYWJsZSBmYXN0IG1hdGNoaW5nXG4gICAgZm9yICh2YXIgaSA9IDA7IGkgPCBydWxlcy5sZW5ndGg7IGkrKykge1xuICAgICAgaWYgKHJ1bGVzW2ldLmZhbGxiYWNrKSB7XG4gICAgICAgIGZhc3RBbGxvd2VkID0gZmFsc2VcbiAgICAgIH1cbiAgICB9XG5cbiAgICBmb3IgKHZhciBpID0gMDsgaSA8IHJ1bGVzLmxlbmd0aDsgaSsrKSB7XG4gICAgICB2YXIgb3B0aW9ucyA9IHJ1bGVzW2ldXG5cbiAgICAgIGlmIChvcHRpb25zLmluY2x1ZGUpIHtcbiAgICAgICAgLy8gYWxsIHZhbGlkIGluY2x1c2lvbnMgYXJlIHJlbW92ZWQgYnkgc3RhdGVzKCkgcHJlcHJvY2Vzc29yXG4gICAgICAgIHRocm93IG5ldyBFcnJvcignSW5oZXJpdGFuY2UgaXMgbm90IGFsbG93ZWQgaW4gc3RhdGVsZXNzIGxleGVycycpXG4gICAgICB9XG5cbiAgICAgIGlmIChvcHRpb25zLmVycm9yIHx8IG9wdGlvbnMuZmFsbGJhY2spIHtcbiAgICAgICAgLy8gZXJyb3JSdWxlIGNhbiBvbmx5IGJlIHNldCBvbmNlXG4gICAgICAgIGlmIChlcnJvclJ1bGUpIHtcbiAgICAgICAgICBpZiAoIW9wdGlvbnMuZmFsbGJhY2sgPT09ICFlcnJvclJ1bGUuZmFsbGJhY2spIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihcIk11bHRpcGxlIFwiICsgKG9wdGlvbnMuZmFsbGJhY2sgPyBcImZhbGxiYWNrXCIgOiBcImVycm9yXCIpICsgXCIgcnVsZXMgbm90IGFsbG93ZWQgKGZvciB0b2tlbiAnXCIgKyBvcHRpb25zLmRlZmF1bHRUeXBlICsgXCInKVwiKVxuICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJmYWxsYmFjayBhbmQgZXJyb3IgYXJlIG11dHVhbGx5IGV4Y2x1c2l2ZSAoZm9yIHRva2VuICdcIiArIG9wdGlvbnMuZGVmYXVsdFR5cGUgKyBcIicpXCIpXG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGVycm9yUnVsZSA9IG9wdGlvbnNcbiAgICAgIH1cblxuICAgICAgdmFyIG1hdGNoID0gb3B0aW9ucy5tYXRjaC5zbGljZSgpXG4gICAgICBpZiAoZmFzdEFsbG93ZWQpIHtcbiAgICAgICAgd2hpbGUgKG1hdGNoLmxlbmd0aCAmJiB0eXBlb2YgbWF0Y2hbMF0gPT09ICdzdHJpbmcnICYmIG1hdGNoWzBdLmxlbmd0aCA9PT0gMSkge1xuICAgICAgICAgIHZhciB3b3JkID0gbWF0Y2guc2hpZnQoKVxuICAgICAgICAgIGZhc3Rbd29yZC5jaGFyQ29kZUF0KDApXSA9IG9wdGlvbnNcbiAgICAgICAgfVxuICAgICAgfVxuXG4gICAgICAvLyBXYXJuIGFib3V0IGluYXBwcm9wcmlhdGUgc3RhdGUtc3dpdGNoaW5nIG9wdGlvbnNcbiAgICAgIGlmIChvcHRpb25zLnBvcCB8fCBvcHRpb25zLnB1c2ggfHwgb3B0aW9ucy5uZXh0KSB7XG4gICAgICAgIGlmICghaGFzU3RhdGVzKSB7XG4gICAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwiU3RhdGUtc3dpdGNoaW5nIG9wdGlvbnMgYXJlIG5vdCBhbGxvd2VkIGluIHN0YXRlbGVzcyBsZXhlcnMgKGZvciB0b2tlbiAnXCIgKyBvcHRpb25zLmRlZmF1bHRUeXBlICsgXCInKVwiKVxuICAgICAgICB9XG4gICAgICAgIGlmIChvcHRpb25zLmZhbGxiYWNrKSB7XG4gICAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwiU3RhdGUtc3dpdGNoaW5nIG9wdGlvbnMgYXJlIG5vdCBhbGxvd2VkIG9uIGZhbGxiYWNrIHRva2VucyAoZm9yIHRva2VuICdcIiArIG9wdGlvbnMuZGVmYXVsdFR5cGUgKyBcIicpXCIpXG4gICAgICAgIH1cbiAgICAgIH1cblxuICAgICAgLy8gT25seSBydWxlcyB3aXRoIGEgLm1hdGNoIGFyZSBpbmNsdWRlZCBpbiB0aGUgUmVnRXhwXG4gICAgICBpZiAobWF0Y2gubGVuZ3RoID09PSAwKSB7XG4gICAgICAgIGNvbnRpbnVlXG4gICAgICB9XG4gICAgICBmYXN0QWxsb3dlZCA9IGZhbHNlXG5cbiAgICAgIGdyb3Vwcy5wdXNoKG9wdGlvbnMpXG5cbiAgICAgIC8vIENoZWNrIHVuaWNvZGUgZmxhZyBpcyB1c2VkIGV2ZXJ5d2hlcmUgb3Igbm93aGVyZVxuICAgICAgZm9yICh2YXIgaiA9IDA7IGogPCBtYXRjaC5sZW5ndGg7IGorKykge1xuICAgICAgICB2YXIgb2JqID0gbWF0Y2hbal1cbiAgICAgICAgaWYgKCFpc1JlZ0V4cChvYmopKSB7XG4gICAgICAgICAgY29udGludWVcbiAgICAgICAgfVxuXG4gICAgICAgIGlmICh1bmljb2RlRmxhZyA9PT0gbnVsbCkge1xuICAgICAgICAgIHVuaWNvZGVGbGFnID0gb2JqLnVuaWNvZGVcbiAgICAgICAgfSBlbHNlIGlmICh1bmljb2RlRmxhZyAhPT0gb2JqLnVuaWNvZGUgJiYgb3B0aW9ucy5mYWxsYmFjayA9PT0gZmFsc2UpIHtcbiAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ0lmIG9uZSBydWxlIGlzIC91IHRoZW4gYWxsIG11c3QgYmUnKVxuICAgICAgICB9XG4gICAgICB9XG5cbiAgICAgIC8vIGNvbnZlcnQgdG8gUmVnRXhwXG4gICAgICB2YXIgcGF0ID0gcmVVbmlvbihtYXRjaC5tYXAocmVnZXhwT3JMaXRlcmFsKSlcblxuICAgICAgLy8gdmFsaWRhdGVcbiAgICAgIHZhciByZWdleHAgPSBuZXcgUmVnRXhwKHBhdClcbiAgICAgIGlmIChyZWdleHAudGVzdChcIlwiKSkge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJSZWdFeHAgbWF0Y2hlcyBlbXB0eSBzdHJpbmc6IFwiICsgcmVnZXhwKVxuICAgICAgfVxuICAgICAgdmFyIGdyb3VwQ291bnQgPSByZUdyb3VwcyhwYXQpXG4gICAgICBpZiAoZ3JvdXBDb3VudCA+IDApIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwiUmVnRXhwIGhhcyBjYXB0dXJlIGdyb3VwczogXCIgKyByZWdleHAgKyBcIlxcblVzZSAoPzog4oCmICkgaW5zdGVhZFwiKVxuICAgICAgfVxuXG4gICAgICAvLyB0cnkgYW5kIGRldGVjdCBydWxlcyBtYXRjaGluZyBuZXdsaW5lc1xuICAgICAgaWYgKCFvcHRpb25zLmxpbmVCcmVha3MgJiYgcmVnZXhwLnRlc3QoJ1xcbicpKSB7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcignUnVsZSBzaG91bGQgZGVjbGFyZSBsaW5lQnJlYWtzOiAnICsgcmVnZXhwKVxuICAgICAgfVxuXG4gICAgICAvLyBzdG9yZSByZWdleFxuICAgICAgcGFydHMucHVzaChyZUNhcHR1cmUocGF0KSlcbiAgICB9XG5cblxuICAgIC8vIElmIHRoZXJlJ3Mgbm8gZmFsbGJhY2sgcnVsZSwgdXNlIHRoZSBzdGlja3kgZmxhZyBzbyB3ZSBvbmx5IGxvb2sgZm9yXG4gICAgLy8gbWF0Y2hlcyBhdCB0aGUgY3VycmVudCBpbmRleC5cbiAgICAvL1xuICAgIC8vIElmIHdlIGRvbid0IHN1cHBvcnQgdGhlIHN0aWNreSBmbGFnLCB0aGVuIGZha2UgaXQgdXNpbmcgYW4gaXJyZWZ1dGFibGVcbiAgICAvLyBtYXRjaCAoaS5lLiBhbiBlbXB0eSBwYXR0ZXJuKS5cbiAgICB2YXIgZmFsbGJhY2tSdWxlID0gZXJyb3JSdWxlICYmIGVycm9yUnVsZS5mYWxsYmFja1xuICAgIHZhciBmbGFncyA9IGhhc1N0aWNreSAmJiAhZmFsbGJhY2tSdWxlID8gJ3ltJyA6ICdnbSdcbiAgICB2YXIgc3VmZml4ID0gaGFzU3RpY2t5IHx8IGZhbGxiYWNrUnVsZSA/ICcnIDogJ3wnXG5cbiAgICBpZiAodW5pY29kZUZsYWcgPT09IHRydWUpIGZsYWdzICs9IFwidVwiXG4gICAgdmFyIGNvbWJpbmVkID0gbmV3IFJlZ0V4cChyZVVuaW9uKHBhcnRzKSArIHN1ZmZpeCwgZmxhZ3MpXG4gICAgcmV0dXJuIHtyZWdleHA6IGNvbWJpbmVkLCBncm91cHM6IGdyb3VwcywgZmFzdDogZmFzdCwgZXJyb3I6IGVycm9yUnVsZSB8fCBkZWZhdWx0RXJyb3JSdWxlfVxuICB9XG5cbiAgZnVuY3Rpb24gY29tcGlsZShydWxlcykge1xuICAgIHZhciByZXN1bHQgPSBjb21waWxlUnVsZXModG9SdWxlcyhydWxlcykpXG4gICAgcmV0dXJuIG5ldyBMZXhlcih7c3RhcnQ6IHJlc3VsdH0sICdzdGFydCcpXG4gIH1cblxuICBmdW5jdGlvbiBjaGVja1N0YXRlR3JvdXAoZywgbmFtZSwgbWFwKSB7XG4gICAgdmFyIHN0YXRlID0gZyAmJiAoZy5wdXNoIHx8IGcubmV4dClcbiAgICBpZiAoc3RhdGUgJiYgIW1hcFtzdGF0ZV0pIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcihcIk1pc3Npbmcgc3RhdGUgJ1wiICsgc3RhdGUgKyBcIicgKGluIHRva2VuICdcIiArIGcuZGVmYXVsdFR5cGUgKyBcIicgb2Ygc3RhdGUgJ1wiICsgbmFtZSArIFwiJylcIilcbiAgICB9XG4gICAgaWYgKGcgJiYgZy5wb3AgJiYgK2cucG9wICE9PSAxKSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoXCJwb3AgbXVzdCBiZSAxIChpbiB0b2tlbiAnXCIgKyBnLmRlZmF1bHRUeXBlICsgXCInIG9mIHN0YXRlICdcIiArIG5hbWUgKyBcIicpXCIpXG4gICAgfVxuICB9XG4gIGZ1bmN0aW9uIGNvbXBpbGVTdGF0ZXMoc3RhdGVzLCBzdGFydCkge1xuICAgIHZhciBhbGwgPSBzdGF0ZXMuJGFsbCA/IHRvUnVsZXMoc3RhdGVzLiRhbGwpIDogW11cbiAgICBkZWxldGUgc3RhdGVzLiRhbGxcblxuICAgIHZhciBrZXlzID0gT2JqZWN0LmdldE93blByb3BlcnR5TmFtZXMoc3RhdGVzKVxuICAgIGlmICghc3RhcnQpIHN0YXJ0ID0ga2V5c1swXVxuXG4gICAgdmFyIHJ1bGVNYXAgPSBPYmplY3QuY3JlYXRlKG51bGwpXG4gICAgZm9yICh2YXIgaSA9IDA7IGkgPCBrZXlzLmxlbmd0aDsgaSsrKSB7XG4gICAgICB2YXIga2V5ID0ga2V5c1tpXVxuICAgICAgcnVsZU1hcFtrZXldID0gdG9SdWxlcyhzdGF0ZXNba2V5XSkuY29uY2F0KGFsbClcbiAgICB9XG4gICAgZm9yICh2YXIgaSA9IDA7IGkgPCBrZXlzLmxlbmd0aDsgaSsrKSB7XG4gICAgICB2YXIga2V5ID0ga2V5c1tpXVxuICAgICAgdmFyIHJ1bGVzID0gcnVsZU1hcFtrZXldXG4gICAgICB2YXIgaW5jbHVkZWQgPSBPYmplY3QuY3JlYXRlKG51bGwpXG4gICAgICBmb3IgKHZhciBqID0gMDsgaiA8IHJ1bGVzLmxlbmd0aDsgaisrKSB7XG4gICAgICAgIHZhciBydWxlID0gcnVsZXNbal1cbiAgICAgICAgaWYgKCFydWxlLmluY2x1ZGUpIGNvbnRpbnVlXG4gICAgICAgIHZhciBzcGxpY2UgPSBbaiwgMV1cbiAgICAgICAgaWYgKHJ1bGUuaW5jbHVkZSAhPT0ga2V5ICYmICFpbmNsdWRlZFtydWxlLmluY2x1ZGVdKSB7XG4gICAgICAgICAgaW5jbHVkZWRbcnVsZS5pbmNsdWRlXSA9IHRydWVcbiAgICAgICAgICB2YXIgbmV3UnVsZXMgPSBydWxlTWFwW3J1bGUuaW5jbHVkZV1cbiAgICAgICAgICBpZiAoIW5ld1J1bGVzKSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJDYW5ub3QgaW5jbHVkZSBub25leGlzdGVudCBzdGF0ZSAnXCIgKyBydWxlLmluY2x1ZGUgKyBcIicgKGluIHN0YXRlICdcIiArIGtleSArIFwiJylcIilcbiAgICAgICAgICB9XG4gICAgICAgICAgZm9yICh2YXIgayA9IDA7IGsgPCBuZXdSdWxlcy5sZW5ndGg7IGsrKykge1xuICAgICAgICAgICAgdmFyIG5ld1J1bGUgPSBuZXdSdWxlc1trXVxuICAgICAgICAgICAgaWYgKHJ1bGVzLmluZGV4T2YobmV3UnVsZSkgIT09IC0xKSBjb250aW51ZVxuICAgICAgICAgICAgc3BsaWNlLnB1c2gobmV3UnVsZSlcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgcnVsZXMuc3BsaWNlLmFwcGx5KHJ1bGVzLCBzcGxpY2UpXG4gICAgICAgIGotLVxuICAgICAgfVxuICAgIH1cblxuICAgIHZhciBtYXAgPSBPYmplY3QuY3JlYXRlKG51bGwpXG4gICAgZm9yICh2YXIgaSA9IDA7IGkgPCBrZXlzLmxlbmd0aDsgaSsrKSB7XG4gICAgICB2YXIga2V5ID0ga2V5c1tpXVxuICAgICAgbWFwW2tleV0gPSBjb21waWxlUnVsZXMocnVsZU1hcFtrZXldLCB0cnVlKVxuICAgIH1cblxuICAgIGZvciAodmFyIGkgPSAwOyBpIDwga2V5cy5sZW5ndGg7IGkrKykge1xuICAgICAgdmFyIG5hbWUgPSBrZXlzW2ldXG4gICAgICB2YXIgc3RhdGUgPSBtYXBbbmFtZV1cbiAgICAgIHZhciBncm91cHMgPSBzdGF0ZS5ncm91cHNcbiAgICAgIGZvciAodmFyIGogPSAwOyBqIDwgZ3JvdXBzLmxlbmd0aDsgaisrKSB7XG4gICAgICAgIGNoZWNrU3RhdGVHcm91cChncm91cHNbal0sIG5hbWUsIG1hcClcbiAgICAgIH1cbiAgICAgIHZhciBmYXN0S2V5cyA9IE9iamVjdC5nZXRPd25Qcm9wZXJ0eU5hbWVzKHN0YXRlLmZhc3QpXG4gICAgICBmb3IgKHZhciBqID0gMDsgaiA8IGZhc3RLZXlzLmxlbmd0aDsgaisrKSB7XG4gICAgICAgIGNoZWNrU3RhdGVHcm91cChzdGF0ZS5mYXN0W2Zhc3RLZXlzW2pdXSwgbmFtZSwgbWFwKVxuICAgICAgfVxuICAgIH1cblxuICAgIHJldHVybiBuZXcgTGV4ZXIobWFwLCBzdGFydClcbiAgfVxuXG4gIGZ1bmN0aW9uIGtleXdvcmRUcmFuc2Zvcm0obWFwKSB7XG5cbiAgICAvLyBVc2UgYSBKYXZhU2NyaXB0IE1hcCB0byBtYXAga2V5d29yZHMgdG8gdGhlaXIgY29ycmVzcG9uZGluZyB0b2tlbiB0eXBlXG4gICAgLy8gdW5sZXNzIE1hcCBpcyB1bnN1cHBvcnRlZCwgdGhlbiBmYWxsIGJhY2sgdG8gdXNpbmcgYW4gT2JqZWN0OlxuICAgIHZhciBpc01hcCA9IHR5cGVvZiBNYXAgIT09ICd1bmRlZmluZWQnXG4gICAgdmFyIHJldmVyc2VNYXAgPSBpc01hcCA/IG5ldyBNYXAgOiBPYmplY3QuY3JlYXRlKG51bGwpXG5cbiAgICB2YXIgdHlwZXMgPSBPYmplY3QuZ2V0T3duUHJvcGVydHlOYW1lcyhtYXApXG4gICAgZm9yICh2YXIgaSA9IDA7IGkgPCB0eXBlcy5sZW5ndGg7IGkrKykge1xuICAgICAgdmFyIHRva2VuVHlwZSA9IHR5cGVzW2ldXG4gICAgICB2YXIgaXRlbSA9IG1hcFt0b2tlblR5cGVdXG4gICAgICB2YXIga2V5d29yZExpc3QgPSBBcnJheS5pc0FycmF5KGl0ZW0pID8gaXRlbSA6IFtpdGVtXVxuICAgICAga2V5d29yZExpc3QuZm9yRWFjaChmdW5jdGlvbihrZXl3b3JkKSB7XG4gICAgICAgIGlmICh0eXBlb2Yga2V5d29yZCAhPT0gJ3N0cmluZycpIHtcbiAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJrZXl3b3JkIG11c3QgYmUgc3RyaW5nIChpbiBrZXl3b3JkICdcIiArIHRva2VuVHlwZSArIFwiJylcIilcbiAgICAgICAgfVxuICAgICAgICBpZiAoaXNNYXApIHtcbiAgICAgICAgICByZXZlcnNlTWFwLnNldChrZXl3b3JkLCB0b2tlblR5cGUpXG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgcmV2ZXJzZU1hcFtrZXl3b3JkXSA9IHRva2VuVHlwZVxuICAgICAgICB9XG4gICAgICB9KVxuICAgIH1cbiAgICByZXR1cm4gZnVuY3Rpb24oaykge1xuICAgICAgcmV0dXJuIGlzTWFwID8gcmV2ZXJzZU1hcC5nZXQoaykgOiByZXZlcnNlTWFwW2tdXG4gICAgfVxuICB9XG5cbiAgLyoqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKi9cblxuICB2YXIgTGV4ZXIgPSBmdW5jdGlvbihzdGF0ZXMsIHN0YXRlKSB7XG4gICAgdGhpcy5zdGFydFN0YXRlID0gc3RhdGVcbiAgICB0aGlzLnN0YXRlcyA9IHN0YXRlc1xuICAgIHRoaXMuYnVmZmVyID0gJydcbiAgICB0aGlzLnN0YWNrID0gW11cbiAgICB0aGlzLnJlc2V0KClcbiAgfVxuXG4gIExleGVyLnByb3RvdHlwZS5yZXNldCA9IGZ1bmN0aW9uKGRhdGEsIGluZm8pIHtcbiAgICB0aGlzLmJ1ZmZlciA9IGRhdGEgfHwgJydcbiAgICB0aGlzLmluZGV4ID0gMFxuICAgIHRoaXMubGluZSA9IGluZm8gPyBpbmZvLmxpbmUgOiAxXG4gICAgdGhpcy5jb2wgPSBpbmZvID8gaW5mby5jb2wgOiAxXG4gICAgdGhpcy5xdWV1ZWRUb2tlbiA9IGluZm8gPyBpbmZvLnF1ZXVlZFRva2VuIDogbnVsbFxuICAgIHRoaXMucXVldWVkVGV4dCA9IGluZm8gPyBpbmZvLnF1ZXVlZFRleHQ6IFwiXCI7XG4gICAgdGhpcy5xdWV1ZWRUaHJvdyA9IGluZm8gPyBpbmZvLnF1ZXVlZFRocm93IDogbnVsbFxuICAgIHRoaXMuc2V0U3RhdGUoaW5mbyA/IGluZm8uc3RhdGUgOiB0aGlzLnN0YXJ0U3RhdGUpXG4gICAgdGhpcy5zdGFjayA9IGluZm8gJiYgaW5mby5zdGFjayA/IGluZm8uc3RhY2suc2xpY2UoKSA6IFtdXG4gICAgcmV0dXJuIHRoaXNcbiAgfVxuXG4gIExleGVyLnByb3RvdHlwZS5zYXZlID0gZnVuY3Rpb24oKSB7XG4gICAgcmV0dXJuIHtcbiAgICAgIGxpbmU6IHRoaXMubGluZSxcbiAgICAgIGNvbDogdGhpcy5jb2wsXG4gICAgICBzdGF0ZTogdGhpcy5zdGF0ZSxcbiAgICAgIHN0YWNrOiB0aGlzLnN0YWNrLnNsaWNlKCksXG4gICAgICBxdWV1ZWRUb2tlbjogdGhpcy5xdWV1ZWRUb2tlbixcbiAgICAgIHF1ZXVlZFRleHQ6IHRoaXMucXVldWVkVGV4dCxcbiAgICAgIHF1ZXVlZFRocm93OiB0aGlzLnF1ZXVlZFRocm93LFxuICAgIH1cbiAgfVxuXG4gIExleGVyLnByb3RvdHlwZS5zZXRTdGF0ZSA9IGZ1bmN0aW9uKHN0YXRlKSB7XG4gICAgaWYgKCFzdGF0ZSB8fCB0aGlzLnN0YXRlID09PSBzdGF0ZSkgcmV0dXJuXG4gICAgdGhpcy5zdGF0ZSA9IHN0YXRlXG4gICAgdmFyIGluZm8gPSB0aGlzLnN0YXRlc1tzdGF0ZV1cbiAgICB0aGlzLmdyb3VwcyA9IGluZm8uZ3JvdXBzXG4gICAgdGhpcy5lcnJvciA9IGluZm8uZXJyb3JcbiAgICB0aGlzLnJlID0gaW5mby5yZWdleHBcbiAgICB0aGlzLmZhc3QgPSBpbmZvLmZhc3RcbiAgfVxuXG4gIExleGVyLnByb3RvdHlwZS5wb3BTdGF0ZSA9IGZ1bmN0aW9uKCkge1xuICAgIHRoaXMuc2V0U3RhdGUodGhpcy5zdGFjay5wb3AoKSlcbiAgfVxuXG4gIExleGVyLnByb3RvdHlwZS5wdXNoU3RhdGUgPSBmdW5jdGlvbihzdGF0ZSkge1xuICAgIHRoaXMuc3RhY2sucHVzaCh0aGlzLnN0YXRlKVxuICAgIHRoaXMuc2V0U3RhdGUoc3RhdGUpXG4gIH1cblxuICB2YXIgZWF0ID0gaGFzU3RpY2t5ID8gZnVuY3Rpb24ocmUsIGJ1ZmZlcikgeyAvLyBhc3N1bWUgcmUgaXMgL3lcbiAgICByZXR1cm4gcmUuZXhlYyhidWZmZXIpXG4gIH0gOiBmdW5jdGlvbihyZSwgYnVmZmVyKSB7IC8vIGFzc3VtZSByZSBpcyAvZ1xuICAgIHZhciBtYXRjaCA9IHJlLmV4ZWMoYnVmZmVyKVxuICAgIC8vIHdpbGwgYWx3YXlzIG1hdGNoLCBzaW5jZSB3ZSB1c2VkIHRoZSB8KD86KSB0cmlja1xuICAgIGlmIChtYXRjaFswXS5sZW5ndGggPT09IDApIHtcbiAgICAgIHJldHVybiBudWxsXG4gICAgfVxuICAgIHJldHVybiBtYXRjaFxuICB9XG5cbiAgTGV4ZXIucHJvdG90eXBlLl9nZXRHcm91cCA9IGZ1bmN0aW9uKG1hdGNoKSB7XG4gICAgdmFyIGdyb3VwQ291bnQgPSB0aGlzLmdyb3Vwcy5sZW5ndGhcbiAgICBmb3IgKHZhciBpID0gMDsgaSA8IGdyb3VwQ291bnQ7IGkrKykge1xuICAgICAgaWYgKG1hdGNoW2kgKyAxXSAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgIHJldHVybiB0aGlzLmdyb3Vwc1tpXVxuICAgICAgfVxuICAgIH1cbiAgICB0aHJvdyBuZXcgRXJyb3IoJ0Nhbm5vdCBmaW5kIHRva2VuIHR5cGUgZm9yIG1hdGNoZWQgdGV4dCcpXG4gIH1cblxuICBmdW5jdGlvbiB0b2tlblRvU3RyaW5nKCkge1xuICAgIHJldHVybiB0aGlzLnZhbHVlXG4gIH1cblxuICBMZXhlci5wcm90b3R5cGUubmV4dCA9IGZ1bmN0aW9uKCkge1xuICAgIHZhciBpbmRleCA9IHRoaXMuaW5kZXhcblxuICAgIC8vIElmIGEgZmFsbGJhY2sgdG9rZW4gbWF0Y2hlZCwgd2UgZG9uJ3QgbmVlZCB0byByZS1ydW4gdGhlIFJlZ0V4cFxuICAgIGlmICh0aGlzLnF1ZXVlZEdyb3VwKSB7XG4gICAgICB2YXIgdG9rZW4gPSB0aGlzLl90b2tlbih0aGlzLnF1ZXVlZEdyb3VwLCB0aGlzLnF1ZXVlZFRleHQsIGluZGV4KVxuICAgICAgdGhpcy5xdWV1ZWRHcm91cCA9IG51bGxcbiAgICAgIHRoaXMucXVldWVkVGV4dCA9IFwiXCJcbiAgICAgIHJldHVybiB0b2tlblxuICAgIH1cblxuICAgIHZhciBidWZmZXIgPSB0aGlzLmJ1ZmZlclxuICAgIGlmIChpbmRleCA9PT0gYnVmZmVyLmxlbmd0aCkge1xuICAgICAgcmV0dXJuIC8vIEVPRlxuICAgIH1cblxuICAgIC8vIEZhc3QgbWF0Y2hpbmcgZm9yIHNpbmdsZSBjaGFyYWN0ZXJzXG4gICAgdmFyIGdyb3VwID0gdGhpcy5mYXN0W2J1ZmZlci5jaGFyQ29kZUF0KGluZGV4KV1cbiAgICBpZiAoZ3JvdXApIHtcbiAgICAgIHJldHVybiB0aGlzLl90b2tlbihncm91cCwgYnVmZmVyLmNoYXJBdChpbmRleCksIGluZGV4KVxuICAgIH1cblxuICAgIC8vIEV4ZWN1dGUgUmVnRXhwXG4gICAgdmFyIHJlID0gdGhpcy5yZVxuICAgIHJlLmxhc3RJbmRleCA9IGluZGV4XG4gICAgdmFyIG1hdGNoID0gZWF0KHJlLCBidWZmZXIpXG5cbiAgICAvLyBFcnJvciB0b2tlbnMgbWF0Y2ggdGhlIHJlbWFpbmluZyBidWZmZXJcbiAgICB2YXIgZXJyb3IgPSB0aGlzLmVycm9yXG4gICAgaWYgKG1hdGNoID09IG51bGwpIHtcbiAgICAgIHJldHVybiB0aGlzLl90b2tlbihlcnJvciwgYnVmZmVyLnNsaWNlKGluZGV4LCBidWZmZXIubGVuZ3RoKSwgaW5kZXgpXG4gICAgfVxuXG4gICAgdmFyIGdyb3VwID0gdGhpcy5fZ2V0R3JvdXAobWF0Y2gpXG4gICAgdmFyIHRleHQgPSBtYXRjaFswXVxuXG4gICAgaWYgKGVycm9yLmZhbGxiYWNrICYmIG1hdGNoLmluZGV4ICE9PSBpbmRleCkge1xuICAgICAgdGhpcy5xdWV1ZWRHcm91cCA9IGdyb3VwXG4gICAgICB0aGlzLnF1ZXVlZFRleHQgPSB0ZXh0XG5cbiAgICAgIC8vIEZhbGxiYWNrIHRva2VucyBjb250YWluIHRoZSB1bm1hdGNoZWQgcG9ydGlvbiBvZiB0aGUgYnVmZmVyXG4gICAgICByZXR1cm4gdGhpcy5fdG9rZW4oZXJyb3IsIGJ1ZmZlci5zbGljZShpbmRleCwgbWF0Y2guaW5kZXgpLCBpbmRleClcbiAgICB9XG5cbiAgICByZXR1cm4gdGhpcy5fdG9rZW4oZ3JvdXAsIHRleHQsIGluZGV4KVxuICB9XG5cbiAgTGV4ZXIucHJvdG90eXBlLl90b2tlbiA9IGZ1bmN0aW9uKGdyb3VwLCB0ZXh0LCBvZmZzZXQpIHtcbiAgICAvLyBjb3VudCBsaW5lIGJyZWFrc1xuICAgIHZhciBsaW5lQnJlYWtzID0gMFxuICAgIGlmIChncm91cC5saW5lQnJlYWtzKSB7XG4gICAgICB2YXIgbWF0Y2hOTCA9IC9cXG4vZ1xuICAgICAgdmFyIG5sID0gMVxuICAgICAgaWYgKHRleHQgPT09ICdcXG4nKSB7XG4gICAgICAgIGxpbmVCcmVha3MgPSAxXG4gICAgICB9IGVsc2Uge1xuICAgICAgICB3aGlsZSAobWF0Y2hOTC5leGVjKHRleHQpKSB7IGxpbmVCcmVha3MrKzsgbmwgPSBtYXRjaE5MLmxhc3RJbmRleCB9XG4gICAgICB9XG4gICAgfVxuXG4gICAgdmFyIHRva2VuID0ge1xuICAgICAgdHlwZTogKHR5cGVvZiBncm91cC50eXBlID09PSAnZnVuY3Rpb24nICYmIGdyb3VwLnR5cGUodGV4dCkpIHx8IGdyb3VwLmRlZmF1bHRUeXBlLFxuICAgICAgdmFsdWU6IHR5cGVvZiBncm91cC52YWx1ZSA9PT0gJ2Z1bmN0aW9uJyA/IGdyb3VwLnZhbHVlKHRleHQpIDogdGV4dCxcbiAgICAgIHRleHQ6IHRleHQsXG4gICAgICB0b1N0cmluZzogdG9rZW5Ub1N0cmluZyxcbiAgICAgIG9mZnNldDogb2Zmc2V0LFxuICAgICAgbGluZUJyZWFrczogbGluZUJyZWFrcyxcbiAgICAgIGxpbmU6IHRoaXMubGluZSxcbiAgICAgIGNvbDogdGhpcy5jb2wsXG4gICAgfVxuICAgIC8vIG5iLiBhZGRpbmcgbW9yZSBwcm9wcyB0byB0b2tlbiBvYmplY3Qgd2lsbCBtYWtlIFY4IHNhZCFcblxuICAgIHZhciBzaXplID0gdGV4dC5sZW5ndGhcbiAgICB0aGlzLmluZGV4ICs9IHNpemVcbiAgICB0aGlzLmxpbmUgKz0gbGluZUJyZWFrc1xuICAgIGlmIChsaW5lQnJlYWtzICE9PSAwKSB7XG4gICAgICB0aGlzLmNvbCA9IHNpemUgLSBubCArIDFcbiAgICB9IGVsc2Uge1xuICAgICAgdGhpcy5jb2wgKz0gc2l6ZVxuICAgIH1cblxuICAgIC8vIHRocm93LCBpZiBubyBydWxlIHdpdGgge2Vycm9yOiB0cnVlfVxuICAgIGlmIChncm91cC5zaG91bGRUaHJvdykge1xuICAgICAgdmFyIGVyciA9IG5ldyBFcnJvcih0aGlzLmZvcm1hdEVycm9yKHRva2VuLCBcImludmFsaWQgc3ludGF4XCIpKVxuICAgICAgdGhyb3cgZXJyO1xuICAgIH1cblxuICAgIGlmIChncm91cC5wb3ApIHRoaXMucG9wU3RhdGUoKVxuICAgIGVsc2UgaWYgKGdyb3VwLnB1c2gpIHRoaXMucHVzaFN0YXRlKGdyb3VwLnB1c2gpXG4gICAgZWxzZSBpZiAoZ3JvdXAubmV4dCkgdGhpcy5zZXRTdGF0ZShncm91cC5uZXh0KVxuXG4gICAgcmV0dXJuIHRva2VuXG4gIH1cblxuICBpZiAodHlwZW9mIFN5bWJvbCAhPT0gJ3VuZGVmaW5lZCcgJiYgU3ltYm9sLml0ZXJhdG9yKSB7XG4gICAgdmFyIExleGVySXRlcmF0b3IgPSBmdW5jdGlvbihsZXhlcikge1xuICAgICAgdGhpcy5sZXhlciA9IGxleGVyXG4gICAgfVxuXG4gICAgTGV4ZXJJdGVyYXRvci5wcm90b3R5cGUubmV4dCA9IGZ1bmN0aW9uKCkge1xuICAgICAgdmFyIHRva2VuID0gdGhpcy5sZXhlci5uZXh0KClcbiAgICAgIHJldHVybiB7dmFsdWU6IHRva2VuLCBkb25lOiAhdG9rZW59XG4gICAgfVxuXG4gICAgTGV4ZXJJdGVyYXRvci5wcm90b3R5cGVbU3ltYm9sLml0ZXJhdG9yXSA9IGZ1bmN0aW9uKCkge1xuICAgICAgcmV0dXJuIHRoaXNcbiAgICB9XG5cbiAgICBMZXhlci5wcm90b3R5cGVbU3ltYm9sLml0ZXJhdG9yXSA9IGZ1bmN0aW9uKCkge1xuICAgICAgcmV0dXJuIG5ldyBMZXhlckl0ZXJhdG9yKHRoaXMpXG4gICAgfVxuICB9XG5cbiAgTGV4ZXIucHJvdG90eXBlLmZvcm1hdEVycm9yID0gZnVuY3Rpb24odG9rZW4sIG1lc3NhZ2UpIHtcbiAgICBpZiAodG9rZW4gPT0gbnVsbCkge1xuICAgICAgLy8gQW4gdW5kZWZpbmVkIHRva2VuIGluZGljYXRlcyBFT0ZcbiAgICAgIHZhciB0ZXh0ID0gdGhpcy5idWZmZXIuc2xpY2UodGhpcy5pbmRleClcbiAgICAgIHZhciB0b2tlbiA9IHtcbiAgICAgICAgdGV4dDogdGV4dCxcbiAgICAgICAgb2Zmc2V0OiB0aGlzLmluZGV4LFxuICAgICAgICBsaW5lQnJlYWtzOiB0ZXh0LmluZGV4T2YoJ1xcbicpID09PSAtMSA/IDAgOiAxLFxuICAgICAgICBsaW5lOiB0aGlzLmxpbmUsXG4gICAgICAgIGNvbDogdGhpcy5jb2wsXG4gICAgICB9XG4gICAgfVxuICAgIFxuICAgIHZhciBudW1MaW5lc0Fyb3VuZCA9IDJcbiAgICB2YXIgZmlyc3REaXNwbGF5ZWRMaW5lID0gTWF0aC5tYXgodG9rZW4ubGluZSAtIG51bUxpbmVzQXJvdW5kLCAxKVxuICAgIHZhciBsYXN0RGlzcGxheWVkTGluZSA9IHRva2VuLmxpbmUgKyBudW1MaW5lc0Fyb3VuZFxuICAgIHZhciBsYXN0TGluZURpZ2l0cyA9IFN0cmluZyhsYXN0RGlzcGxheWVkTGluZSkubGVuZ3RoXG4gICAgdmFyIGRpc3BsYXllZExpbmVzID0gbGFzdE5MaW5lcyhcbiAgICAgICAgdGhpcy5idWZmZXIsIFxuICAgICAgICAodGhpcy5saW5lIC0gdG9rZW4ubGluZSkgKyBudW1MaW5lc0Fyb3VuZCArIDFcbiAgICAgIClcbiAgICAgIC5zbGljZSgwLCA1KVxuICAgIHZhciBlcnJvckxpbmVzID0gW11cbiAgICBlcnJvckxpbmVzLnB1c2gobWVzc2FnZSArIFwiIGF0IGxpbmUgXCIgKyB0b2tlbi5saW5lICsgXCIgY29sIFwiICsgdG9rZW4uY29sICsgXCI6XCIpXG4gICAgZXJyb3JMaW5lcy5wdXNoKFwiXCIpXG4gICAgZm9yICh2YXIgaSA9IDA7IGkgPCBkaXNwbGF5ZWRMaW5lcy5sZW5ndGg7IGkrKykge1xuICAgICAgdmFyIGxpbmUgPSBkaXNwbGF5ZWRMaW5lc1tpXVxuICAgICAgdmFyIGxpbmVObyA9IGZpcnN0RGlzcGxheWVkTGluZSArIGlcbiAgICAgIGVycm9yTGluZXMucHVzaChwYWQoU3RyaW5nKGxpbmVObyksIGxhc3RMaW5lRGlnaXRzKSArIFwiICBcIiArIGxpbmUpO1xuICAgICAgaWYgKGxpbmVObyA9PT0gdG9rZW4ubGluZSkge1xuICAgICAgICBlcnJvckxpbmVzLnB1c2gocGFkKFwiXCIsIGxhc3RMaW5lRGlnaXRzICsgdG9rZW4uY29sICsgMSkgKyBcIl5cIilcbiAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIGVycm9yTGluZXMuam9pbihcIlxcblwiKVxuICB9XG5cbiAgTGV4ZXIucHJvdG90eXBlLmNsb25lID0gZnVuY3Rpb24oKSB7XG4gICAgcmV0dXJuIG5ldyBMZXhlcih0aGlzLnN0YXRlcywgdGhpcy5zdGF0ZSlcbiAgfVxuXG4gIExleGVyLnByb3RvdHlwZS5oYXMgPSBmdW5jdGlvbih0b2tlblR5cGUpIHtcbiAgICByZXR1cm4gdHJ1ZVxuICB9XG5cblxuICByZXR1cm4ge1xuICAgIGNvbXBpbGU6IGNvbXBpbGUsXG4gICAgc3RhdGVzOiBjb21waWxlU3RhdGVzLFxuICAgIGVycm9yOiBPYmplY3QuZnJlZXplKHtlcnJvcjogdHJ1ZX0pLFxuICAgIGZhbGxiYWNrOiBPYmplY3QuZnJlZXplKHtmYWxsYmFjazogdHJ1ZX0pLFxuICAgIGtleXdvcmRzOiBrZXl3b3JkVHJhbnNmb3JtLFxuICB9XG5cbn0pKTtcbiJdLCJuYW1lcyI6W10sImlnbm9yZUxpc3QiOlswXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/moo/moo.js\n");

/***/ })

};
;
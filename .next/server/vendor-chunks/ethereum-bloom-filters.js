"use strict";
/*
 * ATTENTION: An "eval-source-map" devtool has been used.
 * This devtool is neither made for production nor for readable output files.
 * It uses "eval()" calls to create a separate source file with attached SourceMaps in the browser devtools.
 * If you are trying to read the output file, select a different devtool (https://webpack.js.org/configuration/devtool/)
 * or disable the default devtool with "devtool: false".
 * If you are looking for production-ready output files, see mode: "production" (https://webpack.js.org/configuration/mode/).
 */
exports.id = "vendor-chunks/ethereum-bloom-filters";
exports.ids = ["vendor-chunks/ethereum-bloom-filters"];
exports.modules = {

/***/ "(ssr)/./node_modules/ethereum-bloom-filters/dist/index.js":
/*!***********************************************************!*\
  !*** ./node_modules/ethereum-bloom-filters/dist/index.js ***!
  \***********************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

eval("\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nconst utils_1 = __webpack_require__(/*! ./utils */ \"(ssr)/./node_modules/ethereum-bloom-filters/dist/utils.js\");\n/**\n * Returns true if the bloom is a valid bloom\n * @param bloom The bloom\n */\nfunction isBloom(bloom) {\n    if (typeof bloom !== 'string') {\n        return false;\n    }\n    if (!/^(0x)?[0-9a-f]{512}$/i.test(bloom)) {\n        return false;\n    }\n    if (/^(0x)?[0-9a-f]{512}$/.test(bloom) ||\n        /^(0x)?[0-9A-F]{512}$/.test(bloom)) {\n        return true;\n    }\n    return false;\n}\nexports.isBloom = isBloom;\n/**\n * Returns true if the value is part of the given bloom\n * note: false positives are possible.\n * @param bloom encoded bloom\n * @param value The value\n */\nfunction isInBloom(bloom, value) {\n    if (typeof value === 'object' && value.constructor === Uint8Array) {\n        value = utils_1.bytesToHex(value);\n    }\n    const hash = utils_1.keccak256(value).replace('0x', '');\n    for (let i = 0; i < 12; i += 4) {\n        // calculate bit position in bloom filter that must be active\n        const bitpos = ((parseInt(hash.substr(i, 2), 16) << 8) +\n            parseInt(hash.substr(i + 2, 2), 16)) &\n            2047;\n        // test if bitpos in bloom is active\n        const code = codePointToInt(bloom.charCodeAt(bloom.length - 1 - Math.floor(bitpos / 4)));\n        const offset = 1 << bitpos % 4;\n        if ((code & offset) !== offset) {\n            return false;\n        }\n    }\n    return true;\n}\nexports.isInBloom = isInBloom;\n/**\n * Code points to int\n * @param codePoint The code point\n */\nfunction codePointToInt(codePoint) {\n    if (codePoint >= 48 && codePoint <= 57) {\n        /* ['0'..'9'] -> [0..9] */\n        return codePoint - 48;\n    }\n    if (codePoint >= 65 && codePoint <= 70) {\n        /* ['A'..'F'] -> [10..15] */\n        return codePoint - 55;\n    }\n    if (codePoint >= 97 && codePoint <= 102) {\n        /* ['a'..'f'] -> [10..15] */\n        return codePoint - 87;\n    }\n    throw new Error('invalid bloom');\n}\n/**\n * Returns true if the ethereum users address is part of the given bloom.\n * note: false positives are possible.\n * @param bloom encoded bloom\n * @param address the address to test\n */\nfunction isUserEthereumAddressInBloom(bloom, ethereumAddress) {\n    if (!isBloom(bloom)) {\n        throw new Error('Invalid bloom given');\n    }\n    if (!isAddress(ethereumAddress)) {\n        throw new Error(`Invalid ethereum address given: \"${ethereumAddress}\"`);\n    }\n    // you have to pad the ethereum address to 32 bytes\n    // else the bloom filter does not work\n    // this is only if your matching the USERS\n    // ethereum address. Contract address do not need this\n    // hence why we have 2 methods\n    // (0x is not in the 2nd parameter of padleft so 64 chars is fine)\n    const address = utils_1.padLeft(ethereumAddress, 64);\n    return isInBloom(bloom, address);\n}\nexports.isUserEthereumAddressInBloom = isUserEthereumAddressInBloom;\n/**\n * Returns true if the contract address is part of the given bloom.\n * note: false positives are possible.\n * @param bloom encoded bloom\n * @param contractAddress the contract address to test\n */\nfunction isContractAddressInBloom(bloom, contractAddress) {\n    if (!isBloom(bloom)) {\n        throw new Error('Invalid bloom given');\n    }\n    if (!isAddress(contractAddress)) {\n        throw new Error(`Invalid contract address given: \"${contractAddress}\"`);\n    }\n    return isInBloom(bloom, contractAddress);\n}\nexports.isContractAddressInBloom = isContractAddressInBloom;\n/**\n * Returns true if the topic is part of the given bloom.\n * note: false positives are possible.\n * @param bloom encoded bloom\n * @param topic the topic encoded hex\n */\nfunction isTopicInBloom(bloom, topic) {\n    if (!isBloom(bloom)) {\n        throw new Error('Invalid bloom given');\n    }\n    if (!isTopic(topic)) {\n        throw new Error('Invalid topic');\n    }\n    return isInBloom(bloom, topic);\n}\nexports.isTopicInBloom = isTopicInBloom;\n/**\n * Checks if its a valid topic\n * @param topic encoded hex topic\n */\nfunction isTopic(topic) {\n    if (typeof topic !== 'string') {\n        return false;\n    }\n    if (!/^(0x)?[0-9a-f]{64}$/i.test(topic)) {\n        return false;\n    }\n    else if (/^(0x)?[0-9a-f]{64}$/.test(topic) ||\n        /^(0x)?[0-9A-F]{64}$/.test(topic)) {\n        return true;\n    }\n    return false;\n}\nexports.isTopic = isTopic;\n/**\n * Is valid address\n * @param address The address\n */\nfunction isAddress(address) {\n    if (typeof address !== 'string') {\n        return false;\n    }\n    if (address.match(/^(0x)?[0-9a-fA-F]{40}$/)) {\n        return true;\n    }\n    if (address.match(/^XE[0-9]{2}[0-9A-Za-z]{30,31}$/)) {\n        return true;\n    }\n    return false;\n}\nexports.isAddress = isAddress;\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvZXRoZXJldW0tYmxvb20tZmlsdGVycy9kaXN0L2luZGV4LmpzIiwibWFwcGluZ3MiOiJBQUFhO0FBQ2IsOENBQTZDLEVBQUUsYUFBYSxFQUFDO0FBQzdELGdCQUFnQixtQkFBTyxDQUFDLDBFQUFTO0FBQ2pDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx5QkFBeUIsSUFBSTtBQUM3QjtBQUNBO0FBQ0Esd0JBQXdCLElBQUk7QUFDNUIsd0JBQXdCLElBQUk7QUFDNUI7QUFDQTtBQUNBO0FBQ0E7QUFDQSxlQUFlO0FBQ2Y7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG9CQUFvQixRQUFRO0FBQzVCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsaUJBQWlCO0FBQ2pCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDREQUE0RCxnQkFBZ0I7QUFDNUU7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxvQ0FBb0M7QUFDcEM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDREQUE0RCxnQkFBZ0I7QUFDNUU7QUFDQTtBQUNBO0FBQ0EsZ0NBQWdDO0FBQ2hDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHNCQUFzQjtBQUN0QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EseUJBQXlCLEdBQUc7QUFDNUI7QUFDQTtBQUNBLDZCQUE2QixHQUFHO0FBQ2hDLHdCQUF3QixHQUFHO0FBQzNCO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZUFBZTtBQUNmO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx5Q0FBeUMsR0FBRztBQUM1QztBQUNBO0FBQ0EsZ0NBQWdDLEVBQUUsWUFBWSxNQUFNO0FBQ3BEO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsaUJBQWlCIiwic291cmNlcyI6WyIvVXNlcnMvcGFuemEvRG9jdW1lbnRzL1BlcnNvbmFsUHJvamVjdHMvcHJlZGlrL25vZGVfbW9kdWxlcy9ldGhlcmV1bS1ibG9vbS1maWx0ZXJzL2Rpc3QvaW5kZXguanMiXSwic291cmNlc0NvbnRlbnQiOlsiXCJ1c2Ugc3RyaWN0XCI7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XG5jb25zdCB1dGlsc18xID0gcmVxdWlyZShcIi4vdXRpbHNcIik7XG4vKipcbiAqIFJldHVybnMgdHJ1ZSBpZiB0aGUgYmxvb20gaXMgYSB2YWxpZCBibG9vbVxuICogQHBhcmFtIGJsb29tIFRoZSBibG9vbVxuICovXG5mdW5jdGlvbiBpc0Jsb29tKGJsb29tKSB7XG4gICAgaWYgKHR5cGVvZiBibG9vbSAhPT0gJ3N0cmluZycpIHtcbiAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH1cbiAgICBpZiAoIS9eKDB4KT9bMC05YS1mXXs1MTJ9JC9pLnRlc3QoYmxvb20pKSB7XG4gICAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9XG4gICAgaWYgKC9eKDB4KT9bMC05YS1mXXs1MTJ9JC8udGVzdChibG9vbSkgfHxcbiAgICAgICAgL14oMHgpP1swLTlBLUZdezUxMn0kLy50ZXN0KGJsb29tKSkge1xuICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICB9XG4gICAgcmV0dXJuIGZhbHNlO1xufVxuZXhwb3J0cy5pc0Jsb29tID0gaXNCbG9vbTtcbi8qKlxuICogUmV0dXJucyB0cnVlIGlmIHRoZSB2YWx1ZSBpcyBwYXJ0IG9mIHRoZSBnaXZlbiBibG9vbVxuICogbm90ZTogZmFsc2UgcG9zaXRpdmVzIGFyZSBwb3NzaWJsZS5cbiAqIEBwYXJhbSBibG9vbSBlbmNvZGVkIGJsb29tXG4gKiBAcGFyYW0gdmFsdWUgVGhlIHZhbHVlXG4gKi9cbmZ1bmN0aW9uIGlzSW5CbG9vbShibG9vbSwgdmFsdWUpIHtcbiAgICBpZiAodHlwZW9mIHZhbHVlID09PSAnb2JqZWN0JyAmJiB2YWx1ZS5jb25zdHJ1Y3RvciA9PT0gVWludDhBcnJheSkge1xuICAgICAgICB2YWx1ZSA9IHV0aWxzXzEuYnl0ZXNUb0hleCh2YWx1ZSk7XG4gICAgfVxuICAgIGNvbnN0IGhhc2ggPSB1dGlsc18xLmtlY2NhazI1Nih2YWx1ZSkucmVwbGFjZSgnMHgnLCAnJyk7XG4gICAgZm9yIChsZXQgaSA9IDA7IGkgPCAxMjsgaSArPSA0KSB7XG4gICAgICAgIC8vIGNhbGN1bGF0ZSBiaXQgcG9zaXRpb24gaW4gYmxvb20gZmlsdGVyIHRoYXQgbXVzdCBiZSBhY3RpdmVcbiAgICAgICAgY29uc3QgYml0cG9zID0gKChwYXJzZUludChoYXNoLnN1YnN0cihpLCAyKSwgMTYpIDw8IDgpICtcbiAgICAgICAgICAgIHBhcnNlSW50KGhhc2guc3Vic3RyKGkgKyAyLCAyKSwgMTYpKSAmXG4gICAgICAgICAgICAyMDQ3O1xuICAgICAgICAvLyB0ZXN0IGlmIGJpdHBvcyBpbiBibG9vbSBpcyBhY3RpdmVcbiAgICAgICAgY29uc3QgY29kZSA9IGNvZGVQb2ludFRvSW50KGJsb29tLmNoYXJDb2RlQXQoYmxvb20ubGVuZ3RoIC0gMSAtIE1hdGguZmxvb3IoYml0cG9zIC8gNCkpKTtcbiAgICAgICAgY29uc3Qgb2Zmc2V0ID0gMSA8PCBiaXRwb3MgJSA0O1xuICAgICAgICBpZiAoKGNvZGUgJiBvZmZzZXQpICE9PSBvZmZzZXQpIHtcbiAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gdHJ1ZTtcbn1cbmV4cG9ydHMuaXNJbkJsb29tID0gaXNJbkJsb29tO1xuLyoqXG4gKiBDb2RlIHBvaW50cyB0byBpbnRcbiAqIEBwYXJhbSBjb2RlUG9pbnQgVGhlIGNvZGUgcG9pbnRcbiAqL1xuZnVuY3Rpb24gY29kZVBvaW50VG9JbnQoY29kZVBvaW50KSB7XG4gICAgaWYgKGNvZGVQb2ludCA+PSA0OCAmJiBjb2RlUG9pbnQgPD0gNTcpIHtcbiAgICAgICAgLyogWycwJy4uJzknXSAtPiBbMC4uOV0gKi9cbiAgICAgICAgcmV0dXJuIGNvZGVQb2ludCAtIDQ4O1xuICAgIH1cbiAgICBpZiAoY29kZVBvaW50ID49IDY1ICYmIGNvZGVQb2ludCA8PSA3MCkge1xuICAgICAgICAvKiBbJ0EnLi4nRiddIC0+IFsxMC4uMTVdICovXG4gICAgICAgIHJldHVybiBjb2RlUG9pbnQgLSA1NTtcbiAgICB9XG4gICAgaWYgKGNvZGVQb2ludCA+PSA5NyAmJiBjb2RlUG9pbnQgPD0gMTAyKSB7XG4gICAgICAgIC8qIFsnYScuLidmJ10gLT4gWzEwLi4xNV0gKi9cbiAgICAgICAgcmV0dXJuIGNvZGVQb2ludCAtIDg3O1xuICAgIH1cbiAgICB0aHJvdyBuZXcgRXJyb3IoJ2ludmFsaWQgYmxvb20nKTtcbn1cbi8qKlxuICogUmV0dXJucyB0cnVlIGlmIHRoZSBldGhlcmV1bSB1c2VycyBhZGRyZXNzIGlzIHBhcnQgb2YgdGhlIGdpdmVuIGJsb29tLlxuICogbm90ZTogZmFsc2UgcG9zaXRpdmVzIGFyZSBwb3NzaWJsZS5cbiAqIEBwYXJhbSBibG9vbSBlbmNvZGVkIGJsb29tXG4gKiBAcGFyYW0gYWRkcmVzcyB0aGUgYWRkcmVzcyB0byB0ZXN0XG4gKi9cbmZ1bmN0aW9uIGlzVXNlckV0aGVyZXVtQWRkcmVzc0luQmxvb20oYmxvb20sIGV0aGVyZXVtQWRkcmVzcykge1xuICAgIGlmICghaXNCbG9vbShibG9vbSkpIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdJbnZhbGlkIGJsb29tIGdpdmVuJyk7XG4gICAgfVxuICAgIGlmICghaXNBZGRyZXNzKGV0aGVyZXVtQWRkcmVzcykpIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKGBJbnZhbGlkIGV0aGVyZXVtIGFkZHJlc3MgZ2l2ZW46IFwiJHtldGhlcmV1bUFkZHJlc3N9XCJgKTtcbiAgICB9XG4gICAgLy8geW91IGhhdmUgdG8gcGFkIHRoZSBldGhlcmV1bSBhZGRyZXNzIHRvIDMyIGJ5dGVzXG4gICAgLy8gZWxzZSB0aGUgYmxvb20gZmlsdGVyIGRvZXMgbm90IHdvcmtcbiAgICAvLyB0aGlzIGlzIG9ubHkgaWYgeW91ciBtYXRjaGluZyB0aGUgVVNFUlNcbiAgICAvLyBldGhlcmV1bSBhZGRyZXNzLiBDb250cmFjdCBhZGRyZXNzIGRvIG5vdCBuZWVkIHRoaXNcbiAgICAvLyBoZW5jZSB3aHkgd2UgaGF2ZSAyIG1ldGhvZHNcbiAgICAvLyAoMHggaXMgbm90IGluIHRoZSAybmQgcGFyYW1ldGVyIG9mIHBhZGxlZnQgc28gNjQgY2hhcnMgaXMgZmluZSlcbiAgICBjb25zdCBhZGRyZXNzID0gdXRpbHNfMS5wYWRMZWZ0KGV0aGVyZXVtQWRkcmVzcywgNjQpO1xuICAgIHJldHVybiBpc0luQmxvb20oYmxvb20sIGFkZHJlc3MpO1xufVxuZXhwb3J0cy5pc1VzZXJFdGhlcmV1bUFkZHJlc3NJbkJsb29tID0gaXNVc2VyRXRoZXJldW1BZGRyZXNzSW5CbG9vbTtcbi8qKlxuICogUmV0dXJucyB0cnVlIGlmIHRoZSBjb250cmFjdCBhZGRyZXNzIGlzIHBhcnQgb2YgdGhlIGdpdmVuIGJsb29tLlxuICogbm90ZTogZmFsc2UgcG9zaXRpdmVzIGFyZSBwb3NzaWJsZS5cbiAqIEBwYXJhbSBibG9vbSBlbmNvZGVkIGJsb29tXG4gKiBAcGFyYW0gY29udHJhY3RBZGRyZXNzIHRoZSBjb250cmFjdCBhZGRyZXNzIHRvIHRlc3RcbiAqL1xuZnVuY3Rpb24gaXNDb250cmFjdEFkZHJlc3NJbkJsb29tKGJsb29tLCBjb250cmFjdEFkZHJlc3MpIHtcbiAgICBpZiAoIWlzQmxvb20oYmxvb20pKSB7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcignSW52YWxpZCBibG9vbSBnaXZlbicpO1xuICAgIH1cbiAgICBpZiAoIWlzQWRkcmVzcyhjb250cmFjdEFkZHJlc3MpKSB7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcihgSW52YWxpZCBjb250cmFjdCBhZGRyZXNzIGdpdmVuOiBcIiR7Y29udHJhY3RBZGRyZXNzfVwiYCk7XG4gICAgfVxuICAgIHJldHVybiBpc0luQmxvb20oYmxvb20sIGNvbnRyYWN0QWRkcmVzcyk7XG59XG5leHBvcnRzLmlzQ29udHJhY3RBZGRyZXNzSW5CbG9vbSA9IGlzQ29udHJhY3RBZGRyZXNzSW5CbG9vbTtcbi8qKlxuICogUmV0dXJucyB0cnVlIGlmIHRoZSB0b3BpYyBpcyBwYXJ0IG9mIHRoZSBnaXZlbiBibG9vbS5cbiAqIG5vdGU6IGZhbHNlIHBvc2l0aXZlcyBhcmUgcG9zc2libGUuXG4gKiBAcGFyYW0gYmxvb20gZW5jb2RlZCBibG9vbVxuICogQHBhcmFtIHRvcGljIHRoZSB0b3BpYyBlbmNvZGVkIGhleFxuICovXG5mdW5jdGlvbiBpc1RvcGljSW5CbG9vbShibG9vbSwgdG9waWMpIHtcbiAgICBpZiAoIWlzQmxvb20oYmxvb20pKSB7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcignSW52YWxpZCBibG9vbSBnaXZlbicpO1xuICAgIH1cbiAgICBpZiAoIWlzVG9waWModG9waWMpKSB7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcignSW52YWxpZCB0b3BpYycpO1xuICAgIH1cbiAgICByZXR1cm4gaXNJbkJsb29tKGJsb29tLCB0b3BpYyk7XG59XG5leHBvcnRzLmlzVG9waWNJbkJsb29tID0gaXNUb3BpY0luQmxvb207XG4vKipcbiAqIENoZWNrcyBpZiBpdHMgYSB2YWxpZCB0b3BpY1xuICogQHBhcmFtIHRvcGljIGVuY29kZWQgaGV4IHRvcGljXG4gKi9cbmZ1bmN0aW9uIGlzVG9waWModG9waWMpIHtcbiAgICBpZiAodHlwZW9mIHRvcGljICE9PSAnc3RyaW5nJykge1xuICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgfVxuICAgIGlmICghL14oMHgpP1swLTlhLWZdezY0fSQvaS50ZXN0KHRvcGljKSkge1xuICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgfVxuICAgIGVsc2UgaWYgKC9eKDB4KT9bMC05YS1mXXs2NH0kLy50ZXN0KHRvcGljKSB8fFxuICAgICAgICAvXigweCk/WzAtOUEtRl17NjR9JC8udGVzdCh0b3BpYykpIHtcbiAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgfVxuICAgIHJldHVybiBmYWxzZTtcbn1cbmV4cG9ydHMuaXNUb3BpYyA9IGlzVG9waWM7XG4vKipcbiAqIElzIHZhbGlkIGFkZHJlc3NcbiAqIEBwYXJhbSBhZGRyZXNzIFRoZSBhZGRyZXNzXG4gKi9cbmZ1bmN0aW9uIGlzQWRkcmVzcyhhZGRyZXNzKSB7XG4gICAgaWYgKHR5cGVvZiBhZGRyZXNzICE9PSAnc3RyaW5nJykge1xuICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgfVxuICAgIGlmIChhZGRyZXNzLm1hdGNoKC9eKDB4KT9bMC05YS1mQS1GXXs0MH0kLykpIHtcbiAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgfVxuICAgIGlmIChhZGRyZXNzLm1hdGNoKC9eWEVbMC05XXsyfVswLTlBLVphLXpdezMwLDMxfSQvKSkge1xuICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICB9XG4gICAgcmV0dXJuIGZhbHNlO1xufVxuZXhwb3J0cy5pc0FkZHJlc3MgPSBpc0FkZHJlc3M7XG4iXSwibmFtZXMiOltdLCJpZ25vcmVMaXN0IjpbMF0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/ethereum-bloom-filters/dist/index.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/ethereum-bloom-filters/dist/utils.js":
/*!***********************************************************!*\
  !*** ./node_modules/ethereum-bloom-filters/dist/utils.js ***!
  \***********************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

eval("\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nconst sha3_1 = __webpack_require__(/*! @noble/hashes/sha3 */ \"(ssr)/./node_modules/@noble/hashes/sha3.js\");\nconst utils_1 = __webpack_require__(/*! @noble/hashes/utils */ \"(ssr)/./node_modules/@noble/hashes/utils.js\");\n/**\n * Keccak256 hash\n * @param data The data\n */\nfunction keccak256(data) {\n    return bytesToHex(sha3_1.keccak_256(toByteArray(data)));\n}\nexports.keccak256 = keccak256;\n/**\n * Adding padding to string on the left\n * @param value The value\n * @param chars The chars\n */\nexports.padLeft = (value, chars) => {\n    const hasPrefix = /^0x/i.test(value) || typeof value === 'number';\n    value = value.toString().replace(/^0x/i, '');\n    const padding = chars - value.length + 1 >= 0 ? chars - value.length + 1 : 0;\n    return (hasPrefix ? '0x' : '') + new Array(padding).join('0') + value;\n};\n/**\n * Convert bytes to hex\n * @param bytes The bytes\n */\nfunction bytesToHex(bytes) {\n    return \"0x\" + utils_1.bytesToHex(bytes);\n}\nexports.bytesToHex = bytesToHex;\n/**\n * To byte array\n * @param value The value\n */\nfunction toByteArray(value) {\n    if (value == null) {\n        throw new Error('cannot convert null value to array');\n    }\n    if (typeof value === 'string') {\n        const match = value.match(/^(0x)?[0-9a-fA-F]*$/);\n        if (!match) {\n            throw new Error('invalid hexidecimal string');\n        }\n        if (match[1] !== '0x') {\n            throw new Error('hex string must have 0x prefix');\n        }\n        value = value.substring(2);\n        if (value.length % 2) {\n            value = '0' + value;\n        }\n        const result = [];\n        for (let i = 0; i < value.length; i += 2) {\n            result.push(parseInt(value.substr(i, 2), 16));\n        }\n        return addSlice(new Uint8Array(result));\n    }\n    if (isByteArray(value)) {\n        return addSlice(new Uint8Array(value));\n    }\n    throw new Error('invalid arrayify value');\n}\nexports.toByteArray = toByteArray;\n/**\n * Is byte array\n * @param value The value\n */\nfunction isByteArray(value) {\n    if (!value ||\n        // tslint:disable-next-line: radix\n        parseInt(String(value.length)) != value.length ||\n        typeof value === 'string') {\n        return false;\n    }\n    for (let i = 0; i < value.length; i++) {\n        const v = value[i];\n        // tslint:disable-next-line: radix\n        if (v < 0 || v >= 256 || parseInt(String(v)) != v) {\n            return false;\n        }\n    }\n    return true;\n}\n/**\n * Add slice to array\n * @param array The array\n */\nfunction addSlice(array) {\n    if (array.slice !== undefined) {\n        return array;\n    }\n    array.slice = () => {\n        const args = Array.prototype.slice.call(arguments);\n        return addSlice(new Uint8Array(Array.prototype.slice.apply(array, args)));\n    };\n    return array;\n}\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvZXRoZXJldW0tYmxvb20tZmlsdGVycy9kaXN0L3V0aWxzLmpzIiwibWFwcGluZ3MiOiJBQUFhO0FBQ2IsOENBQTZDLEVBQUUsYUFBYSxFQUFDO0FBQzdELGVBQWUsbUJBQU8sQ0FBQyxzRUFBb0I7QUFDM0MsZ0JBQWdCLG1CQUFPLENBQUMsd0VBQXFCO0FBQzdDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsaUJBQWlCO0FBQ2pCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxlQUFlO0FBQ2Y7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esa0JBQWtCO0FBQ2xCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHdCQUF3QixrQkFBa0I7QUFDMUM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsbUJBQW1CO0FBQ25CO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxvQkFBb0Isa0JBQWtCO0FBQ3RDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBIiwic291cmNlcyI6WyIvVXNlcnMvcGFuemEvRG9jdW1lbnRzL1BlcnNvbmFsUHJvamVjdHMvcHJlZGlrL25vZGVfbW9kdWxlcy9ldGhlcmV1bS1ibG9vbS1maWx0ZXJzL2Rpc3QvdXRpbHMuanMiXSwic291cmNlc0NvbnRlbnQiOlsiXCJ1c2Ugc3RyaWN0XCI7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XG5jb25zdCBzaGEzXzEgPSByZXF1aXJlKFwiQG5vYmxlL2hhc2hlcy9zaGEzXCIpO1xuY29uc3QgdXRpbHNfMSA9IHJlcXVpcmUoXCJAbm9ibGUvaGFzaGVzL3V0aWxzXCIpO1xuLyoqXG4gKiBLZWNjYWsyNTYgaGFzaFxuICogQHBhcmFtIGRhdGEgVGhlIGRhdGFcbiAqL1xuZnVuY3Rpb24ga2VjY2FrMjU2KGRhdGEpIHtcbiAgICByZXR1cm4gYnl0ZXNUb0hleChzaGEzXzEua2VjY2FrXzI1Nih0b0J5dGVBcnJheShkYXRhKSkpO1xufVxuZXhwb3J0cy5rZWNjYWsyNTYgPSBrZWNjYWsyNTY7XG4vKipcbiAqIEFkZGluZyBwYWRkaW5nIHRvIHN0cmluZyBvbiB0aGUgbGVmdFxuICogQHBhcmFtIHZhbHVlIFRoZSB2YWx1ZVxuICogQHBhcmFtIGNoYXJzIFRoZSBjaGFyc1xuICovXG5leHBvcnRzLnBhZExlZnQgPSAodmFsdWUsIGNoYXJzKSA9PiB7XG4gICAgY29uc3QgaGFzUHJlZml4ID0gL14weC9pLnRlc3QodmFsdWUpIHx8IHR5cGVvZiB2YWx1ZSA9PT0gJ251bWJlcic7XG4gICAgdmFsdWUgPSB2YWx1ZS50b1N0cmluZygpLnJlcGxhY2UoL14weC9pLCAnJyk7XG4gICAgY29uc3QgcGFkZGluZyA9IGNoYXJzIC0gdmFsdWUubGVuZ3RoICsgMSA+PSAwID8gY2hhcnMgLSB2YWx1ZS5sZW5ndGggKyAxIDogMDtcbiAgICByZXR1cm4gKGhhc1ByZWZpeCA/ICcweCcgOiAnJykgKyBuZXcgQXJyYXkocGFkZGluZykuam9pbignMCcpICsgdmFsdWU7XG59O1xuLyoqXG4gKiBDb252ZXJ0IGJ5dGVzIHRvIGhleFxuICogQHBhcmFtIGJ5dGVzIFRoZSBieXRlc1xuICovXG5mdW5jdGlvbiBieXRlc1RvSGV4KGJ5dGVzKSB7XG4gICAgcmV0dXJuIFwiMHhcIiArIHV0aWxzXzEuYnl0ZXNUb0hleChieXRlcyk7XG59XG5leHBvcnRzLmJ5dGVzVG9IZXggPSBieXRlc1RvSGV4O1xuLyoqXG4gKiBUbyBieXRlIGFycmF5XG4gKiBAcGFyYW0gdmFsdWUgVGhlIHZhbHVlXG4gKi9cbmZ1bmN0aW9uIHRvQnl0ZUFycmF5KHZhbHVlKSB7XG4gICAgaWYgKHZhbHVlID09IG51bGwpIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdjYW5ub3QgY29udmVydCBudWxsIHZhbHVlIHRvIGFycmF5Jyk7XG4gICAgfVxuICAgIGlmICh0eXBlb2YgdmFsdWUgPT09ICdzdHJpbmcnKSB7XG4gICAgICAgIGNvbnN0IG1hdGNoID0gdmFsdWUubWF0Y2goL14oMHgpP1swLTlhLWZBLUZdKiQvKTtcbiAgICAgICAgaWYgKCFtYXRjaCkge1xuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdpbnZhbGlkIGhleGlkZWNpbWFsIHN0cmluZycpO1xuICAgICAgICB9XG4gICAgICAgIGlmIChtYXRjaFsxXSAhPT0gJzB4Jykge1xuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdoZXggc3RyaW5nIG11c3QgaGF2ZSAweCBwcmVmaXgnKTtcbiAgICAgICAgfVxuICAgICAgICB2YWx1ZSA9IHZhbHVlLnN1YnN0cmluZygyKTtcbiAgICAgICAgaWYgKHZhbHVlLmxlbmd0aCAlIDIpIHtcbiAgICAgICAgICAgIHZhbHVlID0gJzAnICsgdmFsdWU7XG4gICAgICAgIH1cbiAgICAgICAgY29uc3QgcmVzdWx0ID0gW107XG4gICAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgdmFsdWUubGVuZ3RoOyBpICs9IDIpIHtcbiAgICAgICAgICAgIHJlc3VsdC5wdXNoKHBhcnNlSW50KHZhbHVlLnN1YnN0cihpLCAyKSwgMTYpKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gYWRkU2xpY2UobmV3IFVpbnQ4QXJyYXkocmVzdWx0KSk7XG4gICAgfVxuICAgIGlmIChpc0J5dGVBcnJheSh2YWx1ZSkpIHtcbiAgICAgICAgcmV0dXJuIGFkZFNsaWNlKG5ldyBVaW50OEFycmF5KHZhbHVlKSk7XG4gICAgfVxuICAgIHRocm93IG5ldyBFcnJvcignaW52YWxpZCBhcnJheWlmeSB2YWx1ZScpO1xufVxuZXhwb3J0cy50b0J5dGVBcnJheSA9IHRvQnl0ZUFycmF5O1xuLyoqXG4gKiBJcyBieXRlIGFycmF5XG4gKiBAcGFyYW0gdmFsdWUgVGhlIHZhbHVlXG4gKi9cbmZ1bmN0aW9uIGlzQnl0ZUFycmF5KHZhbHVlKSB7XG4gICAgaWYgKCF2YWx1ZSB8fFxuICAgICAgICAvLyB0c2xpbnQ6ZGlzYWJsZS1uZXh0LWxpbmU6IHJhZGl4XG4gICAgICAgIHBhcnNlSW50KFN0cmluZyh2YWx1ZS5sZW5ndGgpKSAhPSB2YWx1ZS5sZW5ndGggfHxcbiAgICAgICAgdHlwZW9mIHZhbHVlID09PSAnc3RyaW5nJykge1xuICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgfVxuICAgIGZvciAobGV0IGkgPSAwOyBpIDwgdmFsdWUubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgY29uc3QgdiA9IHZhbHVlW2ldO1xuICAgICAgICAvLyB0c2xpbnQ6ZGlzYWJsZS1uZXh0LWxpbmU6IHJhZGl4XG4gICAgICAgIGlmICh2IDwgMCB8fCB2ID49IDI1NiB8fCBwYXJzZUludChTdHJpbmcodikpICE9IHYpIHtcbiAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gdHJ1ZTtcbn1cbi8qKlxuICogQWRkIHNsaWNlIHRvIGFycmF5XG4gKiBAcGFyYW0gYXJyYXkgVGhlIGFycmF5XG4gKi9cbmZ1bmN0aW9uIGFkZFNsaWNlKGFycmF5KSB7XG4gICAgaWYgKGFycmF5LnNsaWNlICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgcmV0dXJuIGFycmF5O1xuICAgIH1cbiAgICBhcnJheS5zbGljZSA9ICgpID0+IHtcbiAgICAgICAgY29uc3QgYXJncyA9IEFycmF5LnByb3RvdHlwZS5zbGljZS5jYWxsKGFyZ3VtZW50cyk7XG4gICAgICAgIHJldHVybiBhZGRTbGljZShuZXcgVWludDhBcnJheShBcnJheS5wcm90b3R5cGUuc2xpY2UuYXBwbHkoYXJyYXksIGFyZ3MpKSk7XG4gICAgfTtcbiAgICByZXR1cm4gYXJyYXk7XG59XG4iXSwibmFtZXMiOltdLCJpZ25vcmVMaXN0IjpbMF0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/ethereum-bloom-filters/dist/utils.js\n");

/***/ })

};
;
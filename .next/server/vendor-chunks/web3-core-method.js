"use strict";
/*
 * ATTENTION: An "eval-source-map" devtool has been used.
 * This devtool is neither made for production nor for readable output files.
 * It uses "eval()" calls to create a separate source file with attached SourceMaps in the browser devtools.
 * If you are trying to read the output file, select a different devtool (https://webpack.js.org/configuration/devtool/)
 * or disable the default devtool with "devtool: false".
 * If you are looking for production-ready output files, see mode: "production" (https://webpack.js.org/configuration/mode/).
 */
exports.id = "vendor-chunks/web3-core-method";
exports.ids = ["vendor-chunks/web3-core-method"];
exports.modules = {

/***/ "(ssr)/./node_modules/web3-core-method/lib/index.js":
/*!****************************************************!*\
  !*** ./node_modules/web3-core-method/lib/index.js ***!
  \****************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

eval("/*\n    This file is part of web3.js.\n\n    web3.js is free software: you can redistribute it and/or modify\n    it under the terms of the GNU Lesser General Public License as published by\n    the Free Software Foundation, either version 3 of the License, or\n    (at your option) any later version.\n\n    web3.js is distributed in the hope that it will be useful,\n    but WITHOUT ANY WARRANTY; without even the implied warranty of\n    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n    GNU Lesser General Public License for more details.\n\n    You should have received a copy of the GNU Lesser General Public License\n    along with web3.js.  If not, see <http://www.gnu.org/licenses/>.\n*/\n/**\n * @file index.js\n * @author Fabian Vogelsteller <fabian@ethereum.org>\n * @author Marek Kotewicz <marek@parity.io>\n * @date 2017\n */\n\nvar errors = (__webpack_require__(/*! web3-core-helpers */ \"(ssr)/./node_modules/web3-core-helpers/lib/index.js\").errors);\nvar formatters = (__webpack_require__(/*! web3-core-helpers */ \"(ssr)/./node_modules/web3-core-helpers/lib/index.js\").formatters);\nvar utils = __webpack_require__(/*! web3-utils */ \"(ssr)/./node_modules/web3-utils/lib/index.js\");\nvar promiEvent = __webpack_require__(/*! web3-core-promievent */ \"(ssr)/./node_modules/web3-core-promievent/lib/index.js\");\nvar Subscriptions = (__webpack_require__(/*! web3-core-subscriptions */ \"(ssr)/./node_modules/web3-core-subscriptions/lib/index.js\").subscriptions);\nvar EthersTransactionUtils = __webpack_require__(/*! @ethersproject/transactions */ \"(ssr)/./node_modules/@ethersproject/transactions/lib.esm/index.js\");\nvar Method = function Method(options) {\n    if (!options.call || !options.name) {\n        throw new Error('When creating a method you need to provide at least the \"name\" and \"call\" property.');\n    }\n    this.name = options.name;\n    this.call = options.call;\n    this.params = options.params || 0;\n    this.inputFormatter = options.inputFormatter;\n    this.outputFormatter = options.outputFormatter;\n    this.transformPayload = options.transformPayload;\n    this.extraFormatters = options.extraFormatters;\n    this.abiCoder = options.abiCoder; // Will be used to encode the revert reason string\n    this.requestManager = options.requestManager;\n    // reference to eth.accounts\n    this.accounts = options.accounts;\n    this.defaultBlock = options.defaultBlock || 'latest';\n    this.defaultAccount = options.defaultAccount || null;\n    this.transactionBlockTimeout = options.transactionBlockTimeout || 50;\n    this.transactionConfirmationBlocks = options.transactionConfirmationBlocks || 24;\n    this.transactionPollingTimeout = options.transactionPollingTimeout || 750;\n    this.transactionPollingInterval = options.transactionPollingInterval || 1000;\n    this.blockHeaderTimeout = options.blockHeaderTimeout || 10; // 10 seconds\n    this.defaultCommon = options.defaultCommon;\n    this.defaultChain = options.defaultChain;\n    this.defaultHardfork = options.defaultHardfork;\n    this.handleRevert = options.handleRevert;\n};\nMethod.prototype.setRequestManager = function (requestManager, accounts) {\n    this.requestManager = requestManager;\n    // reference to eth.accounts\n    if (accounts) {\n        this.accounts = accounts;\n    }\n};\nMethod.prototype.createFunction = function (requestManager, accounts) {\n    var func = this.buildCall();\n    Object.defineProperty(func, 'call', { configurable: true, writable: true, value: this.call });\n    this.setRequestManager(requestManager || this.requestManager, accounts || this.accounts);\n    return func;\n};\nMethod.prototype.attachToObject = function (obj) {\n    var func = this.buildCall();\n    Object.defineProperty(func, 'call', { configurable: true, writable: true, value: this.call });\n    var name = this.name.split('.');\n    if (name.length > 1) {\n        obj[name[0]] = obj[name[0]] || {};\n        obj[name[0]][name[1]] = func;\n    }\n    else {\n        obj[name[0]] = func;\n    }\n};\n/**\n * Should be used to determine name of the jsonrpc method based on arguments\n *\n * @method getCall\n * @param {Array} arguments\n * @return {String} name of jsonrpc method\n */\nMethod.prototype.getCall = function (args) {\n    return typeof this.call === 'function' ? this.call(args) : this.call;\n};\n/**\n * Should be used to extract callback from array of arguments. Modifies input param\n *\n * @method extractCallback\n * @param {Array} arguments\n * @return {Function|Null} callback, if exists\n */\nMethod.prototype.extractCallback = function (args) {\n    if (typeof (args[args.length - 1]) === 'function') {\n        return args.pop(); // modify the args array!\n    }\n};\n/**\n * Should be called to check if the number of arguments is correct\n *\n * @method validateArgs\n * @param {Array} arguments\n * @throws {Error} if it is not\n */\nMethod.prototype.validateArgs = function (args) {\n    if (args.length !== this.params) {\n        throw errors.InvalidNumberOfParams(args.length, this.params, this.name);\n    }\n};\n/**\n * Should be called to format input args of method\n *\n * @method formatInput\n * @param {Array}\n * @return {Array}\n */\nMethod.prototype.formatInput = function (args) {\n    var _this = this;\n    if (!this.inputFormatter) {\n        return args;\n    }\n    return this.inputFormatter.map(function (formatter, index) {\n        // bind this for defaultBlock, and defaultAccount\n        return formatter ? formatter.call(_this, args[index]) : args[index];\n    });\n};\n/**\n * Should be called to format output(result) of method\n *\n * @method formatOutput\n * @param {Object}\n * @return {Object}\n */\nMethod.prototype.formatOutput = function (result) {\n    var _this = this;\n    if (Array.isArray(result)) {\n        return result.map(function (res) {\n            return _this.outputFormatter && res ? _this.outputFormatter(res, this?.hexFormat) : res;\n        });\n    }\n    else {\n        return this.outputFormatter && result ? this.outputFormatter(result, this?.hexFormat) : result;\n    }\n};\n/**\n * Should create payload from given input args\n *\n * @method toPayload\n * @param {Array} args\n * @return {Object}\n */\nMethod.prototype.toPayload = function (args) {\n    var call = this.getCall(args);\n    var callback = this.extractCallback(args);\n    var params = this.formatInput(args);\n    this.validateArgs(params);\n    var payload = {\n        method: call,\n        params: params,\n        callback: callback\n    };\n    if (this.transformPayload) {\n        payload = this.transformPayload(payload);\n    }\n    return payload;\n};\nMethod.prototype._confirmTransaction = function (defer, result, payload) {\n    var method = this, promiseResolved = false, canUnsubscribe = true, timeoutCount = 0, confirmationCount = 0, intervalId = null, blockHeaderTimeoutId = null, lastBlock = null, receiptJSON = '', gasProvided = ((!!payload.params[0] && typeof payload.params[0] === 'object') && payload.params[0].gas) ? payload.params[0].gas : null, isContractDeployment = (!!payload.params[0] && typeof payload.params[0] === 'object') &&\n        payload.params[0].data &&\n        payload.params[0].from &&\n        !payload.params[0].to, hasBytecode = isContractDeployment && payload.params[0].data.length > 2;\n    // add custom send Methods\n    var _ethereumCalls = [\n        new Method({\n            name: 'getBlockByNumber',\n            call: 'eth_getBlockByNumber',\n            params: 2,\n            inputFormatter: [formatters.inputBlockNumberFormatter, function (val) {\n                    return !!val;\n                }],\n            outputFormatter: formatters.outputBlockFormatter\n        }),\n        new Method({\n            name: 'getTransactionReceipt',\n            call: 'eth_getTransactionReceipt',\n            params: 1,\n            inputFormatter: [null],\n            outputFormatter: formatters.outputTransactionReceiptFormatter\n        }),\n        new Method({\n            name: 'getCode',\n            call: 'eth_getCode',\n            params: 2,\n            inputFormatter: [formatters.inputAddressFormatter, formatters.inputDefaultBlockNumberFormatter]\n        }),\n        new Method({\n            name: 'getTransactionByHash',\n            call: 'eth_getTransactionByHash',\n            params: 1,\n            inputFormatter: [null],\n            outputFormatter: formatters.outputTransactionFormatter\n        }),\n        new Subscriptions({\n            name: 'subscribe',\n            type: 'eth',\n            subscriptions: {\n                'newBlockHeaders': {\n                    subscriptionName: 'newHeads',\n                    params: 0,\n                    outputFormatter: formatters.outputBlockFormatter\n                }\n            }\n        })\n    ];\n    // attach methods to this._ethereumCall\n    var _ethereumCall = {};\n    _ethereumCalls.forEach(mthd => {\n        mthd.attachToObject(_ethereumCall);\n        mthd.requestManager = method.requestManager; // assign rather than call setRequestManager()\n    });\n    // fire \"receipt\" and confirmation events and resolve after\n    var checkConfirmation = function (existingReceipt, isPolling, err, blockHeader, sub) {\n        if (!err) {\n            // create fake unsubscribe\n            if (!sub) {\n                sub = {\n                    unsubscribe: function () {\n                        clearInterval(intervalId);\n                        clearTimeout(blockHeaderTimeoutId);\n                    }\n                };\n            }\n            // if we have a valid receipt we don't need to send a request\n            return (existingReceipt ? promiEvent.resolve(existingReceipt) : _ethereumCall.getTransactionReceipt(result))\n                // catch error from requesting receipt\n                .catch(function (err) {\n                sub.unsubscribe();\n                promiseResolved = true;\n                utils._fireError({\n                    message: 'Failed to check for transaction receipt:',\n                    data: err\n                }, defer.eventEmitter, defer.reject);\n            })\n                // if CONFIRMATION listener exists check for confirmations, by setting canUnsubscribe = false\n                .then(async function (receipt) {\n                if (!receipt || !receipt.blockHash) {\n                    throw new Error('Receipt missing or blockHash null');\n                }\n                // apply extra formatters\n                if (method.extraFormatters && method.extraFormatters.receiptFormatter) {\n                    receipt = method.extraFormatters.receiptFormatter(receipt);\n                }\n                // check if confirmation listener exists\n                if (defer.eventEmitter.listeners('confirmation').length > 0) {\n                    var block;\n                    // If there was an immediately retrieved receipt, it's already\n                    // been confirmed by the direct call to checkConfirmation needed\n                    // for parity instant-seal\n                    if (existingReceipt === undefined || confirmationCount !== 0) {\n                        // Get latest block to emit with confirmation\n                        var latestBlock = await _ethereumCall.getBlockByNumber('latest');\n                        var latestBlockHash = latestBlock ? latestBlock.hash : null;\n                        if (isPolling) { // Check if actually a new block is existing on polling\n                            if (lastBlock) {\n                                block = await _ethereumCall.getBlockByNumber(lastBlock.number + 1);\n                                if (block) {\n                                    lastBlock = block;\n                                    defer.eventEmitter.emit('confirmation', confirmationCount, receipt, latestBlockHash);\n                                }\n                            }\n                            else {\n                                block = await _ethereumCall.getBlockByNumber(receipt.blockNumber);\n                                lastBlock = block;\n                                defer.eventEmitter.emit('confirmation', confirmationCount, receipt, latestBlockHash);\n                            }\n                        }\n                        else {\n                            defer.eventEmitter.emit('confirmation', confirmationCount, receipt, latestBlockHash);\n                        }\n                    }\n                    if ((isPolling && block) || !isPolling) {\n                        confirmationCount++;\n                    }\n                    canUnsubscribe = false;\n                    if (confirmationCount === method.transactionConfirmationBlocks + 1) { // add 1 so we account for conf 0\n                        sub.unsubscribe();\n                        defer.eventEmitter.removeAllListeners();\n                    }\n                }\n                return receipt;\n            })\n                // CHECK for CONTRACT DEPLOYMENT\n                .then(async function (receipt) {\n                if (isContractDeployment && !promiseResolved) {\n                    if (!receipt.contractAddress) {\n                        if (canUnsubscribe) {\n                            sub.unsubscribe();\n                            promiseResolved = true;\n                        }\n                        utils._fireError(errors.NoContractAddressFoundError(receipt), defer.eventEmitter, defer.reject, null, receipt);\n                        return;\n                    }\n                    var code;\n                    try {\n                        code = await _ethereumCall.getCode(receipt.contractAddress);\n                    }\n                    catch (err) {\n                        // ignore;\n                    }\n                    if (!code) {\n                        return;\n                    }\n                    // If deployment is status.true and there was a real\n                    // bytecode string, assume it was successful.\n                    var deploymentSuccess = receipt.status === true && hasBytecode;\n                    if (deploymentSuccess || code.length > 2) {\n                        defer.eventEmitter.emit('receipt', receipt);\n                        // if contract, return instance instead of receipt\n                        if (method.extraFormatters && method.extraFormatters.contractDeployFormatter) {\n                            defer.resolve(method.extraFormatters.contractDeployFormatter(receipt));\n                        }\n                        else {\n                            defer.resolve(receipt);\n                        }\n                        // need to remove listeners, as they aren't removed automatically when succesfull\n                        if (canUnsubscribe) {\n                            defer.eventEmitter.removeAllListeners();\n                        }\n                    }\n                    else {\n                        utils._fireError(errors.ContractCodeNotStoredError(receipt), defer.eventEmitter, defer.reject, null, receipt);\n                    }\n                    if (canUnsubscribe) {\n                        sub.unsubscribe();\n                    }\n                    promiseResolved = true;\n                }\n                return receipt;\n            })\n                // CHECK for normal tx check for receipt only\n                .then(async function (receipt) {\n                if (!isContractDeployment && !promiseResolved) {\n                    if (!receipt.outOfGas &&\n                        (!gasProvided || gasProvided !== receipt.gasUsed) &&\n                        (receipt.status === true || receipt.status === '0x1' || typeof receipt.status === 'undefined')) {\n                        defer.eventEmitter.emit('receipt', receipt);\n                        defer.resolve(receipt);\n                        // need to remove listeners, as they aren't removed automatically when succesfull\n                        if (canUnsubscribe) {\n                            defer.eventEmitter.removeAllListeners();\n                        }\n                    }\n                    else {\n                        receiptJSON = JSON.stringify(receipt, null, 2);\n                        if (receipt.status === false || receipt.status === '0x0') {\n                            try {\n                                var revertMessage = null;\n                                if (method.handleRevert &&\n                                    (method.call === 'eth_sendTransaction' || method.call === 'eth_sendRawTransaction')) {\n                                    var txReplayOptions = payload.params[0];\n                                    // If send was raw, fetch the transaction and reconstitute the\n                                    // original params so they can be replayed with `eth_call`\n                                    if (method.call === 'eth_sendRawTransaction') {\n                                        var rawTransactionHex = payload.params[0];\n                                        var parsedTx = EthersTransactionUtils.parse(rawTransactionHex);\n                                        txReplayOptions = formatters.inputTransactionFormatter({\n                                            data: parsedTx.data,\n                                            to: parsedTx.to,\n                                            from: parsedTx.from,\n                                            gas: parsedTx.gasLimit.toHexString(),\n                                            gasPrice: parsedTx.gasPrice ? parsedTx.gasPrice.toHexString() : undefined,\n                                            value: parsedTx.value.toHexString()\n                                        });\n                                    }\n                                    // Get revert reason string with eth_call\n                                    revertMessage = await method.getRevertReason(txReplayOptions, receipt.blockNumber);\n                                    if (revertMessage) { // Only throw a revert error if a revert reason is existing\n                                        utils._fireError(errors.TransactionRevertInstructionError(revertMessage.reason, revertMessage.signature, receipt), defer.eventEmitter, defer.reject, null, receipt);\n                                    }\n                                    else {\n                                        throw false; // Throw false and let the try/catch statement handle the error correctly after\n                                    }\n                                }\n                                else {\n                                    throw false; // Throw false and let the try/catch statement handle the error correctly after\n                                }\n                            }\n                            catch (error) {\n                                // Throw an normal revert error if no revert reason is given or the detection of it is disabled\n                                utils._fireError(errors.TransactionRevertedWithoutReasonError(receipt), defer.eventEmitter, defer.reject, null, receipt);\n                            }\n                        }\n                        else {\n                            // Throw OOG if status is not existing and provided gas and used gas are equal\n                            utils._fireError(errors.TransactionOutOfGasError(receipt), defer.eventEmitter, defer.reject, null, receipt);\n                        }\n                    }\n                    if (canUnsubscribe) {\n                        sub.unsubscribe();\n                    }\n                    promiseResolved = true;\n                }\n            })\n                // time out the transaction if not mined after 50 blocks\n                .catch(function () {\n                timeoutCount++;\n                // check to see if we are http polling\n                if (!!isPolling) {\n                    // polling timeout is different than transactionBlockTimeout blocks since we are triggering every second\n                    if (timeoutCount - 1 >= method.transactionPollingTimeout) {\n                        sub.unsubscribe();\n                        promiseResolved = true;\n                        utils._fireError(errors.TransactionError('Transaction was not mined within ' + method.transactionPollingTimeout + ' seconds, please make sure your transaction was properly sent. Be aware that it might still be mined!'), defer.eventEmitter, defer.reject);\n                    }\n                }\n                else {\n                    if (timeoutCount - 1 >= method.transactionBlockTimeout) {\n                        sub.unsubscribe();\n                        promiseResolved = true;\n                        utils._fireError(errors.TransactionError('Transaction was not mined within ' + method.transactionBlockTimeout + ' blocks, please make sure your transaction was properly sent. Be aware that it might still be mined!'), defer.eventEmitter, defer.reject);\n                    }\n                }\n            });\n        }\n        else {\n            sub.unsubscribe();\n            promiseResolved = true;\n            utils._fireError({\n                message: 'Failed to subscribe to new newBlockHeaders to confirm the transaction receipts.',\n                data: err\n            }, defer.eventEmitter, defer.reject);\n        }\n    };\n    // start watching for confirmation depending on the support features of the provider\n    var startWatching = function (existingReceipt) {\n        let blockHeaderArrived = false;\n        const startInterval = () => {\n            intervalId = setInterval(checkConfirmation.bind(null, existingReceipt, true), method.transactionPollingInterval);\n        };\n        // If provider do not support event subscription use polling\n        if (!this.requestManager.provider.on) {\n            return startInterval();\n        }\n        // Subscribe to new block headers to look for tx receipt\n        _ethereumCall.subscribe('newBlockHeaders', function (err, blockHeader, sub) {\n            blockHeaderArrived = true;\n            if (err || !blockHeader) {\n                // fall back to polling\n                return startInterval();\n            }\n            checkConfirmation(existingReceipt, false, err, blockHeader, sub);\n        });\n        // Fallback to polling if tx receipt didn't arrived in \"blockHeaderTimeout\" [10 seconds]\n        blockHeaderTimeoutId = setTimeout(() => {\n            if (!blockHeaderArrived) {\n                startInterval();\n            }\n        }, this.blockHeaderTimeout * 1000);\n    }.bind(this);\n    // first check if we already have a confirmed transaction\n    _ethereumCall.getTransactionReceipt(result)\n        .then(function (receipt) {\n        if (receipt && receipt.blockHash) {\n            if (defer.eventEmitter.listeners('confirmation').length > 0) {\n                // We must keep on watching for new Blocks, if a confirmation listener is present\n                startWatching(receipt);\n            }\n            checkConfirmation(receipt, false);\n        }\n        else if (!promiseResolved) {\n            startWatching();\n        }\n    })\n        .catch(function () {\n        if (!promiseResolved)\n            startWatching();\n    });\n};\nvar getWallet = function (from, accounts) {\n    var wallet = null;\n    // is index given\n    if (typeof from === 'number') {\n        wallet = accounts.wallet[from];\n        // is account given\n    }\n    else if (!!from && typeof from === 'object' && from.address && from.privateKey) {\n        wallet = from;\n        // search in wallet for address\n    }\n    else {\n        wallet = accounts.wallet[from.toLowerCase()];\n    }\n    return wallet;\n};\nMethod.prototype.buildCall = function () {\n    var method = this, isSendTx = (method.call === 'eth_sendTransaction' || method.call === 'eth_sendRawTransaction'), // || method.call === 'personal_sendTransaction'\n    isCall = (method.call === 'eth_call');\n    // actual send function\n    var send = function () {\n        let args = Array.prototype.slice.call(arguments);\n        var defer = promiEvent(!isSendTx), payload = method.toPayload(args);\n        method.hexFormat = false;\n        if (method.call === 'eth_getTransactionReceipt'\n            || method.call === 'eth_getTransactionByHash'\n            || method.name === 'getBlock') {\n            method.hexFormat = (payload.params.length < args.length && args[args.length - 1] === 'hex');\n        }\n        // CALLBACK function\n        var sendTxCallback = function (err, result) {\n            if (method.handleRevert && isCall && method.abiCoder) {\n                var reasonData;\n                // Ganache / Geth <= 1.9.13 return the reason data as a successful eth_call response\n                // Geth >= 1.9.15 attaches the reason data to an error object.\n                // Geth 1.9.14 is missing revert reason (https://github.com/ethereum/web3.js/issues/3520)\n                if (!err && method.isRevertReasonString(result)) {\n                    reasonData = result.substring(10);\n                }\n                else if (err && err.data) {\n                    reasonData = err.data.substring(10);\n                }\n                if (reasonData) {\n                    var reason = method.abiCoder.decodeParameter('string', '0x' + reasonData);\n                    var signature = 'Error(String)';\n                    utils._fireError(errors.RevertInstructionError(reason, signature), defer.eventEmitter, defer.reject, payload.callback, {\n                        reason: reason,\n                        signature: signature\n                    });\n                    return;\n                }\n            }\n            try {\n                result = method.formatOutput(result);\n            }\n            catch (e) {\n                err = e;\n            }\n            if (result instanceof Error) {\n                err = result;\n            }\n            if (!err) {\n                if (payload.callback) {\n                    payload.callback(null, result);\n                }\n            }\n            else {\n                if (err.error) {\n                    err = err.error;\n                }\n                return utils._fireError(err, defer.eventEmitter, defer.reject, payload.callback);\n            }\n            // return PROMISE\n            if (!isSendTx) {\n                if (!err) {\n                    defer.resolve(result);\n                }\n                // return PROMIEVENT\n            }\n            else {\n                defer.eventEmitter.emit('transactionHash', result);\n                method._confirmTransaction(defer, result, payload);\n            }\n        };\n        // SENDS the SIGNED SIGNATURE\n        var sendSignedTx = function (sign) {\n            var signedPayload = { ...payload,\n                method: 'eth_sendRawTransaction',\n                params: [sign.rawTransaction]\n            };\n            method.requestManager.send(signedPayload, sendTxCallback);\n        };\n        var sendRequest = function (payload, method) {\n            if (method && method.accounts && method.accounts.wallet && method.accounts.wallet.length) {\n                var wallet;\n                // ETH_SENDTRANSACTION\n                if (payload.method === 'eth_sendTransaction') {\n                    var tx = payload.params[0];\n                    wallet = getWallet((!!tx && typeof tx === 'object') ? tx.from : null, method.accounts);\n                    // If wallet was found, sign tx, and send using sendRawTransaction\n                    if (wallet && wallet.privateKey) {\n                        var tx = JSON.parse(JSON.stringify(tx));\n                        delete tx.from;\n                        if (method.defaultChain && !tx.chain) {\n                            tx.chain = method.defaultChain;\n                        }\n                        if (method.defaultHardfork && !tx.hardfork) {\n                            tx.hardfork = method.defaultHardfork;\n                        }\n                        if (method.defaultCommon && !tx.common) {\n                            tx.common = method.defaultCommon;\n                        }\n                        method.accounts.signTransaction(tx, wallet.privateKey)\n                            .then(sendSignedTx)\n                            .catch(function (err) {\n                            if (typeof defer.eventEmitter.listeners === 'function' && defer.eventEmitter.listeners('error').length) {\n                                try {\n                                    defer.eventEmitter.emit('error', err);\n                                }\n                                catch (err) {\n                                    // Ignore userland error prevent it to bubble up within web3.\n                                }\n                                defer.eventEmitter.removeAllListeners();\n                                defer.eventEmitter.catch(function () {\n                                });\n                            }\n                            defer.reject(err);\n                        });\n                        return;\n                    }\n                    // ETH_SIGN\n                }\n                else if (payload.method === 'eth_sign') {\n                    var data = payload.params[1];\n                    wallet = getWallet(payload.params[0], method.accounts);\n                    // If wallet was found, sign tx, and send using sendRawTransaction\n                    if (wallet && wallet.privateKey) {\n                        var sign = method.accounts.sign(data, wallet.privateKey);\n                        if (payload.callback) {\n                            payload.callback(null, sign.signature);\n                        }\n                        defer.resolve(sign.signature);\n                        return;\n                    }\n                }\n            }\n            return method.requestManager.send(payload, sendTxCallback);\n        };\n        // Send the actual transaction\n        if (isSendTx\n            && !!payload.params[0]\n            && typeof payload.params[0] === 'object'\n            && (typeof payload.params[0].gasPrice === 'undefined'\n                && (typeof payload.params[0].maxPriorityFeePerGas === 'undefined'\n                    || typeof payload.params[0].maxFeePerGas === 'undefined'))) {\n            _handleTxPricing(method, payload.params[0]).then(txPricing => {\n                if (txPricing.gasPrice !== undefined) {\n                    payload.params[0].gasPrice = txPricing.gasPrice;\n                }\n                else if (txPricing.maxPriorityFeePerGas !== undefined\n                    && txPricing.maxFeePerGas !== undefined) {\n                    payload.params[0].maxPriorityFeePerGas = txPricing.maxPriorityFeePerGas;\n                    payload.params[0].maxFeePerGas = txPricing.maxFeePerGas;\n                }\n                if (isSendTx) {\n                    setTimeout(() => {\n                        defer.eventEmitter.emit('sending', payload);\n                    }, 0);\n                }\n                sendRequest(payload, method);\n            });\n        }\n        else {\n            if (isSendTx) {\n                setTimeout(() => {\n                    defer.eventEmitter.emit('sending', payload);\n                }, 0);\n            }\n            sendRequest(payload, method);\n        }\n        if (isSendTx) {\n            setTimeout(() => {\n                defer.eventEmitter.emit('sent', payload);\n            }, 0);\n        }\n        return defer.eventEmitter;\n    };\n    // necessary to attach things to the method\n    send.method = method;\n    // necessary for batch requests\n    send.request = this.request.bind(this);\n    return send;\n};\nfunction _handleTxPricing(method, tx) {\n    return new Promise((resolve, reject) => {\n        try {\n            var getBlockByNumber = (new Method({\n                name: 'getBlockByNumber',\n                call: 'eth_getBlockByNumber',\n                params: 2,\n                inputFormatter: [function (blockNumber) {\n                        return blockNumber ? utils.toHex(blockNumber) : 'latest';\n                    }, function () {\n                        return false;\n                    }]\n            })).createFunction(method.requestManager);\n            var getGasPrice = (new Method({\n                name: 'getGasPrice',\n                call: 'eth_gasPrice',\n                params: 0\n            })).createFunction(method.requestManager);\n            Promise.all([\n                getBlockByNumber(),\n                getGasPrice()\n            ]).then(responses => {\n                const [block, gasPrice] = responses;\n                if ((tx.type === '0x2' || tx.type === undefined) &&\n                    (block && block.baseFeePerGas)) {\n                    // The network supports EIP-1559\n                    // Taken from https://github.com/ethers-io/ethers.js/blob/ba6854bdd5a912fe873d5da494cb5c62c190adde/packages/abstract-provider/src.ts/index.ts#L230\n                    let maxPriorityFeePerGas, maxFeePerGas;\n                    if (tx.gasPrice) {\n                        // Using legacy gasPrice property on an eip-1559 network,\n                        // so use gasPrice as both fee properties\n                        maxPriorityFeePerGas = tx.gasPrice;\n                        maxFeePerGas = tx.gasPrice;\n                        delete tx.gasPrice;\n                    }\n                    else {\n                        maxPriorityFeePerGas = tx.maxPriorityFeePerGas || '0x9502F900'; // 2.5 Gwei\n                        maxFeePerGas = tx.maxFeePerGas ||\n                            utils.toHex(utils.toBN(block.baseFeePerGas)\n                                .mul(utils.toBN(2))\n                                .add(utils.toBN(maxPriorityFeePerGas)));\n                    }\n                    resolve({ maxFeePerGas, maxPriorityFeePerGas });\n                }\n                else {\n                    if (tx.maxPriorityFeePerGas || tx.maxFeePerGas)\n                        throw Error(\"Network doesn't support eip-1559\");\n                    resolve({ gasPrice });\n                }\n            });\n        }\n        catch (error) {\n            reject(error);\n        }\n    });\n}\n/**\n * Returns the revert reason string if existing or otherwise false.\n *\n * @method getRevertReason\n *\n * @param {Object} txOptions\n * @param {Number} blockNumber\n *\n * @returns {Promise<Boolean|String>}\n */\nMethod.prototype.getRevertReason = function (txOptions, blockNumber) {\n    var self = this;\n    return new Promise(function (resolve, reject) {\n        (new Method({\n            name: 'call',\n            call: 'eth_call',\n            params: 2,\n            abiCoder: self.abiCoder,\n            handleRevert: true\n        }))\n            .createFunction(self.requestManager)(txOptions, utils.numberToHex(blockNumber))\n            .then(function () {\n            resolve(false);\n        })\n            .catch(function (error) {\n            if (error.reason) {\n                resolve({\n                    reason: error.reason,\n                    signature: error.signature\n                });\n            }\n            else {\n                reject(error);\n            }\n        });\n    });\n};\n/**\n * Checks if the given hex string is a revert message from the EVM\n *\n * @method isRevertReasonString\n *\n * @param {String} data - Hex string prefixed with 0x\n *\n * @returns {Boolean}\n */\nMethod.prototype.isRevertReasonString = function (data) {\n    return typeof data === 'string' && ((data.length - 2) / 2) % 32 === 4 && data.substring(0, 10) === '0x08c379a0';\n};\n/**\n * Should be called to create the pure JSONRPC request which can be used in a batch request\n *\n * @method request\n * @return {Object} jsonrpc request\n */\nMethod.prototype.request = function () {\n    var payload = this.toPayload(Array.prototype.slice.call(arguments));\n    payload.format = this.formatOutput.bind(this);\n    return payload;\n};\nmodule.exports = Method;\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvd2ViMy1jb3JlLW1ldGhvZC9saWIvaW5kZXguanMiLCJtYXBwaW5ncyI6IkFBQUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLDhCQUE4QjtBQUM5QjtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNhO0FBQ2IsYUFBYSw0R0FBbUM7QUFDaEQsaUJBQWlCLGdIQUF1QztBQUN4RCxZQUFZLG1CQUFPLENBQUMsZ0VBQVk7QUFDaEMsaUJBQWlCLG1CQUFPLENBQUMsb0ZBQXNCO0FBQy9DLG9CQUFvQiwrSEFBZ0Q7QUFDcEUsNkJBQTZCLG1CQUFPLENBQUMsc0dBQTZCO0FBQ2xFO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxzQ0FBc0M7QUFDdEM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZ0VBQWdFO0FBQ2hFO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSwwQ0FBMEMsc0RBQXNEO0FBQ2hHO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSwwQ0FBMEMsc0RBQXNEO0FBQ2hHO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsV0FBVyxPQUFPO0FBQ2xCLFlBQVksUUFBUTtBQUNwQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsV0FBVyxPQUFPO0FBQ2xCLFlBQVksZUFBZTtBQUMzQjtBQUNBO0FBQ0E7QUFDQSwyQkFBMkI7QUFDM0I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsV0FBVyxPQUFPO0FBQ2xCLFlBQVksT0FBTztBQUNuQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFdBQVc7QUFDWCxZQUFZO0FBQ1o7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxXQUFXO0FBQ1gsWUFBWTtBQUNaO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxXQUFXLE9BQU87QUFDbEIsWUFBWTtBQUNaO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxpQkFBaUI7QUFDakI7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxxREFBcUQ7QUFDckQsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGlCQUFpQjtBQUNqQixhQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx5Q0FBeUM7QUFDekM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsMEZBQTBGO0FBQzFGO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWE7QUFDYjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx5Q0FBeUM7QUFDekM7QUFDQTtBQUNBO0FBQ0EseURBQXlEO0FBQ3pEO0FBQ0E7QUFDQTtBQUNBLHFEQUFxRDtBQUNyRDtBQUNBO0FBQ0E7QUFDQSxpREFBaUQ7QUFDakQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWE7QUFDYjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWE7QUFDYjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWE7QUFDYjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1QsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHFCQUFxQjtBQUNyQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGtDQUFrQztBQUNsQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGlDQUFpQztBQUNqQztBQUNBO0FBQ0EseUJBQXlCO0FBQ3pCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHFCQUFxQjtBQUNyQjtBQUNBO0FBQ0EsYUFBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxpQkFBaUI7QUFDakI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHFCQUFxQjtBQUNyQjtBQUNBLHFCQUFxQjtBQUNyQixhQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esd0ZBQXdGO0FBQ3hGO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw4QkFBOEIsb0NBQW9DO0FBQ2xFO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsOEJBQThCLFVBQVU7QUFDeEM7QUFDQSxhQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsV0FBVyxRQUFRO0FBQ25CLFdBQVcsUUFBUTtBQUNuQjtBQUNBLGFBQWE7QUFDYjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGlCQUFpQjtBQUNqQjtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVCxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsV0FBVyxRQUFRO0FBQ25CO0FBQ0EsYUFBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxZQUFZLFFBQVE7QUFDcEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EiLCJzb3VyY2VzIjpbIi9Vc2Vycy9wYW56YS9Eb2N1bWVudHMvUGVyc29uYWxQcm9qZWN0cy9wcmVkaWsvbm9kZV9tb2R1bGVzL3dlYjMtY29yZS1tZXRob2QvbGliL2luZGV4LmpzIl0sInNvdXJjZXNDb250ZW50IjpbIi8qXG4gICAgVGhpcyBmaWxlIGlzIHBhcnQgb2Ygd2ViMy5qcy5cblxuICAgIHdlYjMuanMgaXMgZnJlZSBzb2Z0d2FyZTogeW91IGNhbiByZWRpc3RyaWJ1dGUgaXQgYW5kL29yIG1vZGlmeVxuICAgIGl0IHVuZGVyIHRoZSB0ZXJtcyBvZiB0aGUgR05VIExlc3NlciBHZW5lcmFsIFB1YmxpYyBMaWNlbnNlIGFzIHB1Ymxpc2hlZCBieVxuICAgIHRoZSBGcmVlIFNvZnR3YXJlIEZvdW5kYXRpb24sIGVpdGhlciB2ZXJzaW9uIDMgb2YgdGhlIExpY2Vuc2UsIG9yXG4gICAgKGF0IHlvdXIgb3B0aW9uKSBhbnkgbGF0ZXIgdmVyc2lvbi5cblxuICAgIHdlYjMuanMgaXMgZGlzdHJpYnV0ZWQgaW4gdGhlIGhvcGUgdGhhdCBpdCB3aWxsIGJlIHVzZWZ1bCxcbiAgICBidXQgV0lUSE9VVCBBTlkgV0FSUkFOVFk7IHdpdGhvdXQgZXZlbiB0aGUgaW1wbGllZCB3YXJyYW50eSBvZlxuICAgIE1FUkNIQU5UQUJJTElUWSBvciBGSVRORVNTIEZPUiBBIFBBUlRJQ1VMQVIgUFVSUE9TRS4gIFNlZSB0aGVcbiAgICBHTlUgTGVzc2VyIEdlbmVyYWwgUHVibGljIExpY2Vuc2UgZm9yIG1vcmUgZGV0YWlscy5cblxuICAgIFlvdSBzaG91bGQgaGF2ZSByZWNlaXZlZCBhIGNvcHkgb2YgdGhlIEdOVSBMZXNzZXIgR2VuZXJhbCBQdWJsaWMgTGljZW5zZVxuICAgIGFsb25nIHdpdGggd2ViMy5qcy4gIElmIG5vdCwgc2VlIDxodHRwOi8vd3d3LmdudS5vcmcvbGljZW5zZXMvPi5cbiovXG4vKipcbiAqIEBmaWxlIGluZGV4LmpzXG4gKiBAYXV0aG9yIEZhYmlhbiBWb2dlbHN0ZWxsZXIgPGZhYmlhbkBldGhlcmV1bS5vcmc+XG4gKiBAYXV0aG9yIE1hcmVrIEtvdGV3aWN6IDxtYXJla0BwYXJpdHkuaW8+XG4gKiBAZGF0ZSAyMDE3XG4gKi9cbid1c2Ugc3RyaWN0JztcbnZhciBlcnJvcnMgPSByZXF1aXJlKCd3ZWIzLWNvcmUtaGVscGVycycpLmVycm9ycztcbnZhciBmb3JtYXR0ZXJzID0gcmVxdWlyZSgnd2ViMy1jb3JlLWhlbHBlcnMnKS5mb3JtYXR0ZXJzO1xudmFyIHV0aWxzID0gcmVxdWlyZSgnd2ViMy11dGlscycpO1xudmFyIHByb21pRXZlbnQgPSByZXF1aXJlKCd3ZWIzLWNvcmUtcHJvbWlldmVudCcpO1xudmFyIFN1YnNjcmlwdGlvbnMgPSByZXF1aXJlKCd3ZWIzLWNvcmUtc3Vic2NyaXB0aW9ucycpLnN1YnNjcmlwdGlvbnM7XG52YXIgRXRoZXJzVHJhbnNhY3Rpb25VdGlscyA9IHJlcXVpcmUoJ0BldGhlcnNwcm9qZWN0L3RyYW5zYWN0aW9ucycpO1xudmFyIE1ldGhvZCA9IGZ1bmN0aW9uIE1ldGhvZChvcHRpb25zKSB7XG4gICAgaWYgKCFvcHRpb25zLmNhbGwgfHwgIW9wdGlvbnMubmFtZSkge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ1doZW4gY3JlYXRpbmcgYSBtZXRob2QgeW91IG5lZWQgdG8gcHJvdmlkZSBhdCBsZWFzdCB0aGUgXCJuYW1lXCIgYW5kIFwiY2FsbFwiIHByb3BlcnR5LicpO1xuICAgIH1cbiAgICB0aGlzLm5hbWUgPSBvcHRpb25zLm5hbWU7XG4gICAgdGhpcy5jYWxsID0gb3B0aW9ucy5jYWxsO1xuICAgIHRoaXMucGFyYW1zID0gb3B0aW9ucy5wYXJhbXMgfHwgMDtcbiAgICB0aGlzLmlucHV0Rm9ybWF0dGVyID0gb3B0aW9ucy5pbnB1dEZvcm1hdHRlcjtcbiAgICB0aGlzLm91dHB1dEZvcm1hdHRlciA9IG9wdGlvbnMub3V0cHV0Rm9ybWF0dGVyO1xuICAgIHRoaXMudHJhbnNmb3JtUGF5bG9hZCA9IG9wdGlvbnMudHJhbnNmb3JtUGF5bG9hZDtcbiAgICB0aGlzLmV4dHJhRm9ybWF0dGVycyA9IG9wdGlvbnMuZXh0cmFGb3JtYXR0ZXJzO1xuICAgIHRoaXMuYWJpQ29kZXIgPSBvcHRpb25zLmFiaUNvZGVyOyAvLyBXaWxsIGJlIHVzZWQgdG8gZW5jb2RlIHRoZSByZXZlcnQgcmVhc29uIHN0cmluZ1xuICAgIHRoaXMucmVxdWVzdE1hbmFnZXIgPSBvcHRpb25zLnJlcXVlc3RNYW5hZ2VyO1xuICAgIC8vIHJlZmVyZW5jZSB0byBldGguYWNjb3VudHNcbiAgICB0aGlzLmFjY291bnRzID0gb3B0aW9ucy5hY2NvdW50cztcbiAgICB0aGlzLmRlZmF1bHRCbG9jayA9IG9wdGlvbnMuZGVmYXVsdEJsb2NrIHx8ICdsYXRlc3QnO1xuICAgIHRoaXMuZGVmYXVsdEFjY291bnQgPSBvcHRpb25zLmRlZmF1bHRBY2NvdW50IHx8IG51bGw7XG4gICAgdGhpcy50cmFuc2FjdGlvbkJsb2NrVGltZW91dCA9IG9wdGlvbnMudHJhbnNhY3Rpb25CbG9ja1RpbWVvdXQgfHwgNTA7XG4gICAgdGhpcy50cmFuc2FjdGlvbkNvbmZpcm1hdGlvbkJsb2NrcyA9IG9wdGlvbnMudHJhbnNhY3Rpb25Db25maXJtYXRpb25CbG9ja3MgfHwgMjQ7XG4gICAgdGhpcy50cmFuc2FjdGlvblBvbGxpbmdUaW1lb3V0ID0gb3B0aW9ucy50cmFuc2FjdGlvblBvbGxpbmdUaW1lb3V0IHx8IDc1MDtcbiAgICB0aGlzLnRyYW5zYWN0aW9uUG9sbGluZ0ludGVydmFsID0gb3B0aW9ucy50cmFuc2FjdGlvblBvbGxpbmdJbnRlcnZhbCB8fCAxMDAwO1xuICAgIHRoaXMuYmxvY2tIZWFkZXJUaW1lb3V0ID0gb3B0aW9ucy5ibG9ja0hlYWRlclRpbWVvdXQgfHwgMTA7IC8vIDEwIHNlY29uZHNcbiAgICB0aGlzLmRlZmF1bHRDb21tb24gPSBvcHRpb25zLmRlZmF1bHRDb21tb247XG4gICAgdGhpcy5kZWZhdWx0Q2hhaW4gPSBvcHRpb25zLmRlZmF1bHRDaGFpbjtcbiAgICB0aGlzLmRlZmF1bHRIYXJkZm9yayA9IG9wdGlvbnMuZGVmYXVsdEhhcmRmb3JrO1xuICAgIHRoaXMuaGFuZGxlUmV2ZXJ0ID0gb3B0aW9ucy5oYW5kbGVSZXZlcnQ7XG59O1xuTWV0aG9kLnByb3RvdHlwZS5zZXRSZXF1ZXN0TWFuYWdlciA9IGZ1bmN0aW9uIChyZXF1ZXN0TWFuYWdlciwgYWNjb3VudHMpIHtcbiAgICB0aGlzLnJlcXVlc3RNYW5hZ2VyID0gcmVxdWVzdE1hbmFnZXI7XG4gICAgLy8gcmVmZXJlbmNlIHRvIGV0aC5hY2NvdW50c1xuICAgIGlmIChhY2NvdW50cykge1xuICAgICAgICB0aGlzLmFjY291bnRzID0gYWNjb3VudHM7XG4gICAgfVxufTtcbk1ldGhvZC5wcm90b3R5cGUuY3JlYXRlRnVuY3Rpb24gPSBmdW5jdGlvbiAocmVxdWVzdE1hbmFnZXIsIGFjY291bnRzKSB7XG4gICAgdmFyIGZ1bmMgPSB0aGlzLmJ1aWxkQ2FsbCgpO1xuICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShmdW5jLCAnY2FsbCcsIHsgY29uZmlndXJhYmxlOiB0cnVlLCB3cml0YWJsZTogdHJ1ZSwgdmFsdWU6IHRoaXMuY2FsbCB9KTtcbiAgICB0aGlzLnNldFJlcXVlc3RNYW5hZ2VyKHJlcXVlc3RNYW5hZ2VyIHx8IHRoaXMucmVxdWVzdE1hbmFnZXIsIGFjY291bnRzIHx8IHRoaXMuYWNjb3VudHMpO1xuICAgIHJldHVybiBmdW5jO1xufTtcbk1ldGhvZC5wcm90b3R5cGUuYXR0YWNoVG9PYmplY3QgPSBmdW5jdGlvbiAob2JqKSB7XG4gICAgdmFyIGZ1bmMgPSB0aGlzLmJ1aWxkQ2FsbCgpO1xuICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShmdW5jLCAnY2FsbCcsIHsgY29uZmlndXJhYmxlOiB0cnVlLCB3cml0YWJsZTogdHJ1ZSwgdmFsdWU6IHRoaXMuY2FsbCB9KTtcbiAgICB2YXIgbmFtZSA9IHRoaXMubmFtZS5zcGxpdCgnLicpO1xuICAgIGlmIChuYW1lLmxlbmd0aCA+IDEpIHtcbiAgICAgICAgb2JqW25hbWVbMF1dID0gb2JqW25hbWVbMF1dIHx8IHt9O1xuICAgICAgICBvYmpbbmFtZVswXV1bbmFtZVsxXV0gPSBmdW5jO1xuICAgIH1cbiAgICBlbHNlIHtcbiAgICAgICAgb2JqW25hbWVbMF1dID0gZnVuYztcbiAgICB9XG59O1xuLyoqXG4gKiBTaG91bGQgYmUgdXNlZCB0byBkZXRlcm1pbmUgbmFtZSBvZiB0aGUganNvbnJwYyBtZXRob2QgYmFzZWQgb24gYXJndW1lbnRzXG4gKlxuICogQG1ldGhvZCBnZXRDYWxsXG4gKiBAcGFyYW0ge0FycmF5fSBhcmd1bWVudHNcbiAqIEByZXR1cm4ge1N0cmluZ30gbmFtZSBvZiBqc29ucnBjIG1ldGhvZFxuICovXG5NZXRob2QucHJvdG90eXBlLmdldENhbGwgPSBmdW5jdGlvbiAoYXJncykge1xuICAgIHJldHVybiB0eXBlb2YgdGhpcy5jYWxsID09PSAnZnVuY3Rpb24nID8gdGhpcy5jYWxsKGFyZ3MpIDogdGhpcy5jYWxsO1xufTtcbi8qKlxuICogU2hvdWxkIGJlIHVzZWQgdG8gZXh0cmFjdCBjYWxsYmFjayBmcm9tIGFycmF5IG9mIGFyZ3VtZW50cy4gTW9kaWZpZXMgaW5wdXQgcGFyYW1cbiAqXG4gKiBAbWV0aG9kIGV4dHJhY3RDYWxsYmFja1xuICogQHBhcmFtIHtBcnJheX0gYXJndW1lbnRzXG4gKiBAcmV0dXJuIHtGdW5jdGlvbnxOdWxsfSBjYWxsYmFjaywgaWYgZXhpc3RzXG4gKi9cbk1ldGhvZC5wcm90b3R5cGUuZXh0cmFjdENhbGxiYWNrID0gZnVuY3Rpb24gKGFyZ3MpIHtcbiAgICBpZiAodHlwZW9mIChhcmdzW2FyZ3MubGVuZ3RoIC0gMV0pID09PSAnZnVuY3Rpb24nKSB7XG4gICAgICAgIHJldHVybiBhcmdzLnBvcCgpOyAvLyBtb2RpZnkgdGhlIGFyZ3MgYXJyYXkhXG4gICAgfVxufTtcbi8qKlxuICogU2hvdWxkIGJlIGNhbGxlZCB0byBjaGVjayBpZiB0aGUgbnVtYmVyIG9mIGFyZ3VtZW50cyBpcyBjb3JyZWN0XG4gKlxuICogQG1ldGhvZCB2YWxpZGF0ZUFyZ3NcbiAqIEBwYXJhbSB7QXJyYXl9IGFyZ3VtZW50c1xuICogQHRocm93cyB7RXJyb3J9IGlmIGl0IGlzIG5vdFxuICovXG5NZXRob2QucHJvdG90eXBlLnZhbGlkYXRlQXJncyA9IGZ1bmN0aW9uIChhcmdzKSB7XG4gICAgaWYgKGFyZ3MubGVuZ3RoICE9PSB0aGlzLnBhcmFtcykge1xuICAgICAgICB0aHJvdyBlcnJvcnMuSW52YWxpZE51bWJlck9mUGFyYW1zKGFyZ3MubGVuZ3RoLCB0aGlzLnBhcmFtcywgdGhpcy5uYW1lKTtcbiAgICB9XG59O1xuLyoqXG4gKiBTaG91bGQgYmUgY2FsbGVkIHRvIGZvcm1hdCBpbnB1dCBhcmdzIG9mIG1ldGhvZFxuICpcbiAqIEBtZXRob2QgZm9ybWF0SW5wdXRcbiAqIEBwYXJhbSB7QXJyYXl9XG4gKiBAcmV0dXJuIHtBcnJheX1cbiAqL1xuTWV0aG9kLnByb3RvdHlwZS5mb3JtYXRJbnB1dCA9IGZ1bmN0aW9uIChhcmdzKSB7XG4gICAgdmFyIF90aGlzID0gdGhpcztcbiAgICBpZiAoIXRoaXMuaW5wdXRGb3JtYXR0ZXIpIHtcbiAgICAgICAgcmV0dXJuIGFyZ3M7XG4gICAgfVxuICAgIHJldHVybiB0aGlzLmlucHV0Rm9ybWF0dGVyLm1hcChmdW5jdGlvbiAoZm9ybWF0dGVyLCBpbmRleCkge1xuICAgICAgICAvLyBiaW5kIHRoaXMgZm9yIGRlZmF1bHRCbG9jaywgYW5kIGRlZmF1bHRBY2NvdW50XG4gICAgICAgIHJldHVybiBmb3JtYXR0ZXIgPyBmb3JtYXR0ZXIuY2FsbChfdGhpcywgYXJnc1tpbmRleF0pIDogYXJnc1tpbmRleF07XG4gICAgfSk7XG59O1xuLyoqXG4gKiBTaG91bGQgYmUgY2FsbGVkIHRvIGZvcm1hdCBvdXRwdXQocmVzdWx0KSBvZiBtZXRob2RcbiAqXG4gKiBAbWV0aG9kIGZvcm1hdE91dHB1dFxuICogQHBhcmFtIHtPYmplY3R9XG4gKiBAcmV0dXJuIHtPYmplY3R9XG4gKi9cbk1ldGhvZC5wcm90b3R5cGUuZm9ybWF0T3V0cHV0ID0gZnVuY3Rpb24gKHJlc3VsdCkge1xuICAgIHZhciBfdGhpcyA9IHRoaXM7XG4gICAgaWYgKEFycmF5LmlzQXJyYXkocmVzdWx0KSkge1xuICAgICAgICByZXR1cm4gcmVzdWx0Lm1hcChmdW5jdGlvbiAocmVzKSB7XG4gICAgICAgICAgICByZXR1cm4gX3RoaXMub3V0cHV0Rm9ybWF0dGVyICYmIHJlcyA/IF90aGlzLm91dHB1dEZvcm1hdHRlcihyZXMsIHRoaXM/LmhleEZvcm1hdCkgOiByZXM7XG4gICAgICAgIH0pO1xuICAgIH1cbiAgICBlbHNlIHtcbiAgICAgICAgcmV0dXJuIHRoaXMub3V0cHV0Rm9ybWF0dGVyICYmIHJlc3VsdCA/IHRoaXMub3V0cHV0Rm9ybWF0dGVyKHJlc3VsdCwgdGhpcz8uaGV4Rm9ybWF0KSA6IHJlc3VsdDtcbiAgICB9XG59O1xuLyoqXG4gKiBTaG91bGQgY3JlYXRlIHBheWxvYWQgZnJvbSBnaXZlbiBpbnB1dCBhcmdzXG4gKlxuICogQG1ldGhvZCB0b1BheWxvYWRcbiAqIEBwYXJhbSB7QXJyYXl9IGFyZ3NcbiAqIEByZXR1cm4ge09iamVjdH1cbiAqL1xuTWV0aG9kLnByb3RvdHlwZS50b1BheWxvYWQgPSBmdW5jdGlvbiAoYXJncykge1xuICAgIHZhciBjYWxsID0gdGhpcy5nZXRDYWxsKGFyZ3MpO1xuICAgIHZhciBjYWxsYmFjayA9IHRoaXMuZXh0cmFjdENhbGxiYWNrKGFyZ3MpO1xuICAgIHZhciBwYXJhbXMgPSB0aGlzLmZvcm1hdElucHV0KGFyZ3MpO1xuICAgIHRoaXMudmFsaWRhdGVBcmdzKHBhcmFtcyk7XG4gICAgdmFyIHBheWxvYWQgPSB7XG4gICAgICAgIG1ldGhvZDogY2FsbCxcbiAgICAgICAgcGFyYW1zOiBwYXJhbXMsXG4gICAgICAgIGNhbGxiYWNrOiBjYWxsYmFja1xuICAgIH07XG4gICAgaWYgKHRoaXMudHJhbnNmb3JtUGF5bG9hZCkge1xuICAgICAgICBwYXlsb2FkID0gdGhpcy50cmFuc2Zvcm1QYXlsb2FkKHBheWxvYWQpO1xuICAgIH1cbiAgICByZXR1cm4gcGF5bG9hZDtcbn07XG5NZXRob2QucHJvdG90eXBlLl9jb25maXJtVHJhbnNhY3Rpb24gPSBmdW5jdGlvbiAoZGVmZXIsIHJlc3VsdCwgcGF5bG9hZCkge1xuICAgIHZhciBtZXRob2QgPSB0aGlzLCBwcm9taXNlUmVzb2x2ZWQgPSBmYWxzZSwgY2FuVW5zdWJzY3JpYmUgPSB0cnVlLCB0aW1lb3V0Q291bnQgPSAwLCBjb25maXJtYXRpb25Db3VudCA9IDAsIGludGVydmFsSWQgPSBudWxsLCBibG9ja0hlYWRlclRpbWVvdXRJZCA9IG51bGwsIGxhc3RCbG9jayA9IG51bGwsIHJlY2VpcHRKU09OID0gJycsIGdhc1Byb3ZpZGVkID0gKCghIXBheWxvYWQucGFyYW1zWzBdICYmIHR5cGVvZiBwYXlsb2FkLnBhcmFtc1swXSA9PT0gJ29iamVjdCcpICYmIHBheWxvYWQucGFyYW1zWzBdLmdhcykgPyBwYXlsb2FkLnBhcmFtc1swXS5nYXMgOiBudWxsLCBpc0NvbnRyYWN0RGVwbG95bWVudCA9ICghIXBheWxvYWQucGFyYW1zWzBdICYmIHR5cGVvZiBwYXlsb2FkLnBhcmFtc1swXSA9PT0gJ29iamVjdCcpICYmXG4gICAgICAgIHBheWxvYWQucGFyYW1zWzBdLmRhdGEgJiZcbiAgICAgICAgcGF5bG9hZC5wYXJhbXNbMF0uZnJvbSAmJlxuICAgICAgICAhcGF5bG9hZC5wYXJhbXNbMF0udG8sIGhhc0J5dGVjb2RlID0gaXNDb250cmFjdERlcGxveW1lbnQgJiYgcGF5bG9hZC5wYXJhbXNbMF0uZGF0YS5sZW5ndGggPiAyO1xuICAgIC8vIGFkZCBjdXN0b20gc2VuZCBNZXRob2RzXG4gICAgdmFyIF9ldGhlcmV1bUNhbGxzID0gW1xuICAgICAgICBuZXcgTWV0aG9kKHtcbiAgICAgICAgICAgIG5hbWU6ICdnZXRCbG9ja0J5TnVtYmVyJyxcbiAgICAgICAgICAgIGNhbGw6ICdldGhfZ2V0QmxvY2tCeU51bWJlcicsXG4gICAgICAgICAgICBwYXJhbXM6IDIsXG4gICAgICAgICAgICBpbnB1dEZvcm1hdHRlcjogW2Zvcm1hdHRlcnMuaW5wdXRCbG9ja051bWJlckZvcm1hdHRlciwgZnVuY3Rpb24gKHZhbCkge1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gISF2YWw7XG4gICAgICAgICAgICAgICAgfV0sXG4gICAgICAgICAgICBvdXRwdXRGb3JtYXR0ZXI6IGZvcm1hdHRlcnMub3V0cHV0QmxvY2tGb3JtYXR0ZXJcbiAgICAgICAgfSksXG4gICAgICAgIG5ldyBNZXRob2Qoe1xuICAgICAgICAgICAgbmFtZTogJ2dldFRyYW5zYWN0aW9uUmVjZWlwdCcsXG4gICAgICAgICAgICBjYWxsOiAnZXRoX2dldFRyYW5zYWN0aW9uUmVjZWlwdCcsXG4gICAgICAgICAgICBwYXJhbXM6IDEsXG4gICAgICAgICAgICBpbnB1dEZvcm1hdHRlcjogW251bGxdLFxuICAgICAgICAgICAgb3V0cHV0Rm9ybWF0dGVyOiBmb3JtYXR0ZXJzLm91dHB1dFRyYW5zYWN0aW9uUmVjZWlwdEZvcm1hdHRlclxuICAgICAgICB9KSxcbiAgICAgICAgbmV3IE1ldGhvZCh7XG4gICAgICAgICAgICBuYW1lOiAnZ2V0Q29kZScsXG4gICAgICAgICAgICBjYWxsOiAnZXRoX2dldENvZGUnLFxuICAgICAgICAgICAgcGFyYW1zOiAyLFxuICAgICAgICAgICAgaW5wdXRGb3JtYXR0ZXI6IFtmb3JtYXR0ZXJzLmlucHV0QWRkcmVzc0Zvcm1hdHRlciwgZm9ybWF0dGVycy5pbnB1dERlZmF1bHRCbG9ja051bWJlckZvcm1hdHRlcl1cbiAgICAgICAgfSksXG4gICAgICAgIG5ldyBNZXRob2Qoe1xuICAgICAgICAgICAgbmFtZTogJ2dldFRyYW5zYWN0aW9uQnlIYXNoJyxcbiAgICAgICAgICAgIGNhbGw6ICdldGhfZ2V0VHJhbnNhY3Rpb25CeUhhc2gnLFxuICAgICAgICAgICAgcGFyYW1zOiAxLFxuICAgICAgICAgICAgaW5wdXRGb3JtYXR0ZXI6IFtudWxsXSxcbiAgICAgICAgICAgIG91dHB1dEZvcm1hdHRlcjogZm9ybWF0dGVycy5vdXRwdXRUcmFuc2FjdGlvbkZvcm1hdHRlclxuICAgICAgICB9KSxcbiAgICAgICAgbmV3IFN1YnNjcmlwdGlvbnMoe1xuICAgICAgICAgICAgbmFtZTogJ3N1YnNjcmliZScsXG4gICAgICAgICAgICB0eXBlOiAnZXRoJyxcbiAgICAgICAgICAgIHN1YnNjcmlwdGlvbnM6IHtcbiAgICAgICAgICAgICAgICAnbmV3QmxvY2tIZWFkZXJzJzoge1xuICAgICAgICAgICAgICAgICAgICBzdWJzY3JpcHRpb25OYW1lOiAnbmV3SGVhZHMnLFxuICAgICAgICAgICAgICAgICAgICBwYXJhbXM6IDAsXG4gICAgICAgICAgICAgICAgICAgIG91dHB1dEZvcm1hdHRlcjogZm9ybWF0dGVycy5vdXRwdXRCbG9ja0Zvcm1hdHRlclxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgfSlcbiAgICBdO1xuICAgIC8vIGF0dGFjaCBtZXRob2RzIHRvIHRoaXMuX2V0aGVyZXVtQ2FsbFxuICAgIHZhciBfZXRoZXJldW1DYWxsID0ge307XG4gICAgX2V0aGVyZXVtQ2FsbHMuZm9yRWFjaChtdGhkID0+IHtcbiAgICAgICAgbXRoZC5hdHRhY2hUb09iamVjdChfZXRoZXJldW1DYWxsKTtcbiAgICAgICAgbXRoZC5yZXF1ZXN0TWFuYWdlciA9IG1ldGhvZC5yZXF1ZXN0TWFuYWdlcjsgLy8gYXNzaWduIHJhdGhlciB0aGFuIGNhbGwgc2V0UmVxdWVzdE1hbmFnZXIoKVxuICAgIH0pO1xuICAgIC8vIGZpcmUgXCJyZWNlaXB0XCIgYW5kIGNvbmZpcm1hdGlvbiBldmVudHMgYW5kIHJlc29sdmUgYWZ0ZXJcbiAgICB2YXIgY2hlY2tDb25maXJtYXRpb24gPSBmdW5jdGlvbiAoZXhpc3RpbmdSZWNlaXB0LCBpc1BvbGxpbmcsIGVyciwgYmxvY2tIZWFkZXIsIHN1Yikge1xuICAgICAgICBpZiAoIWVycikge1xuICAgICAgICAgICAgLy8gY3JlYXRlIGZha2UgdW5zdWJzY3JpYmVcbiAgICAgICAgICAgIGlmICghc3ViKSB7XG4gICAgICAgICAgICAgICAgc3ViID0ge1xuICAgICAgICAgICAgICAgICAgICB1bnN1YnNjcmliZTogZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgY2xlYXJJbnRlcnZhbChpbnRlcnZhbElkKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGNsZWFyVGltZW91dChibG9ja0hlYWRlclRpbWVvdXRJZCk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9O1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgLy8gaWYgd2UgaGF2ZSBhIHZhbGlkIHJlY2VpcHQgd2UgZG9uJ3QgbmVlZCB0byBzZW5kIGEgcmVxdWVzdFxuICAgICAgICAgICAgcmV0dXJuIChleGlzdGluZ1JlY2VpcHQgPyBwcm9taUV2ZW50LnJlc29sdmUoZXhpc3RpbmdSZWNlaXB0KSA6IF9ldGhlcmV1bUNhbGwuZ2V0VHJhbnNhY3Rpb25SZWNlaXB0KHJlc3VsdCkpXG4gICAgICAgICAgICAgICAgLy8gY2F0Y2ggZXJyb3IgZnJvbSByZXF1ZXN0aW5nIHJlY2VpcHRcbiAgICAgICAgICAgICAgICAuY2F0Y2goZnVuY3Rpb24gKGVycikge1xuICAgICAgICAgICAgICAgIHN1Yi51bnN1YnNjcmliZSgpO1xuICAgICAgICAgICAgICAgIHByb21pc2VSZXNvbHZlZCA9IHRydWU7XG4gICAgICAgICAgICAgICAgdXRpbHMuX2ZpcmVFcnJvcih7XG4gICAgICAgICAgICAgICAgICAgIG1lc3NhZ2U6ICdGYWlsZWQgdG8gY2hlY2sgZm9yIHRyYW5zYWN0aW9uIHJlY2VpcHQ6JyxcbiAgICAgICAgICAgICAgICAgICAgZGF0YTogZXJyXG4gICAgICAgICAgICAgICAgfSwgZGVmZXIuZXZlbnRFbWl0dGVyLCBkZWZlci5yZWplY3QpO1xuICAgICAgICAgICAgfSlcbiAgICAgICAgICAgICAgICAvLyBpZiBDT05GSVJNQVRJT04gbGlzdGVuZXIgZXhpc3RzIGNoZWNrIGZvciBjb25maXJtYXRpb25zLCBieSBzZXR0aW5nIGNhblVuc3Vic2NyaWJlID0gZmFsc2VcbiAgICAgICAgICAgICAgICAudGhlbihhc3luYyBmdW5jdGlvbiAocmVjZWlwdCkge1xuICAgICAgICAgICAgICAgIGlmICghcmVjZWlwdCB8fCAhcmVjZWlwdC5ibG9ja0hhc2gpIHtcbiAgICAgICAgICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdSZWNlaXB0IG1pc3Npbmcgb3IgYmxvY2tIYXNoIG51bGwnKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgLy8gYXBwbHkgZXh0cmEgZm9ybWF0dGVyc1xuICAgICAgICAgICAgICAgIGlmIChtZXRob2QuZXh0cmFGb3JtYXR0ZXJzICYmIG1ldGhvZC5leHRyYUZvcm1hdHRlcnMucmVjZWlwdEZvcm1hdHRlcikge1xuICAgICAgICAgICAgICAgICAgICByZWNlaXB0ID0gbWV0aG9kLmV4dHJhRm9ybWF0dGVycy5yZWNlaXB0Rm9ybWF0dGVyKHJlY2VpcHQpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAvLyBjaGVjayBpZiBjb25maXJtYXRpb24gbGlzdGVuZXIgZXhpc3RzXG4gICAgICAgICAgICAgICAgaWYgKGRlZmVyLmV2ZW50RW1pdHRlci5saXN0ZW5lcnMoJ2NvbmZpcm1hdGlvbicpLmxlbmd0aCA+IDApIHtcbiAgICAgICAgICAgICAgICAgICAgdmFyIGJsb2NrO1xuICAgICAgICAgICAgICAgICAgICAvLyBJZiB0aGVyZSB3YXMgYW4gaW1tZWRpYXRlbHkgcmV0cmlldmVkIHJlY2VpcHQsIGl0J3MgYWxyZWFkeVxuICAgICAgICAgICAgICAgICAgICAvLyBiZWVuIGNvbmZpcm1lZCBieSB0aGUgZGlyZWN0IGNhbGwgdG8gY2hlY2tDb25maXJtYXRpb24gbmVlZGVkXG4gICAgICAgICAgICAgICAgICAgIC8vIGZvciBwYXJpdHkgaW5zdGFudC1zZWFsXG4gICAgICAgICAgICAgICAgICAgIGlmIChleGlzdGluZ1JlY2VpcHQgPT09IHVuZGVmaW5lZCB8fCBjb25maXJtYXRpb25Db3VudCAhPT0gMCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgLy8gR2V0IGxhdGVzdCBibG9jayB0byBlbWl0IHdpdGggY29uZmlybWF0aW9uXG4gICAgICAgICAgICAgICAgICAgICAgICB2YXIgbGF0ZXN0QmxvY2sgPSBhd2FpdCBfZXRoZXJldW1DYWxsLmdldEJsb2NrQnlOdW1iZXIoJ2xhdGVzdCcpO1xuICAgICAgICAgICAgICAgICAgICAgICAgdmFyIGxhdGVzdEJsb2NrSGFzaCA9IGxhdGVzdEJsb2NrID8gbGF0ZXN0QmxvY2suaGFzaCA6IG51bGw7XG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAoaXNQb2xsaW5nKSB7IC8vIENoZWNrIGlmIGFjdHVhbGx5IGEgbmV3IGJsb2NrIGlzIGV4aXN0aW5nIG9uIHBvbGxpbmdcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAobGFzdEJsb2NrKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGJsb2NrID0gYXdhaXQgX2V0aGVyZXVtQ2FsbC5nZXRCbG9ja0J5TnVtYmVyKGxhc3RCbG9jay5udW1iZXIgKyAxKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKGJsb2NrKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBsYXN0QmxvY2sgPSBibG9jaztcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGRlZmVyLmV2ZW50RW1pdHRlci5lbWl0KCdjb25maXJtYXRpb24nLCBjb25maXJtYXRpb25Db3VudCwgcmVjZWlwdCwgbGF0ZXN0QmxvY2tIYXNoKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgYmxvY2sgPSBhd2FpdCBfZXRoZXJldW1DYWxsLmdldEJsb2NrQnlOdW1iZXIocmVjZWlwdC5ibG9ja051bWJlcik7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGxhc3RCbG9jayA9IGJsb2NrO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBkZWZlci5ldmVudEVtaXR0ZXIuZW1pdCgnY29uZmlybWF0aW9uJywgY29uZmlybWF0aW9uQ291bnQsIHJlY2VpcHQsIGxhdGVzdEJsb2NrSGFzaCk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgZGVmZXIuZXZlbnRFbWl0dGVyLmVtaXQoJ2NvbmZpcm1hdGlvbicsIGNvbmZpcm1hdGlvbkNvdW50LCByZWNlaXB0LCBsYXRlc3RCbG9ja0hhc2gpO1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIGlmICgoaXNQb2xsaW5nICYmIGJsb2NrKSB8fCAhaXNQb2xsaW5nKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBjb25maXJtYXRpb25Db3VudCsrO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIGNhblVuc3Vic2NyaWJlID0gZmFsc2U7XG4gICAgICAgICAgICAgICAgICAgIGlmIChjb25maXJtYXRpb25Db3VudCA9PT0gbWV0aG9kLnRyYW5zYWN0aW9uQ29uZmlybWF0aW9uQmxvY2tzICsgMSkgeyAvLyBhZGQgMSBzbyB3ZSBhY2NvdW50IGZvciBjb25mIDBcbiAgICAgICAgICAgICAgICAgICAgICAgIHN1Yi51bnN1YnNjcmliZSgpO1xuICAgICAgICAgICAgICAgICAgICAgICAgZGVmZXIuZXZlbnRFbWl0dGVyLnJlbW92ZUFsbExpc3RlbmVycygpO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIHJldHVybiByZWNlaXB0O1xuICAgICAgICAgICAgfSlcbiAgICAgICAgICAgICAgICAvLyBDSEVDSyBmb3IgQ09OVFJBQ1QgREVQTE9ZTUVOVFxuICAgICAgICAgICAgICAgIC50aGVuKGFzeW5jIGZ1bmN0aW9uIChyZWNlaXB0KSB7XG4gICAgICAgICAgICAgICAgaWYgKGlzQ29udHJhY3REZXBsb3ltZW50ICYmICFwcm9taXNlUmVzb2x2ZWQpIHtcbiAgICAgICAgICAgICAgICAgICAgaWYgKCFyZWNlaXB0LmNvbnRyYWN0QWRkcmVzcykge1xuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKGNhblVuc3Vic2NyaWJlKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgc3ViLnVuc3Vic2NyaWJlKCk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgcHJvbWlzZVJlc29sdmVkID0gdHJ1ZTtcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgIHV0aWxzLl9maXJlRXJyb3IoZXJyb3JzLk5vQ29udHJhY3RBZGRyZXNzRm91bmRFcnJvcihyZWNlaXB0KSwgZGVmZXIuZXZlbnRFbWl0dGVyLCBkZWZlci5yZWplY3QsIG51bGwsIHJlY2VpcHQpO1xuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIHZhciBjb2RlO1xuICAgICAgICAgICAgICAgICAgICB0cnkge1xuICAgICAgICAgICAgICAgICAgICAgICAgY29kZSA9IGF3YWl0IF9ldGhlcmV1bUNhbGwuZ2V0Q29kZShyZWNlaXB0LmNvbnRyYWN0QWRkcmVzcyk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgY2F0Y2ggKGVycikge1xuICAgICAgICAgICAgICAgICAgICAgICAgLy8gaWdub3JlO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIGlmICghY29kZSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIC8vIElmIGRlcGxveW1lbnQgaXMgc3RhdHVzLnRydWUgYW5kIHRoZXJlIHdhcyBhIHJlYWxcbiAgICAgICAgICAgICAgICAgICAgLy8gYnl0ZWNvZGUgc3RyaW5nLCBhc3N1bWUgaXQgd2FzIHN1Y2Nlc3NmdWwuXG4gICAgICAgICAgICAgICAgICAgIHZhciBkZXBsb3ltZW50U3VjY2VzcyA9IHJlY2VpcHQuc3RhdHVzID09PSB0cnVlICYmIGhhc0J5dGVjb2RlO1xuICAgICAgICAgICAgICAgICAgICBpZiAoZGVwbG95bWVudFN1Y2Nlc3MgfHwgY29kZS5sZW5ndGggPiAyKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBkZWZlci5ldmVudEVtaXR0ZXIuZW1pdCgncmVjZWlwdCcsIHJlY2VpcHQpO1xuICAgICAgICAgICAgICAgICAgICAgICAgLy8gaWYgY29udHJhY3QsIHJldHVybiBpbnN0YW5jZSBpbnN0ZWFkIG9mIHJlY2VpcHRcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmIChtZXRob2QuZXh0cmFGb3JtYXR0ZXJzICYmIG1ldGhvZC5leHRyYUZvcm1hdHRlcnMuY29udHJhY3REZXBsb3lGb3JtYXR0ZXIpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBkZWZlci5yZXNvbHZlKG1ldGhvZC5leHRyYUZvcm1hdHRlcnMuY29udHJhY3REZXBsb3lGb3JtYXR0ZXIocmVjZWlwdCkpO1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgZGVmZXIucmVzb2x2ZShyZWNlaXB0KTtcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgIC8vIG5lZWQgdG8gcmVtb3ZlIGxpc3RlbmVycywgYXMgdGhleSBhcmVuJ3QgcmVtb3ZlZCBhdXRvbWF0aWNhbGx5IHdoZW4gc3VjY2VzZnVsbFxuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKGNhblVuc3Vic2NyaWJlKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgZGVmZXIuZXZlbnRFbWl0dGVyLnJlbW92ZUFsbExpc3RlbmVycygpO1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICAgICAgdXRpbHMuX2ZpcmVFcnJvcihlcnJvcnMuQ29udHJhY3RDb2RlTm90U3RvcmVkRXJyb3IocmVjZWlwdCksIGRlZmVyLmV2ZW50RW1pdHRlciwgZGVmZXIucmVqZWN0LCBudWxsLCByZWNlaXB0KTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICBpZiAoY2FuVW5zdWJzY3JpYmUpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHN1Yi51bnN1YnNjcmliZSgpO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIHByb21pc2VSZXNvbHZlZCA9IHRydWU7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIHJldHVybiByZWNlaXB0O1xuICAgICAgICAgICAgfSlcbiAgICAgICAgICAgICAgICAvLyBDSEVDSyBmb3Igbm9ybWFsIHR4IGNoZWNrIGZvciByZWNlaXB0IG9ubHlcbiAgICAgICAgICAgICAgICAudGhlbihhc3luYyBmdW5jdGlvbiAocmVjZWlwdCkge1xuICAgICAgICAgICAgICAgIGlmICghaXNDb250cmFjdERlcGxveW1lbnQgJiYgIXByb21pc2VSZXNvbHZlZCkge1xuICAgICAgICAgICAgICAgICAgICBpZiAoIXJlY2VpcHQub3V0T2ZHYXMgJiZcbiAgICAgICAgICAgICAgICAgICAgICAgICghZ2FzUHJvdmlkZWQgfHwgZ2FzUHJvdmlkZWQgIT09IHJlY2VpcHQuZ2FzVXNlZCkgJiZcbiAgICAgICAgICAgICAgICAgICAgICAgIChyZWNlaXB0LnN0YXR1cyA9PT0gdHJ1ZSB8fCByZWNlaXB0LnN0YXR1cyA9PT0gJzB4MScgfHwgdHlwZW9mIHJlY2VpcHQuc3RhdHVzID09PSAndW5kZWZpbmVkJykpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGRlZmVyLmV2ZW50RW1pdHRlci5lbWl0KCdyZWNlaXB0JywgcmVjZWlwdCk7XG4gICAgICAgICAgICAgICAgICAgICAgICBkZWZlci5yZXNvbHZlKHJlY2VpcHQpO1xuICAgICAgICAgICAgICAgICAgICAgICAgLy8gbmVlZCB0byByZW1vdmUgbGlzdGVuZXJzLCBhcyB0aGV5IGFyZW4ndCByZW1vdmVkIGF1dG9tYXRpY2FsbHkgd2hlbiBzdWNjZXNmdWxsXG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAoY2FuVW5zdWJzY3JpYmUpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBkZWZlci5ldmVudEVtaXR0ZXIucmVtb3ZlQWxsTGlzdGVuZXJzKCk7XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgICAgICByZWNlaXB0SlNPTiA9IEpTT04uc3RyaW5naWZ5KHJlY2VpcHQsIG51bGwsIDIpO1xuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKHJlY2VpcHQuc3RhdHVzID09PSBmYWxzZSB8fCByZWNlaXB0LnN0YXR1cyA9PT0gJzB4MCcpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB0cnkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB2YXIgcmV2ZXJ0TWVzc2FnZSA9IG51bGw7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmIChtZXRob2QuaGFuZGxlUmV2ZXJ0ICYmXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAobWV0aG9kLmNhbGwgPT09ICdldGhfc2VuZFRyYW5zYWN0aW9uJyB8fCBtZXRob2QuY2FsbCA9PT0gJ2V0aF9zZW5kUmF3VHJhbnNhY3Rpb24nKSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgdmFyIHR4UmVwbGF5T3B0aW9ucyA9IHBheWxvYWQucGFyYW1zWzBdO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgLy8gSWYgc2VuZCB3YXMgcmF3LCBmZXRjaCB0aGUgdHJhbnNhY3Rpb24gYW5kIHJlY29uc3RpdHV0ZSB0aGVcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vIG9yaWdpbmFsIHBhcmFtcyBzbyB0aGV5IGNhbiBiZSByZXBsYXllZCB3aXRoIGBldGhfY2FsbGBcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmIChtZXRob2QuY2FsbCA9PT0gJ2V0aF9zZW5kUmF3VHJhbnNhY3Rpb24nKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgdmFyIHJhd1RyYW5zYWN0aW9uSGV4ID0gcGF5bG9hZC5wYXJhbXNbMF07XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgdmFyIHBhcnNlZFR4ID0gRXRoZXJzVHJhbnNhY3Rpb25VdGlscy5wYXJzZShyYXdUcmFuc2FjdGlvbkhleCk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgdHhSZXBsYXlPcHRpb25zID0gZm9ybWF0dGVycy5pbnB1dFRyYW5zYWN0aW9uRm9ybWF0dGVyKHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgZGF0YTogcGFyc2VkVHguZGF0YSxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgdG86IHBhcnNlZFR4LnRvLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBmcm9tOiBwYXJzZWRUeC5mcm9tLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBnYXM6IHBhcnNlZFR4Lmdhc0xpbWl0LnRvSGV4U3RyaW5nKCksXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGdhc1ByaWNlOiBwYXJzZWRUeC5nYXNQcmljZSA/IHBhcnNlZFR4Lmdhc1ByaWNlLnRvSGV4U3RyaW5nKCkgOiB1bmRlZmluZWQsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHZhbHVlOiBwYXJzZWRUeC52YWx1ZS50b0hleFN0cmluZygpXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAvLyBHZXQgcmV2ZXJ0IHJlYXNvbiBzdHJpbmcgd2l0aCBldGhfY2FsbFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgcmV2ZXJ0TWVzc2FnZSA9IGF3YWl0IG1ldGhvZC5nZXRSZXZlcnRSZWFzb24odHhSZXBsYXlPcHRpb25zLCByZWNlaXB0LmJsb2NrTnVtYmVyKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmIChyZXZlcnRNZXNzYWdlKSB7IC8vIE9ubHkgdGhyb3cgYSByZXZlcnQgZXJyb3IgaWYgYSByZXZlcnQgcmVhc29uIGlzIGV4aXN0aW5nXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgdXRpbHMuX2ZpcmVFcnJvcihlcnJvcnMuVHJhbnNhY3Rpb25SZXZlcnRJbnN0cnVjdGlvbkVycm9yKHJldmVydE1lc3NhZ2UucmVhc29uLCByZXZlcnRNZXNzYWdlLnNpZ25hdHVyZSwgcmVjZWlwdCksIGRlZmVyLmV2ZW50RW1pdHRlciwgZGVmZXIucmVqZWN0LCBudWxsLCByZWNlaXB0KTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHRocm93IGZhbHNlOyAvLyBUaHJvdyBmYWxzZSBhbmQgbGV0IHRoZSB0cnkvY2F0Y2ggc3RhdGVtZW50IGhhbmRsZSB0aGUgZXJyb3IgY29ycmVjdGx5IGFmdGVyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB0aHJvdyBmYWxzZTsgLy8gVGhyb3cgZmFsc2UgYW5kIGxldCB0aGUgdHJ5L2NhdGNoIHN0YXRlbWVudCBoYW5kbGUgdGhlIGVycm9yIGNvcnJlY3RseSBhZnRlclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNhdGNoIChlcnJvcikge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAvLyBUaHJvdyBhbiBub3JtYWwgcmV2ZXJ0IGVycm9yIGlmIG5vIHJldmVydCByZWFzb24gaXMgZ2l2ZW4gb3IgdGhlIGRldGVjdGlvbiBvZiBpdCBpcyBkaXNhYmxlZFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB1dGlscy5fZmlyZUVycm9yKGVycm9ycy5UcmFuc2FjdGlvblJldmVydGVkV2l0aG91dFJlYXNvbkVycm9yKHJlY2VpcHQpLCBkZWZlci5ldmVudEVtaXR0ZXIsIGRlZmVyLnJlamVjdCwgbnVsbCwgcmVjZWlwdCk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgLy8gVGhyb3cgT09HIGlmIHN0YXR1cyBpcyBub3QgZXhpc3RpbmcgYW5kIHByb3ZpZGVkIGdhcyBhbmQgdXNlZCBnYXMgYXJlIGVxdWFsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgdXRpbHMuX2ZpcmVFcnJvcihlcnJvcnMuVHJhbnNhY3Rpb25PdXRPZkdhc0Vycm9yKHJlY2VpcHQpLCBkZWZlci5ldmVudEVtaXR0ZXIsIGRlZmVyLnJlamVjdCwgbnVsbCwgcmVjZWlwdCk7XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgaWYgKGNhblVuc3Vic2NyaWJlKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBzdWIudW5zdWJzY3JpYmUoKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICBwcm9taXNlUmVzb2x2ZWQgPSB0cnVlO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0pXG4gICAgICAgICAgICAgICAgLy8gdGltZSBvdXQgdGhlIHRyYW5zYWN0aW9uIGlmIG5vdCBtaW5lZCBhZnRlciA1MCBibG9ja3NcbiAgICAgICAgICAgICAgICAuY2F0Y2goZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgICAgIHRpbWVvdXRDb3VudCsrO1xuICAgICAgICAgICAgICAgIC8vIGNoZWNrIHRvIHNlZSBpZiB3ZSBhcmUgaHR0cCBwb2xsaW5nXG4gICAgICAgICAgICAgICAgaWYgKCEhaXNQb2xsaW5nKSB7XG4gICAgICAgICAgICAgICAgICAgIC8vIHBvbGxpbmcgdGltZW91dCBpcyBkaWZmZXJlbnQgdGhhbiB0cmFuc2FjdGlvbkJsb2NrVGltZW91dCBibG9ja3Mgc2luY2Ugd2UgYXJlIHRyaWdnZXJpbmcgZXZlcnkgc2Vjb25kXG4gICAgICAgICAgICAgICAgICAgIGlmICh0aW1lb3V0Q291bnQgLSAxID49IG1ldGhvZC50cmFuc2FjdGlvblBvbGxpbmdUaW1lb3V0KSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBzdWIudW5zdWJzY3JpYmUoKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIHByb21pc2VSZXNvbHZlZCA9IHRydWU7XG4gICAgICAgICAgICAgICAgICAgICAgICB1dGlscy5fZmlyZUVycm9yKGVycm9ycy5UcmFuc2FjdGlvbkVycm9yKCdUcmFuc2FjdGlvbiB3YXMgbm90IG1pbmVkIHdpdGhpbiAnICsgbWV0aG9kLnRyYW5zYWN0aW9uUG9sbGluZ1RpbWVvdXQgKyAnIHNlY29uZHMsIHBsZWFzZSBtYWtlIHN1cmUgeW91ciB0cmFuc2FjdGlvbiB3YXMgcHJvcGVybHkgc2VudC4gQmUgYXdhcmUgdGhhdCBpdCBtaWdodCBzdGlsbCBiZSBtaW5lZCEnKSwgZGVmZXIuZXZlbnRFbWl0dGVyLCBkZWZlci5yZWplY3QpO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICBpZiAodGltZW91dENvdW50IC0gMSA+PSBtZXRob2QudHJhbnNhY3Rpb25CbG9ja1RpbWVvdXQpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHN1Yi51bnN1YnNjcmliZSgpO1xuICAgICAgICAgICAgICAgICAgICAgICAgcHJvbWlzZVJlc29sdmVkID0gdHJ1ZTtcbiAgICAgICAgICAgICAgICAgICAgICAgIHV0aWxzLl9maXJlRXJyb3IoZXJyb3JzLlRyYW5zYWN0aW9uRXJyb3IoJ1RyYW5zYWN0aW9uIHdhcyBub3QgbWluZWQgd2l0aGluICcgKyBtZXRob2QudHJhbnNhY3Rpb25CbG9ja1RpbWVvdXQgKyAnIGJsb2NrcywgcGxlYXNlIG1ha2Ugc3VyZSB5b3VyIHRyYW5zYWN0aW9uIHdhcyBwcm9wZXJseSBzZW50LiBCZSBhd2FyZSB0aGF0IGl0IG1pZ2h0IHN0aWxsIGJlIG1pbmVkIScpLCBkZWZlci5ldmVudEVtaXR0ZXIsIGRlZmVyLnJlamVjdCk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIHN1Yi51bnN1YnNjcmliZSgpO1xuICAgICAgICAgICAgcHJvbWlzZVJlc29sdmVkID0gdHJ1ZTtcbiAgICAgICAgICAgIHV0aWxzLl9maXJlRXJyb3Ioe1xuICAgICAgICAgICAgICAgIG1lc3NhZ2U6ICdGYWlsZWQgdG8gc3Vic2NyaWJlIHRvIG5ldyBuZXdCbG9ja0hlYWRlcnMgdG8gY29uZmlybSB0aGUgdHJhbnNhY3Rpb24gcmVjZWlwdHMuJyxcbiAgICAgICAgICAgICAgICBkYXRhOiBlcnJcbiAgICAgICAgICAgIH0sIGRlZmVyLmV2ZW50RW1pdHRlciwgZGVmZXIucmVqZWN0KTtcbiAgICAgICAgfVxuICAgIH07XG4gICAgLy8gc3RhcnQgd2F0Y2hpbmcgZm9yIGNvbmZpcm1hdGlvbiBkZXBlbmRpbmcgb24gdGhlIHN1cHBvcnQgZmVhdHVyZXMgb2YgdGhlIHByb3ZpZGVyXG4gICAgdmFyIHN0YXJ0V2F0Y2hpbmcgPSBmdW5jdGlvbiAoZXhpc3RpbmdSZWNlaXB0KSB7XG4gICAgICAgIGxldCBibG9ja0hlYWRlckFycml2ZWQgPSBmYWxzZTtcbiAgICAgICAgY29uc3Qgc3RhcnRJbnRlcnZhbCA9ICgpID0+IHtcbiAgICAgICAgICAgIGludGVydmFsSWQgPSBzZXRJbnRlcnZhbChjaGVja0NvbmZpcm1hdGlvbi5iaW5kKG51bGwsIGV4aXN0aW5nUmVjZWlwdCwgdHJ1ZSksIG1ldGhvZC50cmFuc2FjdGlvblBvbGxpbmdJbnRlcnZhbCk7XG4gICAgICAgIH07XG4gICAgICAgIC8vIElmIHByb3ZpZGVyIGRvIG5vdCBzdXBwb3J0IGV2ZW50IHN1YnNjcmlwdGlvbiB1c2UgcG9sbGluZ1xuICAgICAgICBpZiAoIXRoaXMucmVxdWVzdE1hbmFnZXIucHJvdmlkZXIub24pIHtcbiAgICAgICAgICAgIHJldHVybiBzdGFydEludGVydmFsKCk7XG4gICAgICAgIH1cbiAgICAgICAgLy8gU3Vic2NyaWJlIHRvIG5ldyBibG9jayBoZWFkZXJzIHRvIGxvb2sgZm9yIHR4IHJlY2VpcHRcbiAgICAgICAgX2V0aGVyZXVtQ2FsbC5zdWJzY3JpYmUoJ25ld0Jsb2NrSGVhZGVycycsIGZ1bmN0aW9uIChlcnIsIGJsb2NrSGVhZGVyLCBzdWIpIHtcbiAgICAgICAgICAgIGJsb2NrSGVhZGVyQXJyaXZlZCA9IHRydWU7XG4gICAgICAgICAgICBpZiAoZXJyIHx8ICFibG9ja0hlYWRlcikge1xuICAgICAgICAgICAgICAgIC8vIGZhbGwgYmFjayB0byBwb2xsaW5nXG4gICAgICAgICAgICAgICAgcmV0dXJuIHN0YXJ0SW50ZXJ2YWwoKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGNoZWNrQ29uZmlybWF0aW9uKGV4aXN0aW5nUmVjZWlwdCwgZmFsc2UsIGVyciwgYmxvY2tIZWFkZXIsIHN1Yik7XG4gICAgICAgIH0pO1xuICAgICAgICAvLyBGYWxsYmFjayB0byBwb2xsaW5nIGlmIHR4IHJlY2VpcHQgZGlkbid0IGFycml2ZWQgaW4gXCJibG9ja0hlYWRlclRpbWVvdXRcIiBbMTAgc2Vjb25kc11cbiAgICAgICAgYmxvY2tIZWFkZXJUaW1lb3V0SWQgPSBzZXRUaW1lb3V0KCgpID0+IHtcbiAgICAgICAgICAgIGlmICghYmxvY2tIZWFkZXJBcnJpdmVkKSB7XG4gICAgICAgICAgICAgICAgc3RhcnRJbnRlcnZhbCgpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9LCB0aGlzLmJsb2NrSGVhZGVyVGltZW91dCAqIDEwMDApO1xuICAgIH0uYmluZCh0aGlzKTtcbiAgICAvLyBmaXJzdCBjaGVjayBpZiB3ZSBhbHJlYWR5IGhhdmUgYSBjb25maXJtZWQgdHJhbnNhY3Rpb25cbiAgICBfZXRoZXJldW1DYWxsLmdldFRyYW5zYWN0aW9uUmVjZWlwdChyZXN1bHQpXG4gICAgICAgIC50aGVuKGZ1bmN0aW9uIChyZWNlaXB0KSB7XG4gICAgICAgIGlmIChyZWNlaXB0ICYmIHJlY2VpcHQuYmxvY2tIYXNoKSB7XG4gICAgICAgICAgICBpZiAoZGVmZXIuZXZlbnRFbWl0dGVyLmxpc3RlbmVycygnY29uZmlybWF0aW9uJykubGVuZ3RoID4gMCkge1xuICAgICAgICAgICAgICAgIC8vIFdlIG11c3Qga2VlcCBvbiB3YXRjaGluZyBmb3IgbmV3IEJsb2NrcywgaWYgYSBjb25maXJtYXRpb24gbGlzdGVuZXIgaXMgcHJlc2VudFxuICAgICAgICAgICAgICAgIHN0YXJ0V2F0Y2hpbmcocmVjZWlwdCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBjaGVja0NvbmZpcm1hdGlvbihyZWNlaXB0LCBmYWxzZSk7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSBpZiAoIXByb21pc2VSZXNvbHZlZCkge1xuICAgICAgICAgICAgc3RhcnRXYXRjaGluZygpO1xuICAgICAgICB9XG4gICAgfSlcbiAgICAgICAgLmNhdGNoKGZ1bmN0aW9uICgpIHtcbiAgICAgICAgaWYgKCFwcm9taXNlUmVzb2x2ZWQpXG4gICAgICAgICAgICBzdGFydFdhdGNoaW5nKCk7XG4gICAgfSk7XG59O1xudmFyIGdldFdhbGxldCA9IGZ1bmN0aW9uIChmcm9tLCBhY2NvdW50cykge1xuICAgIHZhciB3YWxsZXQgPSBudWxsO1xuICAgIC8vIGlzIGluZGV4IGdpdmVuXG4gICAgaWYgKHR5cGVvZiBmcm9tID09PSAnbnVtYmVyJykge1xuICAgICAgICB3YWxsZXQgPSBhY2NvdW50cy53YWxsZXRbZnJvbV07XG4gICAgICAgIC8vIGlzIGFjY291bnQgZ2l2ZW5cbiAgICB9XG4gICAgZWxzZSBpZiAoISFmcm9tICYmIHR5cGVvZiBmcm9tID09PSAnb2JqZWN0JyAmJiBmcm9tLmFkZHJlc3MgJiYgZnJvbS5wcml2YXRlS2V5KSB7XG4gICAgICAgIHdhbGxldCA9IGZyb207XG4gICAgICAgIC8vIHNlYXJjaCBpbiB3YWxsZXQgZm9yIGFkZHJlc3NcbiAgICB9XG4gICAgZWxzZSB7XG4gICAgICAgIHdhbGxldCA9IGFjY291bnRzLndhbGxldFtmcm9tLnRvTG93ZXJDYXNlKCldO1xuICAgIH1cbiAgICByZXR1cm4gd2FsbGV0O1xufTtcbk1ldGhvZC5wcm90b3R5cGUuYnVpbGRDYWxsID0gZnVuY3Rpb24gKCkge1xuICAgIHZhciBtZXRob2QgPSB0aGlzLCBpc1NlbmRUeCA9IChtZXRob2QuY2FsbCA9PT0gJ2V0aF9zZW5kVHJhbnNhY3Rpb24nIHx8IG1ldGhvZC5jYWxsID09PSAnZXRoX3NlbmRSYXdUcmFuc2FjdGlvbicpLCAvLyB8fCBtZXRob2QuY2FsbCA9PT0gJ3BlcnNvbmFsX3NlbmRUcmFuc2FjdGlvbidcbiAgICBpc0NhbGwgPSAobWV0aG9kLmNhbGwgPT09ICdldGhfY2FsbCcpO1xuICAgIC8vIGFjdHVhbCBzZW5kIGZ1bmN0aW9uXG4gICAgdmFyIHNlbmQgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIGxldCBhcmdzID0gQXJyYXkucHJvdG90eXBlLnNsaWNlLmNhbGwoYXJndW1lbnRzKTtcbiAgICAgICAgdmFyIGRlZmVyID0gcHJvbWlFdmVudCghaXNTZW5kVHgpLCBwYXlsb2FkID0gbWV0aG9kLnRvUGF5bG9hZChhcmdzKTtcbiAgICAgICAgbWV0aG9kLmhleEZvcm1hdCA9IGZhbHNlO1xuICAgICAgICBpZiAobWV0aG9kLmNhbGwgPT09ICdldGhfZ2V0VHJhbnNhY3Rpb25SZWNlaXB0J1xuICAgICAgICAgICAgfHwgbWV0aG9kLmNhbGwgPT09ICdldGhfZ2V0VHJhbnNhY3Rpb25CeUhhc2gnXG4gICAgICAgICAgICB8fCBtZXRob2QubmFtZSA9PT0gJ2dldEJsb2NrJykge1xuICAgICAgICAgICAgbWV0aG9kLmhleEZvcm1hdCA9IChwYXlsb2FkLnBhcmFtcy5sZW5ndGggPCBhcmdzLmxlbmd0aCAmJiBhcmdzW2FyZ3MubGVuZ3RoIC0gMV0gPT09ICdoZXgnKTtcbiAgICAgICAgfVxuICAgICAgICAvLyBDQUxMQkFDSyBmdW5jdGlvblxuICAgICAgICB2YXIgc2VuZFR4Q2FsbGJhY2sgPSBmdW5jdGlvbiAoZXJyLCByZXN1bHQpIHtcbiAgICAgICAgICAgIGlmIChtZXRob2QuaGFuZGxlUmV2ZXJ0ICYmIGlzQ2FsbCAmJiBtZXRob2QuYWJpQ29kZXIpIHtcbiAgICAgICAgICAgICAgICB2YXIgcmVhc29uRGF0YTtcbiAgICAgICAgICAgICAgICAvLyBHYW5hY2hlIC8gR2V0aCA8PSAxLjkuMTMgcmV0dXJuIHRoZSByZWFzb24gZGF0YSBhcyBhIHN1Y2Nlc3NmdWwgZXRoX2NhbGwgcmVzcG9uc2VcbiAgICAgICAgICAgICAgICAvLyBHZXRoID49IDEuOS4xNSBhdHRhY2hlcyB0aGUgcmVhc29uIGRhdGEgdG8gYW4gZXJyb3Igb2JqZWN0LlxuICAgICAgICAgICAgICAgIC8vIEdldGggMS45LjE0IGlzIG1pc3NpbmcgcmV2ZXJ0IHJlYXNvbiAoaHR0cHM6Ly9naXRodWIuY29tL2V0aGVyZXVtL3dlYjMuanMvaXNzdWVzLzM1MjApXG4gICAgICAgICAgICAgICAgaWYgKCFlcnIgJiYgbWV0aG9kLmlzUmV2ZXJ0UmVhc29uU3RyaW5nKHJlc3VsdCkpIHtcbiAgICAgICAgICAgICAgICAgICAgcmVhc29uRGF0YSA9IHJlc3VsdC5zdWJzdHJpbmcoMTApO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBlbHNlIGlmIChlcnIgJiYgZXJyLmRhdGEpIHtcbiAgICAgICAgICAgICAgICAgICAgcmVhc29uRGF0YSA9IGVyci5kYXRhLnN1YnN0cmluZygxMCk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGlmIChyZWFzb25EYXRhKSB7XG4gICAgICAgICAgICAgICAgICAgIHZhciByZWFzb24gPSBtZXRob2QuYWJpQ29kZXIuZGVjb2RlUGFyYW1ldGVyKCdzdHJpbmcnLCAnMHgnICsgcmVhc29uRGF0YSk7XG4gICAgICAgICAgICAgICAgICAgIHZhciBzaWduYXR1cmUgPSAnRXJyb3IoU3RyaW5nKSc7XG4gICAgICAgICAgICAgICAgICAgIHV0aWxzLl9maXJlRXJyb3IoZXJyb3JzLlJldmVydEluc3RydWN0aW9uRXJyb3IocmVhc29uLCBzaWduYXR1cmUpLCBkZWZlci5ldmVudEVtaXR0ZXIsIGRlZmVyLnJlamVjdCwgcGF5bG9hZC5jYWxsYmFjaywge1xuICAgICAgICAgICAgICAgICAgICAgICAgcmVhc29uOiByZWFzb24sXG4gICAgICAgICAgICAgICAgICAgICAgICBzaWduYXR1cmU6IHNpZ25hdHVyZVxuICAgICAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHRyeSB7XG4gICAgICAgICAgICAgICAgcmVzdWx0ID0gbWV0aG9kLmZvcm1hdE91dHB1dChyZXN1bHQpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgY2F0Y2ggKGUpIHtcbiAgICAgICAgICAgICAgICBlcnIgPSBlO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKHJlc3VsdCBpbnN0YW5jZW9mIEVycm9yKSB7XG4gICAgICAgICAgICAgICAgZXJyID0gcmVzdWx0O1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKCFlcnIpIHtcbiAgICAgICAgICAgICAgICBpZiAocGF5bG9hZC5jYWxsYmFjaykge1xuICAgICAgICAgICAgICAgICAgICBwYXlsb2FkLmNhbGxiYWNrKG51bGwsIHJlc3VsdCk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgaWYgKGVyci5lcnJvcikge1xuICAgICAgICAgICAgICAgICAgICBlcnIgPSBlcnIuZXJyb3I7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIHJldHVybiB1dGlscy5fZmlyZUVycm9yKGVyciwgZGVmZXIuZXZlbnRFbWl0dGVyLCBkZWZlci5yZWplY3QsIHBheWxvYWQuY2FsbGJhY2spO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgLy8gcmV0dXJuIFBST01JU0VcbiAgICAgICAgICAgIGlmICghaXNTZW5kVHgpIHtcbiAgICAgICAgICAgICAgICBpZiAoIWVycikge1xuICAgICAgICAgICAgICAgICAgICBkZWZlci5yZXNvbHZlKHJlc3VsdCk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIC8vIHJldHVybiBQUk9NSUVWRU5UXG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICBkZWZlci5ldmVudEVtaXR0ZXIuZW1pdCgndHJhbnNhY3Rpb25IYXNoJywgcmVzdWx0KTtcbiAgICAgICAgICAgICAgICBtZXRob2QuX2NvbmZpcm1UcmFuc2FjdGlvbihkZWZlciwgcmVzdWx0LCBwYXlsb2FkKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfTtcbiAgICAgICAgLy8gU0VORFMgdGhlIFNJR05FRCBTSUdOQVRVUkVcbiAgICAgICAgdmFyIHNlbmRTaWduZWRUeCA9IGZ1bmN0aW9uIChzaWduKSB7XG4gICAgICAgICAgICB2YXIgc2lnbmVkUGF5bG9hZCA9IHsgLi4ucGF5bG9hZCxcbiAgICAgICAgICAgICAgICBtZXRob2Q6ICdldGhfc2VuZFJhd1RyYW5zYWN0aW9uJyxcbiAgICAgICAgICAgICAgICBwYXJhbXM6IFtzaWduLnJhd1RyYW5zYWN0aW9uXVxuICAgICAgICAgICAgfTtcbiAgICAgICAgICAgIG1ldGhvZC5yZXF1ZXN0TWFuYWdlci5zZW5kKHNpZ25lZFBheWxvYWQsIHNlbmRUeENhbGxiYWNrKTtcbiAgICAgICAgfTtcbiAgICAgICAgdmFyIHNlbmRSZXF1ZXN0ID0gZnVuY3Rpb24gKHBheWxvYWQsIG1ldGhvZCkge1xuICAgICAgICAgICAgaWYgKG1ldGhvZCAmJiBtZXRob2QuYWNjb3VudHMgJiYgbWV0aG9kLmFjY291bnRzLndhbGxldCAmJiBtZXRob2QuYWNjb3VudHMud2FsbGV0Lmxlbmd0aCkge1xuICAgICAgICAgICAgICAgIHZhciB3YWxsZXQ7XG4gICAgICAgICAgICAgICAgLy8gRVRIX1NFTkRUUkFOU0FDVElPTlxuICAgICAgICAgICAgICAgIGlmIChwYXlsb2FkLm1ldGhvZCA9PT0gJ2V0aF9zZW5kVHJhbnNhY3Rpb24nKSB7XG4gICAgICAgICAgICAgICAgICAgIHZhciB0eCA9IHBheWxvYWQucGFyYW1zWzBdO1xuICAgICAgICAgICAgICAgICAgICB3YWxsZXQgPSBnZXRXYWxsZXQoKCEhdHggJiYgdHlwZW9mIHR4ID09PSAnb2JqZWN0JykgPyB0eC5mcm9tIDogbnVsbCwgbWV0aG9kLmFjY291bnRzKTtcbiAgICAgICAgICAgICAgICAgICAgLy8gSWYgd2FsbGV0IHdhcyBmb3VuZCwgc2lnbiB0eCwgYW5kIHNlbmQgdXNpbmcgc2VuZFJhd1RyYW5zYWN0aW9uXG4gICAgICAgICAgICAgICAgICAgIGlmICh3YWxsZXQgJiYgd2FsbGV0LnByaXZhdGVLZXkpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHZhciB0eCA9IEpTT04ucGFyc2UoSlNPTi5zdHJpbmdpZnkodHgpKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGRlbGV0ZSB0eC5mcm9tO1xuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKG1ldGhvZC5kZWZhdWx0Q2hhaW4gJiYgIXR4LmNoYWluKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgdHguY2hhaW4gPSBtZXRob2QuZGVmYXVsdENoYWluO1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKG1ldGhvZC5kZWZhdWx0SGFyZGZvcmsgJiYgIXR4LmhhcmRmb3JrKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgdHguaGFyZGZvcmsgPSBtZXRob2QuZGVmYXVsdEhhcmRmb3JrO1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKG1ldGhvZC5kZWZhdWx0Q29tbW9uICYmICF0eC5jb21tb24pIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB0eC5jb21tb24gPSBtZXRob2QuZGVmYXVsdENvbW1vbjtcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgIG1ldGhvZC5hY2NvdW50cy5zaWduVHJhbnNhY3Rpb24odHgsIHdhbGxldC5wcml2YXRlS2V5KVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIC50aGVuKHNlbmRTaWduZWRUeClcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAuY2F0Y2goZnVuY3Rpb24gKGVycikge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmICh0eXBlb2YgZGVmZXIuZXZlbnRFbWl0dGVyLmxpc3RlbmVycyA9PT0gJ2Z1bmN0aW9uJyAmJiBkZWZlci5ldmVudEVtaXR0ZXIubGlzdGVuZXJzKCdlcnJvcicpLmxlbmd0aCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB0cnkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgZGVmZXIuZXZlbnRFbWl0dGVyLmVtaXQoJ2Vycm9yJywgZXJyKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBjYXRjaCAoZXJyKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAvLyBJZ25vcmUgdXNlcmxhbmQgZXJyb3IgcHJldmVudCBpdCB0byBidWJibGUgdXAgd2l0aGluIHdlYjMuXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgZGVmZXIuZXZlbnRFbWl0dGVyLnJlbW92ZUFsbExpc3RlbmVycygpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBkZWZlci5ldmVudEVtaXR0ZXIuY2F0Y2goZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgZGVmZXIucmVqZWN0KGVycik7XG4gICAgICAgICAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAvLyBFVEhfU0lHTlxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBlbHNlIGlmIChwYXlsb2FkLm1ldGhvZCA9PT0gJ2V0aF9zaWduJykge1xuICAgICAgICAgICAgICAgICAgICB2YXIgZGF0YSA9IHBheWxvYWQucGFyYW1zWzFdO1xuICAgICAgICAgICAgICAgICAgICB3YWxsZXQgPSBnZXRXYWxsZXQocGF5bG9hZC5wYXJhbXNbMF0sIG1ldGhvZC5hY2NvdW50cyk7XG4gICAgICAgICAgICAgICAgICAgIC8vIElmIHdhbGxldCB3YXMgZm91bmQsIHNpZ24gdHgsIGFuZCBzZW5kIHVzaW5nIHNlbmRSYXdUcmFuc2FjdGlvblxuICAgICAgICAgICAgICAgICAgICBpZiAod2FsbGV0ICYmIHdhbGxldC5wcml2YXRlS2V5KSB7XG4gICAgICAgICAgICAgICAgICAgICAgICB2YXIgc2lnbiA9IG1ldGhvZC5hY2NvdW50cy5zaWduKGRhdGEsIHdhbGxldC5wcml2YXRlS2V5KTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmIChwYXlsb2FkLmNhbGxiYWNrKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgcGF5bG9hZC5jYWxsYmFjayhudWxsLCBzaWduLnNpZ25hdHVyZSk7XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICBkZWZlci5yZXNvbHZlKHNpZ24uc2lnbmF0dXJlKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiBtZXRob2QucmVxdWVzdE1hbmFnZXIuc2VuZChwYXlsb2FkLCBzZW5kVHhDYWxsYmFjayk7XG4gICAgICAgIH07XG4gICAgICAgIC8vIFNlbmQgdGhlIGFjdHVhbCB0cmFuc2FjdGlvblxuICAgICAgICBpZiAoaXNTZW5kVHhcbiAgICAgICAgICAgICYmICEhcGF5bG9hZC5wYXJhbXNbMF1cbiAgICAgICAgICAgICYmIHR5cGVvZiBwYXlsb2FkLnBhcmFtc1swXSA9PT0gJ29iamVjdCdcbiAgICAgICAgICAgICYmICh0eXBlb2YgcGF5bG9hZC5wYXJhbXNbMF0uZ2FzUHJpY2UgPT09ICd1bmRlZmluZWQnXG4gICAgICAgICAgICAgICAgJiYgKHR5cGVvZiBwYXlsb2FkLnBhcmFtc1swXS5tYXhQcmlvcml0eUZlZVBlckdhcyA9PT0gJ3VuZGVmaW5lZCdcbiAgICAgICAgICAgICAgICAgICAgfHwgdHlwZW9mIHBheWxvYWQucGFyYW1zWzBdLm1heEZlZVBlckdhcyA9PT0gJ3VuZGVmaW5lZCcpKSkge1xuICAgICAgICAgICAgX2hhbmRsZVR4UHJpY2luZyhtZXRob2QsIHBheWxvYWQucGFyYW1zWzBdKS50aGVuKHR4UHJpY2luZyA9PiB7XG4gICAgICAgICAgICAgICAgaWYgKHR4UHJpY2luZy5nYXNQcmljZSAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICAgICAgICAgIHBheWxvYWQucGFyYW1zWzBdLmdhc1ByaWNlID0gdHhQcmljaW5nLmdhc1ByaWNlO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBlbHNlIGlmICh0eFByaWNpbmcubWF4UHJpb3JpdHlGZWVQZXJHYXMgIT09IHVuZGVmaW5lZFxuICAgICAgICAgICAgICAgICAgICAmJiB0eFByaWNpbmcubWF4RmVlUGVyR2FzICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgICAgICAgICAgcGF5bG9hZC5wYXJhbXNbMF0ubWF4UHJpb3JpdHlGZWVQZXJHYXMgPSB0eFByaWNpbmcubWF4UHJpb3JpdHlGZWVQZXJHYXM7XG4gICAgICAgICAgICAgICAgICAgIHBheWxvYWQucGFyYW1zWzBdLm1heEZlZVBlckdhcyA9IHR4UHJpY2luZy5tYXhGZWVQZXJHYXM7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGlmIChpc1NlbmRUeCkge1xuICAgICAgICAgICAgICAgICAgICBzZXRUaW1lb3V0KCgpID0+IHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGRlZmVyLmV2ZW50RW1pdHRlci5lbWl0KCdzZW5kaW5nJywgcGF5bG9hZCk7XG4gICAgICAgICAgICAgICAgICAgIH0sIDApO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBzZW5kUmVxdWVzdChwYXlsb2FkLCBtZXRob2QpO1xuICAgICAgICAgICAgfSk7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICBpZiAoaXNTZW5kVHgpIHtcbiAgICAgICAgICAgICAgICBzZXRUaW1lb3V0KCgpID0+IHtcbiAgICAgICAgICAgICAgICAgICAgZGVmZXIuZXZlbnRFbWl0dGVyLmVtaXQoJ3NlbmRpbmcnLCBwYXlsb2FkKTtcbiAgICAgICAgICAgICAgICB9LCAwKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHNlbmRSZXF1ZXN0KHBheWxvYWQsIG1ldGhvZCk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKGlzU2VuZFR4KSB7XG4gICAgICAgICAgICBzZXRUaW1lb3V0KCgpID0+IHtcbiAgICAgICAgICAgICAgICBkZWZlci5ldmVudEVtaXR0ZXIuZW1pdCgnc2VudCcsIHBheWxvYWQpO1xuICAgICAgICAgICAgfSwgMCk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIGRlZmVyLmV2ZW50RW1pdHRlcjtcbiAgICB9O1xuICAgIC8vIG5lY2Vzc2FyeSB0byBhdHRhY2ggdGhpbmdzIHRvIHRoZSBtZXRob2RcbiAgICBzZW5kLm1ldGhvZCA9IG1ldGhvZDtcbiAgICAvLyBuZWNlc3NhcnkgZm9yIGJhdGNoIHJlcXVlc3RzXG4gICAgc2VuZC5yZXF1ZXN0ID0gdGhpcy5yZXF1ZXN0LmJpbmQodGhpcyk7XG4gICAgcmV0dXJuIHNlbmQ7XG59O1xuZnVuY3Rpb24gX2hhbmRsZVR4UHJpY2luZyhtZXRob2QsIHR4KSB7XG4gICAgcmV0dXJuIG5ldyBQcm9taXNlKChyZXNvbHZlLCByZWplY3QpID0+IHtcbiAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgIHZhciBnZXRCbG9ja0J5TnVtYmVyID0gKG5ldyBNZXRob2Qoe1xuICAgICAgICAgICAgICAgIG5hbWU6ICdnZXRCbG9ja0J5TnVtYmVyJyxcbiAgICAgICAgICAgICAgICBjYWxsOiAnZXRoX2dldEJsb2NrQnlOdW1iZXInLFxuICAgICAgICAgICAgICAgIHBhcmFtczogMixcbiAgICAgICAgICAgICAgICBpbnB1dEZvcm1hdHRlcjogW2Z1bmN0aW9uIChibG9ja051bWJlcikge1xuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGJsb2NrTnVtYmVyID8gdXRpbHMudG9IZXgoYmxvY2tOdW1iZXIpIDogJ2xhdGVzdCc7XG4gICAgICAgICAgICAgICAgICAgIH0sIGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgICAgICAgICAgICAgfV1cbiAgICAgICAgICAgIH0pKS5jcmVhdGVGdW5jdGlvbihtZXRob2QucmVxdWVzdE1hbmFnZXIpO1xuICAgICAgICAgICAgdmFyIGdldEdhc1ByaWNlID0gKG5ldyBNZXRob2Qoe1xuICAgICAgICAgICAgICAgIG5hbWU6ICdnZXRHYXNQcmljZScsXG4gICAgICAgICAgICAgICAgY2FsbDogJ2V0aF9nYXNQcmljZScsXG4gICAgICAgICAgICAgICAgcGFyYW1zOiAwXG4gICAgICAgICAgICB9KSkuY3JlYXRlRnVuY3Rpb24obWV0aG9kLnJlcXVlc3RNYW5hZ2VyKTtcbiAgICAgICAgICAgIFByb21pc2UuYWxsKFtcbiAgICAgICAgICAgICAgICBnZXRCbG9ja0J5TnVtYmVyKCksXG4gICAgICAgICAgICAgICAgZ2V0R2FzUHJpY2UoKVxuICAgICAgICAgICAgXSkudGhlbihyZXNwb25zZXMgPT4ge1xuICAgICAgICAgICAgICAgIGNvbnN0IFtibG9jaywgZ2FzUHJpY2VdID0gcmVzcG9uc2VzO1xuICAgICAgICAgICAgICAgIGlmICgodHgudHlwZSA9PT0gJzB4MicgfHwgdHgudHlwZSA9PT0gdW5kZWZpbmVkKSAmJlxuICAgICAgICAgICAgICAgICAgICAoYmxvY2sgJiYgYmxvY2suYmFzZUZlZVBlckdhcykpIHtcbiAgICAgICAgICAgICAgICAgICAgLy8gVGhlIG5ldHdvcmsgc3VwcG9ydHMgRUlQLTE1NTlcbiAgICAgICAgICAgICAgICAgICAgLy8gVGFrZW4gZnJvbSBodHRwczovL2dpdGh1Yi5jb20vZXRoZXJzLWlvL2V0aGVycy5qcy9ibG9iL2JhNjg1NGJkZDVhOTEyZmU4NzNkNWRhNDk0Y2I1YzYyYzE5MGFkZGUvcGFja2FnZXMvYWJzdHJhY3QtcHJvdmlkZXIvc3JjLnRzL2luZGV4LnRzI0wyMzBcbiAgICAgICAgICAgICAgICAgICAgbGV0IG1heFByaW9yaXR5RmVlUGVyR2FzLCBtYXhGZWVQZXJHYXM7XG4gICAgICAgICAgICAgICAgICAgIGlmICh0eC5nYXNQcmljZSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgLy8gVXNpbmcgbGVnYWN5IGdhc1ByaWNlIHByb3BlcnR5IG9uIGFuIGVpcC0xNTU5IG5ldHdvcmssXG4gICAgICAgICAgICAgICAgICAgICAgICAvLyBzbyB1c2UgZ2FzUHJpY2UgYXMgYm90aCBmZWUgcHJvcGVydGllc1xuICAgICAgICAgICAgICAgICAgICAgICAgbWF4UHJpb3JpdHlGZWVQZXJHYXMgPSB0eC5nYXNQcmljZTtcbiAgICAgICAgICAgICAgICAgICAgICAgIG1heEZlZVBlckdhcyA9IHR4Lmdhc1ByaWNlO1xuICAgICAgICAgICAgICAgICAgICAgICAgZGVsZXRlIHR4Lmdhc1ByaWNlO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICAgICAgbWF4UHJpb3JpdHlGZWVQZXJHYXMgPSB0eC5tYXhQcmlvcml0eUZlZVBlckdhcyB8fCAnMHg5NTAyRjkwMCc7IC8vIDIuNSBHd2VpXG4gICAgICAgICAgICAgICAgICAgICAgICBtYXhGZWVQZXJHYXMgPSB0eC5tYXhGZWVQZXJHYXMgfHxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB1dGlscy50b0hleCh1dGlscy50b0JOKGJsb2NrLmJhc2VGZWVQZXJHYXMpXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIC5tdWwodXRpbHMudG9CTigyKSlcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgLmFkZCh1dGlscy50b0JOKG1heFByaW9yaXR5RmVlUGVyR2FzKSkpO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIHJlc29sdmUoeyBtYXhGZWVQZXJHYXMsIG1heFByaW9yaXR5RmVlUGVyR2FzIH0pO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgaWYgKHR4Lm1heFByaW9yaXR5RmVlUGVyR2FzIHx8IHR4Lm1heEZlZVBlckdhcylcbiAgICAgICAgICAgICAgICAgICAgICAgIHRocm93IEVycm9yKFwiTmV0d29yayBkb2Vzbid0IHN1cHBvcnQgZWlwLTE1NTlcIik7XG4gICAgICAgICAgICAgICAgICAgIHJlc29sdmUoeyBnYXNQcmljZSB9KTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfVxuICAgICAgICBjYXRjaCAoZXJyb3IpIHtcbiAgICAgICAgICAgIHJlamVjdChlcnJvcik7XG4gICAgICAgIH1cbiAgICB9KTtcbn1cbi8qKlxuICogUmV0dXJucyB0aGUgcmV2ZXJ0IHJlYXNvbiBzdHJpbmcgaWYgZXhpc3Rpbmcgb3Igb3RoZXJ3aXNlIGZhbHNlLlxuICpcbiAqIEBtZXRob2QgZ2V0UmV2ZXJ0UmVhc29uXG4gKlxuICogQHBhcmFtIHtPYmplY3R9IHR4T3B0aW9uc1xuICogQHBhcmFtIHtOdW1iZXJ9IGJsb2NrTnVtYmVyXG4gKlxuICogQHJldHVybnMge1Byb21pc2U8Qm9vbGVhbnxTdHJpbmc+fVxuICovXG5NZXRob2QucHJvdG90eXBlLmdldFJldmVydFJlYXNvbiA9IGZ1bmN0aW9uICh0eE9wdGlvbnMsIGJsb2NrTnVtYmVyKSB7XG4gICAgdmFyIHNlbGYgPSB0aGlzO1xuICAgIHJldHVybiBuZXcgUHJvbWlzZShmdW5jdGlvbiAocmVzb2x2ZSwgcmVqZWN0KSB7XG4gICAgICAgIChuZXcgTWV0aG9kKHtcbiAgICAgICAgICAgIG5hbWU6ICdjYWxsJyxcbiAgICAgICAgICAgIGNhbGw6ICdldGhfY2FsbCcsXG4gICAgICAgICAgICBwYXJhbXM6IDIsXG4gICAgICAgICAgICBhYmlDb2Rlcjogc2VsZi5hYmlDb2RlcixcbiAgICAgICAgICAgIGhhbmRsZVJldmVydDogdHJ1ZVxuICAgICAgICB9KSlcbiAgICAgICAgICAgIC5jcmVhdGVGdW5jdGlvbihzZWxmLnJlcXVlc3RNYW5hZ2VyKSh0eE9wdGlvbnMsIHV0aWxzLm51bWJlclRvSGV4KGJsb2NrTnVtYmVyKSlcbiAgICAgICAgICAgIC50aGVuKGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIHJlc29sdmUoZmFsc2UpO1xuICAgICAgICB9KVxuICAgICAgICAgICAgLmNhdGNoKGZ1bmN0aW9uIChlcnJvcikge1xuICAgICAgICAgICAgaWYgKGVycm9yLnJlYXNvbikge1xuICAgICAgICAgICAgICAgIHJlc29sdmUoe1xuICAgICAgICAgICAgICAgICAgICByZWFzb246IGVycm9yLnJlYXNvbixcbiAgICAgICAgICAgICAgICAgICAgc2lnbmF0dXJlOiBlcnJvci5zaWduYXR1cmVcbiAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgIHJlamVjdChlcnJvcik7XG4gICAgICAgICAgICB9XG4gICAgICAgIH0pO1xuICAgIH0pO1xufTtcbi8qKlxuICogQ2hlY2tzIGlmIHRoZSBnaXZlbiBoZXggc3RyaW5nIGlzIGEgcmV2ZXJ0IG1lc3NhZ2UgZnJvbSB0aGUgRVZNXG4gKlxuICogQG1ldGhvZCBpc1JldmVydFJlYXNvblN0cmluZ1xuICpcbiAqIEBwYXJhbSB7U3RyaW5nfSBkYXRhIC0gSGV4IHN0cmluZyBwcmVmaXhlZCB3aXRoIDB4XG4gKlxuICogQHJldHVybnMge0Jvb2xlYW59XG4gKi9cbk1ldGhvZC5wcm90b3R5cGUuaXNSZXZlcnRSZWFzb25TdHJpbmcgPSBmdW5jdGlvbiAoZGF0YSkge1xuICAgIHJldHVybiB0eXBlb2YgZGF0YSA9PT0gJ3N0cmluZycgJiYgKChkYXRhLmxlbmd0aCAtIDIpIC8gMikgJSAzMiA9PT0gNCAmJiBkYXRhLnN1YnN0cmluZygwLCAxMCkgPT09ICcweDA4YzM3OWEwJztcbn07XG4vKipcbiAqIFNob3VsZCBiZSBjYWxsZWQgdG8gY3JlYXRlIHRoZSBwdXJlIEpTT05SUEMgcmVxdWVzdCB3aGljaCBjYW4gYmUgdXNlZCBpbiBhIGJhdGNoIHJlcXVlc3RcbiAqXG4gKiBAbWV0aG9kIHJlcXVlc3RcbiAqIEByZXR1cm4ge09iamVjdH0ganNvbnJwYyByZXF1ZXN0XG4gKi9cbk1ldGhvZC5wcm90b3R5cGUucmVxdWVzdCA9IGZ1bmN0aW9uICgpIHtcbiAgICB2YXIgcGF5bG9hZCA9IHRoaXMudG9QYXlsb2FkKEFycmF5LnByb3RvdHlwZS5zbGljZS5jYWxsKGFyZ3VtZW50cykpO1xuICAgIHBheWxvYWQuZm9ybWF0ID0gdGhpcy5mb3JtYXRPdXRwdXQuYmluZCh0aGlzKTtcbiAgICByZXR1cm4gcGF5bG9hZDtcbn07XG5tb2R1bGUuZXhwb3J0cyA9IE1ldGhvZDtcbiJdLCJuYW1lcyI6W10sImlnbm9yZUxpc3QiOlswXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/web3-core-method/lib/index.js\n");

/***/ })

};
;